{"version":3,"file":"session-replay.esm.js","sources":["../src/dom-serializer.ts","../src/console-recorder.ts","../src/heatmap-generator.ts","../src/session-replay.ts"],"sourcesContent":["import type { ReviConfig } from './types';\n\nexport interface SerializedNode {\n  type: 'document' | 'element' | 'text' | 'comment';\n  tagName?: string;\n  attributes?: Record<string, string>;\n  textContent?: string;\n  children?: SerializedNode[];\n  id?: number;\n  parentId?: number;\n}\n\nexport interface DOMSnapshot {\n  timestamp: number;\n  url: string;\n  viewport: {\n    width: number;\n    height: number;\n  };\n  scroll: {\n    x: number;\n    y: number;\n  };\n  nodes: SerializedNode[];\n  stylesheets: SerializedStylesheet[];\n  resources: SerializedResource[];\n}\n\nexport interface SerializedStylesheet {\n  href?: string;\n  cssText: string;\n  disabled: boolean;\n}\n\nexport interface SerializedResource {\n  url: string;\n  type: 'image' | 'font' | 'media';\n  data?: string; // Base64 encoded data for small resources\n  failed?: boolean;\n}\n\nexport interface DOMChange {\n  timestamp: number;\n  type: 'childList' | 'attributes' | 'characterData';\n  target: number; // Node ID\n  addedNodes?: SerializedNode[];\n  removedNodes?: number[]; // Node IDs\n  attributeName?: string;\n  attributeValue?: string;\n  oldValue?: string;\n}\n\n/**\n * Advanced DOM serializer for session replay with rrweb-like capabilities\n */\nexport class DOMSerializer {\n  private config: ReviConfig;\n  private nodeIdMap = new WeakMap<Node, number>();\n  private nodeMap = new Map<number, Node>();\n  private nextNodeId = 1;\n  private observer?: MutationObserver;\n  private isObserving = false;\n  private onDOMChange?: (change: DOMChange) => void;\n\n  constructor(config: ReviConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Take a complete snapshot of the DOM\n   */\n  takeSnapshot(): DOMSnapshot {\n    const snapshot: DOMSnapshot = {\n      timestamp: Date.now(),\n      url: window.location.href,\n      viewport: {\n        width: window.innerWidth,\n        height: window.innerHeight\n      },\n      scroll: {\n        x: window.scrollX,\n        y: window.scrollY\n      },\n      nodes: [],\n      stylesheets: [],\n      resources: []\n    };\n\n    // Serialize DOM\n    snapshot.nodes = this.serializeDocument(document);\n    \n    // Capture stylesheets\n    snapshot.stylesheets = this.serializeStylesheets();\n    \n    // Capture resources (images, fonts, etc.)\n    snapshot.resources = this.serializeResources();\n\n    return snapshot;\n  }\n\n  /**\n   * Start observing DOM changes\n   */\n  startObserving(onDOMChange: (change: DOMChange) => void): void {\n    if (this.isObserving) return;\n\n    this.onDOMChange = onDOMChange;\n    this.observer = new MutationObserver(this.handleMutations.bind(this));\n    \n    this.observer.observe(document, {\n      childList: true,\n      attributes: true,\n      characterData: true,\n      subtree: true,\n      attributeOldValue: true,\n      characterDataOldValue: true\n    });\n\n    this.isObserving = true;\n  }\n\n  /**\n   * Stop observing DOM changes\n   */\n  stopObserving(): void {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = undefined;\n    }\n    this.isObserving = false;\n    this.onDOMChange = undefined;\n  }\n\n  /**\n   * Serialize the entire document\n   */\n  private serializeDocument(doc: Document): SerializedNode[] {\n    const doctype = doc.doctype;\n    const nodes: SerializedNode[] = [];\n\n    // Add doctype if present\n    if (doctype) {\n      nodes.push({\n        type: 'document',\n        tagName: 'DOCTYPE',\n        attributes: {\n          name: doctype.name,\n          publicId: doctype.publicId,\n          systemId: doctype.systemId\n        },\n        id: this.getNodeId(doctype)\n      });\n    }\n\n    // Serialize document element (html)\n    if (doc.documentElement) {\n      const serialized = this.serializeNode(doc.documentElement);\n      if (serialized) {\n        nodes.push(serialized);\n      }\n    }\n\n    return nodes;\n  }\n\n  /**\n   * Serialize a single DOM node\n   */\n  private serializeNode(node: Node): SerializedNode | null {\n    if (this.shouldIgnoreNode(node)) {\n      return null;\n    }\n\n    const nodeId = this.getNodeId(node);\n    const serialized: SerializedNode = {\n      type: this.getNodeType(node),\n      id: nodeId\n    };\n\n    switch (node.nodeType) {\n      case Node.ELEMENT_NODE:\n        const element = node as Element;\n        serialized.tagName = element.tagName.toLowerCase();\n        serialized.attributes = this.serializeAttributes(element);\n        serialized.children = this.serializeChildren(element);\n        break;\n\n      case Node.TEXT_NODE:\n        const textNode = node as Text;\n        serialized.textContent = this.shouldMaskText(textNode) ? '[Masked]' : textNode.textContent || '';\n        break;\n\n      case Node.COMMENT_NODE:\n        const commentNode = node as Comment;\n        serialized.textContent = commentNode.textContent || '';\n        break;\n\n      default:\n        return null;\n    }\n\n    return serialized;\n  }\n\n  /**\n   * Serialize element attributes\n   */\n  private serializeAttributes(element: Element): Record<string, string> {\n    const attributes: Record<string, string> = {};\n    \n    for (let i = 0; i < element.attributes.length; i++) {\n      const attr = element.attributes[i];\n      const name = attr.name.toLowerCase();\n      \n      // Skip sensitive attributes\n      if (this.shouldIgnoreAttribute(name, attr.value)) {\n        continue;\n      }\n\n      // Mask sensitive values\n      if (this.shouldMaskAttribute(name, element)) {\n        attributes[name] = '[Masked]';\n      } else {\n        attributes[name] = attr.value;\n      }\n    }\n\n    return attributes;\n  }\n\n  /**\n   * Serialize element children\n   */\n  private serializeChildren(element: Element): SerializedNode[] {\n    const children: SerializedNode[] = [];\n    \n    for (let i = 0; i < element.childNodes.length; i++) {\n      const child = element.childNodes[i];\n      const serializedChild = this.serializeNode(child);\n      \n      if (serializedChild) {\n        children.push(serializedChild);\n      }\n    }\n\n    return children;\n  }\n\n  /**\n   * Serialize all stylesheets\n   */\n  private serializeStylesheets(): SerializedStylesheet[] {\n    const stylesheets: SerializedStylesheet[] = [];\n\n    for (let i = 0; i < document.styleSheets.length; i++) {\n      const stylesheet = document.styleSheets[i];\n      \n      try {\n        let cssText = '';\n        \n        if (stylesheet.href) {\n          // External stylesheet - we'll capture the URL\n          // In production, you might want to fetch and inline the CSS\n          cssText = `/* External stylesheet: ${stylesheet.href} */`;\n        } else {\n          // Inline stylesheet - capture the rules\n          if (stylesheet.cssRules) {\n            const rules = Array.from(stylesheet.cssRules);\n            cssText = rules.map(rule => rule.cssText).join('\\n');\n          }\n        }\n\n        stylesheets.push({\n          href: stylesheet.href || undefined,\n          cssText,\n          disabled: stylesheet.disabled\n        });\n      } catch (error) {\n        // CORS issues or other access problems\n        if (stylesheet.href) {\n          stylesheets.push({\n            href: stylesheet.href,\n            cssText: `/* Could not access stylesheet: ${stylesheet.href} */`,\n            disabled: stylesheet.disabled\n          });\n        }\n      }\n    }\n\n    return stylesheets;\n  }\n\n  /**\n   * Serialize resources (images, fonts, etc.)\n   */\n  private serializeResources(): SerializedResource[] {\n    const resources: SerializedResource[] = [];\n\n    // Capture images\n    const images = document.querySelectorAll('img');\n    images.forEach(img => {\n      if (img.src && !this.shouldIgnoreResource(img.src)) {\n        resources.push({\n          url: img.src,\n          type: 'image',\n          failed: !img.complete || img.naturalWidth === 0\n        });\n      }\n    });\n\n    // Capture background images from computed styles\n    const elementsWithBackgrounds = document.querySelectorAll('*');\n    elementsWithBackgrounds.forEach(element => {\n      const style = window.getComputedStyle(element);\n      const backgroundImage = style.backgroundImage;\n      \n      if (backgroundImage && backgroundImage !== 'none') {\n        const urlMatch = backgroundImage.match(/url\\(['\"]?([^'\")]+)['\"]?\\)/);\n        if (urlMatch && urlMatch[1] && !this.shouldIgnoreResource(urlMatch[1])) {\n          resources.push({\n            url: urlMatch[1],\n            type: 'image'\n          });\n        }\n      }\n    });\n\n    return resources;\n  }\n\n  /**\n   * Handle mutation events\n   */\n  private handleMutations(mutations: MutationRecord[]): void {\n    mutations.forEach(mutation => {\n      const targetId = this.nodeIdMap.get(mutation.target);\n      if (!targetId) return;\n\n      const change: DOMChange = {\n        timestamp: Date.now(),\n        type: mutation.type,\n        target: targetId\n      };\n\n      switch (mutation.type) {\n        case 'childList':\n          if (mutation.addedNodes.length > 0) {\n            change.addedNodes = Array.from(mutation.addedNodes)\n              .map(node => this.serializeNode(node))\n              .filter((node): node is SerializedNode => node !== null);\n          }\n          \n          if (mutation.removedNodes.length > 0) {\n            change.removedNodes = Array.from(mutation.removedNodes)\n              .map(node => this.nodeIdMap.get(node))\n              .filter((id): id is number => id !== undefined);\n          }\n          break;\n\n        case 'attributes':\n          change.attributeName = mutation.attributeName || undefined;\n          if (mutation.target.nodeType === Node.ELEMENT_NODE) {\n            const element = mutation.target as Element;\n            const value = element.getAttribute(mutation.attributeName || '');\n            change.attributeValue = this.shouldMaskAttribute(\n              mutation.attributeName || '', element\n            ) ? '[Masked]' : value || '';\n          }\n          change.oldValue = mutation.oldValue || undefined;\n          break;\n\n        case 'characterData':\n          change.attributeValue = this.shouldMaskText(mutation.target as Text) \n            ? '[Masked]' \n            : mutation.target.textContent || '';\n          change.oldValue = mutation.oldValue || undefined;\n          break;\n      }\n\n      if (this.onDOMChange) {\n        this.onDOMChange(change);\n      }\n    });\n  }\n\n  /**\n   * Utility methods\n   */\n  private getNodeId(node: Node): number {\n    if (this.nodeIdMap.has(node)) {\n      return this.nodeIdMap.get(node)!;\n    }\n    \n    const id = this.nextNodeId++;\n    this.nodeIdMap.set(node, id);\n    this.nodeMap.set(id, node);\n    \n    return id;\n  }\n\n  private getNodeType(node: Node): SerializedNode['type'] {\n    switch (node.nodeType) {\n      case Node.ELEMENT_NODE:\n        return 'element';\n      case Node.TEXT_NODE:\n        return 'text';\n      case Node.COMMENT_NODE:\n        return 'comment';\n      case Node.DOCUMENT_NODE:\n        return 'document';\n      default:\n        return 'element';\n    }\n  }\n\n  private shouldIgnoreNode(node: Node): boolean {\n    if (node.nodeType === Node.ELEMENT_NODE) {\n      const element = node as Element;\n      const tagName = element.tagName.toLowerCase();\n      \n      // Ignore script tags and other sensitive elements\n      if (['script', 'noscript', 'meta'].includes(tagName)) {\n        return true;\n      }\n      \n      // Ignore elements with data-revi-ignore attribute\n      if (element.hasAttribute('data-revi-ignore')) {\n        return true;\n      }\n      \n      // Ignore elements that match block selector\n      if (this.config.replay?.blockSelector) {\n        try {\n          if (element.matches(this.config.replay.blockSelector)) {\n            return true;\n          }\n        } catch (e) {\n          // Invalid selector\n        }\n      }\n    }\n    \n    return false;\n  }\n\n  private shouldIgnoreAttribute(name: string, value: string): boolean {\n    // Ignore sensitive attributes\n    const sensitiveAttrs = ['data-revi-ignore', 'data-password', 'data-sensitive'];\n    return sensitiveAttrs.includes(name);\n  }\n\n  private shouldMaskAttribute(name: string, element: Element): boolean {\n    if (!this.config.privacy?.maskInputs) return false;\n    \n    // Mask values of sensitive input fields\n    if (element.tagName.toLowerCase() === 'input') {\n      const input = element as HTMLInputElement;\n      const sensitiveTypes = ['password', 'email', 'tel'];\n      if (sensitiveTypes.includes(input.type)) {\n        return name === 'value';\n      }\n    }\n    \n    return false;\n  }\n\n  private shouldMaskText(textNode: Text): boolean {\n    if (!this.config.replay?.maskAllText && !this.config.privacy?.maskInputs) {\n      return false;\n    }\n    \n    const parent = textNode.parentElement;\n    if (!parent) return false;\n    \n    // Mask text in sensitive elements\n    const sensitiveElements = ['input', 'textarea'];\n    if (sensitiveElements.includes(parent.tagName.toLowerCase())) {\n      return true;\n    }\n    \n    // Check for mask selector\n    if (this.config.replay?.maskSelector) {\n      try {\n        return parent.matches(this.config.replay.maskSelector);\n      } catch (e) {\n        return false;\n      }\n    }\n    \n    return this.config.replay?.maskAllText || false;\n  }\n\n  private shouldIgnoreResource(url: string): boolean {\n    try {\n      const urlObj = new URL(url, window.location.href);\n      \n      // Ignore data URLs (they're inline)\n      if (urlObj.protocol === 'data:') return true;\n      \n      // Ignore very large images\n      if (url.includes('?')) {\n        const params = new URLSearchParams(urlObj.search);\n        const width = params.get('w') || params.get('width');\n        const height = params.get('h') || params.get('height');\n        if (width && parseInt(width) > 2000) return true;\n        if (height && parseInt(height) > 2000) return true;\n      }\n      \n      return false;\n    } catch (e) {\n      return true; // Invalid URL\n    }\n  }\n}","import { SessionEvent } from './types';\n\nexport interface ConsoleLogEntry {\n  id: string;\n  timestamp: number;\n  level: 'log' | 'info' | 'warn' | 'error' | 'debug' | 'trace';\n  args: any[];\n  stack?: string;\n  url?: string;\n  lineNumber?: number;\n  columnNumber?: number;\n}\n\nexport interface ConsoleRecorderConfig {\n  maxEntries: number;\n  captureStackTrace: boolean;\n  serializeObjects: boolean;\n  maxObjectDepth: number;\n  maxStringLength: number;\n  ignoredLevels: string[];\n}\n\nexport class ConsoleRecorder {\n  private originalMethods: Record<string, Function> = {};\n  private entries: ConsoleLogEntry[] = [];\n  private config: ConsoleRecorderConfig;\n  private isRecording = false;\n  private sessionId: string;\n\n  constructor(sessionId: string, config: Partial<ConsoleRecorderConfig> = {}) {\n    this.sessionId = sessionId;\n    this.config = {\n      maxEntries: 1000,\n      captureStackTrace: true,\n      serializeObjects: true,\n      maxObjectDepth: 3,\n      maxStringLength: 10000,\n      ignoredLevels: [],\n      ...config\n    };\n  }\n\n  start(): void {\n    if (this.isRecording) return;\n\n    const levels: Array<keyof Console> = ['log', 'info', 'warn', 'error', 'debug', 'trace'];\n    \n    levels.forEach(level => {\n      if (this.config.ignoredLevels.includes(level)) return;\n      \n      const originalMethod = console[level];\n      this.originalMethods[level] = originalMethod;\n      \n      console[level] = (...args: any[]) => {\n        // Call original method first\n        originalMethod.apply(console, args);\n        \n        // Record the log entry\n        this.recordEntry(level as ConsoleLogEntry['level'], args);\n      };\n    });\n\n    this.isRecording = true;\n  }\n\n  stop(): void {\n    if (!this.isRecording) return;\n\n    // Restore original console methods\n    Object.entries(this.originalMethods).forEach(([level, method]) => {\n      (console as any)[level] = method;\n    });\n\n    this.originalMethods = {};\n    this.isRecording = false;\n  }\n\n  private recordEntry(level: ConsoleLogEntry['level'], args: any[]): void {\n    try {\n      const entry: ConsoleLogEntry = {\n        id: this.generateId(),\n        timestamp: Date.now(),\n        level,\n        args: this.serializeArgs(args)\n      };\n\n      // Capture stack trace for errors and warnings\n      if ((level === 'error' || level === 'warn') && this.config.captureStackTrace) {\n        const error = new Error();\n        if (error.stack) {\n          entry.stack = this.cleanStackTrace(error.stack);\n        }\n      }\n\n      // Add source location if available\n      if (level === 'error' && args[0] instanceof Error) {\n        const error = args[0] as Error;\n        // Try to extract location from error stack\n        const stackLines = error.stack?.split('\\n') || [];\n        const sourceLine = stackLines.find(line => \n          line.includes('.js:') || line.includes('.ts:') || line.includes('.tsx:')\n        );\n        \n        if (sourceLine) {\n          const match = sourceLine.match(/([^/]+):(\\d+):(\\d+)/);\n          if (match) {\n            entry.url = match[1];\n            entry.lineNumber = parseInt(match[2]);\n            entry.columnNumber = parseInt(match[3]);\n          }\n        }\n      }\n\n      this.addEntry(entry);\n    } catch (error) {\n      // Fail silently to avoid infinite loops\n      this.originalMethods.warn?.call(console, 'ConsoleRecorder error:', error);\n    }\n  }\n\n  private serializeArgs(args: any[]): any[] {\n    return args.map(arg => this.serializeValue(arg, 0));\n  }\n\n  private serializeValue(value: any, depth: number): any {\n    if (depth > this.config.maxObjectDepth) {\n      return '[Object too deep]';\n    }\n\n    if (value === null || value === undefined) {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      return value.length > this.config.maxStringLength \n        ? value.substring(0, this.config.maxStringLength) + '...'\n        : value;\n    }\n\n    if (typeof value === 'number' || typeof value === 'boolean') {\n      return value;\n    }\n\n    if (typeof value === 'function') {\n      return `[Function: ${value.name || 'anonymous'}]`;\n    }\n\n    if (value instanceof Error) {\n      return {\n        name: value.name,\n        message: value.message,\n        stack: this.config.captureStackTrace ? this.cleanStackTrace(value.stack || '') : undefined\n      };\n    }\n\n    if (value instanceof Date) {\n      return {\n        __type: 'Date',\n        value: value.toISOString()\n      };\n    }\n\n    if (value instanceof RegExp) {\n      return {\n        __type: 'RegExp',\n        value: value.toString()\n      };\n    }\n\n    if (Array.isArray(value)) {\n      if (!this.config.serializeObjects) return '[Array]';\n      \n      return value.slice(0, 100).map(item => this.serializeValue(item, depth + 1));\n    }\n\n    if (typeof value === 'object') {\n      if (!this.config.serializeObjects) return '[Object]';\n      \n      try {\n        const serialized: Record<string, any> = {};\n        const keys = Object.keys(value).slice(0, 50); // Limit keys\n        \n        for (const key of keys) {\n          try {\n            serialized[key] = this.serializeValue(value[key], depth + 1);\n          } catch {\n            serialized[key] = '[Unserializable]';\n          }\n        }\n        \n        if (Object.keys(value).length > 50) {\n          serialized['...'] = `[${Object.keys(value).length - 50} more keys]`;\n        }\n        \n        return serialized;\n      } catch {\n        return '[Unserializable Object]';\n      }\n    }\n\n    return String(value);\n  }\n\n  private cleanStackTrace(stack: string): string {\n    return stack\n      .split('\\n')\n      .filter(line => \n        !line.includes('console-recorder.ts') && \n        !line.includes('ConsoleRecorder')\n      )\n      .slice(0, 10) // Limit stack depth\n      .join('\\n');\n  }\n\n  private addEntry(entry: ConsoleLogEntry): void {\n    this.entries.push(entry);\n    \n    // Maintain max entries limit\n    if (this.entries.length > this.config.maxEntries) {\n      this.entries = this.entries.slice(-this.config.maxEntries * 0.8);\n    }\n  }\n\n  private generateId(): string {\n    return `console-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  getEntries(fromTimestamp?: number, toTimestamp?: number): ConsoleLogEntry[] {\n    let filtered = this.entries;\n    \n    if (fromTimestamp) {\n      filtered = filtered.filter(entry => entry.timestamp >= fromTimestamp);\n    }\n    \n    if (toTimestamp) {\n      filtered = filtered.filter(entry => entry.timestamp <= toTimestamp);\n    }\n    \n    return [...filtered];\n  }\n\n  getEntriesByLevel(level: ConsoleLogEntry['level']): ConsoleLogEntry[] {\n    return this.entries.filter(entry => entry.level === level);\n  }\n\n  clear(): void {\n    this.entries = [];\n  }\n\n  // Convert console entries to session events format\n  toSessionEvents(): SessionEvent[] {\n    return this.entries.map(entry => ({\n      session_id: this.sessionId,\n      event_type: 'console',\n      data: {\n        level: entry.level,\n        args: entry.args,\n        stack: entry.stack,\n        url: entry.url,\n        lineNumber: entry.lineNumber,\n        columnNumber: entry.columnNumber,\n        consoleId: entry.id\n      },\n      timestamp: entry.timestamp,\n      url: entry.url || window.location.href,\n      user_agent: navigator.userAgent\n    }));\n  }\n\n  // Export for analysis\n  exportData(): {\n    sessionId: string;\n    config: ConsoleRecorderConfig;\n    entries: ConsoleLogEntry[];\n    stats: {\n      totalEntries: number;\n      levelCounts: Record<string, number>;\n      errorCount: number;\n      warningCount: number;\n      timeRange: { start: number; end: number };\n    };\n  } {\n    const levelCounts: Record<string, number> = {};\n    let minTime = Infinity;\n    let maxTime = -Infinity;\n\n    this.entries.forEach(entry => {\n      levelCounts[entry.level] = (levelCounts[entry.level] || 0) + 1;\n      minTime = Math.min(minTime, entry.timestamp);\n      maxTime = Math.max(maxTime, entry.timestamp);\n    });\n\n    return {\n      sessionId: this.sessionId,\n      config: this.config,\n      entries: [...this.entries],\n      stats: {\n        totalEntries: this.entries.length,\n        levelCounts,\n        errorCount: levelCounts.error || 0,\n        warningCount: levelCounts.warn || 0,\n        timeRange: {\n          start: minTime === Infinity ? 0 : minTime,\n          end: maxTime === -Infinity ? 0 : maxTime\n        }\n      }\n    };\n  }\n\n  // Generate insights from console logs\n  generateInsights(): {\n    errorPatterns: Array<{ pattern: string; count: number; examples: ConsoleLogEntry[] }>;\n    performanceIssues: Array<{ type: string; severity: 'low' | 'medium' | 'high'; details: string }>;\n    recommendations: string[];\n  } {\n    const errorPatterns = this.findErrorPatterns();\n    const performanceIssues = this.detectPerformanceIssues();\n    const recommendations = this.generateRecommendations();\n\n    return {\n      errorPatterns,\n      performanceIssues,\n      recommendations\n    };\n  }\n\n  private findErrorPatterns(): Array<{ pattern: string; count: number; examples: ConsoleLogEntry[] }> {\n    const errors = this.entries.filter(entry => entry.level === 'error');\n    const patterns: Record<string, ConsoleLogEntry[]> = {};\n\n    errors.forEach(error => {\n      let pattern = 'Unknown Error';\n      \n      if (error.args.length > 0) {\n        const firstArg = error.args[0];\n        if (typeof firstArg === 'string') {\n          // Extract error pattern from message\n          pattern = firstArg\n            .replace(/\\d+/g, 'N') // Replace numbers with N\n            .replace(/[\"'][^\"']*[\"']/g, 'STRING') // Replace strings with STRING\n            .replace(/\\b\\w+@\\w+\\.\\w+/g, 'EMAIL') // Replace emails\n            .replace(/https?:\\/\\/[^\\s]+/g, 'URL') // Replace URLs\n            .substring(0, 100);\n        } else if (typeof firstArg === 'object' && firstArg.name) {\n          pattern = `${firstArg.name}: ${firstArg.message}`.substring(0, 100);\n        }\n      }\n\n      if (!patterns[pattern]) {\n        patterns[pattern] = [];\n      }\n      patterns[pattern].push(error);\n    });\n\n    return Object.entries(patterns)\n      .sort(([, a], [, b]) => b.length - a.length)\n      .slice(0, 10)\n      .map(([pattern, examples]) => ({\n        pattern,\n        count: examples.length,\n        examples: examples.slice(0, 3) // Show first 3 examples\n      }));\n  }\n\n  private detectPerformanceIssues(): Array<{ type: string; severity: 'low' | 'medium' | 'high'; details: string }> {\n    const issues: Array<{ type: string; severity: 'low' | 'medium' | 'high'; details: string }> = [];\n    \n    // Check for excessive logging\n    const recentEntries = this.entries.filter(entry => \n      entry.timestamp > Date.now() - 60000 // Last minute\n    );\n    \n    if (recentEntries.length > 100) {\n      issues.push({\n        type: 'Excessive Logging',\n        severity: 'medium',\n        details: `${recentEntries.length} console entries in the last minute may impact performance`\n      });\n    }\n\n    // Check for repeated errors\n    const errorCounts: Record<string, number> = {};\n    this.entries\n      .filter(entry => entry.level === 'error')\n      .forEach(entry => {\n        const key = JSON.stringify(entry.args);\n        errorCounts[key] = (errorCounts[key] || 0) + 1;\n      });\n\n    Object.entries(errorCounts).forEach(([error, count]) => {\n      if (count > 10) {\n        issues.push({\n          type: 'Repeated Error',\n          severity: count > 50 ? 'high' : 'medium',\n          details: `Same error occurred ${count} times`\n        });\n      }\n    });\n\n    // Check for potential memory leaks (objects not being cleaned up)\n    const objectLogs = this.entries.filter(entry => \n      entry.args.some(arg => \n        typeof arg === 'object' && \n        arg !== null && \n        !Array.isArray(arg)\n      )\n    );\n    \n    if (objectLogs.length > this.entries.length * 0.5) {\n      issues.push({\n        type: 'Object Logging',\n        severity: 'low',\n        details: 'High percentage of object logging may indicate memory leaks'\n      });\n    }\n\n    return issues;\n  }\n\n  private generateRecommendations(): string[] {\n    const recommendations: string[] = [];\n    const stats = this.exportData().stats;\n\n    if (stats.errorCount > 0) {\n      recommendations.push(\n        `Found ${stats.errorCount} console errors. Review error patterns and fix underlying issues.`\n      );\n    }\n\n    if (stats.warningCount > stats.errorCount * 2) {\n      recommendations.push(\n        'High warning-to-error ratio suggests proactive error handling could prevent issues.'\n      );\n    }\n\n    if (stats.totalEntries > 500) {\n      recommendations.push(\n        'Consider reducing console logging in production to improve performance.'\n      );\n    }\n\n    if (stats.levelCounts.debug && stats.levelCounts.debug > 100) {\n      recommendations.push(\n        'Debug logs should be disabled in production environments.'\n      );\n    }\n\n    if (recommendations.length === 0) {\n      recommendations.push('Console logging patterns look healthy.');\n    }\n\n    return recommendations;\n  }\n}","import { SessionEvent } from './types';\n\nexport interface HeatmapData {\n  x: number;\n  y: number;\n  intensity: number;\n  event_type: 'click' | 'move' | 'scroll' | 'hover';\n  timestamp: number;\n}\n\nexport interface HeatmapConfig {\n  radius: number;\n  maxIntensity: number;\n  gradient: Record<string, string>;\n  blur: number;\n  minOpacity: number;\n  maxOpacity: number;\n}\n\nexport class HeatmapGenerator {\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n  private config: HeatmapConfig;\n  private data: HeatmapData[] = [];\n\n  constructor(container: HTMLElement, config: Partial<HeatmapConfig> = {}) {\n    this.config = {\n      radius: 20,\n      maxIntensity: 100,\n      gradient: {\n        0.4: 'blue',\n        0.6: 'cyan',\n        0.7: 'lime',\n        0.8: 'yellow',\n        1.0: 'red'\n      },\n      blur: 15,\n      minOpacity: 0,\n      maxOpacity: 0.6,\n      ...config\n    };\n\n    this.canvas = document.createElement('canvas');\n    this.canvas.style.position = 'absolute';\n    this.canvas.style.top = '0';\n    this.canvas.style.left = '0';\n    this.canvas.style.pointerEvents = 'none';\n    this.canvas.style.zIndex = '9999';\n    \n    container.appendChild(this.canvas);\n    \n    const ctx = this.canvas.getContext('2d');\n    if (!ctx) {\n      throw new Error('Failed to get canvas context');\n    }\n    this.ctx = ctx;\n\n    this.resizeCanvas();\n    window.addEventListener('resize', () => this.resizeCanvas());\n  }\n\n  private resizeCanvas(): void {\n    const rect = this.canvas.parentElement!.getBoundingClientRect();\n    this.canvas.width = rect.width;\n    this.canvas.height = rect.height;\n    this.canvas.style.width = rect.width + 'px';\n    this.canvas.style.height = rect.height + 'px';\n  }\n\n  addDataPoint(x: number, y: number, intensity: number, eventType: HeatmapData['event_type']): void {\n    this.data.push({\n      x,\n      y,\n      intensity,\n      event_type: eventType,\n      timestamp: Date.now()\n    });\n    \n    // Limit data points to prevent memory issues\n    if (this.data.length > 10000) {\n      this.data = this.data.slice(-8000);\n    }\n  }\n\n  generateFromEvents(events: SessionEvent[]): void {\n    this.data = [];\n    \n    events.forEach(event => {\n      if (event.event_type === 'click' && event.data?.x && event.data?.y) {\n        this.addDataPoint(\n          event.data.x,\n          event.data.y,\n          10,\n          'click'\n        );\n      } else if (event.event_type === 'mousemove' && event.data?.x && event.data?.y) {\n        this.addDataPoint(\n          event.data.x,\n          event.data.y,\n          2,\n          'move'\n        );\n      } else if (event.event_type === 'scroll' && event.data?.scrollX !== undefined && event.data?.scrollY !== undefined) {\n        // Convert scroll position to viewport coordinates\n        this.addDataPoint(\n          event.data.scrollX || 0,\n          event.data.scrollY || 0,\n          5,\n          'scroll'\n        );\n      }\n    });\n  }\n\n  render(filter?: HeatmapData['event_type'][]): void {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    \n    if (this.data.length === 0) return;\n\n    const filteredData = filter \n      ? this.data.filter(d => filter.includes(d.event_type))\n      : this.data;\n\n    // Create intensity map\n    const intensityData = this.createIntensityMap(filteredData);\n    \n    // Create gradient\n    const gradient = this.createGradient();\n    \n    // Render heatmap\n    this.renderHeatmap(intensityData, gradient);\n  }\n\n  private createIntensityMap(data: HeatmapData[]): ImageData {\n    const shadowCanvas = document.createElement('canvas');\n    shadowCanvas.width = this.canvas.width;\n    shadowCanvas.height = this.canvas.height;\n    const shadowCtx = shadowCanvas.getContext('2d')!;\n\n    // Draw intensity points\n    data.forEach(point => {\n      const radius = this.config.radius;\n      const gradient = shadowCtx.createRadialGradient(\n        point.x, point.y, 0,\n        point.x, point.y, radius\n      );\n\n      const alpha = Math.min(point.intensity / this.config.maxIntensity, 1);\n      gradient.addColorStop(0, `rgba(0, 0, 0, ${alpha})`);\n      gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\n\n      shadowCtx.fillStyle = gradient;\n      shadowCtx.fillRect(\n        point.x - radius,\n        point.y - radius,\n        radius * 2,\n        radius * 2\n      );\n    });\n\n    // Apply blur\n    shadowCtx.filter = `blur(${this.config.blur}px)`;\n    shadowCtx.drawImage(shadowCanvas, 0, 0);\n\n    return shadowCtx.getImageData(0, 0, shadowCanvas.width, shadowCanvas.height);\n  }\n\n  private createGradient(): ImageData {\n    const gradientCanvas = document.createElement('canvas');\n    gradientCanvas.width = 256;\n    gradientCanvas.height = 1;\n    const gradientCtx = gradientCanvas.getContext('2d')!;\n\n    const gradient = gradientCtx.createLinearGradient(0, 0, 256, 0);\n    Object.entries(this.config.gradient).forEach(([stop, color]) => {\n      gradient.addColorStop(parseFloat(stop), color);\n    });\n\n    gradientCtx.fillStyle = gradient;\n    gradientCtx.fillRect(0, 0, 256, 1);\n\n    return gradientCtx.getImageData(0, 0, 256, 1);\n  }\n\n  private renderHeatmap(intensityData: ImageData, gradientData: ImageData): void {\n    const output = this.ctx.createImageData(intensityData.width, intensityData.height);\n    \n    for (let i = 0; i < intensityData.data.length; i += 4) {\n      const alpha = intensityData.data[i + 3];\n      \n      if (alpha > 0) {\n        const gradientIndex = Math.floor((alpha / 255) * 255) * 4;\n        \n        output.data[i] = gradientData.data[gradientIndex];     // R\n        output.data[i + 1] = gradientData.data[gradientIndex + 1]; // G\n        output.data[i + 2] = gradientData.data[gradientIndex + 2]; // B\n        output.data[i + 3] = Math.floor(alpha * this.config.maxOpacity); // A\n      }\n    }\n\n    this.ctx.putImageData(output, 0, 0);\n  }\n\n  clear(): void {\n    this.data = [];\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n\n  destroy(): void {\n    this.clear();\n    if (this.canvas.parentElement) {\n      this.canvas.parentElement.removeChild(this.canvas);\n    }\n    window.removeEventListener('resize', () => this.resizeCanvas());\n  }\n\n  // Export heatmap data for analysis\n  exportData(): {\n    config: HeatmapConfig;\n    data: HeatmapData[];\n    stats: {\n      totalEvents: number;\n      eventTypes: Record<string, number>;\n      timeRange: { start: number; end: number };\n      bounds: { minX: number; maxX: number; minY: number; maxY: number };\n    };\n  } {\n    const eventTypes: Record<string, number> = {};\n    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;\n    let minTime = Infinity, maxTime = -Infinity;\n\n    this.data.forEach(point => {\n      eventTypes[point.event_type] = (eventTypes[point.event_type] || 0) + 1;\n      \n      minX = Math.min(minX, point.x);\n      maxX = Math.max(maxX, point.x);\n      minY = Math.min(minY, point.y);\n      maxY = Math.max(maxY, point.y);\n      \n      minTime = Math.min(minTime, point.timestamp);\n      maxTime = Math.max(maxTime, point.timestamp);\n    });\n\n    return {\n      config: this.config,\n      data: [...this.data],\n      stats: {\n        totalEvents: this.data.length,\n        eventTypes,\n        timeRange: { start: minTime, end: maxTime },\n        bounds: { minX, maxX, minY, maxY }\n      }\n    };\n  }\n\n  // Generate insights from heatmap data\n  generateInsights(): {\n    hotSpots: Array<{ x: number; y: number; intensity: number; radius: number }>;\n    clickPatterns: Array<{ pattern: string; frequency: number }>;\n    userBehavior: {\n      mostActiveArea: { x: number; y: number; width: number; height: number };\n      averageClicksPerSession: number;\n      scrollDepth: number;\n      engagementScore: number;\n    };\n  } {\n    // Find hot spots using clustering\n    const hotSpots = this.findHotSpots();\n    \n    // Analyze click patterns\n    const clickPatterns = this.analyzeClickPatterns();\n    \n    // Generate user behavior insights\n    const userBehavior = this.analyzeUserBehavior();\n\n    return {\n      hotSpots,\n      clickPatterns,\n      userBehavior\n    };\n  }\n\n  private findHotSpots(): Array<{ x: number; y: number; intensity: number; radius: number }> {\n    const clusters: Array<{ x: number; y: number; intensity: number; count: number }> = [];\n    const clusterRadius = this.config.radius * 2;\n\n    this.data.forEach(point => {\n      let foundCluster = false;\n      \n      for (const cluster of clusters) {\n        const distance = Math.sqrt(\n          Math.pow(point.x - cluster.x, 2) + Math.pow(point.y - cluster.y, 2)\n        );\n        \n        if (distance <= clusterRadius) {\n          // Add to existing cluster\n          cluster.x = (cluster.x * cluster.count + point.x) / (cluster.count + 1);\n          cluster.y = (cluster.y * cluster.count + point.y) / (cluster.count + 1);\n          cluster.intensity += point.intensity;\n          cluster.count++;\n          foundCluster = true;\n          break;\n        }\n      }\n      \n      if (!foundCluster) {\n        clusters.push({\n          x: point.x,\n          y: point.y,\n          intensity: point.intensity,\n          count: 1\n        });\n      }\n    });\n\n    return clusters\n      .filter(cluster => cluster.count >= 3) // Only significant clusters\n      .sort((a, b) => b.intensity - a.intensity)\n      .slice(0, 10) // Top 10 hot spots\n      .map(cluster => ({\n        x: Math.round(cluster.x),\n        y: Math.round(cluster.y),\n        intensity: Math.round(cluster.intensity),\n        radius: Math.min(clusterRadius, cluster.count * 5)\n      }));\n  }\n\n  private analyzeClickPatterns(): Array<{ pattern: string; frequency: number }> {\n    const clicks = this.data.filter(d => d.event_type === 'click');\n    const patterns: Record<string, number> = {};\n\n    // Analyze sequential click patterns\n    for (let i = 0; i < clicks.length - 1; i++) {\n      const current = clicks[i];\n      const next = clicks[i + 1];\n      \n      const timeDiff = next.timestamp - current.timestamp;\n      if (timeDiff < 5000) { // Within 5 seconds\n        const pattern = `(${Math.round(current.x)},${Math.round(current.y)}) -> (${Math.round(next.x)},${Math.round(next.y)})`;\n        patterns[pattern] = (patterns[pattern] || 0) + 1;\n      }\n    }\n\n    return Object.entries(patterns)\n      .sort(([, a], [, b]) => b - a)\n      .slice(0, 5)\n      .map(([pattern, frequency]) => ({ pattern, frequency }));\n  }\n\n  private analyzeUserBehavior(): {\n    mostActiveArea: { x: number; y: number; width: number; height: number };\n    averageClicksPerSession: number;\n    scrollDepth: number;\n    engagementScore: number;\n  } {\n    const clicks = this.data.filter(d => d.event_type === 'click');\n    const scrolls = this.data.filter(d => d.event_type === 'scroll');\n\n    // Find most active area (bounding box of top 50% of events)\n    const sortedByIntensity = [...this.data].sort((a, b) => b.intensity - a.intensity);\n    const topHalf = sortedByIntensity.slice(0, Math.floor(sortedByIntensity.length * 0.5));\n    \n    const minX = Math.min(...topHalf.map(d => d.x));\n    const maxX = Math.max(...topHalf.map(d => d.x));\n    const minY = Math.min(...topHalf.map(d => d.y));\n    const maxY = Math.max(...topHalf.map(d => d.y));\n\n    const scrollDepth = scrolls.length > 0 \n      ? Math.max(...scrolls.map(s => s.y)) / this.canvas.height \n      : 0;\n\n    const engagementScore = Math.min(100, \n      (clicks.length * 2) + \n      (scrollDepth * 50) + \n      (this.data.filter(d => d.event_type === 'move').length * 0.1)\n    );\n\n    return {\n      mostActiveArea: {\n        x: Math.round(minX),\n        y: Math.round(minY),\n        width: Math.round(maxX - minX),\n        height: Math.round(maxY - minY)\n      },\n      averageClicksPerSession: Math.round(clicks.length),\n      scrollDepth: Math.round(scrollDepth * 100) / 100,\n      engagementScore: Math.round(engagementScore)\n    };\n  }\n}","import type { ReviConfig } from './types';\nimport { DOMSerializer, DOMSnapshot, DOMChange } from './dom-serializer';\nimport { ConsoleRecorder, ConsoleLogEntry } from './console-recorder';\nimport { HeatmapGenerator, HeatmapData } from './heatmap-generator';\n\nexport interface ReplayEvent {\n  type: 'full_snapshot' | 'incremental_snapshot' | 'meta' | 'custom';\n  timestamp: number;\n  data: any;\n}\n\nexport interface ConsoleLog {\n  timestamp: number;\n  level: 'log' | 'info' | 'warn' | 'error' | 'debug';\n  args: any[];\n  stack?: string;\n}\n\nexport interface NetworkRequest {\n  timestamp: number;\n  id: string;\n  method: string;\n  url: string;\n  status?: number;\n  duration?: number;\n  requestHeaders?: Record<string, string>;\n  responseHeaders?: Record<string, string>;\n  requestBody?: any;\n  responseBody?: any;\n  failed?: boolean;\n}\n\n/**\n * Advanced session replay system with console logs and network requests\n */\nexport class SessionReplayManager {\n  private config: ReviConfig;\n  private domSerializer: DOMSerializer;\n  private consoleRecorder: ConsoleRecorder;\n  private heatmapGenerator: HeatmapGenerator | null = null;\n  private events: ReplayEvent[] = [];\n  private consoleLogs: ConsoleLog[] = [];\n  private networkRequests: Map<string, NetworkRequest> = new Map();\n  private isRecording = false;\n  private sessionId: string;\n  private startTime: number;\n  private originalConsole: any = {};\n  private originalFetch: any;\n  private originalXMLHttpRequest: any;\n\n  constructor(config: ReviConfig, sessionId: string) {\n    this.config = config;\n    this.sessionId = sessionId;\n    this.startTime = Date.now();\n    this.domSerializer = new DOMSerializer(config);\n    this.consoleRecorder = new ConsoleRecorder(sessionId, {\n      maxEntries: config.replay?.maxConsoleEntries || 1000,\n      captureStackTrace: config.replay?.captureStackTrace !== false,\n      serializeObjects: config.replay?.serializeObjects !== false,\n      maxObjectDepth: config.replay?.maxObjectDepth || 3,\n      maxStringLength: config.replay?.maxStringLength || 10000,\n      ignoredLevels: config.replay?.ignoredConsoleLevels || []\n    });\n    \n    if (this.config.replay?.enabled) {\n      this.setupReplay();\n      \n      // Initialize heatmap generator if enabled\n      if (this.config.replay?.heatmaps?.enabled && typeof document !== 'undefined') {\n        const container = document.body || document.documentElement;\n        if (container) {\n          this.heatmapGenerator = new HeatmapGenerator(container, {\n            radius: config.replay?.heatmaps?.radius || 20,\n            maxIntensity: config.replay?.heatmaps?.maxIntensity || 100,\n            blur: config.replay?.heatmaps?.blur || 15,\n            maxOpacity: config.replay?.heatmaps?.maxOpacity || 0.6\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Start recording session replay\n   */\n  startRecording(): void {\n    if (this.isRecording || !this.config.replay?.enabled) return;\n\n    this.isRecording = true;\n    \n    // Take initial snapshot\n    this.takeFullSnapshot();\n    \n    // Start observing DOM changes\n    this.domSerializer.startObserving(this.handleDOMChange.bind(this));\n    \n    // Start console recording\n    this.consoleRecorder.start();\n    \n    // Setup network monitoring\n    this.setupNetworkCapture();\n    \n    // Setup mouse and keyboard tracking\n    this.setupInteractionTracking();\n    \n    // Periodic full snapshots\n    setInterval(() => {\n      if (this.isRecording) {\n        this.takeFullSnapshot();\n      }\n    }, 60000); // Every minute\n    \n    if (this.config.debug) {\n      console.log('Revi: Session replay started');\n    }\n  }\n\n  /**\n   * Stop recording session replay\n   */\n  stopRecording(): void {\n    if (!this.isRecording) return;\n\n    this.isRecording = false;\n    this.domSerializer.stopObserving();\n    this.consoleRecorder.stop();\n    this.restoreOriginalNetwork();\n    \n    if (this.heatmapGenerator) {\n      this.heatmapGenerator.destroy();\n      this.heatmapGenerator = null;\n    }\n    \n    if (this.config.debug) {\n      console.log('Revi: Session replay stopped');\n    }\n  }\n\n  /**\n   * Get all replay events\n   */\n  getReplayData(): {\n    events: ReplayEvent[];\n    console_logs: ConsoleLogEntry[];\n    network_requests: NetworkRequest[];\n    heatmap_data?: HeatmapData[];\n    session_info: {\n      session_id: string;\n      start_time: number;\n      duration: number;\n      page_url: string;\n    };\n    analytics: {\n      console_insights: any;\n      heatmap_insights?: any;\n    };\n  } {\n    const consoleEntries = this.consoleRecorder.getEntries();\n    const consoleInsights = this.consoleRecorder.generateInsights();\n    \n    let heatmapData: HeatmapData[] | undefined;\n    let heatmapInsights: any;\n    \n    if (this.heatmapGenerator) {\n      const heatmapExport = this.heatmapGenerator.exportData();\n      heatmapData = heatmapExport.data;\n      heatmapInsights = this.heatmapGenerator.generateInsights();\n    }\n\n    return {\n      events: [...this.events],\n      console_logs: consoleEntries,\n      network_requests: Array.from(this.networkRequests.values()),\n      heatmap_data: heatmapData,\n      session_info: {\n        session_id: this.sessionId,\n        start_time: this.startTime,\n        duration: Date.now() - this.startTime,\n        page_url: window.location.href\n      },\n      analytics: {\n        console_insights: consoleInsights,\n        heatmap_insights: heatmapInsights\n      }\n    };\n  }\n\n  /**\n   * Clear replay data\n   */\n  clearReplayData(): void {\n    this.events = [];\n    this.consoleLogs = [];\n    this.networkRequests.clear();\n    this.consoleRecorder.clear();\n    \n    if (this.heatmapGenerator) {\n      this.heatmapGenerator.clear();\n    }\n  }\n\n  /**\n   * Setup basic replay tracking\n   */\n  private setupReplay(): void {\n    if (typeof window === 'undefined') return;\n\n    // Track page visibility changes\n    document.addEventListener('visibilitychange', () => {\n      this.addCustomEvent('visibility_change', {\n        hidden: document.hidden\n      });\n    });\n\n    // Track window focus/blur\n    window.addEventListener('focus', () => {\n      this.addCustomEvent('window_focus', {});\n    });\n\n    window.addEventListener('blur', () => {\n      this.addCustomEvent('window_blur', {});\n    });\n\n    // Track viewport changes\n    window.addEventListener('resize', () => {\n      this.addCustomEvent('viewport_change', {\n        width: window.innerWidth,\n        height: window.innerHeight\n      });\n    });\n\n    // Track scroll events (throttled)\n    let scrollTimeout: NodeJS.Timeout;\n    window.addEventListener('scroll', () => {\n      clearTimeout(scrollTimeout);\n      scrollTimeout = setTimeout(() => {\n        // Add to heatmap data\n        if (this.heatmapGenerator) {\n          this.heatmapGenerator.addDataPoint(\n            window.scrollX || 0,\n            window.scrollY || 0,\n            5,\n            'scroll'\n          );\n        }\n        \n        this.addCustomEvent('scroll', {\n          x: window.scrollX,\n          y: window.scrollY\n        });\n      }, 100);\n    }, { passive: true });\n  }\n\n  /**\n   * Take a full DOM snapshot\n   */\n  private takeFullSnapshot(): void {\n    if (!this.isRecording) return;\n\n    try {\n      const snapshot = this.domSerializer.takeSnapshot();\n      \n      this.addEvent({\n        type: 'full_snapshot',\n        timestamp: Date.now(),\n        data: snapshot\n      });\n    } catch (error) {\n      if (this.config.debug) {\n        console.error('Revi: Failed to take DOM snapshot', error);\n      }\n    }\n  }\n\n  /**\n   * Handle DOM changes\n   */\n  private handleDOMChange(change: DOMChange): void {\n    if (!this.isRecording) return;\n\n    this.addEvent({\n      type: 'incremental_snapshot',\n      timestamp: change.timestamp,\n      data: {\n        source: 'mutation',\n        ...change\n      }\n    });\n  }\n\n  /**\n   * Add heatmap methods\n   */\n  renderHeatmap(filter?: ('click' | 'move' | 'scroll')[]): void {\n    if (this.heatmapGenerator) {\n      this.heatmapGenerator.render(filter);\n    }\n  }\n\n  toggleHeatmap(visible: boolean): void {\n    if (this.heatmapGenerator) {\n      if (visible) {\n        this.heatmapGenerator.render();\n      } else {\n        this.heatmapGenerator.clear();\n      }\n    }\n  }\n\n  getHeatmapInsights(): any {\n    return this.heatmapGenerator?.generateInsights() || null;\n  }\n\n  /**\n   * Setup network request capture\n   */\n  private setupNetworkCapture(): void {\n    // Capture fetch requests\n    if (typeof window.fetch !== 'undefined') {\n      this.originalFetch = window.fetch;\n      \n      window.fetch = async (input: RequestInfo | URL, init?: RequestInit): Promise<Response> => {\n        const startTime = Date.now();\n        const requestId = this.generateRequestId();\n        const url = input instanceof Request ? input.url : input.toString();\n        const method = init?.method || (input instanceof Request ? input.method : 'GET');\n        \n        if (this.isRecording) {\n          this.networkRequests.set(requestId, {\n            timestamp: startTime,\n            id: requestId,\n            method,\n            url,\n            requestHeaders: this.getRequestHeaders(init, input),\n            requestBody: await this.serializeRequestBody(init, input)\n          });\n        }\n        \n        try {\n          const response = await this.originalFetch(input, init);\n          const duration = Date.now() - startTime;\n          \n          if (this.isRecording) {\n            const networkRequest = this.networkRequests.get(requestId);\n            if (networkRequest) {\n              networkRequest.status = response.status;\n              networkRequest.duration = duration;\n              networkRequest.responseHeaders = this.getResponseHeaders(response);\n              \n              // Optionally capture response body (be careful with large responses)\n              if (this.shouldCaptureResponseBody(response)) {\n                try {\n                  const clonedResponse = response.clone();\n                  networkRequest.responseBody = await clonedResponse.text();\n                } catch (e) {\n                  // Response body couldn't be captured\n                }\n              }\n            }\n          }\n          \n          return response;\n        } catch (error) {\n          const duration = Date.now() - startTime;\n          \n          if (this.isRecording) {\n            const networkRequest = this.networkRequests.get(requestId);\n            if (networkRequest) {\n              networkRequest.duration = duration;\n              networkRequest.failed = true;\n            }\n          }\n          \n          throw error;\n        }\n      };\n    }\n\n    // Capture XMLHttpRequest\n    if (typeof XMLHttpRequest !== 'undefined') {\n      this.originalXMLHttpRequest = XMLHttpRequest;\n      \n      const self = this;\n      \n      window.XMLHttpRequest = function() {\n        const xhr = new self.originalXMLHttpRequest();\n        const requestId = self.generateRequestId();\n        let method = 'GET';\n        let url = '';\n        let startTime = 0;\n        \n        const originalOpen = xhr.open;\n        const originalSend = xhr.send;\n        \n        xhr.open = function(m: string, u: string | URL, ...args: any[]) {\n          method = m;\n          url = u.toString();\n          return originalOpen.call(this, m, u, ...args);\n        };\n        \n        xhr.send = function(body?: any) {\n          startTime = Date.now();\n          \n          if (self.isRecording) {\n            self.networkRequests.set(requestId, {\n              timestamp: startTime,\n              id: requestId,\n              method,\n              url,\n              requestBody: body\n            });\n          }\n          \n          return originalSend.call(this, body);\n        };\n        \n        xhr.addEventListener('loadend', () => {\n          const duration = Date.now() - startTime;\n          \n          if (self.isRecording) {\n            const networkRequest = self.networkRequests.get(requestId);\n            if (networkRequest) {\n              networkRequest.status = xhr.status;\n              networkRequest.duration = duration;\n              networkRequest.failed = xhr.status === 0 || xhr.status >= 400;\n              \n              if (self.shouldCaptureXHRResponse(xhr)) {\n                networkRequest.responseBody = xhr.responseText;\n              }\n            }\n          }\n        });\n        \n        return xhr;\n      };\n    }\n  }\n\n  /**\n   * Setup mouse and keyboard interaction tracking\n   */\n  private setupInteractionTracking(): void {\n    // Mouse events\n    const mouseEvents = ['mousedown', 'mouseup', 'click', 'dblclick', 'mousemove'];\n    \n    mouseEvents.forEach(eventType => {\n      document.addEventListener(eventType, (event: MouseEvent) => {\n        if (!this.isRecording) return;\n        \n        // Throttle mousemove events\n        if (eventType === 'mousemove' && Math.random() > 0.1) return;\n        \n        // Add to heatmap data\n        if (this.heatmapGenerator) {\n          let intensity = 1;\n          if (eventType === 'click') intensity = 10;\n          else if (eventType === 'mousemove') intensity = 2;\n          else if (eventType === 'mousedown') intensity = 5;\n          \n          this.heatmapGenerator.addDataPoint(\n            event.clientX,\n            event.clientY,\n            intensity,\n            eventType === 'click' ? 'click' : 'move'\n          );\n        }\n        \n        this.addEvent({\n          type: 'incremental_snapshot',\n          timestamp: Date.now(),\n          data: {\n            source: 'mouse',\n            type: eventType,\n            x: event.clientX,\n            y: event.clientY,\n            id: this.getElementId(event.target as Element)\n          }\n        });\n      }, { capture: true, passive: true });\n    });\n\n    // Keyboard events\n    document.addEventListener('keydown', (event: KeyboardEvent) => {\n      if (!this.isRecording) return;\n      \n      // Don't capture sensitive keystrokes\n      if (this.shouldIgnoreKeystroke(event)) return;\n      \n      this.addEvent({\n        type: 'incremental_snapshot',\n        timestamp: Date.now(),\n        data: {\n          source: 'keyboard',\n          type: 'keydown',\n          key: this.sanitizeKey(event.key),\n          code: event.code,\n          id: this.getElementId(event.target as Element)\n        }\n      });\n    }, { capture: true, passive: true });\n  }\n\n  /**\n   * Utility methods\n   */\n  private addEvent(event: ReplayEvent): void {\n    this.events.push(event);\n    \n    // Limit event buffer\n    if (this.events.length > 10000) {\n      this.events = this.events.slice(-8000);\n    }\n  }\n\n  private addCustomEvent(type: string, data: any): void {\n    this.addEvent({\n      type: 'custom',\n      timestamp: Date.now(),\n      data: { type, ...data }\n    });\n  }\n\n  private serializeConsoleArgs(args: any[]): any[] {\n    return args.map(arg => {\n      try {\n        if (typeof arg === 'object' && arg !== null) {\n          return JSON.parse(JSON.stringify(arg));\n        }\n        return arg;\n      } catch (e) {\n        return '[Unserializable Object]';\n      }\n    });\n  }\n\n  private generateRequestId(): string {\n    return Date.now().toString(36) + Math.random().toString(36).substr(2);\n  }\n\n  private getRequestHeaders(init?: RequestInit, input?: RequestInfo | URL): Record<string, string> {\n    const headers: Record<string, string> = {};\n    \n    if (init?.headers) {\n      if (init.headers instanceof Headers) {\n        init.headers.forEach((value, key) => {\n          headers[key] = value;\n        });\n      } else if (Array.isArray(init.headers)) {\n        init.headers.forEach(([key, value]) => {\n          headers[key] = value;\n        });\n      } else {\n        Object.assign(headers, init.headers);\n      }\n    }\n    \n    if (input instanceof Request) {\n      input.headers.forEach((value, key) => {\n        headers[key] = value;\n      });\n    }\n    \n    return headers;\n  }\n\n  private getResponseHeaders(response: Response): Record<string, string> {\n    const headers: Record<string, string> = {};\n    response.headers.forEach((value, key) => {\n      headers[key] = value;\n    });\n    return headers;\n  }\n\n  private async serializeRequestBody(init?: RequestInit, input?: RequestInfo | URL): Promise<any> {\n    let body = init?.body;\n    \n    if (input instanceof Request && !body) {\n      try {\n        body = await input.clone().text();\n      } catch (e) {\n        return null;\n      }\n    }\n    \n    if (!body) return null;\n    \n    if (typeof body === 'string') {\n      return body.length > 10000 ? body.substring(0, 10000) + '...[truncated]' : body;\n    }\n    \n    if (body instanceof FormData) {\n      const formData: Record<string, any> = {};\n      body.forEach((value, key) => {\n        formData[key] = value instanceof File ? `[File: ${value.name}]` : value;\n      });\n      return formData;\n    }\n    \n    return '[Binary Data]';\n  }\n\n  private shouldCaptureResponseBody(response: Response): boolean {\n    const contentType = response.headers.get('content-type') || '';\n    const contentLength = parseInt(response.headers.get('content-length') || '0');\n    \n    // Only capture text-based responses under 100KB\n    return contentType.includes('application/json') ||\n           contentType.includes('text/') ||\n           (contentLength > 0 && contentLength < 100000);\n  }\n\n  private shouldCaptureXHRResponse(xhr: XMLHttpRequest): boolean {\n    const contentType = xhr.getResponseHeader('content-type') || '';\n    \n    return contentType.includes('application/json') ||\n           contentType.includes('text/') ||\n           (xhr.responseText && xhr.responseText.length < 100000);\n  }\n\n  private getElementId(element: Element | null): number | undefined {\n    // This would ideally use the same node ID system as the DOM serializer\n    return element ? Math.random() : undefined;\n  }\n\n  private shouldIgnoreKeystroke(event: KeyboardEvent): boolean {\n    const target = event.target as HTMLElement;\n    \n    if (target && target.tagName) {\n      const tagName = target.tagName.toLowerCase();\n      const type = (target as HTMLInputElement).type;\n      \n      // Ignore keystrokes in password fields\n      if (tagName === 'input' && type === 'password') return true;\n      \n      // Ignore keystrokes in elements marked as sensitive\n      if (target.hasAttribute('data-revi-ignore')) return true;\n    }\n    \n    return false;\n  }\n\n  private sanitizeKey(key: string): string {\n    // Don't capture the actual key for sensitive inputs\n    if (key.length === 1 && /[a-zA-Z0-9]/.test(key)) {\n      return '*'; // Mask alphanumeric characters\n    }\n    return key;\n  }\n\n\n  private restoreOriginalNetwork(): void {\n    if (this.originalFetch) {\n      window.fetch = this.originalFetch;\n    }\n    \n    if (this.originalXMLHttpRequest) {\n      window.XMLHttpRequest = this.originalXMLHttpRequest;\n    }\n  }\n}"],"names":["DOMSerializer","constructor","config","this","nodeIdMap","WeakMap","nodeMap","Map","nextNodeId","isObserving","takeSnapshot","snapshot","timestamp","Date","now","url","window","location","href","viewport","width","innerWidth","height","innerHeight","scroll","x","scrollX","y","scrollY","nodes","stylesheets","resources","serializeDocument","document","serializeStylesheets","serializeResources","startObserving","onDOMChange","observer","MutationObserver","handleMutations","bind","observe","childList","attributes","characterData","subtree","attributeOldValue","characterDataOldValue","stopObserving","disconnect","undefined","doc","doctype","push","type","tagName","name","publicId","systemId","id","getNodeId","documentElement","serialized","serializeNode","node","shouldIgnoreNode","nodeId","getNodeType","nodeType","Node","ELEMENT_NODE","element","toLowerCase","serializeAttributes","children","serializeChildren","TEXT_NODE","textNode","textContent","shouldMaskText","COMMENT_NODE","i","length","attr","shouldIgnoreAttribute","value","shouldMaskAttribute","childNodes","serializedChild","styleSheets","stylesheet","cssText","cssRules","Array","from","map","rule","join","disabled","error","querySelectorAll","forEach","img","src","shouldIgnoreResource","failed","complete","naturalWidth","backgroundImage","getComputedStyle","urlMatch","match","mutations","mutation","targetId","get","target","change","addedNodes","filter","removedNodes","attributeName","getAttribute","attributeValue","oldValue","has","set","DOCUMENT_NODE","includes","hasAttribute","_a","replay","blockSelector","matches","e","privacy","maskInputs","maskAllText","_b","parent","parentElement","_c","maskSelector","_d","urlObj","URL","protocol","params","URLSearchParams","search","parseInt","ConsoleRecorder","sessionId","originalMethods","entries","isRecording","maxEntries","captureStackTrace","serializeObjects","maxObjectDepth","maxStringLength","ignoredLevels","start","level","originalMethod","console","args","apply","recordEntry","stop","Object","method","entry","generateId","serializeArgs","Error","stack","cleanStackTrace","sourceLine","split","find","line","lineNumber","columnNumber","addEntry","warn","call","arg","serializeValue","depth","substring","message","__type","toISOString","RegExp","isArray","slice","item","keys","key","String","Math","random","toString","substr","getEntries","fromTimestamp","toTimestamp","filtered","getEntriesByLevel","clear","toSessionEvents","session_id","event_type","data","consoleId","user_agent","navigator","userAgent","exportData","levelCounts","minTime","Infinity","maxTime","min","max","stats","totalEntries","errorCount","warningCount","timeRange","end","generateInsights","errorPatterns","findErrorPatterns","performanceIssues","detectPerformanceIssues","recommendations","generateRecommendations","errors","patterns","pattern","firstArg","replace","sort","a","b","examples","count","issues","recentEntries","severity","details","errorCounts","JSON","stringify","some","debug","HeatmapGenerator","container","radius","maxIntensity","gradient","blur","minOpacity","maxOpacity","canvas","createElement","style","position","top","left","pointerEvents","zIndex","appendChild","ctx","getContext","resizeCanvas","addEventListener","rect","getBoundingClientRect","addDataPoint","intensity","eventType","generateFromEvents","events","event","_e","_f","render","clearRect","filteredData","d","intensityData","createIntensityMap","createGradient","renderHeatmap","shadowCanvas","shadowCtx","point","createRadialGradient","addColorStop","fillStyle","fillRect","drawImage","getImageData","gradientCanvas","gradientCtx","createLinearGradient","color","parseFloat","gradientData","output","createImageData","alpha","gradientIndex","floor","putImageData","destroy","removeChild","removeEventListener","eventTypes","minX","maxX","minY","maxY","totalEvents","bounds","hotSpots","findHotSpots","clickPatterns","analyzeClickPatterns","userBehavior","analyzeUserBehavior","clusters","clusterRadius","foundCluster","cluster","sqrt","pow","round","clicks","current","next","frequency","scrolls","sortedByIntensity","topHalf","scrollDepth","s","engagementScore","mostActiveArea","averageClicksPerSession","SessionReplayManager","heatmapGenerator","consoleLogs","networkRequests","originalConsole","startTime","domSerializer","consoleRecorder","maxConsoleEntries","ignoredConsoleLevels","_g","enabled","setupReplay","_j","_h","heatmaps","body","_l","_k","_o","_m","_q","_p","_s","_r","startRecording","takeFullSnapshot","handleDOMChange","setupNetworkCapture","setupInteractionTracking","setInterval","stopRecording","restoreOriginalNetwork","getReplayData","consoleEntries","consoleInsights","heatmapData","heatmapInsights","console_logs","network_requests","values","heatmap_data","session_info","start_time","duration","page_url","analytics","console_insights","heatmap_insights","clearReplayData","scrollTimeout","addCustomEvent","hidden","clearTimeout","setTimeout","passive","addEvent","source","toggleHeatmap","visible","getHeatmapInsights","fetch","originalFetch","async","input","init","requestId","generateRequestId","Request","requestHeaders","getRequestHeaders","requestBody","serializeRequestBody","response","networkRequest","status","responseHeaders","getResponseHeaders","shouldCaptureResponseBody","clonedResponse","clone","responseBody","text","XMLHttpRequest","originalXMLHttpRequest","self","xhr","originalOpen","open","originalSend","send","m","u","shouldCaptureXHRResponse","responseText","clientX","clientY","getElementId","capture","shouldIgnoreKeystroke","sanitizeKey","code","serializeConsoleArgs","parse","headers","Headers","assign","FormData","formData","File","contentType","contentLength","getResponseHeader","test"],"mappings":"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"}