{"version":3,"file":"revi-monitor.umd.js","sources":["../src/utils.ts","../src/trace-manager.ts","../src/error-handler.ts","../src/session.ts","../src/network-monitor.ts","../src/indexed-db-storage.ts","../src/storage-manager.ts","../src/network-manager.ts","../src/compression-utils.ts","../src/data-manager.ts","../src/user-journey.ts","../src/sampling-manager.ts","../src/performance-monitor.ts","../src/dom-serializer.ts","../src/console-recorder.ts","../src/heatmap-generator.ts","../src/session-replay.ts","../src/monitor.ts","../src/retry-manager.ts","../src/circuit-breaker.ts","../src/resilient-storage.ts","../src/health-monitor.ts","../src/sync-manager.ts","../src/idempotency-manager.ts","../src/resilience-coordinator.ts"],"sourcesContent":["export function generateId(): string {\n  return 'xxxx-xxxx-4xxx-yxxx-xxxx'.replace(/[xy]/g, function(c) {\n    const r = Math.random() * 16 | 0;\n    const v = c === 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\nexport function formatStackTrace(error: Error): string {\n  if (!error.stack) return '';\n  \n  return error.stack\n    .split('\\n')\n    .map(line => line.trim())\n    .filter(line => line.length > 0)\n    .join('\\n');\n}\n\nexport function sanitizeUrl(url: string, allowUrls: string[] = [], denyUrls: string[] = []): string {\n  // Check deny list first\n  if (denyUrls.some(pattern => new RegExp(pattern).test(url))) {\n    return '[Filtered]';\n  }\n  \n  // If allow list is provided, ensure URL matches\n  if (allowUrls.length > 0 && !allowUrls.some(pattern => new RegExp(pattern).test(url))) {\n    return '[Filtered]';\n  }\n  \n  // Remove sensitive query parameters\n  try {\n    const urlObj = new URL(url);\n    const sensitiveParams = ['password', 'token', 'key', 'secret', 'auth', 'api_key'];\n    \n    sensitiveParams.forEach(param => {\n      if (urlObj.searchParams.has(param)) {\n        urlObj.searchParams.set(param, '[Filtered]');\n      }\n    });\n    \n    return urlObj.toString();\n  } catch {\n    return url;\n  }\n}\n\nexport function maskSensitiveData(data: any, maskInputs = true): any {\n  if (typeof data !== 'object' || data === null) {\n    return data;\n  }\n  \n  if (Array.isArray(data)) {\n    return data.map(item => maskSensitiveData(item, maskInputs));\n  }\n  \n  const masked: any = {};\n  const sensitiveKeys = ['password', 'token', 'key', 'secret', 'auth', 'api_key', 'credit_card', 'ssn'];\n  \n  Object.keys(data).forEach(key => {\n    const lowerKey = key.toLowerCase();\n    if (sensitiveKeys.some(sensitive => lowerKey.includes(sensitive))) {\n      masked[key] = '[Masked]';\n    } else if (typeof data[key] === 'object') {\n      masked[key] = maskSensitiveData(data[key], maskInputs);\n    } else {\n      masked[key] = data[key];\n    }\n  });\n  \n  return masked;\n}\n\nexport function debounce<T extends (...args: any[]) => any>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout;\n  \n  return function executedFunction(...args: Parameters<T>) {\n    const later = () => {\n      clearTimeout(timeout);\n      func(...args);\n    };\n    \n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n}\n\nexport function throttle<T extends (...args: any[]) => any>(\n  func: T,\n  limit: number\n): (...args: Parameters<T>) => void {\n  let inThrottle = false;\n  \n  return function executedFunction(...args: Parameters<T>) {\n    if (!inThrottle) {\n      func(...args);\n      inThrottle = true;\n      setTimeout(() => inThrottle = false, limit);\n    }\n  };\n}\n\nexport function isBot(): boolean {\n  if (typeof navigator === 'undefined') return false;\n  \n  const botPatterns = [\n    /bot/i,\n    /spider/i,\n    /crawl/i,\n    /headless/i,\n    /phantom/i,\n    /selenium/i\n  ];\n  \n  return botPatterns.some(pattern => pattern.test(navigator.userAgent));\n}\n\nexport function getSessionStorage(): Storage | null {\n  try {\n    if (typeof window !== 'undefined' && window.sessionStorage) {\n      window.sessionStorage.setItem('test', 'test');\n      window.sessionStorage.removeItem('test');\n      return window.sessionStorage;\n    }\n  } catch {\n    // Storage not available\n  }\n  return null;\n}\n\nexport function getLocalStorage(): Storage | null {\n  try {\n    if (typeof window !== 'undefined' && window.localStorage) {\n      window.localStorage.setItem('test', 'test');\n      window.localStorage.removeItem('test');\n      return window.localStorage;\n    }\n  } catch {\n    // Storage not available\n  }\n  return null;\n}\n","export class TraceManager {\n  private currentTraceId?: string;\n  private currentSpanId?: string;\n  private spanCounter = 0;\n\n  constructor() {\n    // Initialize with session-level trace ID if needed\n    this.generateNewTrace();\n  }\n\n  generateNewTrace(): string {\n    this.currentTraceId = this.generateTraceId();\n    this.currentSpanId = undefined;\n    this.spanCounter = 0;\n    return this.currentTraceId;\n  }\n\n  startSpan(operationName?: string): string {\n    const parentSpanId = this.currentSpanId;\n    this.currentSpanId = this.generateSpanId();\n    this.spanCounter++;\n    \n    // Store span context for later correlation\n    if (operationName) {\n      this.setSpanData(operationName, { \n        parentSpanId,\n        operationName,\n        startTime: Date.now()\n      });\n    }\n\n    return this.currentSpanId;\n  }\n\n  finishSpan(spanId?: string, data?: Record<string, any>): void {\n    if (spanId && this.currentSpanId === spanId) {\n      // Mark span as finished\n      if (data) {\n        this.setSpanData(spanId, { \n          ...this.getSpanData(spanId),\n          ...data,\n          endTime: Date.now()\n        });\n      }\n    }\n  }\n\n  getCurrentTraceId(): string | undefined {\n    return this.currentTraceId;\n  }\n\n  getCurrentSpanId(): string | undefined {\n    return this.currentSpanId;\n  }\n\n  getTraceContext(): { traceId?: string; spanId?: string; parentSpanId?: string } {\n    return {\n      traceId: this.currentTraceId,\n      spanId: this.currentSpanId,\n      parentSpanId: this.getParentSpanId()\n    };\n  }\n\n  // Extract trace ID from headers (for network requests)\n  extractTraceFromHeaders(headers: Record<string, string>): { traceId?: string; spanId?: string } {\n    // Support various tracing standards\n    const traceId = headers['x-trace-id'] || \n                   headers['traceparent']?.split('-')[1] ||\n                   headers['b3-traceid'] ||\n                   headers['uber-trace-id']?.split(':')[0];\n\n    const spanId = headers['x-span-id'] || \n                  headers['traceparent']?.split('-')[2] ||\n                  headers['b3-spanid'] ||\n                  headers['uber-trace-id']?.split(':')[1];\n\n    return { traceId, spanId };\n  }\n\n  // Inject trace headers for outgoing requests\n  injectTraceHeaders(): Record<string, string> {\n    if (!this.currentTraceId) {\n      return {};\n    }\n\n    const headers: Record<string, string> = {};\n    \n    // Add custom headers\n    headers['x-trace-id'] = this.currentTraceId;\n    if (this.currentSpanId) {\n      headers['x-span-id'] = this.currentSpanId;\n      headers['x-parent-span-id'] = this.getParentSpanId() || '';\n    }\n\n    // Add W3C Trace Context (traceparent header)\n    if (this.currentSpanId) {\n      headers['traceparent'] = `00-${this.currentTraceId}-${this.currentSpanId}-01`;\n    }\n\n    return headers;\n  }\n\n  // Correlate with backend trace (when available)\n  correlateWithBackendTrace(backendTraceId?: string, backendSpanId?: string): void {\n    if (backendTraceId) {\n      this.currentTraceId = backendTraceId;\n    }\n    if (backendSpanId) {\n      this.currentSpanId = backendSpanId;\n    }\n  }\n\n  private generateTraceId(): string {\n    // Generate 128-bit trace ID (32 hex characters)\n    return this.generateRandomHex(32);\n  }\n\n  private generateSpanId(): string {\n    // Generate 64-bit span ID (16 hex characters)\n    return this.generateRandomHex(16);\n  }\n\n  private generateRandomHex(length: number): string {\n    const array = new Uint8Array(length / 2);\n    if (typeof crypto !== 'undefined' && crypto.getRandomValues) {\n      crypto.getRandomValues(array);\n    } else {\n      // Fallback for environments without crypto\n      for (let i = 0; i < array.length; i++) {\n        array[i] = Math.floor(Math.random() * 256);\n      }\n    }\n    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');\n  }\n\n  private getParentSpanId(): string | undefined {\n    // This would typically track a span stack, simplified for now\n    return this.spanData.get(this.currentSpanId || '')?.parentSpanId;\n  }\n\n  private spanData = new Map<string, any>();\n\n  private setSpanData(spanId: string, data: any): void {\n    this.spanData.set(spanId, data);\n  }\n\n  private getSpanData(spanId: string): any {\n    return this.spanData.get(spanId) || {};\n  }\n\n  // Clean up old span data to prevent memory leaks\n  cleanupSpanData(): void {\n    const cutoff = Date.now() - 5 * 60 * 1000; // 5 minutes ago\n    for (const [spanId, data] of this.spanData.entries()) {\n      if (data.endTime && data.endTime < cutoff) {\n        this.spanData.delete(spanId);\n      }\n    }\n  }\n}","import { formatStackTrace, generateId } from './utils';\nimport type { ErrorEvent, Breadcrumb, ReviConfig } from './types';\nimport { TraceManager } from './trace-manager';\n\nexport class ErrorHandler {\n  private config: ReviConfig;\n  private breadcrumbs: Breadcrumb[] = [];\n  private userContext: any = {};\n  private traceManager: TraceManager;\n\n  constructor(config: ReviConfig, traceManager?: TraceManager) {\n    this.config = config;\n    this.traceManager = traceManager || new TraceManager();\n    this.setupGlobalHandlers();\n  }\n\n  private setupGlobalHandlers(): void {\n    if (typeof window === 'undefined') return;\n\n    // Global error handler\n    window.addEventListener('error', (event) => {\n      this.captureError({\n        message: event.message,\n        filename: event.filename,\n        lineno: event.lineno,\n        colno: event.colno,\n        error: event.error\n      });\n    });\n\n    // Unhandled promise rejections\n    window.addEventListener('unhandledrejection', (event) => {\n      const error = event.reason;\n      let message = 'Unhandled Promise Rejection';\n      let stack = '';\n\n      if (error instanceof Error) {\n        message = error.message;\n        stack = formatStackTrace(error);\n      } else if (typeof error === 'string') {\n        message = error;\n      } else {\n        message = JSON.stringify(error);\n      }\n\n      this.captureError({\n        message,\n        stack,\n        error\n      });\n    });\n\n    // Console error interception\n    const originalConsoleError = console.error;\n    console.error = (...args: any[]) => {\n      this.addBreadcrumb({\n        timestamp: Date.now(),\n        message: args.join(' '),\n        category: 'console',\n        level: 'error'\n      });\n      originalConsoleError.apply(console, args);\n    };\n\n    // Console warn interception\n    const originalConsoleWarn = console.warn;\n    console.warn = (...args: any[]) => {\n      this.addBreadcrumb({\n        timestamp: Date.now(),\n        message: args.join(' '),\n        category: 'console',\n        level: 'warning'\n      });\n      originalConsoleWarn.apply(console, args);\n    };\n  }\n\n  captureError(errorData: {\n    message: string;\n    stack?: string;\n    filename?: string;\n    lineno?: number;\n    colno?: number;\n    error?: Error;\n    level?: 'error' | 'warning' | 'info' | 'debug';\n    tags?: Record<string, string>;\n    extra?: Record<string, any>;\n  }): string {\n    // Apply sampling\n    if (this.config.sampleRate && Math.random() > this.config.sampleRate) {\n      return '';\n    }\n\n    const errorId = generateId();\n    \n    // Start a new span for this error\n    const spanId = this.traceManager.startSpan(`error:${errorData.message}`);\n    const traceContext = this.traceManager.getTraceContext();\n    \n    const errorEvent: ErrorEvent = {\n      id: errorId,\n      timestamp: Date.now(),\n      message: errorData.message,\n      stack: errorData.stack || (errorData.error ? formatStackTrace(errorData.error) : undefined),\n      url: errorData.filename || window.location.href,\n      lineno: errorData.lineno,\n      colno: errorData.colno,\n      filename: errorData.filename,\n      userId: this.config.userId || this.userContext.id,\n      sessionId: '', // Will be set by Monitor class\n      userAgent: navigator.userAgent,\n      environment: this.config.environment,\n      release: this.config.release,\n      tags: errorData.tags,\n      extra: errorData.extra,\n      breadcrumbs: [...this.breadcrumbs],\n      level: errorData.level || 'error',\n      traceId: traceContext.traceId,\n      spanId: spanId,\n      parentSpanId: traceContext.parentSpanId\n    };\n\n    // Apply beforeSend filter\n    const filteredError = this.config.beforeSend?.(errorEvent) || errorEvent;\n    if (!filteredError) return '';\n\n    return errorId;\n  }\n\n  captureException(error: Error, options: {\n    level?: 'error' | 'warning' | 'info' | 'debug';\n    tags?: Record<string, string>;\n    extra?: Record<string, any>;\n  } = {}): string {\n    return this.captureError({\n      message: error.message,\n      stack: formatStackTrace(error),\n      error,\n      level: options.level,\n      tags: options.tags,\n      extra: options.extra\n    });\n  }\n\n  captureMessage(message: string, options: {\n    level?: 'error' | 'warning' | 'info' | 'debug';\n    tags?: Record<string, string>;\n    extra?: Record<string, any>;\n  } = {}): string {\n    return this.captureError({\n      message,\n      level: options.level || 'info',\n      tags: options.tags,\n      extra: options.extra\n    });\n  }\n\n  addBreadcrumb(breadcrumb: Breadcrumb): void {\n    this.breadcrumbs.push(breadcrumb);\n    \n    const maxBreadcrumbs = this.config.maxBreadcrumbs || 50;\n    if (this.breadcrumbs.length > maxBreadcrumbs) {\n      this.breadcrumbs.splice(0, this.breadcrumbs.length - maxBreadcrumbs);\n    }\n  }\n\n  setUserContext(user: any): void {\n    this.userContext = { ...this.userContext, ...user };\n  }\n\n  setTags(tags: Record<string, string>): void {\n    // Tags will be applied to future errors\n  }\n\n  setExtra(extra: Record<string, any>): void {\n    // Extra data will be applied to future errors\n  }\n\n  getBreadcrumbs(): Breadcrumb[] {\n    return [...this.breadcrumbs];\n  }\n\n  clearBreadcrumbs(): void {\n    this.breadcrumbs = [];\n  }\n}\n","import { generateId, getSessionStorage } from './utils';\nimport type { SessionEvent, ReviConfig } from './types';\nimport { TraceManager } from './trace-manager';\n\nexport class SessionManager {\n  private sessionId: string;\n  private startTime: number;\n  private events: SessionEvent[] = [];\n  private config: ReviConfig;\n  private storage: Storage | null;\n  private traceManager?: TraceManager;\n\n  constructor(config: ReviConfig, traceManager?: TraceManager) {\n    this.config = config;\n    this.traceManager = traceManager;\n    this.storage = getSessionStorage();\n    this.sessionId = this.getOrCreateSessionId();\n    this.startTime = Date.now();\n    \n    this.setupEventListeners();\n    this.trackPageLoad();\n  }\n\n  private getOrCreateSessionId(): string {\n    const storageKey = 'revi_session_id';\n    \n    if (this.storage) {\n      const existingId = this.storage.getItem(storageKey);\n      if (existingId) return existingId;\n    }\n    \n    const newId = generateId();\n    if (this.storage) {\n      this.storage.setItem(storageKey, newId);\n    }\n    \n    return newId;\n  }\n\n  getSessionId(): string {\n    return this.sessionId;\n  }\n\n  private setupEventListeners(): void {\n    if (typeof window === 'undefined') return;\n\n    // DOM events\n    const eventTypes = ['click', 'input', 'change', 'submit', 'focus', 'blur'];\n    eventTypes.forEach(eventType => {\n      document.addEventListener(eventType, (event) => {\n        this.captureEvent(eventType, this.serializeDOMEvent(event));\n      }, { capture: true, passive: true });\n    });\n\n    // Navigation events\n    window.addEventListener('popstate', () => {\n      this.captureEvent('navigation', {\n        type: 'popstate',\n        url: window.location.href,\n        timestamp: Date.now()\n      });\n    });\n\n    // Page visibility\n    document.addEventListener('visibilitychange', () => {\n      this.captureEvent('visibility', {\n        hidden: document.hidden,\n        timestamp: Date.now()\n      });\n    });\n\n    // Scroll events (throttled)\n    let scrollTimeout: NodeJS.Timeout;\n    window.addEventListener('scroll', () => {\n      clearTimeout(scrollTimeout);\n      scrollTimeout = setTimeout(() => {\n        this.captureEvent('scroll', {\n          x: window.scrollX,\n          y: window.scrollY,\n          timestamp: Date.now()\n        });\n      }, 100);\n    }, { passive: true });\n\n    // Resize events (throttled)\n    let resizeTimeout: NodeJS.Timeout;\n    window.addEventListener('resize', () => {\n      clearTimeout(resizeTimeout);\n      resizeTimeout = setTimeout(() => {\n        this.captureEvent('resize', {\n          width: window.innerWidth,\n          height: window.innerHeight,\n          timestamp: Date.now()\n        });\n      }, 100);\n    }, { passive: true });\n\n    // Before unload\n    window.addEventListener('beforeunload', () => {\n      this.captureEvent('beforeunload', {\n        timestamp: Date.now(),\n        duration: Date.now() - this.startTime\n      });\n      this.flush();\n    });\n  }\n\n  private serializeDOMEvent(event: Event): Record<string, any> {\n    const target = event.target as HTMLElement;\n    if (!target) return {};\n\n    const data: Record<string, any> = {\n      type: event.type,\n      timestamp: Date.now(),\n      target: {\n        tagName: target.tagName,\n        id: target.id,\n        className: target.className,\n        textContent: this.shouldMaskText(target) ? '[Masked]' : target.textContent?.slice(0, 100)\n      }\n    };\n\n    // Add specific event data\n    if (event.type === 'click') {\n      const mouseEvent = event as MouseEvent;\n      data.coordinates = {\n        x: mouseEvent.clientX,\n        y: mouseEvent.clientY\n      };\n    }\n\n    if (event.type === 'input' || event.type === 'change') {\n      const inputEvent = event.target as HTMLInputElement;\n      if (inputEvent && inputEvent.value !== undefined) {\n        data.value = this.shouldMaskInput(inputEvent) ? '[Masked]' : inputEvent.value;\n      }\n    }\n\n    return data;\n  }\n\n  private shouldMaskInput(element: HTMLInputElement): boolean {\n    if (!this.config.privacy?.maskInputs) return false;\n    \n    const sensitiveTypes = ['password', 'email', 'tel', 'credit-card-number'];\n    const sensitiveNames = ['password', 'email', 'phone', 'credit', 'card', 'ssn'];\n    \n    if (sensitiveTypes.includes(element.type)) return true;\n    \n    const name = element.name?.toLowerCase() || '';\n    const id = element.id?.toLowerCase() || '';\n    \n    return sensitiveNames.some(sensitive => \n      name.includes(sensitive) || id.includes(sensitive)\n    );\n  }\n\n  private shouldMaskText(element: HTMLElement): boolean {\n    if (!this.config.replay?.maskAllText) return false;\n    \n    // Check for specific selectors that should be masked\n    if (this.config.replay?.maskSelector) {\n      try {\n        return element.matches(this.config.replay.maskSelector);\n      } catch {\n        return false;\n      }\n    }\n    \n    return false;\n  }\n\n  private trackPageLoad(): void {\n    if (typeof window === 'undefined') return;\n\n    const captureLoadEvent = () => {\n      this.captureEvent('page_load', {\n        url: window.location.href,\n        title: document.title,\n        referrer: document.referrer,\n        timestamp: Date.now(),\n        loadTime: performance.now()\n      });\n    };\n\n    if (document.readyState === 'complete') {\n      captureLoadEvent();\n    } else {\n      window.addEventListener('load', captureLoadEvent);\n    }\n  }\n\n  captureEvent(type: string, data: Record<string, any>): void {\n    // Apply sampling\n    if (this.config.sessionSampleRate && Math.random() > this.config.sessionSampleRate) {\n      return;\n    }\n\n    // Start a new span for this session event if trace manager is available\n    const traceContext = this.traceManager?.getTraceContext();\n    const spanId = this.traceManager?.startSpan(`session:${type}`);\n\n    const event: SessionEvent = {\n      sessionId: this.sessionId,\n      timestamp: Date.now(),\n      type,\n      data,\n      traceId: traceContext?.traceId,\n      spanId: spanId\n    };\n\n    // Apply beforeSendSession filter\n    const filteredEvent = this.config.beforeSendSession?.(event) || event;\n    if (!filteredEvent) return;\n\n    this.events.push(filteredEvent);\n\n    // Auto-flush when buffer is full\n    if (this.events.length >= 100) {\n      this.flush();\n    }\n  }\n\n  getEvents(): SessionEvent[] {\n    return [...this.events];\n  }\n\n  clearEvents(): void {\n    this.events = [];\n  }\n\n  flush(): SessionEvent[] {\n    const events = this.getEvents();\n    this.clearEvents();\n    return events;\n  }\n\n  endSession(): void {\n    this.captureEvent('session_end', {\n      timestamp: Date.now(),\n      duration: Date.now() - this.startTime\n    });\n    \n    if (this.storage) {\n      this.storage.removeItem('revi_session_id');\n    }\n  }\n}\n","import { generateId } from './utils';\nimport type { NetworkEvent, ReviConfig } from './types';\nimport { TraceManager } from './trace-manager';\n\nexport class NetworkMonitor {\n  private config: ReviConfig;\n  private events: NetworkEvent[] = [];\n  private originalFetch: typeof fetch;\n  private originalXHROpen: typeof XMLHttpRequest.prototype.open;\n  private originalXHRSend: typeof XMLHttpRequest.prototype.send;\n  private traceManager: TraceManager;\n\n  constructor(config: ReviConfig, traceManager?: TraceManager) {\n    this.config = config;\n    this.traceManager = traceManager || new TraceManager();\n    this.originalFetch = window.fetch;\n    this.originalXHROpen = XMLHttpRequest.prototype.open;\n    this.originalXHRSend = XMLHttpRequest.prototype.send;\n    \n    this.setupInterceptors();\n  }\n\n  private setupInterceptors(): void {\n    if (typeof window === 'undefined') return;\n\n    this.interceptFetch();\n    this.interceptXHR();\n  }\n\n  private interceptFetch(): void {\n    window.fetch = async (...args: Parameters<typeof fetch>): Promise<Response> => {\n      const startTime = Date.now();\n      const url = typeof args[0] === 'string' ? args[0] : args[0].url;\n      const method = (args[1]?.method || 'GET').toUpperCase();\n      \n      // Check if this request should be monitored\n      if (!this.shouldMonitorRequest(url)) {\n        return await this.originalFetch.apply(window, args);\n      }\n      \n      // Start a new span for this network request\n      const spanId = this.traceManager.startSpan(`http:${method} ${url}`);\n      \n      // Inject trace headers into the request\n      const traceHeaders = this.traceManager.injectTraceHeaders();\n      const originalHeaders = args[1]?.headers || {};\n      const headers = { ...originalHeaders, ...traceHeaders };\n      \n      // Update request args with trace headers\n      const modifiedArgs: Parameters<typeof fetch> = [\n        args[0],\n        {\n          ...args[1],\n          headers: headers\n        }\n      ];\n      \n      let requestSize = 0;\n      let requestBody: any;\n      \n      if (args[1]?.body) {\n        requestBody = this.serializeRequestBody(args[1].body);\n        requestSize = this.calculateBodySize(args[1].body);\n      }\n\n      try {\n        const response = await this.originalFetch.apply(window, modifiedArgs);\n        const endTime = Date.now();\n        \n        let responseBody: any;\n        let responseSize = 0;\n        \n        if (this.shouldCaptureResponseBody(url)) {\n          const clonedResponse = response.clone();\n          try {\n            responseBody = await this.extractResponseBody(clonedResponse);\n            responseSize = this.calculateResponseSize(responseBody);\n          } catch {\n            // Failed to extract response body\n          }\n        }\n\n        // Extract trace context from response headers\n        const responseTrace = this.traceManager.extractTraceFromHeaders(\n          this.extractResponseHeaders(response.headers)\n        );\n        \n        // Correlate with backend trace if available\n        if (responseTrace.traceId) {\n          this.traceManager.correlateWithBackendTrace(responseTrace.traceId, responseTrace.spanId);\n        }\n        \n        // Finish the span\n        this.traceManager.finishSpan(spanId, {\n          statusCode: response.status,\n          responseTime: endTime - startTime\n        });\n        \n        const traceContext = this.traceManager.getTraceContext();\n        \n        this.captureNetworkEvent({\n          method,\n          url,\n          statusCode: response.status,\n          responseTime: endTime - startTime,\n          requestSize,\n          responseSize,\n          requestHeaders: this.extractHeaders(headers),\n          responseHeaders: this.extractResponseHeaders(response.headers),\n          requestBody,\n          responseBody,\n          timestamp: startTime,\n          traceId: traceContext.traceId,\n          spanId: spanId,\n          parentSpanId: traceContext.parentSpanId\n        });\n\n        return response;\n      } catch (error) {\n        const endTime = Date.now();\n        \n        // Finish the span with error\n        this.traceManager.finishSpan(spanId, {\n          statusCode: 0,\n          responseTime: endTime - startTime,\n          error: error instanceof Error ? error.message : String(error)\n        });\n        \n        const traceContext = this.traceManager.getTraceContext();\n        \n        this.captureNetworkEvent({\n          method,\n          url,\n          statusCode: 0, // Network error\n          responseTime: endTime - startTime,\n          requestSize,\n          responseSize: 0,\n          requestHeaders: this.extractHeaders(headers),\n          requestBody,\n          timestamp: startTime,\n          traceId: traceContext.traceId,\n          spanId: spanId,\n          parentSpanId: traceContext.parentSpanId\n        });\n\n        throw error;\n      }\n    };\n  }\n\n  private interceptXHR(): void {\n    const self = this;\n\n    XMLHttpRequest.prototype.open = function(method: string, url: string, ...args: any[]) {\n      (this as any)._reviData = {\n        method: method.toUpperCase(),\n        url,\n        startTime: Date.now(),\n        shouldMonitor: self.shouldMonitorRequest(url)\n      };\n      \n      return self.originalXHROpen.call(this, method, url, ...args);\n    };\n\n    XMLHttpRequest.prototype.send = function(body?: any) {\n      const reviData = (this as any)._reviData;\n      if (!reviData || !reviData.shouldMonitor) {\n        return self.originalXHRSend.call(this, body);\n      }\n\n      reviData.requestBody = self.serializeRequestBody(body);\n      reviData.requestSize = self.calculateBodySize(body);\n\n      this.addEventListener('loadend', () => {\n        const endTime = Date.now();\n        \n        let responseBody: any;\n        try {\n          if (this.responseType === '' || this.responseType === 'text') {\n            responseBody = this.responseText;\n          } else if (this.responseType === 'json') {\n            responseBody = this.response;\n          }\n        } catch {\n          // Failed to extract response\n        }\n\n        self.captureNetworkEvent({\n          method: reviData.method,\n          url: reviData.url,\n          statusCode: this.status,\n          responseTime: endTime - reviData.startTime,\n          requestSize: reviData.requestSize,\n          responseSize: self.calculateResponseSize(responseBody),\n          requestBody: reviData.requestBody,\n          responseBody: self.shouldCaptureResponseBody(reviData.url) ? responseBody : undefined,\n          timestamp: reviData.startTime\n        });\n      });\n\n      return self.originalXHRSend.call(this, body);\n    };\n  }\n\n  private serializeRequestBody(body: any): any {\n    if (!body) return undefined;\n    \n    if (typeof body === 'string') return body;\n    if (body instanceof FormData) {\n      const formObject: Record<string, any> = {};\n      body.forEach((value, key) => {\n        formObject[key] = value instanceof File ? `[File: ${value.name}]` : value;\n      });\n      return formObject;\n    }\n    if (body instanceof URLSearchParams) {\n      return Object.fromEntries(body);\n    }\n    \n    try {\n      return JSON.parse(JSON.stringify(body));\n    } catch {\n      return '[Unserializable]';\n    }\n  }\n\n  private async extractResponseBody(response: Response): Promise<any> {\n    const contentType = response.headers.get('content-type') || '';\n    \n    if (contentType.includes('application/json')) {\n      return await response.json();\n    } else if (contentType.includes('text/')) {\n      return await response.text();\n    }\n    \n    return '[Binary Data]';\n  }\n\n  private extractHeaders(headers?: HeadersInit): Record<string, string> {\n    if (!headers) return {};\n    \n    if (headers instanceof Headers) {\n      const headerObj: Record<string, string> = {};\n      headers.forEach((value, key) => {\n        headerObj[key] = value;\n      });\n      return headerObj;\n    }\n    \n    if (Array.isArray(headers)) {\n      const headerObj: Record<string, string> = {};\n      headers.forEach(([key, value]) => {\n        headerObj[key] = value;\n      });\n      return headerObj;\n    }\n    \n    return headers as Record<string, string>;\n  }\n\n  private extractResponseHeaders(headers: Headers): Record<string, string> {\n    const headerObj: Record<string, string> = {};\n    headers.forEach((value, key) => {\n      headerObj[key] = value;\n    });\n    return headerObj;\n  }\n\n  private calculateBodySize(body: any): number {\n    if (!body) return 0;\n    \n    if (typeof body === 'string') return body.length;\n    if (body instanceof ArrayBuffer) return body.byteLength;\n    if (body instanceof Blob) return body.size;\n    \n    try {\n      return JSON.stringify(body).length;\n    } catch {\n      return 0;\n    }\n  }\n\n  private calculateResponseSize(response: any): number {\n    if (!response) return 0;\n    \n    try {\n      return JSON.stringify(response).length;\n    } catch {\n      return 0;\n    }\n  }\n\n  private shouldCaptureResponseBody(url: string): boolean {\n    // Only capture response bodies for specific URLs to avoid memory issues\n    const allowedPatterns = [\n      /\\/api\\//,\n      /\\/graphql/,\n    ];\n    \n    return allowedPatterns.some(pattern => pattern.test(url));\n  }\n\n  private shouldMonitorRequest(url: string): boolean {\n    // Don't monitor the SDK's own API calls to prevent feedback loops\n    const apiUrl = this.config.apiUrl || 'https://api.revi.dev';\n    \n    // Remove trailing slash for consistent comparison\n    const normalizedApiUrl = apiUrl.replace(/\\/$/, '');\n    const normalizedUrl = url.replace(/\\/$/, '');\n    \n    // Debug logging to identify filtering issues\n    if (this.config.debug) {\n      console.log('[Revi Debug] Network filter check:', { \n        url, \n        normalizedUrl, \n        apiUrl, \n        normalizedApiUrl \n      });\n    }\n    \n    // Exclude any requests to the Revi API backend\n    if (normalizedUrl.startsWith(normalizedApiUrl)) {\n      if (this.config.debug) {\n        console.log('[Revi Debug] Filtering API URL:', url, '(matches configured apiUrl)');\n      }\n      return false;\n    }\n    \n    // Use configurable development hosts or default patterns\n    const developmentHosts = this.config.developmentHosts || [\n      /^https?:\\/\\/localhost:\\d+/,\n      /^https?:\\/\\/127\\.0\\.0\\.1:\\d+/,\n      /^https?:\\/\\/0\\.0\\.0\\.0:\\d+/,\n      /^https?:\\/\\/.*\\.local:\\d+/\n    ];\n    \n    const matchedPattern = developmentHosts.find(pattern => pattern.test(url));\n    if (matchedPattern) {\n      if (this.config.debug) {\n        console.log('[Revi Debug] Filtering development host URL:', url, '(matched pattern:', matchedPattern, ')');\n      }\n      return false;\n    }\n    \n    // Additional API endpoint patterns to filter\n    const apiEndpointPatterns = [\n      /\\/api\\/capture\\//,\n      /\\/api\\/errors/,\n      /\\/api\\/session/,\n      /\\/api\\/projects/,\n      /\\/api\\/database/,\n      /\\/api\\/analytics/,\n      /\\/health$/,\n    ];\n    \n    const matchedApiPattern = apiEndpointPatterns.find(pattern => pattern.test(url));\n    if (matchedApiPattern) {\n      if (this.config.debug) {\n        console.log('[Revi Debug] Filtering API endpoint:', url, '(matched pattern:', matchedApiPattern, ')');\n      }\n      return false;\n    }\n    \n    // Check configurable exclude URLs\n    if (this.config.excludeUrls) {\n      const excluded = this.config.excludeUrls.some(pattern => pattern.test(url));\n      if (excluded) {\n        if (this.config.debug) {\n          console.log('[Revi Debug] Filtering excluded URL:', url);\n        }\n        return false;\n      }\n    }\n    \n    // Check privacy configuration if available\n    if (this.config.privacy?.denyUrls) {\n      const denied = this.config.privacy.denyUrls.some(pattern => {\n        const regex = new RegExp(pattern);\n        return regex.test(url);\n      });\n      if (denied) {\n        if (this.config.debug) {\n          console.log('[Revi Debug] Filtering denied URL:', url);\n        }\n        return false;\n      }\n    }\n    \n    if (this.config.privacy?.allowUrls) {\n      const allowed = this.config.privacy.allowUrls.some(pattern => {\n        const regex = new RegExp(pattern);\n        return regex.test(url);\n      });\n      if (this.config.debug) {\n        console.log('[Revi Debug] Allow list result for:', url, '- allowed:', allowed);\n      }\n      return allowed;\n    }\n    \n    if (this.config.debug) {\n      console.log('[Revi Debug] Monitoring URL:', url, '(no filters matched)');\n    }\n    return true;\n  }\n\n  private captureNetworkEvent(data: Partial<NetworkEvent> & { method: string; url: string; timestamp: number }): void {\n    const event: NetworkEvent = {\n      sessionId: '', // Will be set by Monitor class\n      timestamp: data.timestamp,\n      method: data.method,\n      url: data.url,\n      statusCode: data.statusCode,\n      responseTime: data.responseTime,\n      requestSize: data.requestSize,\n      responseSize: data.responseSize,\n      requestHeaders: data.requestHeaders,\n      responseHeaders: data.responseHeaders,\n      requestBody: data.requestBody,\n      responseBody: data.responseBody\n    };\n\n    this.events.push(event);\n\n    // Auto-flush when buffer is full\n    if (this.events.length >= 50) {\n      this.flush();\n    }\n  }\n\n  getEvents(): NetworkEvent[] {\n    return [...this.events];\n  }\n\n  clearEvents(): void {\n    this.events = [];\n  }\n\n  flush(): NetworkEvent[] {\n    const events = this.getEvents();\n    this.clearEvents();\n    return events;\n  }\n\n  destroy(): void {\n    // Restore original implementations\n    if (this.originalFetch) {\n      window.fetch = this.originalFetch;\n    }\n    \n    XMLHttpRequest.prototype.open = this.originalXHROpen;\n    XMLHttpRequest.prototype.send = this.originalXHRSend;\n  }\n}\n","import type { ErrorEvent, SessionEvent, NetworkEvent } from './types';\n\ninterface StorageItem {\n  id: string;\n  type: 'error' | 'session' | 'network';\n  data: any;\n  timestamp: number;\n  compressed: boolean;\n}\n\nexport class IndexedDBStorage {\n  private db: IDBDatabase | null = null;\n  private dbName = 'revi-storage';\n  private version = 1;\n  private storeName = 'queue';\n  private maxQueueSize = 1000;\n  private maxAge = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds\n\n  async initialize(): Promise<void> {\n    if (typeof window === 'undefined' || !window.indexedDB) {\n      throw new Error('IndexedDB not supported');\n    }\n\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, this.version);\n\n      request.onerror = () => {\n        reject(new Error('Failed to open IndexedDB'));\n      };\n\n      request.onsuccess = () => {\n        this.db = request.result;\n        resolve();\n      };\n\n      request.onupgradeneeded = (event) => {\n        const db = (event.target as IDBOpenDBRequest).result;\n        \n        if (!db.objectStoreNames.contains(this.storeName)) {\n          const objectStore = db.createObjectStore(this.storeName, { keyPath: 'id' });\n          objectStore.createIndex('timestamp', 'timestamp', { unique: false });\n          objectStore.createIndex('type', 'type', { unique: false });\n        }\n      };\n    });\n  }\n\n  async store(type: 'error' | 'session' | 'network', data: any): Promise<void> {\n    if (!this.db) {\n      await this.initialize();\n    }\n\n    await this.cleanupExpiredItems();\n    \n    const queueSize = await this.getQueueSize();\n    if (queueSize >= this.maxQueueSize) {\n      await this.removeOldestItems(100);\n    }\n\n    const item: StorageItem = {\n      id: this.generateId(),\n      type,\n      data: await this.compress(data),\n      timestamp: Date.now(),\n      compressed: true\n    };\n\n    return new Promise((resolve, reject) => {\n      if (!this.db) {\n        reject(new Error('Database not initialized'));\n        return;\n      }\n\n      const transaction = this.db.transaction([this.storeName], 'readwrite');\n      const objectStore = transaction.objectStore(this.storeName);\n      const request = objectStore.add(item);\n\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(new Error('Failed to store item'));\n    });\n  }\n\n  async getAll(): Promise<{ errors: ErrorEvent[]; sessionEvents: SessionEvent[]; networkEvents: NetworkEvent[] }> {\n    if (!this.db) {\n      await this.initialize();\n    }\n\n    return new Promise((resolve, reject) => {\n      if (!this.db) {\n        reject(new Error('Database not initialized'));\n        return;\n      }\n\n      const transaction = this.db.transaction([this.storeName], 'readonly');\n      const objectStore = transaction.objectStore(this.storeName);\n      const request = objectStore.getAll();\n\n      request.onsuccess = async () => {\n        const items = request.result as StorageItem[];\n        const result = {\n          errors: [] as ErrorEvent[],\n          sessionEvents: [] as SessionEvent[],\n          networkEvents: [] as NetworkEvent[]\n        };\n\n        for (const item of items) {\n          const decompressedData = await this.decompress(item.data);\n          \n          switch (item.type) {\n            case 'error':\n              result.errors.push(...(Array.isArray(decompressedData) ? decompressedData : [decompressedData]));\n              break;\n            case 'session':\n              result.sessionEvents.push(...(Array.isArray(decompressedData) ? decompressedData : [decompressedData]));\n              break;\n            case 'network':\n              result.networkEvents.push(...(Array.isArray(decompressedData) ? decompressedData : [decompressedData]));\n              break;\n          }\n        }\n\n        resolve(result);\n      };\n\n      request.onerror = () => reject(new Error('Failed to retrieve items'));\n    });\n  }\n\n  async clear(): Promise<void> {\n    if (!this.db) {\n      await this.initialize();\n    }\n\n    return new Promise((resolve, reject) => {\n      if (!this.db) {\n        reject(new Error('Database not initialized'));\n        return;\n      }\n\n      const transaction = this.db.transaction([this.storeName], 'readwrite');\n      const objectStore = transaction.objectStore(this.storeName);\n      const request = objectStore.clear();\n\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(new Error('Failed to clear storage'));\n    });\n  }\n\n  async getQueueSize(): Promise<number> {\n    if (!this.db) {\n      await this.initialize();\n    }\n\n    return new Promise((resolve, reject) => {\n      if (!this.db) {\n        reject(new Error('Database not initialized'));\n        return;\n      }\n\n      const transaction = this.db.transaction([this.storeName], 'readonly');\n      const objectStore = transaction.objectStore(this.storeName);\n      const request = objectStore.count();\n\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(new Error('Failed to get queue size'));\n    });\n  }\n\n  private async cleanupExpiredItems(): Promise<void> {\n    if (!this.db) return;\n\n    const cutoffTime = Date.now() - this.maxAge;\n\n    return new Promise((resolve) => {\n      if (!this.db) {\n        resolve();\n        return;\n      }\n\n      const transaction = this.db.transaction([this.storeName], 'readwrite');\n      const objectStore = transaction.objectStore(this.storeName);\n      const index = objectStore.index('timestamp');\n      const range = IDBKeyRange.upperBound(cutoffTime);\n      const request = index.openCursor(range);\n\n      request.onsuccess = (event) => {\n        const cursor = (event.target as IDBRequest).result;\n        if (cursor) {\n          cursor.delete();\n          cursor.continue();\n        } else {\n          resolve();\n        }\n      };\n\n      request.onerror = () => resolve();\n    });\n  }\n\n  private async removeOldestItems(count: number): Promise<void> {\n    if (!this.db) return;\n\n    return new Promise((resolve) => {\n      if (!this.db) {\n        resolve();\n        return;\n      }\n\n      const transaction = this.db.transaction([this.storeName], 'readwrite');\n      const objectStore = transaction.objectStore(this.storeName);\n      const index = objectStore.index('timestamp');\n      const request = index.openCursor();\n\n      let deletedCount = 0;\n      request.onsuccess = (event) => {\n        const cursor = (event.target as IDBRequest).result;\n        if (cursor && deletedCount < count) {\n          cursor.delete();\n          deletedCount++;\n          cursor.continue();\n        } else {\n          resolve();\n        }\n      };\n\n      request.onerror = () => resolve();\n    });\n  }\n\n  private async compress(data: any): Promise<string> {\n    try {\n      const json = JSON.stringify(data);\n      // Simple base64 compression for now - can be upgraded to gzip\n      return btoa(unescape(encodeURIComponent(json)));\n    } catch (error) {\n      // Fallback to uncompressed JSON string\n      return JSON.stringify(data);\n    }\n  }\n\n  private async decompress(data: string): Promise<any> {\n    try {\n      // Try to decode base64 first\n      const decoded = decodeURIComponent(escape(atob(data)));\n      return JSON.parse(decoded);\n    } catch (error) {\n      // Fallback to direct JSON parse\n      try {\n        return JSON.parse(data);\n      } catch (parseError) {\n        return data;\n      }\n    }\n  }\n\n  private generateId(): string {\n    return `revi-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n}","import { IndexedDBStorage } from './indexed-db-storage';\nimport { getLocalStorage } from './utils';\nimport type { ErrorEvent, SessionEvent, NetworkEvent } from './types';\n\ninterface StorageInterface {\n  store(type: 'error' | 'session' | 'network', data: any): Promise<void>;\n  getAll(): Promise<{ errors: ErrorEvent[]; sessionEvents: SessionEvent[]; networkEvents: NetworkEvent[] }>;\n  clear(): Promise<void>;\n  getQueueSize?(): Promise<number>;\n}\n\nclass LocalStorageAdapter implements StorageInterface {\n  private storage: Storage;\n  private storageKey = 'revi_upload_queue';\n\n  constructor() {\n    const localStorage = getLocalStorage();\n    if (!localStorage) {\n      throw new Error('No storage available');\n    }\n    this.storage = localStorage;\n  }\n\n  async store(type: 'error' | 'session' | 'network', data: any): Promise<void> {\n    try {\n      const existing = await this.getAll();\n      \n      switch (type) {\n        case 'error':\n          existing.errors.push(...(Array.isArray(data) ? data : [data]));\n          break;\n        case 'session':\n          existing.sessionEvents.push(...(Array.isArray(data) ? data : [data]));\n          break;\n        case 'network':\n          existing.networkEvents.push(...(Array.isArray(data) ? data : [data]));\n          break;\n      }\n\n      this.storage.setItem(this.storageKey, JSON.stringify(existing));\n    } catch (error) {\n      // Storage quota exceeded or other error\n      throw new Error('Failed to store data');\n    }\n  }\n\n  async getAll(): Promise<{ errors: ErrorEvent[]; sessionEvents: SessionEvent[]; networkEvents: NetworkEvent[] }> {\n    try {\n      const storedData = this.storage.getItem(this.storageKey);\n      if (storedData) {\n        return JSON.parse(storedData);\n      }\n    } catch (error) {\n      // Failed to parse or retrieve data\n    }\n    \n    return {\n      errors: [],\n      sessionEvents: [],\n      networkEvents: []\n    };\n  }\n\n  async clear(): Promise<void> {\n    try {\n      this.storage.removeItem(this.storageKey);\n    } catch (error) {\n      // Ignore errors\n    }\n  }\n}\n\nexport class StorageManager {\n  private storage: StorageInterface | null = null;\n  private isInitialized = false;\n\n  async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n\n    try {\n      // Try IndexedDB first\n      const indexedDB = new IndexedDBStorage();\n      await indexedDB.initialize();\n      this.storage = indexedDB;\n      console.log('[Revi] Using IndexedDB for offline storage');\n    } catch (error) {\n      // Fallback to localStorage\n      try {\n        this.storage = new LocalStorageAdapter();\n        console.log('[Revi] Using localStorage for offline storage');\n      } catch (localStorageError) {\n        console.warn('[Revi] No storage available, data will not persist offline');\n        this.storage = new NoOpStorage();\n      }\n    }\n\n    this.isInitialized = true;\n  }\n\n  async storeErrors(errors: ErrorEvent[]): Promise<void> {\n    await this.ensureInitialized();\n    if (errors.length > 0) {\n      await this.storage!.store('error', errors);\n    }\n  }\n\n  async storeSessionEvents(events: SessionEvent[]): Promise<void> {\n    await this.ensureInitialized();\n    if (events.length > 0) {\n      await this.storage!.store('session', events);\n    }\n  }\n\n  async storeNetworkEvents(events: NetworkEvent[]): Promise<void> {\n    await this.ensureInitialized();\n    if (events.length > 0) {\n      await this.storage!.store('network', events);\n    }\n  }\n\n  async getAllData(): Promise<{ errors: ErrorEvent[]; sessionEvents: SessionEvent[]; networkEvents: NetworkEvent[] }> {\n    await this.ensureInitialized();\n    return await this.storage!.getAll();\n  }\n\n  async clearAll(): Promise<void> {\n    await this.ensureInitialized();\n    await this.storage!.clear();\n  }\n\n  async getQueueSize(): Promise<number> {\n    await this.ensureInitialized();\n    if (this.storage && 'getQueueSize' in this.storage && this.storage.getQueueSize) {\n      return await this.storage.getQueueSize();\n    } else {\n      // Fallback for localStorage\n      const data = await this.getAllData();\n      return data.errors.length + data.sessionEvents.length + data.networkEvents.length;\n    }\n  }\n\n  private async ensureInitialized(): Promise<void> {\n    if (!this.isInitialized) {\n      await this.initialize();\n    }\n  }\n}\n\nclass NoOpStorage implements StorageInterface {\n  async store(): Promise<void> {\n    // Do nothing\n  }\n\n  async getAll(): Promise<{ errors: ErrorEvent[]; sessionEvents: SessionEvent[]; networkEvents: NetworkEvent[] }> {\n    return {\n      errors: [],\n      sessionEvents: [],\n      networkEvents: []\n    };\n  }\n\n  async clear(): Promise<void> {\n    // Do nothing\n  }\n}","export class NetworkManager {\n  private isOnline = typeof navigator !== 'undefined' ? navigator.onLine : true;\n  private connectionType: string = 'unknown';\n  private listeners: Array<(online: boolean) => void> = [];\n\n  constructor() {\n    if (typeof window !== 'undefined') {\n      // Listen for online/offline events\n      window.addEventListener('online', () => {\n        this.isOnline = true;\n        this.notifyListeners(true);\n      });\n\n      window.addEventListener('offline', () => {\n        this.isOnline = false;\n        this.notifyListeners(false);\n      });\n\n      // Detect connection type if available\n      this.detectConnectionType();\n    }\n  }\n\n  getConnectionStatus(): { online: boolean; connectionType: string } {\n    return {\n      online: this.isOnline,\n      connectionType: this.connectionType\n    };\n  }\n\n  onConnectionChange(callback: (online: boolean) => void): () => void {\n    this.listeners.push(callback);\n    \n    // Return unsubscribe function\n    return () => {\n      const index = this.listeners.indexOf(callback);\n      if (index > -1) {\n        this.listeners.splice(index, 1);\n      }\n    };\n  }\n\n  getBatchSize(): number {\n    if (!this.isOnline) {\n      return 0; // Don't upload when offline\n    }\n\n    // Adjust batch size based on connection quality\n    switch (this.connectionType) {\n      case 'slow-2g':\n        return 5;\n      case '2g':\n        return 10;\n      case '3g':\n        return 25;\n      case '4g':\n        return 50;\n      default:\n        return 25;\n    }\n  }\n\n  getUploadDelay(): number {\n    if (!this.isOnline) {\n      return 0; // Don't upload when offline\n    }\n\n    // Adjust upload frequency based on connection\n    switch (this.connectionType) {\n      case 'slow-2g':\n        return 30000; // 30 seconds\n      case '2g':\n        return 15000; // 15 seconds\n      case '3g':\n        return 10000; // 10 seconds\n      case '4g':\n        return 5000;  // 5 seconds\n      default:\n        return 10000; // 10 seconds\n    }\n  }\n\n  shouldRetry(attempt: number): boolean {\n    if (!this.isOnline) {\n      return false; // Don't retry when offline\n    }\n\n    // Exponential backoff with max attempts\n    const maxAttempts = 5;\n    return attempt < maxAttempts;\n  }\n\n  getRetryDelay(attempt: number): number {\n    // Exponential backoff: 1s, 2s, 4s, 8s, 16s\n    return Math.min(1000 * Math.pow(2, attempt), 16000);\n  }\n\n  private detectConnectionType(): void {\n    if ('connection' in navigator) {\n      const connection = (navigator as any).connection;\n      this.connectionType = connection.effectiveType || connection.type || 'unknown';\n      \n      // Listen for connection changes\n      connection.addEventListener('change', () => {\n        this.connectionType = connection.effectiveType || connection.type || 'unknown';\n      });\n    }\n  }\n\n  private notifyListeners(online: boolean): void {\n    this.listeners.forEach(callback => {\n      try {\n        callback(online);\n      } catch (error) {\n        console.error('[Revi] Error in connection change callback:', error);\n      }\n    });\n  }\n\n  // Ping test to verify actual connectivity\n  async testConnectivity(url?: string): Promise<boolean> {\n    if (!this.isOnline) {\n      return false;\n    }\n\n    try {\n      const testUrl = url || 'https://api.revi.dev/health';\n      const response = await fetch(testUrl, {\n        method: 'HEAD',\n        mode: 'no-cors',\n        cache: 'no-cache'\n      });\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n}","// Simple compression utilities for data transmission\n\n// Basic gzip-like compression using built-in compression APIs\nexport async function compressData(data: any): Promise<{ data: string; compressed: boolean }> {\n  const jsonString = JSON.stringify(data);\n  \n  // Only compress if the data is large enough to benefit\n  if (jsonString.length < 1024) {\n    return { data: jsonString, compressed: false };\n  }\n\n  try {\n    // Use CompressionStream if available (modern browsers)\n    if (typeof CompressionStream !== 'undefined') {\n      const stream = new CompressionStream('gzip');\n      const writer = stream.writable.getWriter();\n      const reader = stream.readable.getReader();\n      \n      // Write the JSON string as UTF-8 bytes\n      const encoder = new TextEncoder();\n      const bytes = encoder.encode(jsonString);\n      \n      await writer.write(bytes);\n      await writer.close();\n      \n      // Read compressed data\n      const compressed = [];\n      let done = false;\n      \n      while (!done) {\n        const { value, done: readerDone } = await reader.read();\n        done = readerDone;\n        if (value) {\n          compressed.push(value);\n        }\n      }\n      \n      // Combine all chunks and convert to base64\n      const compressedBytes = new Uint8Array(\n        compressed.reduce((acc, chunk) => acc + chunk.length, 0)\n      );\n      \n      let offset = 0;\n      for (const chunk of compressed) {\n        compressedBytes.set(chunk, offset);\n        offset += chunk.length;\n      }\n      \n      const base64 = btoa(String.fromCharCode(...compressedBytes));\n      \n      // Only return compressed if it's actually smaller\n      if (base64.length < jsonString.length * 0.8) {\n        return { data: base64, compressed: true };\n      }\n    }\n  } catch (error) {\n    console.warn('[Revi] Compression failed, sending uncompressed data:', error);\n  }\n  \n  // Fallback to uncompressed data\n  return { data: jsonString, compressed: false };\n}\n\n// Simple string compression for older browsers\nexport function compressString(str: string): string {\n  // Simple run-length encoding for repeated patterns\n  let compressed = '';\n  let i = 0;\n  \n  while (i < str.length) {\n    let count = 1;\n    const char = str[i];\n    \n    // Count consecutive characters\n    while (i + count < str.length && str[i + count] === char && count < 99) {\n      count++;\n    }\n    \n    if (count > 3) {\n      compressed += `${char}${count}`;\n    } else {\n      compressed += char.repeat(count);\n    }\n    \n    i += count;\n  }\n  \n  return compressed.length < str.length ? compressed : str;\n}\n\n// Deduplicate arrays of objects with similar keys\nexport function deduplicateEvents<T extends Record<string, any>>(events: T[]): {\n  events: T[];\n  compressionRatio: number;\n} {\n  if (events.length === 0) return { events, compressionRatio: 1 };\n  \n  const originalSize = JSON.stringify(events).length;\n  \n  // Group events by type/structure\n  const grouped = new Map<string, T[]>();\n  \n  for (const event of events) {\n    const keys = Object.keys(event).sort().join(',');\n    if (!grouped.has(keys)) {\n      grouped.set(keys, []);\n    }\n    grouped.get(keys)!.push(event);\n  }\n  \n  // Compress each group separately\n  const compressed: T[] = [];\n  \n  for (const [keys, groupedEvents] of grouped) {\n    if (groupedEvents.length === 1) {\n      compressed.push(groupedEvents[0]);\n      continue;\n    }\n    \n    // Extract common values\n    const commonValues: Record<string, any> = {};\n    const keyArray = keys.split(',');\n    \n    for (const key of keyArray) {\n      const values = groupedEvents.map(e => e[key]);\n      const firstValue = values[0];\n      \n      if (values.every(v => \n        JSON.stringify(v) === JSON.stringify(firstValue)\n      )) {\n        commonValues[key] = firstValue;\n      }\n    }\n    \n    // Create compressed events\n    for (const event of groupedEvents) {\n      const compressedEvent: any = { ...event };\n      \n      // Remove common values (they're implicit)\n      for (const key of Object.keys(commonValues)) {\n        if (JSON.stringify(event[key]) === JSON.stringify(commonValues[key])) {\n          delete compressedEvent[key];\n        }\n      }\n      \n      // Add common values reference if significant compression\n      if (Object.keys(commonValues).length > 2) {\n        compressedEvent._common = commonValues;\n      }\n      \n      compressed.push(compressedEvent);\n    }\n  }\n  \n  const compressedSize = JSON.stringify(compressed).length;\n  const compressionRatio = compressedSize / originalSize;\n  \n  return { events: compressed, compressionRatio };\n}\n\n// Batch events intelligently based on size and type\nexport function createOptimalBatches<T>(\n  events: T[],\n  maxBatchSize: number,\n  maxBatchBytes: number = 64 * 1024 // 64KB default\n): T[][] {\n  if (events.length === 0) return [];\n  \n  const batches: T[][] = [];\n  let currentBatch: T[] = [];\n  let currentBatchSize = 0;\n  \n  for (const event of events) {\n    const eventSize = JSON.stringify(event).length;\n    \n    // Start new batch if current would exceed limits\n    if (\n      currentBatch.length >= maxBatchSize ||\n      currentBatchSize + eventSize > maxBatchBytes\n    ) {\n      if (currentBatch.length > 0) {\n        batches.push(currentBatch);\n        currentBatch = [];\n        currentBatchSize = 0;\n      }\n    }\n    \n    currentBatch.push(event);\n    currentBatchSize += eventSize;\n  }\n  \n  // Don't forget the last batch\n  if (currentBatch.length > 0) {\n    batches.push(currentBatch);\n  }\n  \n  return batches;\n}","import { StorageManager } from './storage-manager';\nimport { NetworkManager } from './network-manager';\nimport { compressData, deduplicateEvents, createOptimalBatches } from './compression-utils';\nimport type { ErrorEvent, SessionEvent, NetworkEvent, ReviConfig } from './types';\n\nexport class DataManager {\n  private config: ReviConfig;\n  private storageManager: StorageManager;\n  private networkManager: NetworkManager;\n  private uploadTimer: NodeJS.Timeout | null = null;\n  private isUploading = false;\n  private retryAttempts = new Map<string, number>();\n  private uploadQueue: {\n    errors: ErrorEvent[];\n    sessionEvents: SessionEvent[];\n    networkEvents: NetworkEvent[];\n  } = {\n    errors: [],\n    sessionEvents: [],\n    networkEvents: []\n  };\n\n  constructor(config: ReviConfig) {\n    this.config = config;\n    this.storageManager = new StorageManager();\n    this.networkManager = new NetworkManager();\n    \n    this.initialize();\n  }\n\n  private async initialize(): Promise<void> {\n    try {\n      await this.storageManager.initialize();\n      await this.loadQueueFromStorage();\n      this.startNetworkAwareUploadTimer();\n      this.setupBeforeUnloadHandler();\n      this.setupNetworkChangeHandler();\n    } catch (error) {\n      console.error('[Revi] Failed to initialize data manager:', error);\n    }\n  }\n\n  private async loadQueueFromStorage(): Promise<void> {\n    try {\n      const storedData = await this.storageManager.getAllData();\n      this.uploadQueue = storedData;\n    } catch (error) {\n      console.error('[Revi] Failed to load queue from storage:', error);\n    }\n  }\n\n  private async saveQueueToStorage(): Promise<void> {\n    try {\n      await this.storageManager.clearAll();\n      if (this.uploadQueue.errors.length > 0) {\n        await this.storageManager.storeErrors(this.uploadQueue.errors);\n      }\n      if (this.uploadQueue.sessionEvents.length > 0) {\n        await this.storageManager.storeSessionEvents(this.uploadQueue.sessionEvents);\n      }\n      if (this.uploadQueue.networkEvents.length > 0) {\n        await this.storageManager.storeNetworkEvents(this.uploadQueue.networkEvents);\n      }\n    } catch (error) {\n      console.error('[Revi] Failed to save queue to storage:', error);\n    }\n  }\n\n  private startNetworkAwareUploadTimer(): void {\n    const scheduleNextUpload = () => {\n      if (this.uploadTimer) {\n        clearTimeout(this.uploadTimer);\n      }\n\n      const delay = this.networkManager.getUploadDelay();\n      if (delay > 0) {\n        this.uploadTimer = setTimeout(() => {\n          if (!this.isUploading && this.hasQueuedData()) {\n            this.uploadData().finally(() => {\n              scheduleNextUpload();\n            });\n          } else {\n            scheduleNextUpload();\n          }\n        }, delay);\n      }\n    };\n\n    scheduleNextUpload();\n  }\n\n  private setupNetworkChangeHandler(): void {\n    this.networkManager.onConnectionChange((online) => {\n      if (online) {\n        console.log('[Revi] Network connection restored, resuming uploads');\n        if (this.hasQueuedData() && !this.isUploading) {\n          // Wait a bit before starting uploads to ensure connection is stable\n          setTimeout(() => {\n            this.uploadData();\n          }, 1000);\n        }\n      } else {\n        console.log('[Revi] Network connection lost, uploads paused');\n      }\n    });\n  }\n\n  private setupBeforeUnloadHandler(): void {\n    if (typeof window === 'undefined') return;\n\n    window.addEventListener('beforeunload', () => {\n      if (this.hasQueuedData()) {\n        this.uploadDataSync();\n      }\n    });\n  }\n\n  queueError(error: ErrorEvent): void {\n    this.uploadQueue.errors.push(error);\n    this.saveQueueToStorage().catch(err => {\n      console.error('[Revi] Failed to save error to storage:', err);\n    });\n  }\n\n  queueSessionEvents(events: SessionEvent[]): void {\n    this.uploadQueue.sessionEvents.push(...events);\n    this.saveQueueToStorage().catch(err => {\n      console.error('[Revi] Failed to save session events to storage:', err);\n    });\n  }\n\n  queueNetworkEvents(events: NetworkEvent[]): void {\n    this.uploadQueue.networkEvents.push(...events);\n    this.saveQueueToStorage().catch(err => {\n      console.error('[Revi] Failed to save network events to storage:', err);\n    });\n  }\n\n  private hasQueuedData(): boolean {\n    return this.uploadQueue.errors.length > 0 ||\n           this.uploadQueue.sessionEvents.length > 0 ||\n           this.uploadQueue.networkEvents.length > 0;\n  }\n\n  private async uploadData(): Promise<void> {\n    if (this.isUploading || !this.hasQueuedData()) return;\n\n    const { online } = this.networkManager.getConnectionStatus();\n    if (!online) {\n      console.log('[Revi] Skipping upload - device is offline');\n      return;\n    }\n\n    this.isUploading = true;\n    const apiUrl = this.config.apiUrl || 'https://api.revi.dev';\n    const batchSize = this.networkManager.getBatchSize();\n\n    try {\n      // Upload errors in optimized batches with compression\n      if (this.uploadQueue.errors.length > 0) {\n        const { events: dedupedErrors } = deduplicateEvents(this.uploadQueue.errors);\n        const errorBatches = createOptimalBatches(dedupedErrors, batchSize, 32 * 1024);\n        for (const batch of errorBatches) {\n          await this.uploadErrorsWithRetry(apiUrl, batch);\n        }\n        this.uploadQueue.errors = [];\n      }\n\n      // Upload session events in optimized batches with compression\n      if (this.uploadQueue.sessionEvents.length > 0) {\n        const { events: dedupedEvents } = deduplicateEvents(this.uploadQueue.sessionEvents);\n        const sessionBatches = createOptimalBatches(dedupedEvents, batchSize, 64 * 1024);\n        for (const batch of sessionBatches) {\n          await this.uploadSessionEventsWithRetry(apiUrl, batch);\n        }\n        this.uploadQueue.sessionEvents = [];\n      }\n\n      // Upload network events in optimized batches with compression\n      if (this.uploadQueue.networkEvents.length > 0) {\n        const { events: dedupedEvents } = deduplicateEvents(this.uploadQueue.networkEvents);\n        const networkBatches = createOptimalBatches(dedupedEvents, batchSize, 48 * 1024);\n        for (const batch of networkBatches) {\n          await this.uploadNetworkEventsWithRetry(apiUrl, batch);\n        }\n        this.uploadQueue.networkEvents = [];\n      }\n\n      await this.saveQueueToStorage();\n      \n      // Reset retry attempts on successful upload\n      this.retryAttempts.clear();\n      \n    } catch (error) {\n      if (this.config.debug) {\n        console.error('Revi: Failed to upload data', error);\n      }\n      // Keep data in queue for retry\n    } finally {\n      this.isUploading = false;\n    }\n  }\n\n  private createBatches<T>(items: T[], batchSize: number): T[][] {\n    if (batchSize <= 0) return [];\n    \n    const batches: T[][] = [];\n    for (let i = 0; i < items.length; i += batchSize) {\n      batches.push(items.slice(i, i + batchSize));\n    }\n    return batches;\n  }\n\n  private uploadDataSync(): void {\n    if (!this.hasQueuedData()) return;\n\n    const apiUrl = this.config.apiUrl || 'https://api.revi.dev';\n\n    // Use sendBeacon for synchronous upload on page unload\n    if (navigator.sendBeacon) {\n      if (this.uploadQueue.errors.length > 0) {\n        const payload = JSON.stringify({ errors: this.uploadQueue.errors });\n        navigator.sendBeacon(`${apiUrl}/api/capture/error`, payload);\n      }\n\n      if (this.uploadQueue.sessionEvents.length > 0) {\n        const payload = JSON.stringify({ \n          session_id: this.uploadQueue.sessionEvents[0]?.sessionId,\n          events: this.uploadQueue.sessionEvents.map(e => ({\n            event_type: e.type,\n            data: e.data,\n            timestamp: e.timestamp,\n            session_id: e.sessionId\n          }))\n        });\n        navigator.sendBeacon(`${apiUrl}/api/capture/session-event`, payload);\n      }\n\n      if (this.uploadQueue.networkEvents.length > 0) {\n        const payload = JSON.stringify({ events: this.uploadQueue.networkEvents });\n        navigator.sendBeacon(`${apiUrl}/api/capture/network-event`, payload);\n      }\n    }\n  }\n\n  private async uploadErrors(apiUrl: string, errors: ErrorEvent[]): Promise<void> {\n    const payload = {\n      errors: errors.map(error => ({\n        message: error.message,\n        stack_trace: error.stack,\n        url: error.url,\n        user_agent: error.userAgent,\n        session_id: error.sessionId,\n        metadata: {\n          id: error.id,\n          userId: error.userId,\n          environment: error.environment,\n          release: error.release,\n          tags: error.tags,\n          extra: error.extra,\n          breadcrumbs: error.breadcrumbs,\n          level: error.level,\n          lineno: error.lineno,\n          colno: error.colno,\n          filename: error.filename\n        }\n      }))\n    };\n\n    const { data: compressedData, compressed } = await compressData(payload);\n    \n    const headers: Record<string, string> = {\n      'X-API-Key': this.config.apiKey\n    };\n    \n    if (compressed) {\n      headers['Content-Type'] = 'application/octet-stream';\n      headers['Content-Encoding'] = 'gzip';\n      headers['X-Original-Content-Type'] = 'application/json';\n    } else {\n      headers['Content-Type'] = 'application/json';\n    }\n\n    const response = await fetch(`${apiUrl}/api/capture/error`, {\n      method: 'POST',\n      headers,\n      body: compressedData\n    });\n\n    if (!response.ok) {\n      throw new Error(`Upload failed: ${response.status}`);\n    }\n  }\n\n  private async uploadSessionEvents(apiUrl: string, events: SessionEvent[]): Promise<void> {\n    if (events.length === 0) return;\n\n    const sessionId = events[0].sessionId;\n    const payload = {\n      session_id: sessionId,\n      events: events.map(event => ({\n        event_type: event.type,\n        data: event.data,\n        timestamp: event.timestamp,\n        session_id: event.sessionId\n      }))\n    };\n\n    const { data: compressedData, compressed } = await compressData(payload);\n    \n    const headers: Record<string, string> = {\n      'X-API-Key': this.config.apiKey\n    };\n    \n    if (compressed) {\n      headers['Content-Type'] = 'application/octet-stream';\n      headers['Content-Encoding'] = 'gzip';\n      headers['X-Original-Content-Type'] = 'application/json';\n    } else {\n      headers['Content-Type'] = 'application/json';\n    }\n\n    const response = await fetch(`${apiUrl}/api/capture/session-event`, {\n      method: 'POST',\n      headers,\n      body: compressedData\n    });\n\n    if (!response.ok) {\n      throw new Error(`Upload failed: ${response.status}`);\n    }\n  }\n\n  private async uploadNetworkEvents(apiUrl: string, events: NetworkEvent[]): Promise<void> {\n    const promises = events.map(event => \n      fetch(`${apiUrl}/api/capture/network-event`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-API-Key': this.config.apiKey\n        },\n        body: JSON.stringify({\n          session_id: event.sessionId,\n          events: [{\n            method: event.method,\n            url: event.url,\n            status_code: event.statusCode,\n            response_time: event.responseTime,\n            timestamp: event.timestamp,\n            session_id: event.sessionId,\n            request_data: {\n              headers: event.requestHeaders || {},\n              body: event.requestBody || null,\n              size: event.requestSize || 0\n            },\n            response_data: {\n              headers: event.responseHeaders || {},\n              body: event.responseBody || null,\n              size: event.responseSize || 0\n            }\n          }]\n        })\n      })\n    );\n\n    const responses = await Promise.allSettled(promises);\n    const failures = responses.filter(r => r.status === 'rejected');\n    \n    if (failures.length > 0) {\n      throw new Error(`${failures.length} network event uploads failed`);\n    }\n  }\n\n  private async uploadErrorsWithRetry(apiUrl: string, errors: ErrorEvent[]): Promise<void> {\n    const key = 'errors';\n    return this.executeWithRetry(key, () => this.uploadErrors(apiUrl, errors));\n  }\n\n  private async uploadSessionEventsWithRetry(apiUrl: string, events: SessionEvent[]): Promise<void> {\n    const key = 'session_events';\n    return this.executeWithRetry(key, () => this.uploadSessionEvents(apiUrl, events));\n  }\n\n  private async uploadNetworkEventsWithRetry(apiUrl: string, events: NetworkEvent[]): Promise<void> {\n    const key = 'network_events';  \n    return this.executeWithRetry(key, () => this.uploadNetworkEvents(apiUrl, events));\n  }\n\n  private async executeWithRetry<T>(key: string, operation: () => Promise<T>): Promise<T> {\n    const currentAttempt = this.retryAttempts.get(key) || 0;\n\n    if (!this.networkManager.shouldRetry(currentAttempt)) {\n      throw new Error(`Max retry attempts exceeded for ${key}`);\n    }\n\n    try {\n      const result = await operation();\n      this.retryAttempts.delete(key); // Success, reset retry count\n      return result;\n    } catch (error) {\n      this.retryAttempts.set(key, currentAttempt + 1);\n      \n      if (this.networkManager.shouldRetry(currentAttempt + 1)) {\n        const delay = this.networkManager.getRetryDelay(currentAttempt + 1);\n        console.log(`[Revi] Upload failed for ${key}, retrying in ${delay}ms (attempt ${currentAttempt + 2})`);\n        \n        await new Promise(resolve => setTimeout(resolve, delay));\n        return this.executeWithRetry(key, operation);\n      } else {\n        console.error(`[Revi] Max retry attempts exceeded for ${key}:`, error);\n        throw error;\n      }\n    }\n  }\n\n  async clearQueue(): Promise<void> {\n    this.uploadQueue = {\n      errors: [],\n      sessionEvents: [],\n      networkEvents: []\n    };\n    \n    await this.storageManager.clearAll();\n  }\n\n  destroy(): void {\n    if (this.uploadTimer) {\n      clearTimeout(this.uploadTimer);\n      this.uploadTimer = null;\n    }\n    \n    // Final upload attempt\n    if (this.hasQueuedData()) {\n      this.uploadDataSync();\n    }\n  }\n}\n","import type { ReviConfig } from './types';\nimport { generateId } from './utils';\nimport crypto from 'crypto';\n\nexport interface JourneyEvent {\n  event_type: 'page_view' | 'click' | 'form_submit' | 'api_call' | 'error';\n  url: string;\n  referrer?: string;\n  timestamp: number;\n  duration_ms?: number;\n  metadata: Record<string, any>;\n}\n\nexport interface DeviceFingerprint {\n  screen_resolution: string;\n  color_depth: number;\n  timezone: string;\n  language: string;\n  platform: string;\n  user_agent: string;\n  canvas_fingerprint?: string;\n  webgl_fingerprint?: string;\n}\n\n/**\n * Advanced user journey tracking with device fingerprinting\n */\nexport class UserJourneyTracker {\n  private config: ReviConfig;\n  private userId?: string;\n  private deviceFingerprint: string;\n  private sessionStartTime: number;\n  private currentPageStartTime: number;\n  private journeyEvents: JourneyEvent[] = [];\n  private isTracking = false;\n\n  constructor(config: ReviConfig) {\n    this.config = config;\n    this.deviceFingerprint = this.generateDeviceFingerprint();\n    this.sessionStartTime = Date.now();\n    this.currentPageStartTime = Date.now();\n    \n    if (typeof window !== 'undefined') {\n      this.setupJourneyTracking();\n    }\n  }\n\n  /**\n   * Start tracking user journey\n   */\n  startTracking(userId?: string): void {\n    this.userId = userId;\n    this.isTracking = true;\n    \n    // Track initial page view\n    this.trackPageView();\n    \n    if (this.config.debug) {\n      console.log('Revi: User journey tracking started', { userId, deviceFingerprint: this.deviceFingerprint });\n    }\n  }\n\n  /**\n   * Stop tracking user journey\n   */\n  stopTracking(): void {\n    this.isTracking = false;\n    this.flush();\n  }\n\n  /**\n   * Set user ID for tracking\n   */\n  setUserId(userId: string): void {\n    this.userId = userId;\n  }\n\n  /**\n   * Track page view with timing\n   */\n  private trackPageView(): void {\n    if (!this.isTracking) return;\n\n    const event: JourneyEvent = {\n      event_type: 'page_view',\n      url: window.location.href,\n      referrer: document.referrer || undefined,\n      timestamp: Date.now(),\n      metadata: {\n        title: document.title,\n        viewport: {\n          width: window.innerWidth,\n          height: window.innerHeight\n        },\n        scroll_position: {\n          x: window.scrollX,\n          y: window.scrollY\n        },\n        device_fingerprint: this.deviceFingerprint,\n        user_agent: navigator.userAgent,\n        language: navigator.language,\n        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n        connection_type: this.getConnectionType()\n      }\n    };\n\n    this.addJourneyEvent(event);\n  }\n\n  /**\n   * Track user clicks with context\n   */\n  private trackClick(element: HTMLElement, event: MouseEvent): void {\n    if (!this.isTracking) return;\n\n    const journeyEvent: JourneyEvent = {\n      event_type: 'click',\n      url: window.location.href,\n      timestamp: Date.now(),\n      metadata: {\n        element: {\n          tag: element.tagName.toLowerCase(),\n          id: element.id,\n          class: element.className,\n          text: this.getElementText(element),\n          attributes: this.getRelevantAttributes(element)\n        },\n        coordinates: {\n          x: event.clientX,\n          y: event.clientY,\n          page_x: event.pageX,\n          page_y: event.pageY\n        },\n        viewport: {\n          width: window.innerWidth,\n          height: window.innerHeight\n        },\n        scroll_position: {\n          x: window.scrollX,\n          y: window.scrollY\n        }\n      }\n    };\n\n    this.addJourneyEvent(journeyEvent);\n  }\n\n  /**\n   * Track form submissions\n   */\n  private trackFormSubmit(form: HTMLFormElement): void {\n    if (!this.isTracking) return;\n\n    const formData = new FormData(form);\n    const fields: Record<string, any> = {};\n    \n    formData.forEach((value, key) => {\n      // Only track field names and types, not values for privacy\n      const input = form.querySelector(`[name=\"${key}\"]`) as HTMLInputElement;\n      fields[key] = {\n        type: input?.type || 'unknown',\n        has_value: !!value,\n        value_length: typeof value === 'string' ? value.length : 0\n      };\n    });\n\n    const journeyEvent: JourneyEvent = {\n      event_type: 'form_submit',\n      url: window.location.href,\n      timestamp: Date.now(),\n      metadata: {\n        form: {\n          id: form.id,\n          class: form.className,\n          method: form.method,\n          action: form.action,\n          field_count: formData.entries().length\n        },\n        fields: this.config.privacy?.maskInputs ? {} : fields\n      }\n    };\n\n    this.addJourneyEvent(journeyEvent);\n  }\n\n  /**\n   * Track API calls and their performance\n   */\n  trackApiCall(url: string, method: string, status: number, duration: number, size?: number): void {\n    if (!this.isTracking) return;\n\n    const journeyEvent: JourneyEvent = {\n      event_type: 'api_call',\n      url: window.location.href,\n      timestamp: Date.now(),\n      duration_ms: duration,\n      metadata: {\n        api: {\n          url,\n          method,\n          status,\n          duration,\n          size: size || 0,\n          success: status >= 200 && status < 300\n        },\n        page_context: {\n          title: document.title,\n          time_on_page: Date.now() - this.currentPageStartTime\n        }\n      }\n    };\n\n    this.addJourneyEvent(journeyEvent);\n  }\n\n  /**\n   * Track errors in user journey context\n   */\n  trackError(error: Error, context?: Record<string, any>): void {\n    if (!this.isTracking) return;\n\n    const journeyEvent: JourneyEvent = {\n      event_type: 'error',\n      url: window.location.href,\n      timestamp: Date.now(),\n      metadata: {\n        error: {\n          message: error.message,\n          name: error.name,\n          stack: error.stack?.split('\\n').slice(0, 5).join('\\n') // Limit stack trace\n        },\n        user_context: {\n          time_on_page: Date.now() - this.currentPageStartTime,\n          session_duration: Date.now() - this.sessionStartTime,\n          page_interactions: this.countPageInteractions()\n        },\n        custom_context: context || {}\n      }\n    };\n\n    this.addJourneyEvent(journeyEvent);\n  }\n\n  /**\n   * Setup event listeners for journey tracking\n   */\n  private setupJourneyTracking(): void {\n    // Track page views on navigation\n    let currentUrl = window.location.href;\n    \n    const handleNavigation = () => {\n      if (window.location.href !== currentUrl) {\n        // Track time spent on previous page\n        const timeSpent = Date.now() - this.currentPageStartTime;\n        this.updateLastPageViewDuration(timeSpent);\n        \n        // Track new page view\n        currentUrl = window.location.href;\n        this.currentPageStartTime = Date.now();\n        this.trackPageView();\n      }\n    };\n\n    // Handle navigation events\n    window.addEventListener('popstate', handleNavigation);\n    \n    // Override pushState and replaceState to catch programmatic navigation\n    const originalPushState = history.pushState;\n    const originalReplaceState = history.replaceState;\n    \n    history.pushState = function(...args) {\n      originalPushState.apply(history, args);\n      setTimeout(handleNavigation, 0);\n    };\n    \n    history.replaceState = function(...args) {\n      originalReplaceState.apply(history, args);\n      setTimeout(handleNavigation, 0);\n    };\n\n    // Track clicks\n    document.addEventListener('click', (event) => {\n      const target = event.target as HTMLElement;\n      if (target && this.shouldTrackClick(target)) {\n        this.trackClick(target, event);\n      }\n    }, { capture: true, passive: true });\n\n    // Track form submissions\n    document.addEventListener('submit', (event) => {\n      const form = event.target as HTMLFormElement;\n      if (form && form.tagName === 'FORM') {\n        this.trackFormSubmit(form);\n      }\n    }, { capture: true, passive: true });\n\n    // Track page exit\n    window.addEventListener('beforeunload', () => {\n      const timeSpent = Date.now() - this.currentPageStartTime;\n      this.updateLastPageViewDuration(timeSpent);\n      this.flush();\n    });\n\n    // Periodic flush\n    setInterval(() => {\n      if (this.journeyEvents.length > 0) {\n        this.flush();\n      }\n    }, 30000); // Flush every 30 seconds\n  }\n\n  /**\n   * Generate device fingerprint for user tracking\n   */\n  private generateDeviceFingerprint(): string {\n    if (typeof window === 'undefined') return 'server';\n\n    const components = [\n      navigator.userAgent,\n      navigator.language,\n      screen.width + 'x' + screen.height,\n      screen.colorDepth,\n      Intl.DateTimeFormat().resolvedOptions().timeZone,\n      navigator.platform,\n      navigator.cookieEnabled,\n      typeof window.localStorage !== 'undefined',\n      typeof window.sessionStorage !== 'undefined'\n    ];\n\n    // Add canvas fingerprint if available\n    try {\n      const canvas = document.createElement('canvas');\n      const ctx = canvas.getContext('2d');\n      if (ctx) {\n        ctx.textBaseline = 'top';\n        ctx.font = '14px Arial';\n        ctx.fillText('Device fingerprint', 2, 2);\n        components.push(canvas.toDataURL());\n      }\n    } catch (e) {\n      // Canvas fingerprinting failed\n    }\n\n    // Create hash of all components\n    const fingerprint = components.join('|');\n    \n    // Simple hash function (in production, use a proper crypto library)\n    let hash = 0;\n    for (let i = 0; i < fingerprint.length; i++) {\n      const char = fingerprint.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    \n    return Math.abs(hash).toString(36);\n  }\n\n  /**\n   * Add journey event to buffer\n   */\n  private addJourneyEvent(event: JourneyEvent): void {\n    this.journeyEvents.push(event);\n\n    // Auto-flush if buffer is full\n    if (this.journeyEvents.length >= 50) {\n      this.flush();\n    }\n  }\n\n  /**\n   * Flush journey events to backend\n   */\n  private flush(): void {\n    if (this.journeyEvents.length === 0) return;\n\n    const events = [...this.journeyEvents];\n    this.journeyEvents = [];\n\n    // Send to backend (implement based on your API structure)\n    this.sendJourneyEvents(events).catch(error => {\n      if (this.config.debug) {\n        console.error('Revi: Failed to send journey events', error);\n      }\n      // Re-add events to buffer for retry\n      this.journeyEvents.unshift(...events);\n    });\n  }\n\n  /**\n   * Send journey events to analytics backend\n   */\n  private async sendJourneyEvents(events: JourneyEvent[]): Promise<void> {\n    const apiUrl = this.config.apiUrl || 'https://api.revi.dev';\n    \n    // Send each event individually (could be optimized for batch sending)\n    const promises = events.map(event => \n      fetch(`${apiUrl}/api/analytics/user-event`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-API-Key': this.config.apiKey\n        },\n        body: JSON.stringify({\n          user_id: this.userId,\n          session_id: this.getSessionId(),\n          ...event\n        })\n      })\n    );\n\n    await Promise.allSettled(promises);\n  }\n\n  /**\n   * Helper methods\n   */\n  private shouldTrackClick(element: HTMLElement): boolean {\n    // Don't track clicks on sensitive elements\n    const tag = element.tagName.toLowerCase();\n    if (['input', 'textarea'].includes(tag)) {\n      const input = element as HTMLInputElement;\n      if (['password', 'hidden'].includes(input.type)) {\n        return false;\n      }\n    }\n\n    // Don't track if element has data-revi-ignore attribute\n    return !element.hasAttribute('data-revi-ignore');\n  }\n\n  private getElementText(element: HTMLElement): string {\n    const text = element.textContent || element.innerText || '';\n    return text.trim().substring(0, 100);\n  }\n\n  private getRelevantAttributes(element: HTMLElement): Record<string, string> {\n    const attrs: Record<string, string> = {};\n    const relevantAttrs = ['href', 'src', 'alt', 'title', 'data-testid', 'role'];\n    \n    relevantAttrs.forEach(attr => {\n      const value = element.getAttribute(attr);\n      if (value) {\n        attrs[attr] = value;\n      }\n    });\n    \n    return attrs;\n  }\n\n  private getConnectionType(): string {\n    if ('connection' in navigator) {\n      const connection = (navigator as any).connection;\n      return connection?.effectiveType || connection?.type || 'unknown';\n    }\n    return 'unknown';\n  }\n\n  private countPageInteractions(): number {\n    return this.journeyEvents.filter(event => \n      ['click', 'form_submit'].includes(event.event_type)\n    ).length;\n  }\n\n  private updateLastPageViewDuration(duration: number): void {\n    if (this.journeyEvents.length > 0) {\n      const lastEvent = this.journeyEvents[this.journeyEvents.length - 1];\n      if (lastEvent.event_type === 'page_view') {\n        lastEvent.duration_ms = duration;\n      }\n    }\n  }\n\n  private getSessionId(): string {\n    // This should be implemented to get session ID from session manager\n    // For now, return a placeholder\n    return 'session-' + Date.now();\n  }\n}","import type { ReviConfig } from './types';\n\nexport class SamplingManager {\n  private config: ReviConfig;\n  private activityLevel = 0;\n  private lastActivity = Date.now();\n  private errorFrequency = 0;\n  private performanceImpact = 0;\n  \n  constructor(config: ReviConfig) {\n    this.config = config;\n    this.startPerformanceMonitoring();\n  }\n\n  private startPerformanceMonitoring(): void {\n    // Monitor performance impact and adjust sampling\n    if (typeof window !== 'undefined' && 'performance' in window) {\n      setInterval(() => {\n        this.assessPerformanceImpact();\n      }, 5000);\n    }\n  }\n\n  private assessPerformanceImpact(): void {\n    if (typeof performance === 'undefined') return;\n    \n    try {\n      // Simple heuristic: if long tasks are frequent, reduce sampling\n      const now = performance.now();\n      const entries = performance.getEntriesByType('longtask');\n      const recentLongTasks = entries.filter(entry => \n        (now - entry.startTime) < 10000\n      );\n      \n      // Higher impact = more aggressive sampling reduction\n      this.performanceImpact = Math.min(recentLongTasks.length / 5, 1);\n    } catch (error) {\n      // Fallback to low impact if performance API fails\n      this.performanceImpact = 0.1;\n    }\n  }\n\n  updateActivityLevel(activity: 'high' | 'medium' | 'low' | 'idle'): void {\n    const levels = { high: 1, medium: 0.7, low: 0.4, idle: 0.1 };\n    this.activityLevel = levels[activity];\n    this.lastActivity = Date.now();\n  }\n\n  incrementErrorFrequency(): void {\n    this.errorFrequency = Math.min(this.errorFrequency + 0.1, 1);\n    \n    // Decay error frequency over time\n    setTimeout(() => {\n      this.errorFrequency = Math.max(this.errorFrequency - 0.05, 0);\n    }, 30000);\n  }\n\n  shouldSampleError(): boolean {\n    const baseSampleRate = this.config.sampling?.errorSampleRate ?? 1.0;\n    \n    // Always sample errors if error rate is high\n    if (this.errorFrequency > 0.5) {\n      return Math.random() < baseSampleRate;\n    }\n    \n    // Reduce sampling if performance impact is high\n    const adjustedRate = baseSampleRate * (1 - this.performanceImpact * 0.5);\n    \n    return Math.random() < adjustedRate;\n  }\n\n  shouldSampleSession(): boolean {\n    const baseSampleRate = this.config.sampling?.sessionSampleRate ?? this.config.sessionSampleRate ?? 1.0;\n    \n    // Increase sampling during high activity\n    const activityBonus = this.activityLevel * 0.2;\n    const adjustedRate = Math.min(baseSampleRate + activityBonus, 1.0);\n    \n    // Reduce sampling if performance impact is high\n    const finalRate = adjustedRate * (1 - this.performanceImpact * 0.3);\n    \n    return Math.random() < finalRate;\n  }\n\n  shouldSamplePerformance(): boolean {\n    const baseSampleRate = this.config.sampling?.performanceSampleRate ?? 0.1;\n    \n    // Reduce performance sampling during high load\n    const adjustedRate = baseSampleRate * (1 - this.performanceImpact * 0.7);\n    \n    return Math.random() < adjustedRate;\n  }\n\n  shouldSampleNetwork(): boolean {\n    const baseSampleRate = this.config.sampling?.networkSampleRate ?? 0.5;\n    \n    // Sample less during idle periods\n    const idleTimeDays = (Date.now() - this.lastActivity) / (1000 * 60);\n    const idlePenalty = idleTimeDays > 5 ? 0.5 : 1.0;\n    \n    const adjustedRate = baseSampleRate * idlePenalty * (1 - this.performanceImpact * 0.4);\n    \n    return Math.random() < adjustedRate;\n  }\n\n  shouldSampleReplay(): boolean {\n    const baseSampleRate = this.config.sampling?.replaySampleRate ?? 0.1;\n    \n    // Increase replay sampling when there are errors\n    const errorBonus = this.errorFrequency * 0.3;\n    let adjustedRate = Math.min(baseSampleRate + errorBonus, 1.0);\n    \n    // Heavy penalty for performance impact since replay is expensive\n    adjustedRate = adjustedRate * (1 - this.performanceImpact * 0.8);\n    \n    return Math.random() < adjustedRate;\n  }\n\n  getAdaptiveBatchSize(baseSize: number): number {\n    // Reduce batch sizes during high performance impact\n    const impactReduction = this.performanceImpact * 0.6;\n    return Math.max(Math.floor(baseSize * (1 - impactReduction)), 1);\n  }\n\n  getAdaptiveUploadDelay(baseDelay: number): number {\n    // Increase delays during high performance impact\n    const impactMultiplier = 1 + (this.performanceImpact * 2);\n    \n    // Decrease delays during high error frequency\n    const errorMultiplier = Math.max(0.3, 1 - (this.errorFrequency * 0.7));\n    \n    return Math.floor(baseDelay * impactMultiplier * errorMultiplier);\n  }\n\n  shouldSkipCapture(eventType: 'error' | 'session' | 'performance' | 'network' | 'replay'): boolean {\n    switch (eventType) {\n      case 'error':\n        return !this.shouldSampleError();\n      case 'session':\n        return !this.shouldSampleSession();\n      case 'performance':\n        return !this.shouldSamplePerformance();\n      case 'network':\n        return !this.shouldSampleNetwork();\n      case 'replay':\n        return !this.shouldSampleReplay();\n      default:\n        return false;\n    }\n  }\n\n  getPerformanceImpact(): number {\n    return this.performanceImpact;\n  }\n\n  getActivityLevel(): number {\n    return this.activityLevel;\n  }\n\n  getErrorFrequency(): number {\n    return this.errorFrequency;\n  }\n}","import type { PerformanceEntry, WebVitals, ReviConfig } from './types';\n\nexport class PerformanceMonitor {\n  private config: ReviConfig;\n  private webVitals: WebVitals = {};\n  private performanceEntries: PerformanceEntry[] = [];\n\n  constructor(config: ReviConfig) {\n    this.config = config;\n    \n    if (this.config.performance?.captureWebVitals) {\n      this.setupWebVitals();\n    }\n    \n    if (this.config.performance?.captureResourceTiming) {\n      this.setupResourceTiming();\n    }\n    \n    if (this.config.performance?.captureNavigationTiming) {\n      this.setupNavigationTiming();\n    }\n  }\n\n  private setupWebVitals(): void {\n    if (typeof window === 'undefined' || !('PerformanceObserver' in window)) return;\n\n    // Largest Contentful Paint (LCP)\n    try {\n      const lcpObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        const lastEntry = entries[entries.length - 1];\n        this.webVitals.lcp = lastEntry.startTime;\n      });\n      lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });\n    } catch (e) {\n      // LCP not supported\n    }\n\n    // First Input Delay (FID)\n    try {\n      const fidObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries() as any[];\n        entries.forEach((entry) => {\n          this.webVitals.fid = entry.processingStart - entry.startTime;\n        });\n      });\n      fidObserver.observe({ entryTypes: ['first-input'] });\n    } catch (e) {\n      // FID not supported\n    }\n\n    // Cumulative Layout Shift (CLS)\n    try {\n      let clsValue = 0;\n      const clsObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries() as any[];\n        entries.forEach((entry) => {\n          if (!entry.hadRecentInput) {\n            clsValue += entry.value;\n            this.webVitals.cls = clsValue;\n          }\n        });\n      });\n      clsObserver.observe({ entryTypes: ['layout-shift'] });\n    } catch (e) {\n      // CLS not supported\n    }\n\n    // First Contentful Paint (FCP)\n    try {\n      const fcpObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        entries.forEach((entry) => {\n          if (entry.name === 'first-contentful-paint') {\n            this.webVitals.fcp = entry.startTime;\n          }\n        });\n      });\n      fcpObserver.observe({ entryTypes: ['paint'] });\n    } catch (e) {\n      // FCP not supported\n    }\n\n    // Time to First Byte (TTFB)\n    this.calculateTTFB();\n  }\n\n  private calculateTTFB(): void {\n    if (typeof window === 'undefined' || !window.performance) return;\n\n    try {\n      const navigationTiming = performance.getEntriesByType('navigation')[0] as any;\n      if (navigationTiming) {\n        this.webVitals.ttfb = navigationTiming.responseStart - navigationTiming.requestStart;\n      }\n    } catch (e) {\n      // TTFB calculation failed\n    }\n  }\n\n  private setupResourceTiming(): void {\n    if (typeof window === 'undefined' || !window.performance) return;\n\n    try {\n      const resourceObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        entries.forEach((entry) => {\n          this.performanceEntries.push({\n            name: entry.name,\n            entryType: entry.entryType,\n            startTime: entry.startTime,\n            duration: entry.duration,\n            transferSize: (entry as any).transferSize,\n            encodedBodySize: (entry as any).encodedBodySize,\n            decodedBodySize: (entry as any).decodedBodySize\n          });\n        });\n      });\n      \n      resourceObserver.observe({ entryTypes: ['resource'] });\n    } catch (e) {\n      // Resource timing not supported\n    }\n  }\n\n  private setupNavigationTiming(): void {\n    if (typeof window === 'undefined' || !window.performance) return;\n\n    window.addEventListener('load', () => {\n      try {\n        const navigationTiming = performance.getEntriesByType('navigation')[0] as any;\n        if (navigationTiming) {\n          this.performanceEntries.push({\n            name: 'navigation',\n            entryType: 'navigation',\n            startTime: navigationTiming.startTime,\n            duration: navigationTiming.duration,\n            domContentLoadedEventEnd: navigationTiming.domContentLoadedEventEnd,\n            domContentLoadedEventStart: navigationTiming.domContentLoadedEventStart,\n            loadEventEnd: navigationTiming.loadEventEnd,\n            loadEventStart: navigationTiming.loadEventStart,\n            domComplete: navigationTiming.domComplete,\n            domInteractive: navigationTiming.domInteractive\n          });\n        }\n      } catch (e) {\n        // Navigation timing failed\n      }\n    });\n  }\n\n  getWebVitals(): WebVitals {\n    return { ...this.webVitals };\n  }\n\n  getPerformanceEntries(): PerformanceEntry[] {\n    return [...this.performanceEntries];\n  }\n\n  clearPerformanceEntries(): void {\n    this.performanceEntries = [];\n  }\n\n  // Custom performance marks\n  mark(name: string): void {\n    if (typeof window !== 'undefined' && window.performance && window.performance.mark) {\n      try {\n        performance.mark(name);\n      } catch (e) {\n        // Mark failed\n      }\n    }\n  }\n\n  measure(name: string, startMark?: string, endMark?: string): number | null {\n    if (typeof window === 'undefined' || !window.performance || !window.performance.measure) {\n      return null;\n    }\n\n    try {\n      performance.measure(name, startMark, endMark);\n      const measure = performance.getEntriesByName(name, 'measure')[0];\n      return measure ? measure.duration : null;\n    } catch (e) {\n      return null;\n    }\n  }\n}\n","import type { ReviConfig } from './types';\n\nexport interface SerializedNode {\n  type: 'document' | 'element' | 'text' | 'comment';\n  tagName?: string;\n  attributes?: Record<string, string>;\n  textContent?: string;\n  children?: SerializedNode[];\n  id?: number;\n  parentId?: number;\n}\n\nexport interface DOMSnapshot {\n  timestamp: number;\n  url: string;\n  viewport: {\n    width: number;\n    height: number;\n  };\n  scroll: {\n    x: number;\n    y: number;\n  };\n  nodes: SerializedNode[];\n  stylesheets: SerializedStylesheet[];\n  resources: SerializedResource[];\n}\n\nexport interface SerializedStylesheet {\n  href?: string;\n  cssText: string;\n  disabled: boolean;\n}\n\nexport interface SerializedResource {\n  url: string;\n  type: 'image' | 'font' | 'media';\n  data?: string; // Base64 encoded data for small resources\n  failed?: boolean;\n}\n\nexport interface DOMChange {\n  timestamp: number;\n  type: 'childList' | 'attributes' | 'characterData';\n  target: number; // Node ID\n  addedNodes?: SerializedNode[];\n  removedNodes?: number[]; // Node IDs\n  attributeName?: string;\n  attributeValue?: string;\n  oldValue?: string;\n}\n\n/**\n * Advanced DOM serializer for session replay with rrweb-like capabilities\n */\nexport class DOMSerializer {\n  private config: ReviConfig;\n  private nodeIdMap = new WeakMap<Node, number>();\n  private nodeMap = new Map<number, Node>();\n  private nextNodeId = 1;\n  private observer?: MutationObserver;\n  private isObserving = false;\n  private onDOMChange?: (change: DOMChange) => void;\n\n  constructor(config: ReviConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Take a complete snapshot of the DOM\n   */\n  takeSnapshot(): DOMSnapshot {\n    const snapshot: DOMSnapshot = {\n      timestamp: Date.now(),\n      url: window.location.href,\n      viewport: {\n        width: window.innerWidth,\n        height: window.innerHeight\n      },\n      scroll: {\n        x: window.scrollX,\n        y: window.scrollY\n      },\n      nodes: [],\n      stylesheets: [],\n      resources: []\n    };\n\n    // Serialize DOM\n    snapshot.nodes = this.serializeDocument(document);\n    \n    // Capture stylesheets\n    snapshot.stylesheets = this.serializeStylesheets();\n    \n    // Capture resources (images, fonts, etc.)\n    snapshot.resources = this.serializeResources();\n\n    return snapshot;\n  }\n\n  /**\n   * Start observing DOM changes\n   */\n  startObserving(onDOMChange: (change: DOMChange) => void): void {\n    if (this.isObserving) return;\n\n    this.onDOMChange = onDOMChange;\n    this.observer = new MutationObserver(this.handleMutations.bind(this));\n    \n    this.observer.observe(document, {\n      childList: true,\n      attributes: true,\n      characterData: true,\n      subtree: true,\n      attributeOldValue: true,\n      characterDataOldValue: true\n    });\n\n    this.isObserving = true;\n  }\n\n  /**\n   * Stop observing DOM changes\n   */\n  stopObserving(): void {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = undefined;\n    }\n    this.isObserving = false;\n    this.onDOMChange = undefined;\n  }\n\n  /**\n   * Serialize the entire document\n   */\n  private serializeDocument(doc: Document): SerializedNode[] {\n    const doctype = doc.doctype;\n    const nodes: SerializedNode[] = [];\n\n    // Add doctype if present\n    if (doctype) {\n      nodes.push({\n        type: 'document',\n        tagName: 'DOCTYPE',\n        attributes: {\n          name: doctype.name,\n          publicId: doctype.publicId,\n          systemId: doctype.systemId\n        },\n        id: this.getNodeId(doctype)\n      });\n    }\n\n    // Serialize document element (html)\n    if (doc.documentElement) {\n      const serialized = this.serializeNode(doc.documentElement);\n      if (serialized) {\n        nodes.push(serialized);\n      }\n    }\n\n    return nodes;\n  }\n\n  /**\n   * Serialize a single DOM node\n   */\n  private serializeNode(node: Node): SerializedNode | null {\n    if (this.shouldIgnoreNode(node)) {\n      return null;\n    }\n\n    const nodeId = this.getNodeId(node);\n    const serialized: SerializedNode = {\n      type: this.getNodeType(node),\n      id: nodeId\n    };\n\n    switch (node.nodeType) {\n      case Node.ELEMENT_NODE:\n        const element = node as Element;\n        serialized.tagName = element.tagName.toLowerCase();\n        serialized.attributes = this.serializeAttributes(element);\n        serialized.children = this.serializeChildren(element);\n        break;\n\n      case Node.TEXT_NODE:\n        const textNode = node as Text;\n        serialized.textContent = this.shouldMaskText(textNode) ? '[Masked]' : textNode.textContent || '';\n        break;\n\n      case Node.COMMENT_NODE:\n        const commentNode = node as Comment;\n        serialized.textContent = commentNode.textContent || '';\n        break;\n\n      default:\n        return null;\n    }\n\n    return serialized;\n  }\n\n  /**\n   * Serialize element attributes\n   */\n  private serializeAttributes(element: Element): Record<string, string> {\n    const attributes: Record<string, string> = {};\n    \n    for (let i = 0; i < element.attributes.length; i++) {\n      const attr = element.attributes[i];\n      const name = attr.name.toLowerCase();\n      \n      // Skip sensitive attributes\n      if (this.shouldIgnoreAttribute(name, attr.value)) {\n        continue;\n      }\n\n      // Mask sensitive values\n      if (this.shouldMaskAttribute(name, element)) {\n        attributes[name] = '[Masked]';\n      } else {\n        attributes[name] = attr.value;\n      }\n    }\n\n    return attributes;\n  }\n\n  /**\n   * Serialize element children\n   */\n  private serializeChildren(element: Element): SerializedNode[] {\n    const children: SerializedNode[] = [];\n    \n    for (let i = 0; i < element.childNodes.length; i++) {\n      const child = element.childNodes[i];\n      const serializedChild = this.serializeNode(child);\n      \n      if (serializedChild) {\n        children.push(serializedChild);\n      }\n    }\n\n    return children;\n  }\n\n  /**\n   * Serialize all stylesheets\n   */\n  private serializeStylesheets(): SerializedStylesheet[] {\n    const stylesheets: SerializedStylesheet[] = [];\n\n    for (let i = 0; i < document.styleSheets.length; i++) {\n      const stylesheet = document.styleSheets[i];\n      \n      try {\n        let cssText = '';\n        \n        if (stylesheet.href) {\n          // External stylesheet - we'll capture the URL\n          // In production, you might want to fetch and inline the CSS\n          cssText = `/* External stylesheet: ${stylesheet.href} */`;\n        } else {\n          // Inline stylesheet - capture the rules\n          if (stylesheet.cssRules) {\n            const rules = Array.from(stylesheet.cssRules);\n            cssText = rules.map(rule => rule.cssText).join('\\n');\n          }\n        }\n\n        stylesheets.push({\n          href: stylesheet.href || undefined,\n          cssText,\n          disabled: stylesheet.disabled\n        });\n      } catch (error) {\n        // CORS issues or other access problems\n        if (stylesheet.href) {\n          stylesheets.push({\n            href: stylesheet.href,\n            cssText: `/* Could not access stylesheet: ${stylesheet.href} */`,\n            disabled: stylesheet.disabled\n          });\n        }\n      }\n    }\n\n    return stylesheets;\n  }\n\n  /**\n   * Serialize resources (images, fonts, etc.)\n   */\n  private serializeResources(): SerializedResource[] {\n    const resources: SerializedResource[] = [];\n\n    // Capture images\n    const images = document.querySelectorAll('img');\n    images.forEach(img => {\n      if (img.src && !this.shouldIgnoreResource(img.src)) {\n        resources.push({\n          url: img.src,\n          type: 'image',\n          failed: !img.complete || img.naturalWidth === 0\n        });\n      }\n    });\n\n    // Capture background images from computed styles\n    const elementsWithBackgrounds = document.querySelectorAll('*');\n    elementsWithBackgrounds.forEach(element => {\n      const style = window.getComputedStyle(element);\n      const backgroundImage = style.backgroundImage;\n      \n      if (backgroundImage && backgroundImage !== 'none') {\n        const urlMatch = backgroundImage.match(/url\\(['\"]?([^'\")]+)['\"]?\\)/);\n        if (urlMatch && urlMatch[1] && !this.shouldIgnoreResource(urlMatch[1])) {\n          resources.push({\n            url: urlMatch[1],\n            type: 'image'\n          });\n        }\n      }\n    });\n\n    return resources;\n  }\n\n  /**\n   * Handle mutation events\n   */\n  private handleMutations(mutations: MutationRecord[]): void {\n    mutations.forEach(mutation => {\n      const targetId = this.nodeIdMap.get(mutation.target);\n      if (!targetId) return;\n\n      const change: DOMChange = {\n        timestamp: Date.now(),\n        type: mutation.type,\n        target: targetId\n      };\n\n      switch (mutation.type) {\n        case 'childList':\n          if (mutation.addedNodes.length > 0) {\n            change.addedNodes = Array.from(mutation.addedNodes)\n              .map(node => this.serializeNode(node))\n              .filter((node): node is SerializedNode => node !== null);\n          }\n          \n          if (mutation.removedNodes.length > 0) {\n            change.removedNodes = Array.from(mutation.removedNodes)\n              .map(node => this.nodeIdMap.get(node))\n              .filter((id): id is number => id !== undefined);\n          }\n          break;\n\n        case 'attributes':\n          change.attributeName = mutation.attributeName || undefined;\n          if (mutation.target.nodeType === Node.ELEMENT_NODE) {\n            const element = mutation.target as Element;\n            const value = element.getAttribute(mutation.attributeName || '');\n            change.attributeValue = this.shouldMaskAttribute(\n              mutation.attributeName || '', element\n            ) ? '[Masked]' : value || '';\n          }\n          change.oldValue = mutation.oldValue || undefined;\n          break;\n\n        case 'characterData':\n          change.attributeValue = this.shouldMaskText(mutation.target as Text) \n            ? '[Masked]' \n            : mutation.target.textContent || '';\n          change.oldValue = mutation.oldValue || undefined;\n          break;\n      }\n\n      if (this.onDOMChange) {\n        this.onDOMChange(change);\n      }\n    });\n  }\n\n  /**\n   * Utility methods\n   */\n  private getNodeId(node: Node): number {\n    if (this.nodeIdMap.has(node)) {\n      return this.nodeIdMap.get(node)!;\n    }\n    \n    const id = this.nextNodeId++;\n    this.nodeIdMap.set(node, id);\n    this.nodeMap.set(id, node);\n    \n    return id;\n  }\n\n  private getNodeType(node: Node): SerializedNode['type'] {\n    switch (node.nodeType) {\n      case Node.ELEMENT_NODE:\n        return 'element';\n      case Node.TEXT_NODE:\n        return 'text';\n      case Node.COMMENT_NODE:\n        return 'comment';\n      case Node.DOCUMENT_NODE:\n        return 'document';\n      default:\n        return 'element';\n    }\n  }\n\n  private shouldIgnoreNode(node: Node): boolean {\n    if (node.nodeType === Node.ELEMENT_NODE) {\n      const element = node as Element;\n      const tagName = element.tagName.toLowerCase();\n      \n      // Ignore script tags and other sensitive elements\n      if (['script', 'noscript', 'meta'].includes(tagName)) {\n        return true;\n      }\n      \n      // Ignore elements with data-revi-ignore attribute\n      if (element.hasAttribute('data-revi-ignore')) {\n        return true;\n      }\n      \n      // Ignore elements that match block selector\n      if (this.config.replay?.blockSelector) {\n        try {\n          if (element.matches(this.config.replay.blockSelector)) {\n            return true;\n          }\n        } catch (e) {\n          // Invalid selector\n        }\n      }\n    }\n    \n    return false;\n  }\n\n  private shouldIgnoreAttribute(name: string, value: string): boolean {\n    // Ignore sensitive attributes\n    const sensitiveAttrs = ['data-revi-ignore', 'data-password', 'data-sensitive'];\n    return sensitiveAttrs.includes(name);\n  }\n\n  private shouldMaskAttribute(name: string, element: Element): boolean {\n    if (!this.config.privacy?.maskInputs) return false;\n    \n    // Mask values of sensitive input fields\n    if (element.tagName.toLowerCase() === 'input') {\n      const input = element as HTMLInputElement;\n      const sensitiveTypes = ['password', 'email', 'tel'];\n      if (sensitiveTypes.includes(input.type)) {\n        return name === 'value';\n      }\n    }\n    \n    return false;\n  }\n\n  private shouldMaskText(textNode: Text): boolean {\n    if (!this.config.replay?.maskAllText && !this.config.privacy?.maskInputs) {\n      return false;\n    }\n    \n    const parent = textNode.parentElement;\n    if (!parent) return false;\n    \n    // Mask text in sensitive elements\n    const sensitiveElements = ['input', 'textarea'];\n    if (sensitiveElements.includes(parent.tagName.toLowerCase())) {\n      return true;\n    }\n    \n    // Check for mask selector\n    if (this.config.replay?.maskSelector) {\n      try {\n        return parent.matches(this.config.replay.maskSelector);\n      } catch (e) {\n        return false;\n      }\n    }\n    \n    return this.config.replay?.maskAllText || false;\n  }\n\n  private shouldIgnoreResource(url: string): boolean {\n    try {\n      const urlObj = new URL(url, window.location.href);\n      \n      // Ignore data URLs (they're inline)\n      if (urlObj.protocol === 'data:') return true;\n      \n      // Ignore very large images\n      if (url.includes('?')) {\n        const params = new URLSearchParams(urlObj.search);\n        const width = params.get('w') || params.get('width');\n        const height = params.get('h') || params.get('height');\n        if (width && parseInt(width) > 2000) return true;\n        if (height && parseInt(height) > 2000) return true;\n      }\n      \n      return false;\n    } catch (e) {\n      return true; // Invalid URL\n    }\n  }\n}","import { SessionEvent } from './types';\n\nexport interface ConsoleLogEntry {\n  id: string;\n  timestamp: number;\n  level: 'log' | 'info' | 'warn' | 'error' | 'debug' | 'trace';\n  args: any[];\n  stack?: string;\n  url?: string;\n  lineNumber?: number;\n  columnNumber?: number;\n}\n\nexport interface ConsoleRecorderConfig {\n  maxEntries: number;\n  captureStackTrace: boolean;\n  serializeObjects: boolean;\n  maxObjectDepth: number;\n  maxStringLength: number;\n  ignoredLevels: string[];\n}\n\nexport class ConsoleRecorder {\n  private originalMethods: Record<string, Function> = {};\n  private entries: ConsoleLogEntry[] = [];\n  private config: ConsoleRecorderConfig;\n  private isRecording = false;\n  private sessionId: string;\n\n  constructor(sessionId: string, config: Partial<ConsoleRecorderConfig> = {}) {\n    this.sessionId = sessionId;\n    this.config = {\n      maxEntries: 1000,\n      captureStackTrace: true,\n      serializeObjects: true,\n      maxObjectDepth: 3,\n      maxStringLength: 10000,\n      ignoredLevels: [],\n      ...config\n    };\n  }\n\n  start(): void {\n    if (this.isRecording) return;\n\n    const levels: Array<keyof Console> = ['log', 'info', 'warn', 'error', 'debug', 'trace'];\n    \n    levels.forEach(level => {\n      if (this.config.ignoredLevels.includes(level)) return;\n      \n      const originalMethod = console[level];\n      this.originalMethods[level] = originalMethod;\n      \n      console[level] = (...args: any[]) => {\n        // Call original method first\n        originalMethod.apply(console, args);\n        \n        // Record the log entry\n        this.recordEntry(level as ConsoleLogEntry['level'], args);\n      };\n    });\n\n    this.isRecording = true;\n  }\n\n  stop(): void {\n    if (!this.isRecording) return;\n\n    // Restore original console methods\n    Object.entries(this.originalMethods).forEach(([level, method]) => {\n      (console as any)[level] = method;\n    });\n\n    this.originalMethods = {};\n    this.isRecording = false;\n  }\n\n  private recordEntry(level: ConsoleLogEntry['level'], args: any[]): void {\n    try {\n      const entry: ConsoleLogEntry = {\n        id: this.generateId(),\n        timestamp: Date.now(),\n        level,\n        args: this.serializeArgs(args)\n      };\n\n      // Capture stack trace for errors and warnings\n      if ((level === 'error' || level === 'warn') && this.config.captureStackTrace) {\n        const error = new Error();\n        if (error.stack) {\n          entry.stack = this.cleanStackTrace(error.stack);\n        }\n      }\n\n      // Add source location if available\n      if (level === 'error' && args[0] instanceof Error) {\n        const error = args[0] as Error;\n        // Try to extract location from error stack\n        const stackLines = error.stack?.split('\\n') || [];\n        const sourceLine = stackLines.find(line => \n          line.includes('.js:') || line.includes('.ts:') || line.includes('.tsx:')\n        );\n        \n        if (sourceLine) {\n          const match = sourceLine.match(/([^/]+):(\\d+):(\\d+)/);\n          if (match) {\n            entry.url = match[1];\n            entry.lineNumber = parseInt(match[2]);\n            entry.columnNumber = parseInt(match[3]);\n          }\n        }\n      }\n\n      this.addEntry(entry);\n    } catch (error) {\n      // Fail silently to avoid infinite loops\n      this.originalMethods.warn?.call(console, 'ConsoleRecorder error:', error);\n    }\n  }\n\n  private serializeArgs(args: any[]): any[] {\n    return args.map(arg => this.serializeValue(arg, 0));\n  }\n\n  private serializeValue(value: any, depth: number): any {\n    if (depth > this.config.maxObjectDepth) {\n      return '[Object too deep]';\n    }\n\n    if (value === null || value === undefined) {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      return value.length > this.config.maxStringLength \n        ? value.substring(0, this.config.maxStringLength) + '...'\n        : value;\n    }\n\n    if (typeof value === 'number' || typeof value === 'boolean') {\n      return value;\n    }\n\n    if (typeof value === 'function') {\n      return `[Function: ${value.name || 'anonymous'}]`;\n    }\n\n    if (value instanceof Error) {\n      return {\n        name: value.name,\n        message: value.message,\n        stack: this.config.captureStackTrace ? this.cleanStackTrace(value.stack || '') : undefined\n      };\n    }\n\n    if (value instanceof Date) {\n      return {\n        __type: 'Date',\n        value: value.toISOString()\n      };\n    }\n\n    if (value instanceof RegExp) {\n      return {\n        __type: 'RegExp',\n        value: value.toString()\n      };\n    }\n\n    if (Array.isArray(value)) {\n      if (!this.config.serializeObjects) return '[Array]';\n      \n      return value.slice(0, 100).map(item => this.serializeValue(item, depth + 1));\n    }\n\n    if (typeof value === 'object') {\n      if (!this.config.serializeObjects) return '[Object]';\n      \n      try {\n        const serialized: Record<string, any> = {};\n        const keys = Object.keys(value).slice(0, 50); // Limit keys\n        \n        for (const key of keys) {\n          try {\n            serialized[key] = this.serializeValue(value[key], depth + 1);\n          } catch {\n            serialized[key] = '[Unserializable]';\n          }\n        }\n        \n        if (Object.keys(value).length > 50) {\n          serialized['...'] = `[${Object.keys(value).length - 50} more keys]`;\n        }\n        \n        return serialized;\n      } catch {\n        return '[Unserializable Object]';\n      }\n    }\n\n    return String(value);\n  }\n\n  private cleanStackTrace(stack: string): string {\n    return stack\n      .split('\\n')\n      .filter(line => \n        !line.includes('console-recorder.ts') && \n        !line.includes('ConsoleRecorder')\n      )\n      .slice(0, 10) // Limit stack depth\n      .join('\\n');\n  }\n\n  private addEntry(entry: ConsoleLogEntry): void {\n    this.entries.push(entry);\n    \n    // Maintain max entries limit\n    if (this.entries.length > this.config.maxEntries) {\n      this.entries = this.entries.slice(-this.config.maxEntries * 0.8);\n    }\n  }\n\n  private generateId(): string {\n    return `console-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  getEntries(fromTimestamp?: number, toTimestamp?: number): ConsoleLogEntry[] {\n    let filtered = this.entries;\n    \n    if (fromTimestamp) {\n      filtered = filtered.filter(entry => entry.timestamp >= fromTimestamp);\n    }\n    \n    if (toTimestamp) {\n      filtered = filtered.filter(entry => entry.timestamp <= toTimestamp);\n    }\n    \n    return [...filtered];\n  }\n\n  getEntriesByLevel(level: ConsoleLogEntry['level']): ConsoleLogEntry[] {\n    return this.entries.filter(entry => entry.level === level);\n  }\n\n  clear(): void {\n    this.entries = [];\n  }\n\n  // Convert console entries to session events format\n  toSessionEvents(): SessionEvent[] {\n    return this.entries.map(entry => ({\n      session_id: this.sessionId,\n      event_type: 'console',\n      data: {\n        level: entry.level,\n        args: entry.args,\n        stack: entry.stack,\n        url: entry.url,\n        lineNumber: entry.lineNumber,\n        columnNumber: entry.columnNumber,\n        consoleId: entry.id\n      },\n      timestamp: entry.timestamp,\n      url: entry.url || window.location.href,\n      user_agent: navigator.userAgent\n    }));\n  }\n\n  // Export for analysis\n  exportData(): {\n    sessionId: string;\n    config: ConsoleRecorderConfig;\n    entries: ConsoleLogEntry[];\n    stats: {\n      totalEntries: number;\n      levelCounts: Record<string, number>;\n      errorCount: number;\n      warningCount: number;\n      timeRange: { start: number; end: number };\n    };\n  } {\n    const levelCounts: Record<string, number> = {};\n    let minTime = Infinity;\n    let maxTime = -Infinity;\n\n    this.entries.forEach(entry => {\n      levelCounts[entry.level] = (levelCounts[entry.level] || 0) + 1;\n      minTime = Math.min(minTime, entry.timestamp);\n      maxTime = Math.max(maxTime, entry.timestamp);\n    });\n\n    return {\n      sessionId: this.sessionId,\n      config: this.config,\n      entries: [...this.entries],\n      stats: {\n        totalEntries: this.entries.length,\n        levelCounts,\n        errorCount: levelCounts.error || 0,\n        warningCount: levelCounts.warn || 0,\n        timeRange: {\n          start: minTime === Infinity ? 0 : minTime,\n          end: maxTime === -Infinity ? 0 : maxTime\n        }\n      }\n    };\n  }\n\n  // Generate insights from console logs\n  generateInsights(): {\n    errorPatterns: Array<{ pattern: string; count: number; examples: ConsoleLogEntry[] }>;\n    performanceIssues: Array<{ type: string; severity: 'low' | 'medium' | 'high'; details: string }>;\n    recommendations: string[];\n  } {\n    const errorPatterns = this.findErrorPatterns();\n    const performanceIssues = this.detectPerformanceIssues();\n    const recommendations = this.generateRecommendations();\n\n    return {\n      errorPatterns,\n      performanceIssues,\n      recommendations\n    };\n  }\n\n  private findErrorPatterns(): Array<{ pattern: string; count: number; examples: ConsoleLogEntry[] }> {\n    const errors = this.entries.filter(entry => entry.level === 'error');\n    const patterns: Record<string, ConsoleLogEntry[]> = {};\n\n    errors.forEach(error => {\n      let pattern = 'Unknown Error';\n      \n      if (error.args.length > 0) {\n        const firstArg = error.args[0];\n        if (typeof firstArg === 'string') {\n          // Extract error pattern from message\n          pattern = firstArg\n            .replace(/\\d+/g, 'N') // Replace numbers with N\n            .replace(/[\"'][^\"']*[\"']/g, 'STRING') // Replace strings with STRING\n            .replace(/\\b\\w+@\\w+\\.\\w+/g, 'EMAIL') // Replace emails\n            .replace(/https?:\\/\\/[^\\s]+/g, 'URL') // Replace URLs\n            .substring(0, 100);\n        } else if (typeof firstArg === 'object' && firstArg.name) {\n          pattern = `${firstArg.name}: ${firstArg.message}`.substring(0, 100);\n        }\n      }\n\n      if (!patterns[pattern]) {\n        patterns[pattern] = [];\n      }\n      patterns[pattern].push(error);\n    });\n\n    return Object.entries(patterns)\n      .sort(([, a], [, b]) => b.length - a.length)\n      .slice(0, 10)\n      .map(([pattern, examples]) => ({\n        pattern,\n        count: examples.length,\n        examples: examples.slice(0, 3) // Show first 3 examples\n      }));\n  }\n\n  private detectPerformanceIssues(): Array<{ type: string; severity: 'low' | 'medium' | 'high'; details: string }> {\n    const issues: Array<{ type: string; severity: 'low' | 'medium' | 'high'; details: string }> = [];\n    \n    // Check for excessive logging\n    const recentEntries = this.entries.filter(entry => \n      entry.timestamp > Date.now() - 60000 // Last minute\n    );\n    \n    if (recentEntries.length > 100) {\n      issues.push({\n        type: 'Excessive Logging',\n        severity: 'medium',\n        details: `${recentEntries.length} console entries in the last minute may impact performance`\n      });\n    }\n\n    // Check for repeated errors\n    const errorCounts: Record<string, number> = {};\n    this.entries\n      .filter(entry => entry.level === 'error')\n      .forEach(entry => {\n        const key = JSON.stringify(entry.args);\n        errorCounts[key] = (errorCounts[key] || 0) + 1;\n      });\n\n    Object.entries(errorCounts).forEach(([error, count]) => {\n      if (count > 10) {\n        issues.push({\n          type: 'Repeated Error',\n          severity: count > 50 ? 'high' : 'medium',\n          details: `Same error occurred ${count} times`\n        });\n      }\n    });\n\n    // Check for potential memory leaks (objects not being cleaned up)\n    const objectLogs = this.entries.filter(entry => \n      entry.args.some(arg => \n        typeof arg === 'object' && \n        arg !== null && \n        !Array.isArray(arg)\n      )\n    );\n    \n    if (objectLogs.length > this.entries.length * 0.5) {\n      issues.push({\n        type: 'Object Logging',\n        severity: 'low',\n        details: 'High percentage of object logging may indicate memory leaks'\n      });\n    }\n\n    return issues;\n  }\n\n  private generateRecommendations(): string[] {\n    const recommendations: string[] = [];\n    const stats = this.exportData().stats;\n\n    if (stats.errorCount > 0) {\n      recommendations.push(\n        `Found ${stats.errorCount} console errors. Review error patterns and fix underlying issues.`\n      );\n    }\n\n    if (stats.warningCount > stats.errorCount * 2) {\n      recommendations.push(\n        'High warning-to-error ratio suggests proactive error handling could prevent issues.'\n      );\n    }\n\n    if (stats.totalEntries > 500) {\n      recommendations.push(\n        'Consider reducing console logging in production to improve performance.'\n      );\n    }\n\n    if (stats.levelCounts.debug && stats.levelCounts.debug > 100) {\n      recommendations.push(\n        'Debug logs should be disabled in production environments.'\n      );\n    }\n\n    if (recommendations.length === 0) {\n      recommendations.push('Console logging patterns look healthy.');\n    }\n\n    return recommendations;\n  }\n}","import { SessionEvent } from './types';\n\nexport interface HeatmapData {\n  x: number;\n  y: number;\n  intensity: number;\n  event_type: 'click' | 'move' | 'scroll' | 'hover';\n  timestamp: number;\n}\n\nexport interface HeatmapConfig {\n  radius: number;\n  maxIntensity: number;\n  gradient: Record<string, string>;\n  blur: number;\n  minOpacity: number;\n  maxOpacity: number;\n}\n\nexport class HeatmapGenerator {\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n  private config: HeatmapConfig;\n  private data: HeatmapData[] = [];\n\n  constructor(container: HTMLElement, config: Partial<HeatmapConfig> = {}) {\n    this.config = {\n      radius: 20,\n      maxIntensity: 100,\n      gradient: {\n        0.4: 'blue',\n        0.6: 'cyan',\n        0.7: 'lime',\n        0.8: 'yellow',\n        1.0: 'red'\n      },\n      blur: 15,\n      minOpacity: 0,\n      maxOpacity: 0.6,\n      ...config\n    };\n\n    this.canvas = document.createElement('canvas');\n    this.canvas.style.position = 'absolute';\n    this.canvas.style.top = '0';\n    this.canvas.style.left = '0';\n    this.canvas.style.pointerEvents = 'none';\n    this.canvas.style.zIndex = '9999';\n    \n    container.appendChild(this.canvas);\n    \n    const ctx = this.canvas.getContext('2d');\n    if (!ctx) {\n      throw new Error('Failed to get canvas context');\n    }\n    this.ctx = ctx;\n\n    this.resizeCanvas();\n    window.addEventListener('resize', () => this.resizeCanvas());\n  }\n\n  private resizeCanvas(): void {\n    const rect = this.canvas.parentElement!.getBoundingClientRect();\n    this.canvas.width = rect.width;\n    this.canvas.height = rect.height;\n    this.canvas.style.width = rect.width + 'px';\n    this.canvas.style.height = rect.height + 'px';\n  }\n\n  addDataPoint(x: number, y: number, intensity: number, eventType: HeatmapData['event_type']): void {\n    this.data.push({\n      x,\n      y,\n      intensity,\n      event_type: eventType,\n      timestamp: Date.now()\n    });\n    \n    // Limit data points to prevent memory issues\n    if (this.data.length > 10000) {\n      this.data = this.data.slice(-8000);\n    }\n  }\n\n  generateFromEvents(events: SessionEvent[]): void {\n    this.data = [];\n    \n    events.forEach(event => {\n      if (event.event_type === 'click' && event.data?.x && event.data?.y) {\n        this.addDataPoint(\n          event.data.x,\n          event.data.y,\n          10,\n          'click'\n        );\n      } else if (event.event_type === 'mousemove' && event.data?.x && event.data?.y) {\n        this.addDataPoint(\n          event.data.x,\n          event.data.y,\n          2,\n          'move'\n        );\n      } else if (event.event_type === 'scroll' && event.data?.scrollX !== undefined && event.data?.scrollY !== undefined) {\n        // Convert scroll position to viewport coordinates\n        this.addDataPoint(\n          event.data.scrollX || 0,\n          event.data.scrollY || 0,\n          5,\n          'scroll'\n        );\n      }\n    });\n  }\n\n  render(filter?: HeatmapData['event_type'][]): void {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    \n    if (this.data.length === 0) return;\n\n    const filteredData = filter \n      ? this.data.filter(d => filter.includes(d.event_type))\n      : this.data;\n\n    // Create intensity map\n    const intensityData = this.createIntensityMap(filteredData);\n    \n    // Create gradient\n    const gradient = this.createGradient();\n    \n    // Render heatmap\n    this.renderHeatmap(intensityData, gradient);\n  }\n\n  private createIntensityMap(data: HeatmapData[]): ImageData {\n    const shadowCanvas = document.createElement('canvas');\n    shadowCanvas.width = this.canvas.width;\n    shadowCanvas.height = this.canvas.height;\n    const shadowCtx = shadowCanvas.getContext('2d')!;\n\n    // Draw intensity points\n    data.forEach(point => {\n      const radius = this.config.radius;\n      const gradient = shadowCtx.createRadialGradient(\n        point.x, point.y, 0,\n        point.x, point.y, radius\n      );\n\n      const alpha = Math.min(point.intensity / this.config.maxIntensity, 1);\n      gradient.addColorStop(0, `rgba(0, 0, 0, ${alpha})`);\n      gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\n\n      shadowCtx.fillStyle = gradient;\n      shadowCtx.fillRect(\n        point.x - radius,\n        point.y - radius,\n        radius * 2,\n        radius * 2\n      );\n    });\n\n    // Apply blur\n    shadowCtx.filter = `blur(${this.config.blur}px)`;\n    shadowCtx.drawImage(shadowCanvas, 0, 0);\n\n    return shadowCtx.getImageData(0, 0, shadowCanvas.width, shadowCanvas.height);\n  }\n\n  private createGradient(): ImageData {\n    const gradientCanvas = document.createElement('canvas');\n    gradientCanvas.width = 256;\n    gradientCanvas.height = 1;\n    const gradientCtx = gradientCanvas.getContext('2d')!;\n\n    const gradient = gradientCtx.createLinearGradient(0, 0, 256, 0);\n    Object.entries(this.config.gradient).forEach(([stop, color]) => {\n      gradient.addColorStop(parseFloat(stop), color);\n    });\n\n    gradientCtx.fillStyle = gradient;\n    gradientCtx.fillRect(0, 0, 256, 1);\n\n    return gradientCtx.getImageData(0, 0, 256, 1);\n  }\n\n  private renderHeatmap(intensityData: ImageData, gradientData: ImageData): void {\n    const output = this.ctx.createImageData(intensityData.width, intensityData.height);\n    \n    for (let i = 0; i < intensityData.data.length; i += 4) {\n      const alpha = intensityData.data[i + 3];\n      \n      if (alpha > 0) {\n        const gradientIndex = Math.floor((alpha / 255) * 255) * 4;\n        \n        output.data[i] = gradientData.data[gradientIndex];     // R\n        output.data[i + 1] = gradientData.data[gradientIndex + 1]; // G\n        output.data[i + 2] = gradientData.data[gradientIndex + 2]; // B\n        output.data[i + 3] = Math.floor(alpha * this.config.maxOpacity); // A\n      }\n    }\n\n    this.ctx.putImageData(output, 0, 0);\n  }\n\n  clear(): void {\n    this.data = [];\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n\n  destroy(): void {\n    this.clear();\n    if (this.canvas.parentElement) {\n      this.canvas.parentElement.removeChild(this.canvas);\n    }\n    window.removeEventListener('resize', () => this.resizeCanvas());\n  }\n\n  // Export heatmap data for analysis\n  exportData(): {\n    config: HeatmapConfig;\n    data: HeatmapData[];\n    stats: {\n      totalEvents: number;\n      eventTypes: Record<string, number>;\n      timeRange: { start: number; end: number };\n      bounds: { minX: number; maxX: number; minY: number; maxY: number };\n    };\n  } {\n    const eventTypes: Record<string, number> = {};\n    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;\n    let minTime = Infinity, maxTime = -Infinity;\n\n    this.data.forEach(point => {\n      eventTypes[point.event_type] = (eventTypes[point.event_type] || 0) + 1;\n      \n      minX = Math.min(minX, point.x);\n      maxX = Math.max(maxX, point.x);\n      minY = Math.min(minY, point.y);\n      maxY = Math.max(maxY, point.y);\n      \n      minTime = Math.min(minTime, point.timestamp);\n      maxTime = Math.max(maxTime, point.timestamp);\n    });\n\n    return {\n      config: this.config,\n      data: [...this.data],\n      stats: {\n        totalEvents: this.data.length,\n        eventTypes,\n        timeRange: { start: minTime, end: maxTime },\n        bounds: { minX, maxX, minY, maxY }\n      }\n    };\n  }\n\n  // Generate insights from heatmap data\n  generateInsights(): {\n    hotSpots: Array<{ x: number; y: number; intensity: number; radius: number }>;\n    clickPatterns: Array<{ pattern: string; frequency: number }>;\n    userBehavior: {\n      mostActiveArea: { x: number; y: number; width: number; height: number };\n      averageClicksPerSession: number;\n      scrollDepth: number;\n      engagementScore: number;\n    };\n  } {\n    // Find hot spots using clustering\n    const hotSpots = this.findHotSpots();\n    \n    // Analyze click patterns\n    const clickPatterns = this.analyzeClickPatterns();\n    \n    // Generate user behavior insights\n    const userBehavior = this.analyzeUserBehavior();\n\n    return {\n      hotSpots,\n      clickPatterns,\n      userBehavior\n    };\n  }\n\n  private findHotSpots(): Array<{ x: number; y: number; intensity: number; radius: number }> {\n    const clusters: Array<{ x: number; y: number; intensity: number; count: number }> = [];\n    const clusterRadius = this.config.radius * 2;\n\n    this.data.forEach(point => {\n      let foundCluster = false;\n      \n      for (const cluster of clusters) {\n        const distance = Math.sqrt(\n          Math.pow(point.x - cluster.x, 2) + Math.pow(point.y - cluster.y, 2)\n        );\n        \n        if (distance <= clusterRadius) {\n          // Add to existing cluster\n          cluster.x = (cluster.x * cluster.count + point.x) / (cluster.count + 1);\n          cluster.y = (cluster.y * cluster.count + point.y) / (cluster.count + 1);\n          cluster.intensity += point.intensity;\n          cluster.count++;\n          foundCluster = true;\n          break;\n        }\n      }\n      \n      if (!foundCluster) {\n        clusters.push({\n          x: point.x,\n          y: point.y,\n          intensity: point.intensity,\n          count: 1\n        });\n      }\n    });\n\n    return clusters\n      .filter(cluster => cluster.count >= 3) // Only significant clusters\n      .sort((a, b) => b.intensity - a.intensity)\n      .slice(0, 10) // Top 10 hot spots\n      .map(cluster => ({\n        x: Math.round(cluster.x),\n        y: Math.round(cluster.y),\n        intensity: Math.round(cluster.intensity),\n        radius: Math.min(clusterRadius, cluster.count * 5)\n      }));\n  }\n\n  private analyzeClickPatterns(): Array<{ pattern: string; frequency: number }> {\n    const clicks = this.data.filter(d => d.event_type === 'click');\n    const patterns: Record<string, number> = {};\n\n    // Analyze sequential click patterns\n    for (let i = 0; i < clicks.length - 1; i++) {\n      const current = clicks[i];\n      const next = clicks[i + 1];\n      \n      const timeDiff = next.timestamp - current.timestamp;\n      if (timeDiff < 5000) { // Within 5 seconds\n        const pattern = `(${Math.round(current.x)},${Math.round(current.y)}) -> (${Math.round(next.x)},${Math.round(next.y)})`;\n        patterns[pattern] = (patterns[pattern] || 0) + 1;\n      }\n    }\n\n    return Object.entries(patterns)\n      .sort(([, a], [, b]) => b - a)\n      .slice(0, 5)\n      .map(([pattern, frequency]) => ({ pattern, frequency }));\n  }\n\n  private analyzeUserBehavior(): {\n    mostActiveArea: { x: number; y: number; width: number; height: number };\n    averageClicksPerSession: number;\n    scrollDepth: number;\n    engagementScore: number;\n  } {\n    const clicks = this.data.filter(d => d.event_type === 'click');\n    const scrolls = this.data.filter(d => d.event_type === 'scroll');\n\n    // Find most active area (bounding box of top 50% of events)\n    const sortedByIntensity = [...this.data].sort((a, b) => b.intensity - a.intensity);\n    const topHalf = sortedByIntensity.slice(0, Math.floor(sortedByIntensity.length * 0.5));\n    \n    const minX = Math.min(...topHalf.map(d => d.x));\n    const maxX = Math.max(...topHalf.map(d => d.x));\n    const minY = Math.min(...topHalf.map(d => d.y));\n    const maxY = Math.max(...topHalf.map(d => d.y));\n\n    const scrollDepth = scrolls.length > 0 \n      ? Math.max(...scrolls.map(s => s.y)) / this.canvas.height \n      : 0;\n\n    const engagementScore = Math.min(100, \n      (clicks.length * 2) + \n      (scrollDepth * 50) + \n      (this.data.filter(d => d.event_type === 'move').length * 0.1)\n    );\n\n    return {\n      mostActiveArea: {\n        x: Math.round(minX),\n        y: Math.round(minY),\n        width: Math.round(maxX - minX),\n        height: Math.round(maxY - minY)\n      },\n      averageClicksPerSession: Math.round(clicks.length),\n      scrollDepth: Math.round(scrollDepth * 100) / 100,\n      engagementScore: Math.round(engagementScore)\n    };\n  }\n}","import type { ReviConfig } from './types';\nimport { DOMSerializer, DOMSnapshot, DOMChange } from './dom-serializer';\nimport { ConsoleRecorder, ConsoleLogEntry } from './console-recorder';\nimport { HeatmapGenerator, HeatmapData } from './heatmap-generator';\n\nexport interface ReplayEvent {\n  type: 'full_snapshot' | 'incremental_snapshot' | 'meta' | 'custom';\n  timestamp: number;\n  data: any;\n}\n\nexport interface ConsoleLog {\n  timestamp: number;\n  level: 'log' | 'info' | 'warn' | 'error' | 'debug';\n  args: any[];\n  stack?: string;\n}\n\nexport interface NetworkRequest {\n  timestamp: number;\n  id: string;\n  method: string;\n  url: string;\n  status?: number;\n  duration?: number;\n  requestHeaders?: Record<string, string>;\n  responseHeaders?: Record<string, string>;\n  requestBody?: any;\n  responseBody?: any;\n  failed?: boolean;\n}\n\n/**\n * Advanced session replay system with console logs and network requests\n */\nexport class SessionReplayManager {\n  private config: ReviConfig;\n  private domSerializer: DOMSerializer;\n  private consoleRecorder: ConsoleRecorder;\n  private heatmapGenerator: HeatmapGenerator | null = null;\n  private events: ReplayEvent[] = [];\n  private consoleLogs: ConsoleLog[] = [];\n  private networkRequests: Map<string, NetworkRequest> = new Map();\n  private isRecording = false;\n  private sessionId: string;\n  private startTime: number;\n  private originalConsole: any = {};\n  private originalFetch: any;\n  private originalXMLHttpRequest: any;\n\n  constructor(config: ReviConfig, sessionId: string) {\n    this.config = config;\n    this.sessionId = sessionId;\n    this.startTime = Date.now();\n    this.domSerializer = new DOMSerializer(config);\n    this.consoleRecorder = new ConsoleRecorder(sessionId, {\n      maxEntries: config.replay?.maxConsoleEntries || 1000,\n      captureStackTrace: config.replay?.captureStackTrace !== false,\n      serializeObjects: config.replay?.serializeObjects !== false,\n      maxObjectDepth: config.replay?.maxObjectDepth || 3,\n      maxStringLength: config.replay?.maxStringLength || 10000,\n      ignoredLevels: config.replay?.ignoredConsoleLevels || []\n    });\n    \n    if (this.config.replay?.enabled) {\n      this.setupReplay();\n      \n      // Initialize heatmap generator if enabled\n      if (this.config.replay?.heatmaps?.enabled && typeof document !== 'undefined') {\n        const container = document.body || document.documentElement;\n        if (container) {\n          this.heatmapGenerator = new HeatmapGenerator(container, {\n            radius: config.replay?.heatmaps?.radius || 20,\n            maxIntensity: config.replay?.heatmaps?.maxIntensity || 100,\n            blur: config.replay?.heatmaps?.blur || 15,\n            maxOpacity: config.replay?.heatmaps?.maxOpacity || 0.6\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Start recording session replay\n   */\n  startRecording(): void {\n    if (this.isRecording || !this.config.replay?.enabled) return;\n\n    this.isRecording = true;\n    \n    // Take initial snapshot\n    this.takeFullSnapshot();\n    \n    // Start observing DOM changes\n    this.domSerializer.startObserving(this.handleDOMChange.bind(this));\n    \n    // Start console recording\n    this.consoleRecorder.start();\n    \n    // Setup network monitoring\n    this.setupNetworkCapture();\n    \n    // Setup mouse and keyboard tracking\n    this.setupInteractionTracking();\n    \n    // Periodic full snapshots\n    setInterval(() => {\n      if (this.isRecording) {\n        this.takeFullSnapshot();\n      }\n    }, 60000); // Every minute\n    \n    if (this.config.debug) {\n      console.log('Revi: Session replay started');\n    }\n  }\n\n  /**\n   * Stop recording session replay\n   */\n  stopRecording(): void {\n    if (!this.isRecording) return;\n\n    this.isRecording = false;\n    this.domSerializer.stopObserving();\n    this.consoleRecorder.stop();\n    this.restoreOriginalNetwork();\n    \n    if (this.heatmapGenerator) {\n      this.heatmapGenerator.destroy();\n      this.heatmapGenerator = null;\n    }\n    \n    if (this.config.debug) {\n      console.log('Revi: Session replay stopped');\n    }\n  }\n\n  /**\n   * Get all replay events\n   */\n  getReplayData(): {\n    events: ReplayEvent[];\n    console_logs: ConsoleLogEntry[];\n    network_requests: NetworkRequest[];\n    heatmap_data?: HeatmapData[];\n    session_info: {\n      session_id: string;\n      start_time: number;\n      duration: number;\n      page_url: string;\n    };\n    analytics: {\n      console_insights: any;\n      heatmap_insights?: any;\n    };\n  } {\n    const consoleEntries = this.consoleRecorder.getEntries();\n    const consoleInsights = this.consoleRecorder.generateInsights();\n    \n    let heatmapData: HeatmapData[] | undefined;\n    let heatmapInsights: any;\n    \n    if (this.heatmapGenerator) {\n      const heatmapExport = this.heatmapGenerator.exportData();\n      heatmapData = heatmapExport.data;\n      heatmapInsights = this.heatmapGenerator.generateInsights();\n    }\n\n    return {\n      events: [...this.events],\n      console_logs: consoleEntries,\n      network_requests: Array.from(this.networkRequests.values()),\n      heatmap_data: heatmapData,\n      session_info: {\n        session_id: this.sessionId,\n        start_time: this.startTime,\n        duration: Date.now() - this.startTime,\n        page_url: window.location.href\n      },\n      analytics: {\n        console_insights: consoleInsights,\n        heatmap_insights: heatmapInsights\n      }\n    };\n  }\n\n  /**\n   * Clear replay data\n   */\n  clearReplayData(): void {\n    this.events = [];\n    this.consoleLogs = [];\n    this.networkRequests.clear();\n    this.consoleRecorder.clear();\n    \n    if (this.heatmapGenerator) {\n      this.heatmapGenerator.clear();\n    }\n  }\n\n  /**\n   * Setup basic replay tracking\n   */\n  private setupReplay(): void {\n    if (typeof window === 'undefined') return;\n\n    // Track page visibility changes\n    document.addEventListener('visibilitychange', () => {\n      this.addCustomEvent('visibility_change', {\n        hidden: document.hidden\n      });\n    });\n\n    // Track window focus/blur\n    window.addEventListener('focus', () => {\n      this.addCustomEvent('window_focus', {});\n    });\n\n    window.addEventListener('blur', () => {\n      this.addCustomEvent('window_blur', {});\n    });\n\n    // Track viewport changes\n    window.addEventListener('resize', () => {\n      this.addCustomEvent('viewport_change', {\n        width: window.innerWidth,\n        height: window.innerHeight\n      });\n    });\n\n    // Track scroll events (throttled)\n    let scrollTimeout: NodeJS.Timeout;\n    window.addEventListener('scroll', () => {\n      clearTimeout(scrollTimeout);\n      scrollTimeout = setTimeout(() => {\n        // Add to heatmap data\n        if (this.heatmapGenerator) {\n          this.heatmapGenerator.addDataPoint(\n            window.scrollX || 0,\n            window.scrollY || 0,\n            5,\n            'scroll'\n          );\n        }\n        \n        this.addCustomEvent('scroll', {\n          x: window.scrollX,\n          y: window.scrollY\n        });\n      }, 100);\n    }, { passive: true });\n  }\n\n  /**\n   * Take a full DOM snapshot\n   */\n  private takeFullSnapshot(): void {\n    if (!this.isRecording) return;\n\n    try {\n      const snapshot = this.domSerializer.takeSnapshot();\n      \n      this.addEvent({\n        type: 'full_snapshot',\n        timestamp: Date.now(),\n        data: snapshot\n      });\n    } catch (error) {\n      if (this.config.debug) {\n        console.error('Revi: Failed to take DOM snapshot', error);\n      }\n    }\n  }\n\n  /**\n   * Handle DOM changes\n   */\n  private handleDOMChange(change: DOMChange): void {\n    if (!this.isRecording) return;\n\n    this.addEvent({\n      type: 'incremental_snapshot',\n      timestamp: change.timestamp,\n      data: {\n        source: 'mutation',\n        ...change\n      }\n    });\n  }\n\n  /**\n   * Add heatmap methods\n   */\n  renderHeatmap(filter?: ('click' | 'move' | 'scroll')[]): void {\n    if (this.heatmapGenerator) {\n      this.heatmapGenerator.render(filter);\n    }\n  }\n\n  toggleHeatmap(visible: boolean): void {\n    if (this.heatmapGenerator) {\n      if (visible) {\n        this.heatmapGenerator.render();\n      } else {\n        this.heatmapGenerator.clear();\n      }\n    }\n  }\n\n  getHeatmapInsights(): any {\n    return this.heatmapGenerator?.generateInsights() || null;\n  }\n\n  /**\n   * Setup network request capture\n   */\n  private setupNetworkCapture(): void {\n    // Capture fetch requests\n    if (typeof window.fetch !== 'undefined') {\n      this.originalFetch = window.fetch;\n      \n      window.fetch = async (input: RequestInfo | URL, init?: RequestInit): Promise<Response> => {\n        const startTime = Date.now();\n        const requestId = this.generateRequestId();\n        const url = input instanceof Request ? input.url : input.toString();\n        const method = init?.method || (input instanceof Request ? input.method : 'GET');\n        \n        if (this.isRecording) {\n          this.networkRequests.set(requestId, {\n            timestamp: startTime,\n            id: requestId,\n            method,\n            url,\n            requestHeaders: this.getRequestHeaders(init, input),\n            requestBody: await this.serializeRequestBody(init, input)\n          });\n        }\n        \n        try {\n          const response = await this.originalFetch(input, init);\n          const duration = Date.now() - startTime;\n          \n          if (this.isRecording) {\n            const networkRequest = this.networkRequests.get(requestId);\n            if (networkRequest) {\n              networkRequest.status = response.status;\n              networkRequest.duration = duration;\n              networkRequest.responseHeaders = this.getResponseHeaders(response);\n              \n              // Optionally capture response body (be careful with large responses)\n              if (this.shouldCaptureResponseBody(response)) {\n                try {\n                  const clonedResponse = response.clone();\n                  networkRequest.responseBody = await clonedResponse.text();\n                } catch (e) {\n                  // Response body couldn't be captured\n                }\n              }\n            }\n          }\n          \n          return response;\n        } catch (error) {\n          const duration = Date.now() - startTime;\n          \n          if (this.isRecording) {\n            const networkRequest = this.networkRequests.get(requestId);\n            if (networkRequest) {\n              networkRequest.duration = duration;\n              networkRequest.failed = true;\n            }\n          }\n          \n          throw error;\n        }\n      };\n    }\n\n    // Capture XMLHttpRequest\n    if (typeof XMLHttpRequest !== 'undefined') {\n      this.originalXMLHttpRequest = XMLHttpRequest;\n      \n      const self = this;\n      \n      window.XMLHttpRequest = function() {\n        const xhr = new self.originalXMLHttpRequest();\n        const requestId = self.generateRequestId();\n        let method = 'GET';\n        let url = '';\n        let startTime = 0;\n        \n        const originalOpen = xhr.open;\n        const originalSend = xhr.send;\n        \n        xhr.open = function(m: string, u: string | URL, ...args: any[]) {\n          method = m;\n          url = u.toString();\n          return originalOpen.call(this, m, u, ...args);\n        };\n        \n        xhr.send = function(body?: any) {\n          startTime = Date.now();\n          \n          if (self.isRecording) {\n            self.networkRequests.set(requestId, {\n              timestamp: startTime,\n              id: requestId,\n              method,\n              url,\n              requestBody: body\n            });\n          }\n          \n          return originalSend.call(this, body);\n        };\n        \n        xhr.addEventListener('loadend', () => {\n          const duration = Date.now() - startTime;\n          \n          if (self.isRecording) {\n            const networkRequest = self.networkRequests.get(requestId);\n            if (networkRequest) {\n              networkRequest.status = xhr.status;\n              networkRequest.duration = duration;\n              networkRequest.failed = xhr.status === 0 || xhr.status >= 400;\n              \n              if (self.shouldCaptureXHRResponse(xhr)) {\n                networkRequest.responseBody = xhr.responseText;\n              }\n            }\n          }\n        });\n        \n        return xhr;\n      };\n    }\n  }\n\n  /**\n   * Setup mouse and keyboard interaction tracking\n   */\n  private setupInteractionTracking(): void {\n    // Mouse events\n    const mouseEvents = ['mousedown', 'mouseup', 'click', 'dblclick', 'mousemove'];\n    \n    mouseEvents.forEach(eventType => {\n      document.addEventListener(eventType, (event: MouseEvent) => {\n        if (!this.isRecording) return;\n        \n        // Throttle mousemove events\n        if (eventType === 'mousemove' && Math.random() > 0.1) return;\n        \n        // Add to heatmap data\n        if (this.heatmapGenerator) {\n          let intensity = 1;\n          if (eventType === 'click') intensity = 10;\n          else if (eventType === 'mousemove') intensity = 2;\n          else if (eventType === 'mousedown') intensity = 5;\n          \n          this.heatmapGenerator.addDataPoint(\n            event.clientX,\n            event.clientY,\n            intensity,\n            eventType === 'click' ? 'click' : 'move'\n          );\n        }\n        \n        this.addEvent({\n          type: 'incremental_snapshot',\n          timestamp: Date.now(),\n          data: {\n            source: 'mouse',\n            type: eventType,\n            x: event.clientX,\n            y: event.clientY,\n            id: this.getElementId(event.target as Element)\n          }\n        });\n      }, { capture: true, passive: true });\n    });\n\n    // Keyboard events\n    document.addEventListener('keydown', (event: KeyboardEvent) => {\n      if (!this.isRecording) return;\n      \n      // Don't capture sensitive keystrokes\n      if (this.shouldIgnoreKeystroke(event)) return;\n      \n      this.addEvent({\n        type: 'incremental_snapshot',\n        timestamp: Date.now(),\n        data: {\n          source: 'keyboard',\n          type: 'keydown',\n          key: this.sanitizeKey(event.key),\n          code: event.code,\n          id: this.getElementId(event.target as Element)\n        }\n      });\n    }, { capture: true, passive: true });\n  }\n\n  /**\n   * Utility methods\n   */\n  private addEvent(event: ReplayEvent): void {\n    this.events.push(event);\n    \n    // Limit event buffer\n    if (this.events.length > 10000) {\n      this.events = this.events.slice(-8000);\n    }\n  }\n\n  private addCustomEvent(type: string, data: any): void {\n    this.addEvent({\n      type: 'custom',\n      timestamp: Date.now(),\n      data: { type, ...data }\n    });\n  }\n\n  private serializeConsoleArgs(args: any[]): any[] {\n    return args.map(arg => {\n      try {\n        if (typeof arg === 'object' && arg !== null) {\n          return JSON.parse(JSON.stringify(arg));\n        }\n        return arg;\n      } catch (e) {\n        return '[Unserializable Object]';\n      }\n    });\n  }\n\n  private generateRequestId(): string {\n    return Date.now().toString(36) + Math.random().toString(36).substr(2);\n  }\n\n  private getRequestHeaders(init?: RequestInit, input?: RequestInfo | URL): Record<string, string> {\n    const headers: Record<string, string> = {};\n    \n    if (init?.headers) {\n      if (init.headers instanceof Headers) {\n        init.headers.forEach((value, key) => {\n          headers[key] = value;\n        });\n      } else if (Array.isArray(init.headers)) {\n        init.headers.forEach(([key, value]) => {\n          headers[key] = value;\n        });\n      } else {\n        Object.assign(headers, init.headers);\n      }\n    }\n    \n    if (input instanceof Request) {\n      input.headers.forEach((value, key) => {\n        headers[key] = value;\n      });\n    }\n    \n    return headers;\n  }\n\n  private getResponseHeaders(response: Response): Record<string, string> {\n    const headers: Record<string, string> = {};\n    response.headers.forEach((value, key) => {\n      headers[key] = value;\n    });\n    return headers;\n  }\n\n  private async serializeRequestBody(init?: RequestInit, input?: RequestInfo | URL): Promise<any> {\n    let body = init?.body;\n    \n    if (input instanceof Request && !body) {\n      try {\n        body = await input.clone().text();\n      } catch (e) {\n        return null;\n      }\n    }\n    \n    if (!body) return null;\n    \n    if (typeof body === 'string') {\n      return body.length > 10000 ? body.substring(0, 10000) + '...[truncated]' : body;\n    }\n    \n    if (body instanceof FormData) {\n      const formData: Record<string, any> = {};\n      body.forEach((value, key) => {\n        formData[key] = value instanceof File ? `[File: ${value.name}]` : value;\n      });\n      return formData;\n    }\n    \n    return '[Binary Data]';\n  }\n\n  private shouldCaptureResponseBody(response: Response): boolean {\n    const contentType = response.headers.get('content-type') || '';\n    const contentLength = parseInt(response.headers.get('content-length') || '0');\n    \n    // Only capture text-based responses under 100KB\n    return contentType.includes('application/json') ||\n           contentType.includes('text/') ||\n           (contentLength > 0 && contentLength < 100000);\n  }\n\n  private shouldCaptureXHRResponse(xhr: XMLHttpRequest): boolean {\n    const contentType = xhr.getResponseHeader('content-type') || '';\n    \n    return contentType.includes('application/json') ||\n           contentType.includes('text/') ||\n           (xhr.responseText && xhr.responseText.length < 100000);\n  }\n\n  private getElementId(element: Element | null): number | undefined {\n    // This would ideally use the same node ID system as the DOM serializer\n    return element ? Math.random() : undefined;\n  }\n\n  private shouldIgnoreKeystroke(event: KeyboardEvent): boolean {\n    const target = event.target as HTMLElement;\n    \n    if (target && target.tagName) {\n      const tagName = target.tagName.toLowerCase();\n      const type = (target as HTMLInputElement).type;\n      \n      // Ignore keystrokes in password fields\n      if (tagName === 'input' && type === 'password') return true;\n      \n      // Ignore keystrokes in elements marked as sensitive\n      if (target.hasAttribute('data-revi-ignore')) return true;\n    }\n    \n    return false;\n  }\n\n  private sanitizeKey(key: string): string {\n    // Don't capture the actual key for sensitive inputs\n    if (key.length === 1 && /[a-zA-Z0-9]/.test(key)) {\n      return '*'; // Mask alphanumeric characters\n    }\n    return key;\n  }\n\n\n  private restoreOriginalNetwork(): void {\n    if (this.originalFetch) {\n      window.fetch = this.originalFetch;\n    }\n    \n    if (this.originalXMLHttpRequest) {\n      window.XMLHttpRequest = this.originalXMLHttpRequest;\n    }\n  }\n}","import { ErrorHandler } from './error-handler';\nimport { SessionManager } from './session';\nimport { NetworkMonitor } from './network-monitor';\nimport { DataManager } from './data-manager';\nimport { UserJourneyTracker } from './user-journey';\nimport { TraceManager } from './trace-manager';\nimport { SamplingManager } from './sampling-manager';\nimport { PerformanceMonitor } from './performance-monitor';\nimport { SessionReplayManager } from './session-replay';\nimport { isBot } from './utils';\nimport type { ReviConfig, ErrorEvent, UserContext } from './types';\n\nexport class Monitor {\n  private config: ReviConfig;\n  private traceManager: TraceManager;\n  private errorHandler: ErrorHandler;\n  private sessionManager: SessionManager;\n  private networkMonitor: NetworkMonitor;\n  private performanceMonitor: PerformanceMonitor;\n  private dataManager: DataManager;\n  private userJourneyTracker: UserJourneyTracker;\n  private sessionReplayManager: SessionReplayManager;\n  private samplingManager: SamplingManager;\n  private isInitialized = false;\n\n  constructor(config: ReviConfig) {\n    this.config = {\n      apiUrl: process.env.REVI_API_URL || 'https://api.revi.dev',\n      environment: 'production',\n      debug: false,\n      sampleRate: 1.0,\n      sessionSampleRate: 1.0,\n      maxBreadcrumbs: 50,\n      privacy: {\n        maskInputs: true,\n        maskPasswords: true,\n        maskCreditCards: true\n      },\n      performance: {\n        captureWebVitals: true,\n        captureResourceTiming: false,\n        captureNavigationTiming: true\n      },\n      replay: {\n        enabled: true,\n        maskAllInputs: false,\n        maskAllText: false\n      },\n      ...config\n    };\n\n    if (!this.config.apiKey) {\n      throw new Error('Revi: API key is required');\n    }\n\n    if (isBot()) {\n      if (this.config.debug) {\n        console.log('Revi: Bot detected, skipping initialization');\n      }\n      return;\n    }\n\n    this.init();\n  }\n\n  private init(): void {\n    if (this.isInitialized) return;\n\n    try {\n      // Create shared trace manager\n      this.traceManager = new TraceManager();\n      \n      // Initialize core components with shared trace manager\n      this.errorHandler = new ErrorHandler(this.config, this.traceManager);\n      this.sessionManager = new SessionManager(this.config, this.traceManager);\n      this.networkMonitor = new NetworkMonitor(this.config, this.traceManager);\n      this.performanceMonitor = new PerformanceMonitor(this.config);\n      this.dataManager = new DataManager(this.config);\n      this.userJourneyTracker = new UserJourneyTracker(this.config);\n      this.sessionReplayManager = new SessionReplayManager(this.config, this.sessionManager.getSessionId());\n      this.samplingManager = new SamplingManager(this.config);\n\n      this.setupAdaptiveFlush();\n      \n      // Start session replay if enabled\n      if (this.config.replay?.enabled) {\n        this.sessionReplayManager.startRecording();\n      }\n      \n      this.isInitialized = true;\n\n      if (this.config.debug) {\n        console.log('Revi: Initialized successfully');\n      }\n    } catch (error) {\n      if (this.config.debug) {\n        console.error('Revi: Initialization failed', error);\n      }\n    }\n  }\n\n  private setupAdaptiveFlush(): void {\n    let errorCount = 0;\n    let lastFlushTime = Date.now();\n    \n    const adaptiveFlush = () => {\n      const now = Date.now();\n      const timeSinceLastFlush = now - lastFlushTime;\n      \n      // Base interval: 10 seconds\n      let flushInterval = 10000;\n      \n      // Reduce interval if there are many errors (max: 3 seconds)\n      if (errorCount > 0) {\n        flushInterval = Math.max(3000, 10000 - (errorCount * 1000));\n      }\n      \n      // Increase interval if no activity (max: 30 seconds)\n      if (errorCount === 0 && timeSinceLastFlush > 15000) {\n        flushInterval = Math.min(30000, flushInterval + 5000);\n      }\n      \n      if (timeSinceLastFlush >= flushInterval) {\n        this.flush();\n        lastFlushTime = now;\n        errorCount = 0; // Reset error count after flush\n      }\n      \n      // Schedule next check\n      setTimeout(adaptiveFlush, 2000);\n    };\n    \n    // Start the adaptive flush cycle\n    adaptiveFlush();\n    \n    // Track errors for adaptive frequency\n    const originalCaptureException = this.captureException.bind(this);\n    this.captureException = (error: Error, options = {}) => {\n      errorCount++;\n      return originalCaptureException(error, options);\n    };\n  }\n\n  // Public API methods\n  captureException(error: Error, options: {\n    level?: 'error' | 'warning' | 'info' | 'debug';\n    tags?: Record<string, string>;\n    extra?: Record<string, any>;\n  } = {}): string {\n    if (!this.isInitialized) return '';\n\n    // Sampling check - always capture critical errors\n    const isCriticalError = options.level === 'error' || !options.level;\n    if (!isCriticalError && this.samplingManager.shouldSkipCapture('error')) {\n      return ''; // Skip non-critical errors based on sampling\n    }\n\n    // Update activity level based on error frequency\n    this.samplingManager.incrementErrorFrequency();\n    this.samplingManager.updateActivityLevel('high');\n\n    const errorId = this.errorHandler.captureException(error, options);\n    if (errorId) {\n      // Create error event and queue for upload\n      const errorEvent: ErrorEvent = {\n        id: errorId,\n        timestamp: Date.now(),\n        message: error.message,\n        stack: error.stack,\n        url: window.location.href,\n        userId: this.config.userId,\n        sessionId: this.sessionManager.getSessionId(),\n        userAgent: navigator.userAgent,\n        environment: this.config.environment,\n        release: this.config.release,\n        tags: options.tags,\n        extra: options.extra,\n        breadcrumbs: this.errorHandler.getBreadcrumbs(),\n        level: options.level || 'error'\n      };\n\n      this.dataManager.queueError(errorEvent);\n      \n      // Track error in user journey\n      if (this.userJourneyTracker) {\n        this.userJourneyTracker.trackError(error, {\n          level: options.level,\n          tags: options.tags,\n          extra: options.extra\n        });\n      }\n    }\n\n    return errorId;\n  }\n\n  captureMessage(message: string, options: {\n    level?: 'error' | 'warning' | 'info' | 'debug';\n    tags?: Record<string, string>;\n    extra?: Record<string, any>;\n  } = {}): string {\n    if (!this.isInitialized) return '';\n\n    const errorId = this.errorHandler.captureMessage(message, options);\n    if (errorId) {\n      const errorEvent: ErrorEvent = {\n        id: errorId,\n        timestamp: Date.now(),\n        message,\n        url: window.location.href,\n        userId: this.config.userId,\n        sessionId: this.sessionManager.getSessionId(),\n        userAgent: navigator.userAgent,\n        environment: this.config.environment,\n        release: this.config.release,\n        tags: options.tags,\n        extra: options.extra,\n        breadcrumbs: this.errorHandler.getBreadcrumbs(),\n        level: options.level || 'info'\n      };\n\n      this.dataManager.queueError(errorEvent);\n    }\n\n    return errorId;\n  }\n\n  addBreadcrumb(breadcrumb: {\n    message: string;\n    category?: string;\n    level?: 'error' | 'warning' | 'info' | 'debug';\n    data?: Record<string, any>;\n  }): void {\n    if (!this.isInitialized) return;\n\n    this.errorHandler.addBreadcrumb({\n      timestamp: Date.now(),\n      message: breadcrumb.message,\n      category: breadcrumb.category || 'manual',\n      level: breadcrumb.level || 'info',\n      data: breadcrumb.data\n    });\n  }\n\n  setUserContext(user: UserContext): void {\n    if (!this.isInitialized) return;\n\n    this.config.userId = user.id;\n    this.errorHandler.setUserContext(user);\n    this.userJourneyTracker.setUserId(user.id || '');\n    this.userJourneyTracker.startTracking(user.id);\n  }\n\n  setTags(tags: Record<string, string>): void {\n    if (!this.isInitialized) return;\n    this.errorHandler.setTags(tags);\n  }\n\n  setExtra(extra: Record<string, any>): void {\n    if (!this.isInitialized) return;\n    this.errorHandler.setExtra(extra);\n  }\n\n  // Session management\n  getSessionId(): string {\n    if (!this.isInitialized) return '';\n    return this.sessionManager.getSessionId();\n  }\n\n  endSession(): void {\n    if (!this.isInitialized) return;\n    \n    this.flush();\n    this.sessionManager.endSession();\n  }\n\n  // Performance monitoring\n  mark(name: string): void {\n    if (!this.isInitialized) return;\n    this.performanceMonitor.mark(name);\n  }\n\n  measure(name: string, startMark?: string, endMark?: string): number | null {\n    if (!this.isInitialized) return null;\n    return this.performanceMonitor.measure(name, startMark, endMark);\n  }\n\n  getWebVitals() {\n    if (!this.isInitialized) return {};\n    return this.performanceMonitor.getWebVitals();\n  }\n\n  // Session Replay methods\n  startSessionReplay(): void {\n    if (!this.isInitialized || !this.sessionReplayManager) return;\n    this.sessionReplayManager.startRecording();\n  }\n\n  stopSessionReplay(): void {\n    if (!this.isInitialized || !this.sessionReplayManager) return;\n    this.sessionReplayManager.stopRecording();\n  }\n\n  getSessionReplayData() {\n    if (!this.isInitialized || !this.sessionReplayManager) return null;\n    return this.sessionReplayManager.getReplayData();\n  }\n\n  // Data management\n  flush(): void {\n    if (!this.isInitialized) return;\n\n    // Get all queued events\n    const sessionEvents = this.sessionManager.flush();\n    const networkEvents = this.networkMonitor.flush();\n\n    // Add session ID to network events\n    networkEvents.forEach(event => {\n      event.sessionId = this.sessionManager.getSessionId();\n    });\n\n    // Queue for upload\n    if (sessionEvents.length > 0) {\n      this.dataManager.queueSessionEvents(sessionEvents);\n    }\n    \n    if (networkEvents.length > 0) {\n      this.dataManager.queueNetworkEvents(networkEvents);\n    }\n  }\n\n\n  // Trace context methods\n  getCurrentTraceId(): string | undefined {\n    return this.traceManager?.getCurrentTraceId();\n  }\n\n  getCurrentSpanId(): string | undefined {\n    return this.traceManager?.getCurrentSpanId();\n  }\n\n  getTraceContext(): { traceId?: string; spanId?: string; parentSpanId?: string } {\n    return this.traceManager?.getTraceContext() || {};\n  }\n\n  startSpan(operationName: string): string | undefined {\n    return this.traceManager?.startSpan(operationName);\n  }\n\n  finishSpan(spanId?: string, data?: Record<string, any>): void {\n    this.traceManager?.finishSpan(spanId, data);\n  }\n\n  destroy(): void {\n    if (!this.isInitialized) return;\n\n    this.flush();\n    \n    if (this.networkMonitor) {\n      this.networkMonitor.destroy();\n    }\n    \n    if (this.dataManager) {\n      this.dataManager.destroy();\n    }\n\n    if (this.sessionReplayManager) {\n      this.sessionReplayManager.stopRecording();\n    }\n\n    if (this.userJourneyTracker) {\n      this.userJourneyTracker.stopTracking();\n    }\n    \n    // Cleanup trace manager\n    if (this.traceManager) {\n      this.traceManager.cleanupSpanData();\n    }\n\n    this.isInitialized = false;\n  }\n}\n","/**\n * Advanced Retry Manager with sophisticated retry strategies\n * Implements jittered exponential backoff, failure classification, and retry budgets\n */\n\nexport interface RetryConfig {\n  maxAttempts: number;\n  baseDelay: number;\n  maxDelay: number;\n  jitterRatio: number;\n  timeoutMultiplier: number;\n  retryBudget: number;\n  enableJitter: boolean;\n}\n\nexport interface RetryableError {\n  statusCode?: number;\n  type: 'network' | 'timeout' | 'server' | 'client' | 'unknown';\n  message: string;\n  retryable: boolean;\n  priority: 'critical' | 'high' | 'medium' | 'low';\n}\n\nexport interface RetryAttempt {\n  attempt: number;\n  delay: number;\n  timestamp: number;\n  error?: RetryableError;\n  duration?: number;\n}\n\nexport interface RetryStats {\n  totalAttempts: number;\n  successfulRetries: number;\n  failedRetries: number;\n  averageDelay: number;\n  budgetUsed: number;\n  lastSuccess?: number;\n  lastFailure?: number;\n}\n\nexport class RetryManager {\n  private config: RetryConfig;\n  private retryStats: Map<string, RetryStats> = new Map();\n  private retryBudgetUsed = 0;\n  private lastBudgetReset = Date.now();\n  private budgetResetInterval = 60000; // 1 minute\n  private requestDeduplication = new Map<string, Promise<any>>();\n  private rateLimitedUntil = 0;\n\n  constructor(config: Partial<RetryConfig> = {}) {\n    this.config = {\n      maxAttempts: 5,\n      baseDelay: 1000,\n      maxDelay: 30000,\n      jitterRatio: 0.1,\n      timeoutMultiplier: 1.5,\n      retryBudget: 100, // Max retry attempts per minute\n      enableJitter: true,\n      ...config\n    };\n  }\n\n  /**\n   * Execute operation with advanced retry logic\n   */\n  async executeWithRetry<T>(\n    key: string,\n    operation: () => Promise<T>,\n    options: {\n      priority?: 'critical' | 'high' | 'medium' | 'low';\n      timeout?: number;\n      payloadSize?: number;\n      deduplicationKey?: string;\n    } = {}\n  ): Promise<T> {\n    const { priority = 'medium', timeout, payloadSize, deduplicationKey } = options;\n    \n    // Check deduplication\n    if (deduplicationKey && this.requestDeduplication.has(deduplicationKey)) {\n      return this.requestDeduplication.get(deduplicationKey);\n    }\n\n    // Check retry budget\n    this.resetBudgetIfNeeded();\n    if (!this.hasBudgetAvailable(priority)) {\n      throw new Error('Retry budget exceeded. Operation rate-limited.');\n    }\n\n    const stats = this.getOrCreateStats(key);\n    const attempts: RetryAttempt[] = [];\n    let lastError: RetryableError | undefined;\n\n    // Create deduplication promise if needed\n    const executePromise = this.performRetryLoop(key, operation, priority, timeout, payloadSize, attempts, stats);\n    \n    if (deduplicationKey) {\n      this.requestDeduplication.set(deduplicationKey, executePromise);\n      \n      // Clean up deduplication entry after completion\n      executePromise.finally(() => {\n        this.requestDeduplication.delete(deduplicationKey);\n      });\n    }\n\n    return executePromise;\n  }\n\n  private async performRetryLoop<T>(\n    key: string,\n    operation: () => Promise<T>,\n    priority: 'critical' | 'high' | 'medium' | 'low',\n    timeout: number | undefined,\n    payloadSize: number | undefined,\n    attempts: RetryAttempt[],\n    stats: RetryStats\n  ): Promise<T> {\n    for (let attempt = 0; attempt < this.config.maxAttempts; attempt++) {\n      const attemptStart = Date.now();\n      \n      try {\n        // Check rate limiting\n        if (Date.now() < this.rateLimitedUntil) {\n          throw this.createRetryableError(429, 'Rate limited', 'server', false, priority);\n        }\n\n        // Execute with timeout if specified\n        const result = timeout \n          ? await this.executeWithTimeout(operation, timeout * Math.pow(this.config.timeoutMultiplier, attempt))\n          : await operation();\n\n        // Success - update stats and return\n        stats.totalAttempts++;\n        stats.successfulRetries = attempt > 0 ? stats.successfulRetries + 1 : stats.successfulRetries;\n        stats.lastSuccess = Date.now();\n        \n        const attemptRecord: RetryAttempt = {\n          attempt: attempt + 1,\n          delay: 0,\n          timestamp: attemptStart,\n          duration: Date.now() - attemptStart\n        };\n        attempts.push(attemptRecord);\n\n        return result;\n\n      } catch (error: any) {\n        const retryableError = this.classifyError(error, priority);\n        const attemptRecord: RetryAttempt = {\n          attempt: attempt + 1,\n          delay: 0,\n          timestamp: attemptStart,\n          error: retryableError,\n          duration: Date.now() - attemptStart\n        };\n        attempts.push(attemptRecord);\n\n        stats.totalAttempts++;\n        stats.lastFailure = Date.now();\n\n        // Handle rate limiting\n        if (retryableError.statusCode === 429) {\n          this.handleRateLimit(error);\n        }\n\n        // Check if we should retry\n        if (!this.shouldRetry(retryableError, attempt, priority, payloadSize)) {\n          stats.failedRetries++;\n          throw error;\n        }\n\n        // Calculate delay for next attempt\n        const delay = this.calculateDelay(attempt, priority, payloadSize);\n        attemptRecord.delay = delay;\n        \n        // Update stats\n        const totalDelay = attempts.reduce((sum, att) => sum + att.delay, 0);\n        stats.averageDelay = totalDelay / attempts.length;\n\n        // Wait before retry\n        if (delay > 0) {\n          await this.sleep(delay);\n        }\n\n        // Consume retry budget\n        this.consumeRetryBudget(priority);\n      }\n    }\n\n    // All retries exhausted\n    stats.failedRetries++;\n    throw new Error(`Max retry attempts (${this.config.maxAttempts}) exceeded for ${key}`);\n  }\n\n  private executeWithTimeout<T>(operation: () => Promise<T>, timeout: number): Promise<T> {\n    return Promise.race([\n      operation(),\n      new Promise<never>((_, reject) => \n        setTimeout(() => reject(new Error(`Operation timed out after ${timeout}ms`)), timeout)\n      )\n    ]);\n  }\n\n  private classifyError(error: any, priority: 'critical' | 'high' | 'medium' | 'low'): RetryableError {\n    // Network errors\n    if (error.name === 'TypeError' && error.message.includes('fetch')) {\n      return this.createRetryableError(0, error.message, 'network', true, priority);\n    }\n\n    // Timeout errors\n    if (error.message?.includes('timeout') || error.name === 'TimeoutError') {\n      return this.createRetryableError(0, error.message, 'timeout', true, priority);\n    }\n\n    // HTTP status code errors\n    if (error.status || error.statusCode) {\n      const status = error.status || error.statusCode;\n      \n      if (status >= 500) {\n        // Server errors - retryable\n        return this.createRetryableError(status, error.message, 'server', true, priority);\n      } else if (status === 429) {\n        // Rate limiting - retryable with backoff\n        return this.createRetryableError(status, error.message, 'server', true, priority);\n      } else if (status >= 400) {\n        // Client errors - mostly not retryable, except specific cases\n        const retryable = status === 408 || status === 409 || status === 423 || status === 424;\n        return this.createRetryableError(status, error.message, 'client', retryable, priority);\n      }\n    }\n\n    // Unknown errors - not retryable by default\n    return this.createRetryableError(0, error.message || 'Unknown error', 'unknown', false, priority);\n  }\n\n  private createRetryableError(\n    statusCode: number,\n    message: string,\n    type: RetryableError['type'],\n    retryable: boolean,\n    priority: 'critical' | 'high' | 'medium' | 'low'\n  ): RetryableError {\n    return {\n      statusCode,\n      message,\n      type,\n      retryable,\n      priority\n    };\n  }\n\n  private shouldRetry(\n    error: RetryableError,\n    attempt: number,\n    priority: 'critical' | 'high' | 'medium' | 'low',\n    payloadSize?: number\n  ): boolean {\n    // Don't retry if error is not retryable\n    if (!error.retryable) {\n      return false;\n    }\n\n    // Don't retry if we've exceeded max attempts\n    if (attempt >= this.config.maxAttempts - 1) {\n      return false;\n    }\n\n    // Don't retry if no budget available (except for critical priority)\n    if (priority !== 'critical' && !this.hasBudgetAvailable(priority)) {\n      return false;\n    }\n\n    // For large payloads, reduce retry attempts on slow connections\n    if (payloadSize && payloadSize > 100000) { // 100KB\n      const maxAttemptsForLargePayload = Math.max(2, this.config.maxAttempts - 2);\n      if (attempt >= maxAttemptsForLargePayload) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private calculateDelay(\n    attempt: number,\n    priority: 'critical' | 'high' | 'medium' | 'low',\n    payloadSize?: number\n  ): number {\n    // Base exponential backoff\n    let delay = Math.min(\n      this.config.baseDelay * Math.pow(2, attempt),\n      this.config.maxDelay\n    );\n\n    // Priority-based delay adjustment\n    const priorityMultipliers = {\n      critical: 0.5,\n      high: 0.7,\n      medium: 1.0,\n      low: 1.5\n    };\n    delay *= priorityMultipliers[priority];\n\n    // Payload size adjustment (larger payloads wait longer)\n    if (payloadSize && payloadSize > 50000) { // 50KB\n      const sizeMultiplier = Math.min(1 + (payloadSize / 100000), 2); // Max 2x delay\n      delay *= sizeMultiplier;\n    }\n\n    // Add jitter to prevent thundering herd\n    if (this.config.enableJitter) {\n      const jitter = delay * this.config.jitterRatio * (Math.random() - 0.5);\n      delay += jitter;\n    }\n\n    return Math.max(0, Math.floor(delay));\n  }\n\n  private handleRateLimit(error: any): void {\n    // Check for Retry-After header\n    const retryAfter = error.headers?.['retry-after'] || error.retryAfter;\n    \n    if (retryAfter) {\n      const retryAfterMs = parseInt(retryAfter) * 1000;\n      this.rateLimitedUntil = Date.now() + retryAfterMs;\n    } else {\n      // Default rate limit backoff\n      this.rateLimitedUntil = Date.now() + 60000; // 1 minute\n    }\n  }\n\n  private resetBudgetIfNeeded(): void {\n    const now = Date.now();\n    if (now - this.lastBudgetReset > this.budgetResetInterval) {\n      this.retryBudgetUsed = 0;\n      this.lastBudgetReset = now;\n    }\n  }\n\n  private hasBudgetAvailable(priority: 'critical' | 'high' | 'medium' | 'low'): boolean {\n    // Critical requests always have budget\n    if (priority === 'critical') {\n      return true;\n    }\n\n    // Reserve some budget for high priority requests\n    const reservedBudget = priority === 'high' ? this.config.retryBudget * 0.2 : this.config.retryBudget * 0.5;\n    \n    return this.retryBudgetUsed < (this.config.retryBudget - reservedBudget);\n  }\n\n  private consumeRetryBudget(priority: 'critical' | 'high' | 'medium' | 'low'): void {\n    // Critical requests don't consume budget\n    if (priority !== 'critical') {\n      this.retryBudgetUsed++;\n      \n      // Update stats\n      for (const stats of this.retryStats.values()) {\n        stats.budgetUsed = this.retryBudgetUsed / this.config.retryBudget;\n      }\n    }\n  }\n\n  private getOrCreateStats(key: string): RetryStats {\n    if (!this.retryStats.has(key)) {\n      this.retryStats.set(key, {\n        totalAttempts: 0,\n        successfulRetries: 0,\n        failedRetries: 0,\n        averageDelay: 0,\n        budgetUsed: 0\n      });\n    }\n    return this.retryStats.get(key)!;\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Get retry statistics for monitoring\n   */\n  getStats(key?: string): RetryStats | Map<string, RetryStats> {\n    if (key) {\n      return this.retryStats.get(key) || this.getOrCreateStats(key);\n    }\n    return new Map(this.retryStats);\n  }\n\n  /**\n   * Reset statistics (useful for testing)\n   */\n  resetStats(key?: string): void {\n    if (key) {\n      this.retryStats.delete(key);\n    } else {\n      this.retryStats.clear();\n      this.retryBudgetUsed = 0;\n      this.lastBudgetReset = Date.now();\n      this.requestDeduplication.clear();\n    }\n  }\n\n  /**\n   * Check if currently rate limited\n   */\n  isRateLimited(): boolean {\n    return Date.now() < this.rateLimitedUntil;\n  }\n\n  /**\n   * Get remaining retry budget\n   */\n  getRemainingBudget(): number {\n    this.resetBudgetIfNeeded();\n    return Math.max(0, this.config.retryBudget - this.retryBudgetUsed);\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(newConfig: Partial<RetryConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n  }\n}","/**\n * Multi-Level Circuit Breaker System\n * Prevents cascade failures and provides graceful degradation\n */\n\nexport type CircuitState = 'closed' | 'open' | 'half-open';\n\nexport interface CircuitBreakerConfig {\n  failureThreshold: number;\n  recoveryTime: number;\n  successThreshold: number;\n  timeout: number;\n  maxFailureRate: number;\n  windowSize: number;\n  minRequests: number;\n}\n\nexport interface CircuitMetrics {\n  requests: number;\n  failures: number;\n  successes: number;\n  failureRate: number;\n  averageResponseTime: number;\n  lastFailureTime?: number;\n  lastSuccessTime?: number;\n  state: CircuitState;\n  openTime?: number;\n  nextRetryTime?: number;\n}\n\nexport interface FeatureConfig {\n  name: string;\n  priority: 'critical' | 'high' | 'medium' | 'low';\n  fallbackEnabled: boolean;\n  gracefulDegradation: boolean;\n}\n\n/**\n * Individual Circuit Breaker for a single endpoint/feature\n */\nexport class CircuitBreaker {\n  private config: CircuitBreakerConfig;\n  private state: CircuitState = 'closed';\n  private metrics: CircuitMetrics;\n  private requestWindow: Array<{ timestamp: number; success: boolean; duration: number }> = [];\n  private listeners: Array<(state: CircuitState, metrics: CircuitMetrics) => void> = [];\n\n  constructor(\n    private name: string,\n    config: Partial<CircuitBreakerConfig> = {}\n  ) {\n    this.config = {\n      failureThreshold: 5,\n      recoveryTime: 60000, // 1 minute\n      successThreshold: 3,\n      timeout: 30000, // 30 seconds\n      maxFailureRate: 0.5, // 50%\n      windowSize: 60000, // 1 minute window\n      minRequests: 5,\n      ...config\n    };\n\n    this.metrics = {\n      requests: 0,\n      failures: 0,\n      successes: 0,\n      failureRate: 0,\n      averageResponseTime: 0,\n      state: this.state\n    };\n  }\n\n  /**\n   * Execute operation through circuit breaker\n   */\n  async execute<T>(operation: () => Promise<T>, fallback?: () => Promise<T>): Promise<T> {\n    // Check if circuit is open\n    if (this.state === 'open') {\n      if (Date.now() < (this.metrics.nextRetryTime || 0)) {\n        if (fallback) {\n          return await fallback();\n        }\n        throw new Error(`Circuit breaker ${this.name} is OPEN. Next retry: ${new Date(this.metrics.nextRetryTime!)}`);\n      }\n      \n      // Time to try half-open\n      this.transitionToHalfOpen();\n    }\n\n    // Execute operation\n    const startTime = Date.now();\n    \n    try {\n      const result = await Promise.race([\n        operation(),\n        new Promise<never>((_, reject) => \n          setTimeout(() => reject(new Error(`Circuit breaker timeout: ${this.config.timeout}ms`)), this.config.timeout)\n        )\n      ]);\n\n      // Success\n      const duration = Date.now() - startTime;\n      this.recordSuccess(duration);\n      return result;\n\n    } catch (error) {\n      // Failure\n      const duration = Date.now() - startTime;\n      this.recordFailure(duration);\n\n      // Try fallback if available\n      if (fallback) {\n        try {\n          return await fallback();\n        } catch (fallbackError) {\n          // Both primary and fallback failed\n          throw error; // Throw original error\n        }\n      }\n\n      throw error;\n    }\n  }\n\n  private recordSuccess(duration: number): void {\n    const now = Date.now();\n    \n    this.requestWindow.push({\n      timestamp: now,\n      success: true,\n      duration\n    });\n\n    this.cleanupOldRequests();\n    this.updateMetrics();\n\n    this.metrics.lastSuccessTime = now;\n\n    // State transitions\n    if (this.state === 'half-open') {\n      if (this.metrics.successes >= this.config.successThreshold) {\n        this.transitionToClosed();\n      }\n    }\n\n    this.notifyListeners();\n  }\n\n  private recordFailure(duration: number): void {\n    const now = Date.now();\n    \n    this.requestWindow.push({\n      timestamp: now,\n      success: false,\n      duration\n    });\n\n    this.cleanupOldRequests();\n    this.updateMetrics();\n\n    this.metrics.lastFailureTime = now;\n\n    // State transitions\n    if (this.state === 'closed' || this.state === 'half-open') {\n      if (this.shouldOpen()) {\n        this.transitionToOpen();\n      }\n    }\n\n    this.notifyListeners();\n  }\n\n  private shouldOpen(): boolean {\n    // Need minimum requests to make a decision\n    if (this.metrics.requests < this.config.minRequests) {\n      return false;\n    }\n\n    // Check failure threshold (absolute)\n    if (this.metrics.failures >= this.config.failureThreshold) {\n      return true;\n    }\n\n    // Check failure rate (percentage)\n    if (this.metrics.failureRate >= this.config.maxFailureRate) {\n      return true;\n    }\n\n    // For half-open state, any failure should open the circuit\n    if (this.state === 'half-open') {\n      return true;\n    }\n\n    return false;\n  }\n\n  private transitionToClosed(): void {\n    this.state = 'closed';\n    this.metrics.state = 'closed';\n    this.metrics.openTime = undefined;\n    this.metrics.nextRetryTime = undefined;\n    \n    // Reset failure counters but keep some history\n    this.metrics.failures = 0;\n    this.metrics.successes = 0;\n  }\n\n  private transitionToOpen(): void {\n    this.state = 'open';\n    this.metrics.state = 'open';\n    this.metrics.openTime = Date.now();\n    this.metrics.nextRetryTime = Date.now() + this.config.recoveryTime;\n  }\n\n  private transitionToHalfOpen(): void {\n    this.state = 'half-open';\n    this.metrics.state = 'half-open';\n    this.metrics.successes = 0; // Reset success counter for half-open test\n  }\n\n  private cleanupOldRequests(): void {\n    const cutoff = Date.now() - this.config.windowSize;\n    this.requestWindow = this.requestWindow.filter(req => req.timestamp > cutoff);\n  }\n\n  private updateMetrics(): void {\n    const totalRequests = this.requestWindow.length;\n    const successfulRequests = this.requestWindow.filter(req => req.success).length;\n    const failedRequests = totalRequests - successfulRequests;\n\n    this.metrics.requests = totalRequests;\n    this.metrics.successes = successfulRequests;\n    this.metrics.failures = failedRequests;\n    this.metrics.failureRate = totalRequests > 0 ? failedRequests / totalRequests : 0;\n    \n    // Calculate average response time\n    if (this.requestWindow.length > 0) {\n      const totalDuration = this.requestWindow.reduce((sum, req) => sum + req.duration, 0);\n      this.metrics.averageResponseTime = totalDuration / this.requestWindow.length;\n    }\n  }\n\n  /**\n   * Get current metrics\n   */\n  getMetrics(): CircuitMetrics {\n    this.cleanupOldRequests();\n    this.updateMetrics();\n    return { ...this.metrics };\n  }\n\n  /**\n   * Get current state\n   */\n  getState(): CircuitState {\n    return this.state;\n  }\n\n  /**\n   * Force state change (for testing)\n   */\n  forceState(state: CircuitState): void {\n    this.state = state;\n    this.metrics.state = state;\n    \n    if (state === 'open') {\n      this.metrics.openTime = Date.now();\n      this.metrics.nextRetryTime = Date.now() + this.config.recoveryTime;\n    }\n    \n    this.notifyListeners();\n  }\n\n  /**\n   * Reset circuit breaker\n   */\n  reset(): void {\n    this.state = 'closed';\n    this.requestWindow = [];\n    this.metrics = {\n      requests: 0,\n      failures: 0,\n      successes: 0,\n      failureRate: 0,\n      averageResponseTime: 0,\n      state: 'closed'\n    };\n    this.notifyListeners();\n  }\n\n  /**\n   * Listen for state changes\n   */\n  onStateChange(callback: (state: CircuitState, metrics: CircuitMetrics) => void): () => void {\n    this.listeners.push(callback);\n    return () => {\n      const index = this.listeners.indexOf(callback);\n      if (index > -1) {\n        this.listeners.splice(index, 1);\n      }\n    };\n  }\n\n  private notifyListeners(): void {\n    this.listeners.forEach(callback => {\n      try {\n        callback(this.state, { ...this.metrics });\n      } catch (error) {\n        console.error(`Circuit breaker ${this.name} listener error:`, error);\n      }\n    });\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(newConfig: Partial<CircuitBreakerConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n  }\n}\n\n/**\n * Multi-Level Circuit Breaker Manager\n */\nexport class CircuitBreakerManager {\n  private circuitBreakers = new Map<string, CircuitBreaker>();\n  private globalCircuitBreaker: CircuitBreaker;\n  private featureConfigs = new Map<string, FeatureConfig>();\n  private degradedFeatures = new Set<string>();\n  private listeners: Array<(event: string, data: any) => void> = [];\n\n  constructor() {\n    // Global circuit breaker with more lenient settings\n    this.globalCircuitBreaker = new CircuitBreaker('global', {\n      failureThreshold: 20,\n      maxFailureRate: 0.8,\n      recoveryTime: 30000, // 30 seconds\n      minRequests: 10\n    });\n\n    this.globalCircuitBreaker.onStateChange((state, metrics) => {\n      this.notifyListeners('global-state-change', { state, metrics });\n      \n      if (state === 'open') {\n        this.enableEmergencyMode();\n      } else if (state === 'closed') {\n        this.disableEmergencyMode();\n      }\n    });\n  }\n\n  /**\n   * Register a feature with circuit breaker protection\n   */\n  registerFeature(\n    name: string,\n    feature: FeatureConfig,\n    config?: Partial<CircuitBreakerConfig>\n  ): CircuitBreaker {\n    this.featureConfigs.set(name, feature);\n    \n    const circuitBreaker = new CircuitBreaker(name, {\n      // Priority-based configuration\n      failureThreshold: feature.priority === 'critical' ? 10 : feature.priority === 'high' ? 5 : 3,\n      maxFailureRate: feature.priority === 'critical' ? 0.8 : 0.5,\n      recoveryTime: feature.priority === 'critical' ? 30000 : 60000,\n      ...config\n    });\n\n    circuitBreaker.onStateChange((state, metrics) => {\n      this.handleFeatureStateChange(name, feature, state, metrics);\n    });\n\n    this.circuitBreakers.set(name, circuitBreaker);\n    return circuitBreaker;\n  }\n\n  /**\n   * Execute operation with multi-level protection\n   */\n  async executeProtected<T>(\n    featureName: string,\n    operation: () => Promise<T>,\n    fallback?: () => Promise<T>\n  ): Promise<T> {\n    // Check if feature exists\n    if (!this.circuitBreakers.has(featureName)) {\n      throw new Error(`Feature ${featureName} not registered with circuit breaker`);\n    }\n\n    const featureBreaker = this.circuitBreakers.get(featureName)!;\n    const featureConfig = this.featureConfigs.get(featureName)!;\n\n    // Check global circuit breaker first\n    if (this.globalCircuitBreaker.getState() === 'open') {\n      if (featureConfig.priority !== 'critical') {\n        if (fallback) {\n          return await fallback();\n        }\n        throw new Error('Global circuit breaker is OPEN. Only critical features allowed.');\n      }\n    }\n\n    // Check if feature is degraded\n    if (this.degradedFeatures.has(featureName)) {\n      if (featureConfig.gracefulDegradation && fallback) {\n        return await fallback();\n      }\n    }\n\n    // Execute through both global and feature-specific circuit breakers\n    return await this.globalCircuitBreaker.execute(\n      () => featureBreaker.execute(operation, fallback),\n      fallback\n    );\n  }\n\n  private handleFeatureStateChange(\n    featureName: string,\n    feature: FeatureConfig,\n    state: CircuitState,\n    metrics: CircuitMetrics\n  ): void {\n    this.notifyListeners('feature-state-change', { featureName, feature, state, metrics });\n\n    if (state === 'open') {\n      // Feature circuit opened\n      if (feature.gracefulDegradation) {\n        this.degradedFeatures.add(featureName);\n        this.notifyListeners('feature-degraded', { featureName, feature });\n      }\n\n      // Disable non-critical features if too many are failing\n      if (feature.priority !== 'critical') {\n        this.evaluateSystemHealth();\n      }\n\n    } else if (state === 'closed') {\n      // Feature circuit closed\n      if (this.degradedFeatures.has(featureName)) {\n        this.degradedFeatures.delete(featureName);\n        this.notifyListeners('feature-recovered', { featureName, feature });\n      }\n    }\n  }\n\n  private evaluateSystemHealth(): void {\n    const totalFeatures = this.circuitBreakers.size;\n    const failedFeatures = Array.from(this.circuitBreakers.values())\n      .filter(cb => cb.getState() === 'open').length;\n    \n    const failureRate = failedFeatures / totalFeatures;\n\n    // If too many features are failing, enable progressive degradation\n    if (failureRate > 0.3) { // 30% of features failing\n      this.enableProgressiveDegradation();\n    } else if (failureRate < 0.1) { // Less than 10% failing\n      this.disableProgressiveDegradation();\n    }\n  }\n\n  private enableEmergencyMode(): void {\n    this.notifyListeners('emergency-mode-enabled', { timestamp: Date.now() });\n    \n    // Degrade all non-critical features\n    this.featureConfigs.forEach((config, name) => {\n      if (config.priority !== 'critical') {\n        this.degradedFeatures.add(name);\n      }\n    });\n  }\n\n  private disableEmergencyMode(): void {\n    this.notifyListeners('emergency-mode-disabled', { timestamp: Date.now() });\n    \n    // Re-enable features based on their individual circuit breaker states\n    this.degradedFeatures.forEach(featureName => {\n      const breaker = this.circuitBreakers.get(featureName);\n      if (breaker && breaker.getState() !== 'open') {\n        this.degradedFeatures.delete(featureName);\n      }\n    });\n  }\n\n  private enableProgressiveDegradation(): void {\n    this.notifyListeners('progressive-degradation-enabled', { timestamp: Date.now() });\n    \n    // Degrade low priority features first\n    this.featureConfigs.forEach((config, name) => {\n      if (config.priority === 'low' && config.gracefulDegradation) {\n        this.degradedFeatures.add(name);\n      }\n    });\n  }\n\n  private disableProgressiveDegradation(): void {\n    this.notifyListeners('progressive-degradation-disabled', { timestamp: Date.now() });\n    \n    // Re-enable low priority features\n    this.featureConfigs.forEach((config, name) => {\n      if (config.priority === 'low') {\n        const breaker = this.circuitBreakers.get(name);\n        if (breaker && breaker.getState() !== 'open') {\n          this.degradedFeatures.delete(name);\n        }\n      }\n    });\n  }\n\n  /**\n   * Get system health overview\n   */\n  getSystemHealth(): {\n    globalState: CircuitState;\n    featuresTotal: number;\n    featuresHealthy: number;\n    featuresFailed: number;\n    featuresDegraded: number;\n    emergencyMode: boolean;\n    progressiveDegradation: boolean;\n  } {\n    const featuresTotal = this.circuitBreakers.size;\n    const featuresFailed = Array.from(this.circuitBreakers.values())\n      .filter(cb => cb.getState() === 'open').length;\n    const featuresHealthy = featuresTotal - featuresFailed;\n    const featuresDegraded = this.degradedFeatures.size;\n\n    return {\n      globalState: this.globalCircuitBreaker.getState(),\n      featuresTotal,\n      featuresHealthy,\n      featuresFailed,\n      featuresDegraded,\n      emergencyMode: this.globalCircuitBreaker.getState() === 'open',\n      progressiveDegradation: featuresDegraded > 0\n    };\n  }\n\n  /**\n   * Get metrics for all circuit breakers\n   */\n  getAllMetrics(): Map<string, CircuitMetrics> {\n    const metrics = new Map<string, CircuitMetrics>();\n    \n    metrics.set('global', this.globalCircuitBreaker.getMetrics());\n    \n    this.circuitBreakers.forEach((breaker, name) => {\n      metrics.set(name, breaker.getMetrics());\n    });\n\n    return metrics;\n  }\n\n  /**\n   * Get specific circuit breaker\n   */\n  getCircuitBreaker(featureName: string): CircuitBreaker | undefined {\n    return this.circuitBreakers.get(featureName);\n  }\n\n  /**\n   * Check if feature is degraded\n   */\n  isFeatureDegraded(featureName: string): boolean {\n    return this.degradedFeatures.has(featureName);\n  }\n\n  /**\n   * Reset all circuit breakers\n   */\n  resetAll(): void {\n    this.globalCircuitBreaker.reset();\n    this.circuitBreakers.forEach(breaker => breaker.reset());\n    this.degradedFeatures.clear();\n  }\n\n  /**\n   * Listen for circuit breaker events\n   */\n  onEvent(callback: (event: string, data: any) => void): () => void {\n    this.listeners.push(callback);\n    return () => {\n      const index = this.listeners.indexOf(callback);\n      if (index > -1) {\n        this.listeners.splice(index, 1);\n      }\n    };\n  }\n\n  private notifyListeners(event: string, data: any): void {\n    this.listeners.forEach(callback => {\n      try {\n        callback(event, data);\n      } catch (error) {\n        console.error(`Circuit breaker manager listener error:`, error);\n      }\n    });\n  }\n\n  /**\n   * Execute operation with circuit breaker protection\n   */\n  executeWithBreaker<T>(\n    featureName: string,\n    operation: () => Promise<T>,\n    options: {\n      priority?: 'critical' | 'high' | 'medium' | 'low';\n      region?: string;\n      degradeGracefully?: boolean;\n      degradedResponse?: any;\n    } = {}\n  ): Promise<T> {\n    const { priority = 'medium', degradeGracefully = false, degradedResponse } = options;\n    \n    const featureConfig: FeatureConfig = {\n      name: featureName,\n      priority,\n      fallbackEnabled: degradeGracefully,\n      gracefulDegradation: degradeGracefully\n    };\n\n    const fallback = degradeGracefully ? () => Promise.resolve(degradedResponse) : undefined;\n    \n    return this.registerFeature(featureName, operation, featureConfig, fallback);\n  }\n\n  /**\n   * Update global configuration\n   */\n  updateGlobalConfig(config: Partial<CircuitBreakerConfig>): void {\n    this.globalCircuitBreaker.updateConfig(config);\n  }\n\n  /**\n   * Get global statistics\n   */\n  getGlobalStats(): any {\n    return {\n      global: this.globalCircuitBreaker.getMetrics(),\n      features: Object.fromEntries(this.getAllMetrics()),\n      systemHealth: this.getSystemHealth(),\n      degradedFeatures: Array.from(this.degradedFeatures)\n    };\n  }\n\n  /**\n   * Reset all statistics\n   */\n  resetStats(): void {\n    this.resetAll();\n  }\n}","/**\n * Resilient Storage System with Prioritization and Quota Management\n * Multi-tier storage with intelligent data management\n */\n\nimport { ErrorEvent, SessionEvent, NetworkEvent } from './types';\nimport { compressData, deduplicateEvents } from './compression-utils';\n\nexport interface StorageQuota {\n  total: number;\n  used: number;\n  available: number;\n  percentage: number;\n}\n\nexport interface StorageTier {\n  name: 'hot' | 'warm' | 'cold';\n  maxSize: number;\n  compressionEnabled: boolean;\n  encryptionEnabled: boolean;\n  retentionTime: number; // milliseconds\n  priority: number; // 1 = highest\n}\n\nexport interface StoredItem<T = any> {\n  id: string;\n  data: T;\n  priority: 'critical' | 'high' | 'medium' | 'low';\n  timestamp: number;\n  size: number;\n  compressed: boolean;\n  encrypted: boolean;\n  retryCount: number;\n  tier: StorageTier['name'];\n  expiresAt?: number;\n  checksum?: string;\n}\n\nexport interface StorageStats {\n  totalItems: number;\n  totalSize: number;\n  itemsByPriority: Record<string, number>;\n  itemsByTier: Record<string, number>;\n  compressionRatio: number;\n  oldestItem?: number;\n  newestItem?: number;\n  quotaUsage: StorageQuota;\n}\n\n/**\n * Multi-tier storage with intelligent data management\n */\nexport class ResilientStorage {\n  private tiers: Map<StorageTier['name'], StorageTier> = new Map();\n  private indexedDB: IDBDatabase | null = null;\n  private localStorage: Storage | null = null;\n  private memoryStore: Map<string, StoredItem> = new Map();\n  private quotaManager: StorageQuotaManager;\n  private initialized = false;\n  private compressionWorker: Worker | null = null;\n\n  constructor() {\n    this.initializeTiers();\n    this.quotaManager = new StorageQuotaManager();\n    this.initializeCompressionWorker();\n  }\n\n  private initializeTiers(): void {\n    // Hot tier: In-memory, immediate access, critical data\n    this.tiers.set('hot', {\n      name: 'hot',\n      maxSize: 5 * 1024 * 1024, // 5MB\n      compressionEnabled: false,\n      encryptionEnabled: false,\n      retentionTime: 5 * 60 * 1000, // 5 minutes\n      priority: 1\n    });\n\n    // Warm tier: IndexedDB, fast access, important data\n    this.tiers.set('warm', {\n      name: 'warm',\n      maxSize: 50 * 1024 * 1024, // 50MB\n      compressionEnabled: true,\n      encryptionEnabled: false,\n      retentionTime: 24 * 60 * 60 * 1000, // 24 hours\n      priority: 2\n    });\n\n    // Cold tier: LocalStorage, slower access, archived data\n    this.tiers.set('cold', {\n      name: 'cold',\n      maxSize: 10 * 1024 * 1024, // 10MB (localStorage limit)\n      compressionEnabled: true,\n      encryptionEnabled: true,\n      retentionTime: 7 * 24 * 60 * 60 * 1000, // 7 days\n      priority: 3\n    });\n  }\n\n  private async initializeCompressionWorker(): Promise<void> {\n    if (typeof Worker !== 'undefined') {\n      try {\n        // Create compression worker for background processing\n        const workerCode = `\n          self.onmessage = function(e) {\n            const { action, data, id } = e.data;\n            \n            if (action === 'compress') {\n              // Simple compression simulation\n              const compressed = JSON.stringify(data);\n              self.postMessage({ id, result: compressed, compressed: true });\n            } else if (action === 'decompress') {\n              try {\n                const decompressed = JSON.parse(data);\n                self.postMessage({ id, result: decompressed, compressed: false });\n              } catch (error) {\n                self.postMessage({ id, error: error.message });\n              }\n            }\n          };\n        `;\n        \n        const blob = new Blob([workerCode], { type: 'application/javascript' });\n        this.compressionWorker = new Worker(URL.createObjectURL(blob));\n      } catch (error) {\n        console.warn('[ResilientStorage] Compression worker not available:', error);\n      }\n    }\n  }\n\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n\n    await Promise.all([\n      this.initializeIndexedDB(),\n      this.initializeLocalStorage(),\n      this.quotaManager.initialize()\n    ]);\n\n    // Start background cleanup\n    this.startBackgroundCleanup();\n    \n    this.initialized = true;\n  }\n\n  private async initializeIndexedDB(): Promise<void> {\n    if (typeof window === 'undefined' || !window.indexedDB) return;\n\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open('ReviResilientStorage', 1);\n      \n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => {\n        this.indexedDB = request.result;\n        resolve();\n      };\n      \n      request.onupgradeneeded = () => {\n        const db = request.result;\n        \n        // Create stores for each data type\n        if (!db.objectStoreNames.contains('errors')) {\n          db.createObjectStore('errors', { keyPath: 'id' });\n        }\n        if (!db.objectStoreNames.contains('sessions')) {\n          db.createObjectStore('sessions', { keyPath: 'id' });\n        }\n        if (!db.objectStoreNames.contains('network')) {\n          db.createObjectStore('network', { keyPath: 'id' });\n        }\n        if (!db.objectStoreNames.contains('metadata')) {\n          db.createObjectStore('metadata', { keyPath: 'key' });\n        }\n      };\n    });\n  }\n\n  private initializeLocalStorage(): void {\n    if (typeof window !== 'undefined' && window.localStorage) {\n      this.localStorage = window.localStorage;\n    }\n  }\n\n  /**\n   * Store data with intelligent tier selection\n   */\n  async store<T>(\n    type: 'error' | 'session' | 'network',\n    data: T,\n    options: {\n      priority?: 'critical' | 'high' | 'medium' | 'low';\n      ttl?: number;\n      forceSync?: boolean;\n    } = {}\n  ): Promise<string> {\n    if (!this.initialized) {\n      await this.initialize();\n    }\n\n    const { priority = 'medium', ttl, forceSync = false } = options;\n    \n    // Generate unique ID\n    const id = this.generateId(type);\n    \n    // Calculate data size\n    const dataSize = this.calculateSize(data);\n    \n    // Determine optimal tier\n    const tier = this.selectOptimalTier(priority, dataSize, forceSync);\n    \n    // Create storage item\n    const item: StoredItem<T> = {\n      id,\n      data,\n      priority,\n      timestamp: Date.now(),\n      size: dataSize,\n      compressed: false,\n      encrypted: false,\n      retryCount: 0,\n      tier: tier.name,\n      expiresAt: ttl ? Date.now() + ttl : undefined,\n      checksum: this.calculateChecksum(data)\n    };\n\n    // Store in selected tier\n    await this.storeInTier(item, tier);\n    \n    return id;\n  }\n\n  private selectOptimalTier(\n    priority: 'critical' | 'high' | 'medium' | 'low',\n    dataSize: number,\n    forceSync: boolean\n  ): StorageTier {\n    // Critical data or force sync -> hot tier\n    if (priority === 'critical' || forceSync) {\n      return this.tiers.get('hot')!;\n    }\n\n    // High priority or small data -> warm tier\n    if (priority === 'high' || dataSize < 10240) { // < 10KB\n      return this.tiers.get('warm')!;\n    }\n\n    // Everything else -> cold tier\n    return this.tiers.get('cold')!;\n  }\n\n  private async storeInTier<T>(item: StoredItem<T>, tier: StorageTier): Promise<void> {\n    // Check quota before storing\n    if (!await this.checkQuotaAvailable(tier, item.size)) {\n      await this.makeSpace(tier, item.size);\n    }\n\n    switch (tier.name) {\n      case 'hot':\n        await this.storeInMemory(item);\n        break;\n      case 'warm':\n        await this.storeInIndexedDB(item, tier);\n        break;\n      case 'cold':\n        await this.storeInLocalStorage(item, tier);\n        break;\n    }\n  }\n\n  private async storeInMemory<T>(item: StoredItem<T>): Promise<void> {\n    this.memoryStore.set(item.id, item);\n  }\n\n  private async storeInIndexedDB<T>(item: StoredItem<T>, tier: StorageTier): Promise<void> {\n    if (!this.indexedDB) throw new Error('IndexedDB not available');\n\n    // Compress data if enabled\n    if (tier.compressionEnabled) {\n      const compressed = await this.compressData(item.data);\n      if (compressed.compressed) {\n        item.data = compressed.data as T;\n        item.compressed = true;\n        item.size = this.calculateSize(item.data);\n      }\n    }\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.indexedDB!.transaction(['errors', 'sessions', 'network'], 'readwrite');\n      const store = transaction.objectStore(this.getStoreNameFromId(item.id));\n      \n      const request = store.put(item);\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  private async storeInLocalStorage<T>(item: StoredItem<T>, tier: StorageTier): Promise<void> {\n    if (!this.localStorage) throw new Error('LocalStorage not available');\n\n    // Compress and encrypt data if enabled\n    let processedData = item.data;\n    \n    if (tier.compressionEnabled) {\n      const compressed = await this.compressData(processedData);\n      if (compressed.compressed) {\n        processedData = compressed.data;\n        item.compressed = true;\n      }\n    }\n\n    if (tier.encryptionEnabled) {\n      processedData = await this.encryptData(processedData);\n      item.encrypted = true;\n    }\n\n    item.data = processedData as T;\n    item.size = this.calculateSize(item.data);\n\n    try {\n      this.localStorage.setItem(`revi_${item.id}`, JSON.stringify(item));\n    } catch (error) {\n      if (error instanceof Error && error.name === 'QuotaExceededError') {\n        await this.makeSpace(tier, item.size);\n        this.localStorage.setItem(`revi_${item.id}`, JSON.stringify(item));\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  /**\n   * Retrieve data with automatic tier searching\n   */\n  async retrieve<T>(id: string): Promise<StoredItem<T> | null> {\n    if (!this.initialized) {\n      await this.initialize();\n    }\n\n    // Search in priority order: hot -> warm -> cold\n    const tiers: StorageTier['name'][] = ['hot', 'warm', 'cold'];\n    \n    for (const tierName of tiers) {\n      const item = await this.retrieveFromTier<T>(id, tierName);\n      if (item) {\n        // Validate item integrity\n        if (!this.validateItemIntegrity(item)) {\n          console.warn(`[ResilientStorage] Data integrity check failed for ${id}`);\n          continue;\n        }\n        \n        // Promote frequently accessed data to higher tier\n        if (tierName !== 'hot' && this.shouldPromote(item)) {\n          await this.promoteItem(item);\n        }\n        \n        return item;\n      }\n    }\n    \n    return null;\n  }\n\n  private async retrieveFromTier<T>(id: string, tierName: StorageTier['name']): Promise<StoredItem<T> | null> {\n    switch (tierName) {\n      case 'hot':\n        return this.memoryStore.get(id) as StoredItem<T> || null;\n      case 'warm':\n        return this.retrieveFromIndexedDB<T>(id);\n      case 'cold':\n        return this.retrieveFromLocalStorage<T>(id);\n    }\n  }\n\n  private async retrieveFromIndexedDB<T>(id: string): Promise<StoredItem<T> | null> {\n    if (!this.indexedDB) return null;\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.indexedDB!.transaction(['errors', 'sessions', 'network'], 'readonly');\n      const store = transaction.objectStore(this.getStoreNameFromId(id));\n      \n      const request = store.get(id);\n      request.onsuccess = async () => {\n        const item = request.result as StoredItem<T>;\n        if (item && item.compressed) {\n          const decompressed = await this.decompressData(item.data);\n          item.data = decompressed as T;\n          item.compressed = false;\n        }\n        resolve(item || null);\n      };\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  private async retrieveFromLocalStorage<T>(id: string): Promise<StoredItem<T> | null> {\n    if (!this.localStorage) return null;\n\n    try {\n      const itemJson = this.localStorage.getItem(`revi_${id}`);\n      if (!itemJson) return null;\n\n      const item = JSON.parse(itemJson) as StoredItem<T>;\n      \n      // Decrypt if encrypted\n      if (item.encrypted) {\n        item.data = await this.decryptData(item.data);\n        item.encrypted = false;\n      }\n      \n      // Decompress if compressed\n      if (item.compressed) {\n        const decompressed = await this.decompressData(item.data);\n        item.data = decompressed as T;\n        item.compressed = false;\n      }\n      \n      return item;\n    } catch (error) {\n      console.error(`[ResilientStorage] Failed to retrieve ${id}:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Get all items by type with priority ordering\n   */\n  async getAllByType<T>(type: 'error' | 'session' | 'network'): Promise<StoredItem<T>[]> {\n    if (!this.initialized) {\n      await this.initialize();\n    }\n\n    const items: StoredItem<T>[] = [];\n    \n    // Collect from all tiers\n    for (const tierName of ['hot', 'warm', 'cold'] as const) {\n      const tierItems = await this.getAllFromTier<T>(type, tierName);\n      items.push(...tierItems);\n    }\n\n    // Sort by priority and timestamp\n    return items.sort((a, b) => {\n      const priorityOrder = { critical: 0, high: 1, medium: 2, low: 3 };\n      const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority];\n      \n      if (priorityDiff !== 0) return priorityDiff;\n      return a.timestamp - b.timestamp; // Older first\n    });\n  }\n\n  private async getAllFromTier<T>(type: string, tierName: StorageTier['name']): Promise<StoredItem<T>[]> {\n    switch (tierName) {\n      case 'hot':\n        return Array.from(this.memoryStore.values())\n          .filter(item => item.id.startsWith(type)) as StoredItem<T>[];\n      case 'warm':\n        return this.getAllFromIndexedDB<T>(type);\n      case 'cold':\n        return this.getAllFromLocalStorage<T>(type);\n    }\n  }\n\n  private async getAllFromIndexedDB<T>(type: string): Promise<StoredItem<T>[]> {\n    if (!this.indexedDB) return [];\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.indexedDB!.transaction([this.getStoreName(type)], 'readonly');\n      const store = transaction.objectStore(this.getStoreName(type));\n      \n      const request = store.getAll();\n      request.onsuccess = async () => {\n        const items = request.result as StoredItem<T>[];\n        \n        // Decompress items if needed\n        for (const item of items) {\n          if (item.compressed) {\n            const decompressed = await this.decompressData(item.data);\n            item.data = decompressed as T;\n            item.compressed = false;\n          }\n        }\n        \n        resolve(items);\n      };\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  private async getAllFromLocalStorage<T>(type: string): Promise<StoredItem<T>[]> {\n    if (!this.localStorage) return [];\n\n    const items: StoredItem<T>[] = [];\n    \n    for (let i = 0; i < this.localStorage.length; i++) {\n      const key = this.localStorage.key(i);\n      if (key && key.startsWith(`revi_${type}`)) {\n        try {\n          const itemJson = this.localStorage.getItem(key);\n          if (itemJson) {\n            const item = JSON.parse(itemJson) as StoredItem<T>;\n            \n            // Decrypt and decompress if needed\n            if (item.encrypted) {\n              item.data = await this.decryptData(item.data);\n              item.encrypted = false;\n            }\n            if (item.compressed) {\n              const decompressed = await this.decompressData(item.data);\n              item.data = decompressed as T;\n              item.compressed = false;\n            }\n            \n            items.push(item);\n          }\n        } catch (error) {\n          console.error(`[ResilientStorage] Failed to parse item ${key}:`, error);\n        }\n      }\n    }\n    \n    return items;\n  }\n\n  /**\n   * Remove item from all tiers\n   */\n  async remove(id: string): Promise<void> {\n    // Remove from all tiers\n    this.memoryStore.delete(id);\n    \n    if (this.indexedDB) {\n      const transaction = this.indexedDB.transaction(['errors', 'sessions', 'network'], 'readwrite');\n      const store = transaction.objectStore(this.getStoreNameFromId(id));\n      store.delete(id);\n    }\n    \n    if (this.localStorage) {\n      this.localStorage.removeItem(`revi_${id}`);\n    }\n  }\n\n  /**\n   * Clear all data\n   */\n  async clear(): Promise<void> {\n    this.memoryStore.clear();\n    \n    if (this.indexedDB) {\n      const transaction = this.indexedDB.transaction(['errors', 'sessions', 'network'], 'readwrite');\n      transaction.objectStore('errors').clear();\n      transaction.objectStore('sessions').clear();\n      transaction.objectStore('network').clear();\n    }\n    \n    if (this.localStorage) {\n      const keysToRemove: string[] = [];\n      for (let i = 0; i < this.localStorage.length; i++) {\n        const key = this.localStorage.key(i);\n        if (key && key.startsWith('revi_')) {\n          keysToRemove.push(key);\n        }\n      }\n      keysToRemove.forEach(key => this.localStorage!.removeItem(key));\n    }\n  }\n\n  private async checkQuotaAvailable(tier: StorageTier, requiredSize: number): Promise<boolean> {\n    const usage = await this.quotaManager.getUsage(tier.name);\n    return (usage.available >= requiredSize);\n  }\n\n  private async makeSpace(tier: StorageTier, requiredSize: number): Promise<void> {\n    // Remove expired items first\n    await this.cleanupExpiredItems(tier);\n    \n    // Check if we have enough space now\n    if (await this.checkQuotaAvailable(tier, requiredSize)) {\n      return;\n    }\n    \n    // Remove old, low-priority items\n    await this.evictLowPriorityItems(tier, requiredSize);\n  }\n\n  private async cleanupExpiredItems(tier: StorageTier): Promise<void> {\n    const now = Date.now();\n    \n    switch (tier.name) {\n      case 'hot':\n        for (const [id, item] of this.memoryStore) {\n          if ((item.expiresAt && now > item.expiresAt) || \n              (now - item.timestamp > tier.retentionTime)) {\n            this.memoryStore.delete(id);\n          }\n        }\n        break;\n        \n      case 'warm':\n        if (this.indexedDB) {\n          // Implementation for IndexedDB cleanup\n          const stores = ['errors', 'sessions', 'network'];\n          for (const storeName of stores) {\n            await this.cleanupIndexedDBStore(storeName, tier.retentionTime);\n          }\n        }\n        break;\n        \n      case 'cold':\n        if (this.localStorage) {\n          await this.cleanupLocalStorage(tier.retentionTime);\n        }\n        break;\n    }\n  }\n\n  private async evictLowPriorityItems(tier: StorageTier, requiredSize: number): Promise<void> {\n    // Get items sorted by priority (low priority first) and age (old first)\n    const priorityOrder = { low: 0, medium: 1, high: 2, critical: 3 };\n    let evictedSize = 0;\n    \n    // This is a simplified implementation - in practice, you'd implement\n    // more sophisticated eviction policies per tier\n    if (tier.name === 'hot') {\n      const sortedItems = Array.from(this.memoryStore.values()).sort((a, b) => {\n        const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority];\n        if (priorityDiff !== 0) return priorityDiff;\n        return a.timestamp - b.timestamp;\n      });\n      \n      for (const item of sortedItems) {\n        if (evictedSize >= requiredSize) break;\n        this.memoryStore.delete(item.id);\n        evictedSize += item.size;\n      }\n    }\n  }\n\n  // Helper methods\n  private generateId(type: string): string {\n    return `${type}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private calculateSize(data: any): number {\n    return JSON.stringify(data).length * 2; // Rough estimation (UTF-16)\n  }\n\n  private calculateChecksum(data: any): string {\n    // Simple checksum using JSON string hash\n    const str = JSON.stringify(data);\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    return hash.toString();\n  }\n\n  private validateItemIntegrity(item: StoredItem): boolean {\n    if (!item.checksum) return true; // No checksum to validate\n    \n    const currentChecksum = this.calculateChecksum(item.data);\n    return currentChecksum === item.checksum;\n  }\n\n  private shouldPromote(item: StoredItem): boolean {\n    // Promote critical items or frequently accessed items\n    return item.priority === 'critical' || \n           (item.priority === 'high' && Date.now() - item.timestamp < 300000); // 5 minutes\n  }\n\n  private async promoteItem<T>(item: StoredItem<T>): Promise<void> {\n    // Move item to hot tier\n    const hotTier = this.tiers.get('hot')!;\n    await this.storeInTier(item, hotTier);\n    \n    // Remove from current tier (this is simplified)\n    await this.remove(item.id);\n  }\n\n  private async compressData(data: any): Promise<{ data: any; compressed: boolean }> {\n    if (this.compressionWorker) {\n      // Use web worker for compression\n      return new Promise((resolve) => {\n        const id = Math.random().toString();\n        \n        const handleMessage = (e: MessageEvent) => {\n          if (e.data.id === id) {\n            this.compressionWorker!.removeEventListener('message', handleMessage);\n            resolve({ data: e.data.result, compressed: e.data.compressed });\n          }\n        };\n        \n        this.compressionWorker.addEventListener('message', handleMessage);\n        this.compressionWorker.postMessage({ action: 'compress', data, id });\n      });\n    }\n    \n    // Fallback to synchronous compression\n    try {\n      const result = await compressData(data);\n      return { data: result.data, compressed: result.compressed };\n    } catch (error) {\n      return { data, compressed: false };\n    }\n  }\n\n  private async decompressData(data: any): Promise<any> {\n    if (this.compressionWorker) {\n      return new Promise((resolve, reject) => {\n        const id = Math.random().toString();\n        \n        const handleMessage = (e: MessageEvent) => {\n          if (e.data.id === id) {\n            this.compressionWorker!.removeEventListener('message', handleMessage);\n            if (e.data.error) {\n              reject(new Error(e.data.error));\n            } else {\n              resolve(e.data.result);\n            }\n          }\n        };\n        \n        this.compressionWorker.addEventListener('message', handleMessage);\n        this.compressionWorker.postMessage({ action: 'decompress', data, id });\n      });\n    }\n    \n    // Fallback\n    return typeof data === 'string' ? JSON.parse(data) : data;\n  }\n\n  private async encryptData(data: any): Promise<any> {\n    // Simple encryption simulation - in production, use proper encryption\n    const str = JSON.stringify(data);\n    return btoa(str); // Base64 encoding as simulation\n  }\n\n  private async decryptData(encryptedData: any): Promise<any> {\n    // Simple decryption simulation\n    try {\n      const str = atob(encryptedData);\n      return JSON.parse(str);\n    } catch (error) {\n      throw new Error('Failed to decrypt data');\n    }\n  }\n\n  private getStoreName(type: string): string {\n    switch (type) {\n      case 'error': return 'errors';\n      case 'session': return 'sessions';\n      case 'network': return 'network';\n      default: return 'errors';\n    }\n  }\n\n  private getStoreNameFromId(id: string): string {\n    if (id.startsWith('error_')) return 'errors';\n    if (id.startsWith('session_')) return 'sessions';\n    if (id.startsWith('network_')) return 'network';\n    return 'errors';\n  }\n\n  private async cleanupIndexedDBStore(storeName: string, retentionTime: number): Promise<void> {\n    // Implementation for cleaning up expired items from IndexedDB\n    // This is a placeholder - implement based on your needs\n  }\n\n  private async cleanupLocalStorage(retentionTime: number): Promise<void> {\n    if (!this.localStorage) return;\n    \n    const now = Date.now();\n    const keysToRemove: string[] = [];\n    \n    for (let i = 0; i < this.localStorage.length; i++) {\n      const key = this.localStorage.key(i);\n      if (key && key.startsWith('revi_')) {\n        try {\n          const itemJson = this.localStorage.getItem(key);\n          if (itemJson) {\n            const item = JSON.parse(itemJson);\n            if (now - item.timestamp > retentionTime) {\n              keysToRemove.push(key);\n            }\n          }\n        } catch (error) {\n          // Invalid item, remove it\n          keysToRemove.push(key);\n        }\n      }\n    }\n    \n    keysToRemove.forEach(key => this.localStorage!.removeItem(key));\n  }\n\n  private startBackgroundCleanup(): void {\n    // Run cleanup every 5 minutes\n    setInterval(() => {\n      this.tiers.forEach(async (tier) => {\n        await this.cleanupExpiredItems(tier);\n      });\n    }, 5 * 60 * 1000);\n  }\n\n  /**\n   * Store data with resilience features\n   */\n  async storeData(key: string, data: any, options: {\n    priority: 'critical' | 'high' | 'medium' | 'low';\n    tier?: 'hot' | 'warm' | 'cold';\n    compress?: boolean;\n    encrypt?: boolean;\n  }): Promise<void> {\n    const tier = this.selectOptimalTier(options.priority, JSON.stringify(data).length);\n    const storage = this.storageProviders.get(tier);\n    if (!storage) {\n      throw new Error(`Storage tier ${tier} not available`);\n    }\n\n    let processedData = data;\n    if (options.compress) {\n      processedData = this.compressData(data);\n    }\n\n    await storage.setItem(key, JSON.stringify({\n      data: processedData,\n      metadata: {\n        priority: options.priority,\n        tier,\n        compressed: options.compress || false,\n        timestamp: Date.now()\n      }\n    }));\n  }\n\n  /**\n   * Get stored data\n   */\n  async getData(key: string): Promise<any> {\n    for (const [tierName, storage] of this.storageProviders) {\n      try {\n        const item = await storage.getItem(key);\n        if (item) {\n          const parsed = JSON.parse(item);\n          return parsed.metadata?.compressed ? this.decompressData(parsed.data) : parsed.data;\n        }\n      } catch (error) {\n        console.warn(`Failed to read from ${tierName}:`, error);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Delete stored data\n   */\n  async deleteData(key: string): Promise<void> {\n    await Promise.all(\n      Array.from(this.storageProviders.values()).map(storage =>\n        storage.removeItem(key).catch(() => {}) // Ignore errors\n      )\n    );\n  }\n\n  /**\n   * Get all data matching pattern\n   */\n  async getAllDataByPattern(pattern: string): Promise<Array<{key: string, data: any, metadata?: any}>> {\n    const results: Array<{key: string, data: any, metadata?: any}> = [];\n    const regex = new RegExp(pattern.replace('*', '.*'));\n\n    for (const [tierName, storage] of this.storageProviders) {\n      try {\n        for (let i = 0; i < storage.length; i++) {\n          const key = storage.key(i);\n          if (key && regex.test(key)) {\n            const item = await storage.getItem(key);\n            if (item) {\n              const parsed = JSON.parse(item);\n              results.push({\n                key,\n                data: parsed.metadata?.compressed ? this.decompressData(parsed.data) : parsed.data,\n                metadata: parsed.metadata\n              });\n            }\n          }\n        }\n      } catch (error) {\n        console.warn(`Failed to scan ${tierName}:`, error);\n      }\n    }\n\n    return results;\n  }\n\n  private selectOptimalTier(priority: string, dataSize: number): 'hot' | 'warm' | 'cold' {\n    if (priority === 'critical') return 'hot';\n    if (priority === 'high' && dataSize < 10000) return 'hot';\n    if (priority === 'low' || dataSize > 100000) return 'cold';\n    return 'warm';\n  }\n\n  private compressData(data: any): any {\n    // Simple compression simulation\n    return data;\n  }\n\n  private decompressData(data: any): any {\n    // Simple decompression simulation\n    return data;\n  }\n\n  /**\n   * Get storage statistics\n   */\n  async getStats(): Promise<StorageStats> {\n    // Implementation placeholder\n    const stats: StorageStats = {\n      totalItems: 0,\n      totalSize: 0,\n      itemsByPriority: { critical: 0, high: 0, medium: 0, low: 0 },\n      itemsByTier: { hot: 0, warm: 0, cold: 0 },\n      compressionRatio: 0.7,\n      quotaUsage: await this.quotaManager.getTotalUsage(),\n      tierUsage: {\n        hot: { itemCount: 0, sizeBytes: 0, quotaUsed: 0 },\n        warm: { itemCount: 0, sizeBytes: 0, quotaUsed: 0 },\n        cold: { itemCount: 0, sizeBytes: 0, quotaUsed: 0 }\n      }\n    };\n    \n    return stats;\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(config: Partial<ResilientStorageConfig>): void {\n    this.config = { ...this.config, ...config };\n  }\n\n  /**\n   * Reset statistics\n   */\n  resetStats(): void {\n    // Reset internal counters if any\n  }\n}\n\n/**\n * Storage Quota Manager\n */\nclass StorageQuotaManager {\n  private quotas: Map<string, StorageQuota> = new Map();\n\n  async initialize(): Promise<void> {\n    if ('storage' in navigator && 'estimate' in navigator.storage) {\n      const estimate = await navigator.storage.estimate();\n      const total = estimate.quota || 0;\n      const used = estimate.usage || 0;\n      \n      this.quotas.set('global', {\n        total,\n        used,\n        available: total - used,\n        percentage: total > 0 ? (used / total) * 100 : 0\n      });\n    }\n  }\n\n  async getUsage(tierName: string): Promise<StorageQuota> {\n    // Simplified implementation - in practice, calculate per-tier usage\n    return this.quotas.get('global') || {\n      total: 0,\n      used: 0,\n      available: 0,\n      percentage: 0\n    };\n  }\n\n  async getTotalUsage(): Promise<StorageQuota> {\n    return this.quotas.get('global') || {\n      total: 0,\n      used: 0,\n      available: 0,\n      percentage: 0\n    };\n  }\n}","/**\n * API Health Monitoring System\n * Continuous health assessment with adaptive behavior\n */\n\nexport interface HealthMetrics {\n  responseTime: number[];\n  successRate: number;\n  errorRate: number;\n  availability: number;\n  lastCheck: number;\n  consecutiveFailures: number;\n  consecutiveSuccesses: number;\n  averageResponseTime: number;\n  p95ResponseTime: number;\n  p99ResponseTime: number;\n  totalRequests: number;\n  totalErrors: number;\n  uptime: number;\n  downtime: number;\n}\n\nexport interface HealthCheckConfig {\n  interval: number;\n  timeout: number;\n  endpoint: string;\n  method: 'GET' | 'HEAD' | 'POST';\n  expectedStatus: number[];\n  retryCount: number;\n  failureThreshold: number;\n  recoveryThreshold: number;\n  degradationThreshold: number;\n  critical: boolean;\n}\n\nexport interface HealthStatus {\n  status: 'healthy' | 'degraded' | 'unhealthy' | 'unknown';\n  lastChecked: number;\n  responseTime?: number;\n  error?: string;\n  metrics: HealthMetrics;\n  trend: 'improving' | 'stable' | 'degrading';\n  confidence: number; // 0-1\n}\n\nexport interface RegionalHealth {\n  region: string;\n  endpoint: string;\n  status: HealthStatus;\n  priority: number;\n  lastFailover?: number;\n}\n\n/**\n * Health Monitor for individual endpoints\n */\nexport class EndpointHealthMonitor {\n  private config: HealthCheckConfig;\n  private metrics: HealthMetrics;\n  private checkInterval: NodeJS.Timeout | null = null;\n  private listeners: Array<(status: HealthStatus) => void> = [];\n  private requestHistory: Array<{ timestamp: number; success: boolean; responseTime: number }> = [];\n  private windowSize = 60000; // 1 minute window\n  private isRunning = false;\n\n  constructor(\n    private name: string,\n    config: Partial<HealthCheckConfig>\n  ) {\n    this.config = {\n      interval: 30000, // 30 seconds\n      timeout: 10000, // 10 seconds\n      endpoint: '',\n      method: 'HEAD',\n      expectedStatus: [200, 204],\n      retryCount: 3,\n      failureThreshold: 3,\n      recoveryThreshold: 3,\n      degradationThreshold: 0.1, // 10% error rate\n      critical: false,\n      ...config\n    };\n\n    this.metrics = this.initializeMetrics();\n  }\n\n  private initializeMetrics(): HealthMetrics {\n    return {\n      responseTime: [],\n      successRate: 1.0,\n      errorRate: 0.0,\n      availability: 1.0,\n      lastCheck: 0,\n      consecutiveFailures: 0,\n      consecutiveSuccesses: 0,\n      averageResponseTime: 0,\n      p95ResponseTime: 0,\n      p99ResponseTime: 0,\n      totalRequests: 0,\n      totalErrors: 0,\n      uptime: 0,\n      downtime: 0\n    };\n  }\n\n  /**\n   * Start health monitoring\n   */\n  start(): void {\n    if (this.isRunning) return;\n\n    this.isRunning = true;\n    this.scheduleCheck();\n  }\n\n  /**\n   * Stop health monitoring\n   */\n  stop(): void {\n    this.isRunning = false;\n    if (this.checkInterval) {\n      clearTimeout(this.checkInterval);\n      this.checkInterval = null;\n    }\n  }\n\n  private scheduleCheck(): void {\n    if (!this.isRunning) return;\n\n    this.checkInterval = setTimeout(async () => {\n      await this.performHealthCheck();\n      this.scheduleCheck();\n    }, this.config.interval);\n  }\n\n  private async performHealthCheck(): Promise<void> {\n    const startTime = Date.now();\n    let success = false;\n    let responseTime = 0;\n    let error: string | undefined;\n\n    try {\n      for (let attempt = 0; attempt <= this.config.retryCount; attempt++) {\n        try {\n          const checkStartTime = Date.now();\n          const response = await this.executeHealthCheck();\n          responseTime = Date.now() - checkStartTime;\n\n          if (this.config.expectedStatus.includes(response.status)) {\n            success = true;\n            break;\n          } else {\n            throw new Error(`Unexpected status code: ${response.status}`);\n          }\n        } catch (attemptError: any) {\n          if (attempt === this.config.retryCount) {\n            throw attemptError;\n          }\n          // Wait before retry with exponential backoff\n          await this.sleep(1000 * Math.pow(2, attempt));\n        }\n      }\n    } catch (checkError: any) {\n      error = checkError.message;\n      responseTime = Date.now() - startTime;\n    }\n\n    this.recordCheckResult(success, responseTime, error);\n  }\n\n  private async executeHealthCheck(): Promise<Response> {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);\n\n    try {\n      const response = await fetch(this.config.endpoint, {\n        method: this.config.method,\n        signal: controller.signal,\n        cache: 'no-cache',\n        headers: {\n          'User-Agent': 'Revi-HealthMonitor/1.0'\n        }\n      });\n\n      return response;\n    } finally {\n      clearTimeout(timeoutId);\n    }\n  }\n\n  private recordCheckResult(success: boolean, responseTime: number, error?: string): void {\n    const timestamp = Date.now();\n\n    // Add to request history\n    this.requestHistory.push({ timestamp, success, responseTime });\n    this.cleanupOldHistory();\n\n    // Update metrics\n    this.updateMetrics(success, responseTime);\n\n    // Update consecutive counters\n    if (success) {\n      this.metrics.consecutiveFailures = 0;\n      this.metrics.consecutiveSuccesses++;\n    } else {\n      this.metrics.consecutiveSuccesses = 0;\n      this.metrics.consecutiveFailures++;\n    }\n\n    this.metrics.lastCheck = timestamp;\n\n    // Notify listeners\n    const status = this.calculateHealthStatus(error);\n    this.notifyListeners(status);\n  }\n\n  private cleanupOldHistory(): void {\n    const cutoff = Date.now() - this.windowSize;\n    this.requestHistory = this.requestHistory.filter(req => req.timestamp > cutoff);\n  }\n\n  private updateMetrics(success: boolean, responseTime: number): void {\n    this.metrics.totalRequests++;\n    \n    if (!success) {\n      this.metrics.totalErrors++;\n    }\n\n    // Update response times\n    this.metrics.responseTime.push(responseTime);\n    if (this.metrics.responseTime.length > 100) {\n      this.metrics.responseTime.shift(); // Keep only last 100 measurements\n    }\n\n    // Calculate current window metrics\n    const windowRequests = this.requestHistory.length;\n    const windowSuccesses = this.requestHistory.filter(r => r.success).length;\n    const windowErrors = windowRequests - windowSuccesses;\n\n    this.metrics.successRate = windowRequests > 0 ? windowSuccesses / windowRequests : 1.0;\n    this.metrics.errorRate = windowRequests > 0 ? windowErrors / windowRequests : 0.0;\n\n    // Calculate availability (uptime vs downtime)\n    const totalTime = this.metrics.totalRequests * this.config.interval;\n    const estimatedDowntime = this.metrics.totalErrors * this.config.interval;\n    this.metrics.availability = totalTime > 0 ? 1 - (estimatedDowntime / totalTime) : 1.0;\n\n    // Calculate response time percentiles\n    if (this.metrics.responseTime.length > 0) {\n      const sorted = [...this.metrics.responseTime].sort((a, b) => a - b);\n      this.metrics.averageResponseTime = sorted.reduce((a, b) => a + b) / sorted.length;\n      this.metrics.p95ResponseTime = sorted[Math.floor(sorted.length * 0.95)];\n      this.metrics.p99ResponseTime = sorted[Math.floor(sorted.length * 0.99)];\n    }\n  }\n\n  private calculateHealthStatus(error?: string): HealthStatus {\n    let status: HealthStatus['status'] = 'unknown';\n    let trend: HealthStatus['trend'] = 'stable';\n    let confidence = 0.5;\n\n    // Determine status based on consecutive failures and error rate\n    if (this.metrics.consecutiveFailures >= this.config.failureThreshold) {\n      status = 'unhealthy';\n      confidence = Math.min(0.9, this.metrics.consecutiveFailures / (this.config.failureThreshold * 2));\n    } else if (this.metrics.errorRate > this.config.degradationThreshold) {\n      status = 'degraded';\n      confidence = Math.min(0.8, this.metrics.errorRate * 2);\n    } else if (this.metrics.consecutiveSuccesses >= this.config.recoveryThreshold) {\n      status = 'healthy';\n      confidence = Math.min(0.95, this.metrics.consecutiveSuccesses / (this.config.recoveryThreshold * 2));\n    }\n\n    // Determine trend based on recent history\n    if (this.requestHistory.length >= 10) {\n      const recentHalf = this.requestHistory.slice(-5);\n      const earlierHalf = this.requestHistory.slice(-10, -5);\n      \n      const recentSuccessRate = recentHalf.filter(r => r.success).length / recentHalf.length;\n      const earlierSuccessRate = earlierHalf.filter(r => r.success).length / earlierHalf.length;\n      \n      if (recentSuccessRate > earlierSuccessRate + 0.2) {\n        trend = 'improving';\n      } else if (recentSuccessRate < earlierSuccessRate - 0.2) {\n        trend = 'degrading';\n      }\n    }\n\n    return {\n      status,\n      lastChecked: this.metrics.lastCheck,\n      responseTime: this.metrics.averageResponseTime,\n      error,\n      metrics: { ...this.metrics },\n      trend,\n      confidence\n    };\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Get current health status\n   */\n  getHealthStatus(): HealthStatus {\n    return this.calculateHealthStatus();\n  }\n\n  /**\n   * Get current metrics\n   */\n  getMetrics(): HealthMetrics {\n    return { ...this.metrics };\n  }\n\n  /**\n   * Force a health check\n   */\n  async forceCheck(): Promise<HealthStatus> {\n    await this.performHealthCheck();\n    return this.getHealthStatus();\n  }\n\n  /**\n   * Listen for health status changes\n   */\n  onStatusChange(callback: (status: HealthStatus) => void): () => void {\n    this.listeners.push(callback);\n    return () => {\n      const index = this.listeners.indexOf(callback);\n      if (index > -1) {\n        this.listeners.splice(index, 1);\n      }\n    };\n  }\n\n  private notifyListeners(status: HealthStatus): void {\n    this.listeners.forEach(callback => {\n      try {\n        callback(status);\n      } catch (error) {\n        console.error(`Health monitor ${this.name} listener error:`, error);\n      }\n    });\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(newConfig: Partial<HealthCheckConfig>): void {\n    const oldInterval = this.config.interval;\n    this.config = { ...this.config, ...newConfig };\n    \n    // Restart if interval changed and monitor is running\n    if (this.isRunning && oldInterval !== this.config.interval) {\n      this.stop();\n      this.start();\n    }\n  }\n\n  /**\n   * Reset metrics (useful for testing)\n   */\n  reset(): void {\n    this.metrics = this.initializeMetrics();\n    this.requestHistory = [];\n  }\n}\n\n/**\n * Multi-Regional Health Monitor\n */\nexport class MultiRegionalHealthMonitor {\n  private regionalMonitors = new Map<string, EndpointHealthMonitor>();\n  private primaryRegion: string | null = null;\n  private failoverHistory: Array<{ from: string; to: string; timestamp: number; reason: string }> = [];\n  private listeners: Array<(event: string, data: any) => void> = [];\n  private adaptiveBehavior: AdaptiveBehavior;\n\n  constructor() {\n    this.adaptiveBehavior = new AdaptiveBehavior();\n  }\n\n  /**\n   * Register a regional endpoint\n   */\n  registerRegion(\n    region: string,\n    endpoint: string,\n    priority: number,\n    config?: Partial<HealthCheckConfig>\n  ): EndpointHealthMonitor {\n    const monitor = new EndpointHealthMonitor(`region-${region}`, {\n      endpoint,\n      critical: priority === 1,\n      ...config\n    });\n\n    // Set as primary if it's the highest priority\n    if (!this.primaryRegion || priority === 1) {\n      this.primaryRegion = region;\n    }\n\n    monitor.onStatusChange((status) => {\n      this.handleRegionalStatusChange(region, status);\n    });\n\n    this.regionalMonitors.set(region, monitor);\n    return monitor;\n  }\n\n  /**\n   * Start monitoring all regions\n   */\n  startAll(): void {\n    this.regionalMonitors.forEach(monitor => monitor.start());\n  }\n\n  /**\n   * Stop monitoring all regions\n   */\n  stopAll(): void {\n    this.regionalMonitors.forEach(monitor => monitor.stop());\n  }\n\n  private handleRegionalStatusChange(region: string, status: HealthStatus): void {\n    this.notifyListeners('regional-status-change', { region, status });\n\n    // Check if primary region failed and failover is needed\n    if (region === this.primaryRegion && status.status === 'unhealthy') {\n      this.performFailover(region, 'primary_unhealthy');\n    }\n\n    // Update adaptive behavior\n    this.adaptiveBehavior.recordRegionalHealth(region, status);\n  }\n\n  private performFailover(fromRegion: string, reason: string): void {\n    // Find the best available region\n    const availableRegions = Array.from(this.regionalMonitors.entries())\n      .filter(([region, monitor]) => \n        region !== fromRegion && \n        monitor.getHealthStatus().status !== 'unhealthy'\n      )\n      .sort(([, a], [, b]) => {\n        const aHealth = a.getHealthStatus();\n        const bHealth = b.getHealthStatus();\n        \n        // Prefer healthy over degraded\n        if (aHealth.status === 'healthy' && bHealth.status !== 'healthy') return -1;\n        if (bHealth.status === 'healthy' && aHealth.status !== 'healthy') return 1;\n        \n        // Prefer better response times\n        return (aHealth.responseTime || Infinity) - (bHealth.responseTime || Infinity);\n      });\n\n    if (availableRegions.length > 0) {\n      const [newPrimaryRegion] = availableRegions[0];\n      const oldPrimary = this.primaryRegion;\n      \n      this.primaryRegion = newPrimaryRegion;\n      \n      this.failoverHistory.push({\n        from: fromRegion,\n        to: newPrimaryRegion,\n        timestamp: Date.now(),\n        reason\n      });\n\n      this.notifyListeners('failover', {\n        from: fromRegion,\n        to: newPrimaryRegion,\n        reason,\n        timestamp: Date.now()\n      });\n\n      // Update adaptive behavior\n      this.adaptiveBehavior.recordFailover(fromRegion, newPrimaryRegion, reason);\n    }\n  }\n\n  /**\n   * Get current primary region\n   */\n  getPrimaryRegion(): string | null {\n    return this.primaryRegion;\n  }\n\n  /**\n   * Get health status for all regions\n   */\n  getAllRegionalHealth(): RegionalHealth[] {\n    return Array.from(this.regionalMonitors.entries()).map(([region, monitor]) => ({\n      region,\n      endpoint: monitor['config'].endpoint,\n      status: monitor.getHealthStatus(),\n      priority: region === this.primaryRegion ? 1 : 2,\n      lastFailover: this.failoverHistory\n        .filter(f => f.to === region)\n        .sort((a, b) => b.timestamp - a.timestamp)[0]?.timestamp\n    }));\n  }\n\n  /**\n   * Get failover history\n   */\n  getFailoverHistory(): typeof this.failoverHistory {\n    return [...this.failoverHistory];\n  }\n\n  /**\n   * Get adaptive behavior recommendations\n   */\n  getAdaptiveBehaviorRecommendations(): any {\n    return this.adaptiveBehavior.getRecommendations();\n  }\n\n  /**\n   * Force failover to specific region\n   */\n  forceFailover(toRegion: string, reason: string = 'manual'): void {\n    if (this.regionalMonitors.has(toRegion)) {\n      this.performFailover(this.primaryRegion || 'unknown', reason);\n    }\n  }\n\n  /**\n   * Listen for health monitor events\n   */\n  onEvent(callback: (event: string, data: any) => void): () => void {\n    this.listeners.push(callback);\n    return () => {\n      const index = this.listeners.indexOf(callback);\n      if (index > -1) {\n        this.listeners.splice(index, 1);\n      }\n    };\n  }\n\n  private notifyListeners(event: string, data: any): void {\n    this.listeners.forEach(callback => {\n      try {\n        callback(event, data);\n      } catch (error) {\n        console.error('Multi-regional health monitor listener error:', error);\n      }\n    });\n  }\n\n  /**\n   * Get global statistics\n   */\n  getGlobalStats(): any {\n    const allStats = Array.from(this.regionalMonitors.values()).map(monitor => monitor.getStats());\n    const avgLatency = allStats.reduce((sum, stats) => sum + stats.averageLatency, 0) / allStats.length;\n    const avgErrorRate = allStats.reduce((sum, stats) => sum + stats.errorRate, 0) / allStats.length;\n\n    return {\n      regions: this.config.regions.length,\n      endpoints: Object.keys(this.config.endpoints).length,\n      primaryRegion: this.primaryRegion,\n      totalChecks: allStats.reduce((sum, stats) => sum + stats.totalChecks, 0),\n      averageLatency: avgLatency || 0,\n      averageErrorRate: avgErrorRate || 0,\n      failovers: this.failoverHistory.length,\n      adaptiveBehavior: this.adaptiveBehavior.getRecommendations()\n    };\n  }\n\n  /**\n   * Reset all statistics\n   */\n  resetStats(): void {\n    this.regionalMonitors.forEach(monitor => monitor.resetStats());\n    this.failoverHistory = [];\n    this.adaptiveBehavior.reset();\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(config: Partial<HealthMonitorConfig>): void {\n    this.config = { ...this.config, ...config };\n  }\n\n  /**\n   * Destroy and cleanup\n   */\n  destroy(): void {\n    this.regionalMonitors.forEach(monitor => monitor.destroy());\n    this.regionalMonitors.clear();\n    this.listeners = [];\n  }\n}\n\n/**\n * Adaptive Behavior Engine\n */\nclass AdaptiveBehavior {\n  private regionalHealthHistory = new Map<string, HealthStatus[]>();\n  private failoverPatterns: Array<{ from: string; to: string; timestamp: number; reason: string }> = [];\n  private adaptiveSettings = {\n    uploadFrequency: 10000, // Base frequency\n    batchSize: 25, // Base batch size\n    retryAttempts: 3, // Base retry attempts\n    timeoutMultiplier: 1.0 // Base timeout multiplier\n  };\n\n  recordRegionalHealth(region: string, status: HealthStatus): void {\n    if (!this.regionalHealthHistory.has(region)) {\n      this.regionalHealthHistory.set(region, []);\n    }\n    \n    const history = this.regionalHealthHistory.get(region)!;\n    history.push(status);\n    \n    // Keep only last 100 records\n    if (history.length > 100) {\n      history.shift();\n    }\n    \n    // Update adaptive settings based on health\n    this.updateAdaptiveSettings(region, status);\n  }\n\n  recordFailover(from: string, to: string, reason: string): void {\n    this.failoverPatterns.push({ from, to, timestamp: Date.now(), reason });\n    \n    // Keep only last 50 failovers\n    if (this.failoverPatterns.length > 50) {\n      this.failoverPatterns.shift();\n    }\n  }\n\n  private updateAdaptiveSettings(region: string, status: HealthStatus): void {\n    // Adjust upload frequency based on health\n    if (status.status === 'unhealthy') {\n      this.adaptiveSettings.uploadFrequency = Math.min(this.adaptiveSettings.uploadFrequency * 2, 60000);\n    } else if (status.status === 'healthy') {\n      this.adaptiveSettings.uploadFrequency = Math.max(this.adaptiveSettings.uploadFrequency * 0.9, 5000);\n    }\n\n    // Adjust batch size based on response times\n    if (status.responseTime && status.responseTime > 5000) {\n      this.adaptiveSettings.batchSize = Math.max(this.adaptiveSettings.batchSize - 5, 5);\n    } else if (status.responseTime && status.responseTime < 1000) {\n      this.adaptiveSettings.batchSize = Math.min(this.adaptiveSettings.batchSize + 5, 100);\n    }\n\n    // Adjust retry attempts based on error rates\n    if (status.metrics.errorRate > 0.3) {\n      this.adaptiveSettings.retryAttempts = Math.min(this.adaptiveSettings.retryAttempts + 1, 10);\n    } else if (status.metrics.errorRate < 0.05) {\n      this.adaptiveSettings.retryAttempts = Math.max(this.adaptiveSettings.retryAttempts - 1, 1);\n    }\n  }\n\n  getRecommendations(): typeof this.adaptiveSettings & { \n    confidence: number;\n    reasoning: string[];\n  } {\n    const reasoning: string[] = [];\n    let confidence = 0.7;\n\n    // Add reasoning based on current settings\n    if (this.adaptiveSettings.uploadFrequency > 30000) {\n      reasoning.push('Reduced upload frequency due to poor API health');\n    }\n    if (this.adaptiveSettings.batchSize < 15) {\n      reasoning.push('Reduced batch size due to slow response times');\n    }\n    if (this.adaptiveSettings.retryAttempts > 5) {\n      reasoning.push('Increased retry attempts due to high error rates');\n    }\n\n    // Calculate confidence based on data available\n    const totalHealthRecords = Array.from(this.regionalHealthHistory.values())\n      .reduce((sum, history) => sum + history.length, 0);\n    \n    if (totalHealthRecords > 50) {\n      confidence = Math.min(0.95, confidence + 0.2);\n    }\n\n    return {\n      ...this.adaptiveSettings,\n      confidence,\n      reasoning\n    };\n  }\n\n  reset(): void {\n    this.regionalHealthHistory.clear();\n    this.failoverPatterns = [];\n    this.adaptiveSettings = {\n      uploadFrequency: 10000,\n      batchSize: 25,\n      retryAttempts: 3,\n      timeoutMultiplier: 1.0\n    };\n  }\n}","/**\n * Intelligent Sync-on-Reconnect System\n * Handles efficient data synchronization when network connectivity is restored\n */\n\nimport { ResilientStorage, StoredItem } from './resilient-storage';\nimport { RetryManager } from './retry-manager';\nimport { EndpointHealthMonitor } from './health-monitor';\nimport { ErrorEvent, SessionEvent, NetworkEvent } from './types';\n\nexport interface SyncProgress {\n  phase: 'preparing' | 'syncing' | 'completed' | 'failed';\n  totalItems: number;\n  syncedItems: number;\n  failedItems: number;\n  currentBatch: number;\n  totalBatches: number;\n  estimatedTimeRemaining: number;\n  bytesTransferred: number;\n  totalBytes: number;\n  errors: string[];\n}\n\nexport interface SyncConfig {\n  batchSize: number;\n  maxConcurrentBatches: number;\n  priorityWeights: Record<string, number>;\n  bandwidthThrottling: boolean;\n  progressiveSync: boolean;\n  conflictResolution: 'client-wins' | 'server-wins' | 'timestamp-wins';\n  maxSyncTime: number;\n  resumeIncomplete: boolean;\n}\n\nexport interface SyncContext {\n  sessionId: string;\n  userId?: string;\n  deviceId: string;\n  lastSyncTimestamp: number;\n  offlineDuration: number;\n  networkQuality: 'excellent' | 'good' | 'poor' | 'unknown';\n  batteryLevel?: number;\n  isBackground?: boolean;\n}\n\nexport interface ConflictItem {\n  localItem: StoredItem;\n  serverItem?: any;\n  conflictType: 'timestamp' | 'version' | 'data';\n  resolution: 'pending' | 'resolved';\n  resolvedWith: 'local' | 'server' | 'merged';\n}\n\n/**\n * Intelligent Sync Manager\n */\nexport class IntelligentSyncManager {\n  private storage: ResilientStorage;\n  private retryManager: RetryManager;\n  private healthMonitor: EndpointHealthMonitor | null = null;\n  private currentSync: Promise<SyncProgress> | null = null;\n  private syncContext: SyncContext | null = null;\n  private config: SyncConfig;\n  private listeners: Array<(progress: SyncProgress) => void> = [];\n  private abortController: AbortController | null = null;\n  private syncHistory: Array<{ timestamp: number; duration: number; itemsSynced: number; success: boolean }> = [];\n\n  constructor(\n    storage: ResilientStorage,\n    config: Partial<SyncConfig> = {}\n  ) {\n    this.storage = storage;\n    this.retryManager = new RetryManager({\n      maxAttempts: 5,\n      baseDelay: 2000,\n      maxDelay: 30000,\n      enableJitter: true\n    });\n\n    this.config = {\n      batchSize: 20,\n      maxConcurrentBatches: 3,\n      priorityWeights: {\n        critical: 1.0,\n        high: 0.8,\n        medium: 0.5,\n        low: 0.2\n      },\n      bandwidthThrottling: true,\n      progressiveSync: true,\n      conflictResolution: 'timestamp-wins',\n      maxSyncTime: 300000, // 5 minutes\n      resumeIncomplete: true,\n      ...config\n    };\n  }\n\n  /**\n   * Initialize sync manager with health monitoring\n   */\n  initialize(apiEndpoint: string, healthMonitor?: EndpointHealthMonitor): void {\n    if (healthMonitor) {\n      this.healthMonitor = healthMonitor;\n    } else {\n      this.healthMonitor = new EndpointHealthMonitor('sync-health', {\n        endpoint: `${apiEndpoint}/health`,\n        interval: 30000,\n        timeout: 10000\n      });\n      this.healthMonitor.start();\n    }\n\n    // Listen for network reconnection\n    this.setupNetworkListeners();\n  }\n\n  private setupNetworkListeners(): void {\n    if (typeof window === 'undefined') return;\n\n    window.addEventListener('online', () => {\n      this.handleNetworkReconnection();\n    });\n\n    // Listen for visibility changes (tab becomes active)\n    document.addEventListener('visibilitychange', () => {\n      if (!document.hidden && navigator.onLine) {\n        this.handleNetworkReconnection();\n      }\n    });\n  }\n\n  private async handleNetworkReconnection(): Promise<void> {\n    // Wait a bit for connection to stabilize\n    await this.sleep(2000);\n    \n    // Check if we actually have connectivity\n    if (this.healthMonitor) {\n      const health = await this.healthMonitor.forceCheck();\n      if (health.status === 'unhealthy') {\n        console.log('[SyncManager] API still unhealthy after reconnection, waiting...');\n        return;\n      }\n    }\n\n    // Start sync if not already running\n    if (!this.currentSync) {\n      this.startIntelligentSync();\n    }\n  }\n\n  /**\n   * Start intelligent synchronization\n   */\n  async startIntelligentSync(context?: Partial<SyncContext>): Promise<SyncProgress> {\n    // Return existing sync if in progress\n    if (this.currentSync) {\n      return this.currentSync;\n    }\n\n    // Create sync context\n    this.syncContext = {\n      sessionId: this.generateSessionId(),\n      deviceId: this.getDeviceId(),\n      lastSyncTimestamp: this.getLastSyncTimestamp(),\n      offlineDuration: Date.now() - this.getLastSyncTimestamp(),\n      networkQuality: await this.assessNetworkQuality(),\n      batteryLevel: this.getBatteryLevel(),\n      isBackground: document.hidden,\n      ...context\n    };\n\n    // Create abort controller for cancellation\n    this.abortController = new AbortController();\n\n    // Start sync process\n    this.currentSync = this.performIntelligentSync(this.syncContext);\n    \n    try {\n      const result = await this.currentSync;\n      this.recordSyncHistory(result);\n      return result;\n    } finally {\n      this.currentSync = null;\n      this.syncContext = null;\n      this.abortController = null;\n    }\n  }\n\n  private async performIntelligentSync(context: SyncContext): Promise<SyncProgress> {\n    const progress: SyncProgress = {\n      phase: 'preparing',\n      totalItems: 0,\n      syncedItems: 0,\n      failedItems: 0,\n      currentBatch: 0,\n      totalBatches: 0,\n      estimatedTimeRemaining: 0,\n      bytesTransferred: 0,\n      totalBytes: 0,\n      errors: []\n    };\n\n    this.notifyProgress(progress);\n\n    try {\n      // Phase 1: Prepare sync data\n      const syncPlan = await this.prepareSyncPlan(context);\n      progress.totalItems = syncPlan.totalItems;\n      progress.totalBatches = syncPlan.batches.length;\n      progress.totalBytes = syncPlan.totalBytes;\n\n      // Phase 2: Execute sync with intelligent batching\n      progress.phase = 'syncing';\n      this.notifyProgress(progress);\n\n      const startTime = Date.now();\n      await this.executeSyncBatches(syncPlan, progress);\n\n      // Phase 3: Handle conflicts and finalize\n      if (syncPlan.conflicts.length > 0) {\n        await this.resolveConflicts(syncPlan.conflicts);\n      }\n\n      progress.phase = 'completed';\n      progress.estimatedTimeRemaining = 0;\n      this.notifyProgress(progress);\n\n      // Update last sync timestamp\n      this.updateLastSyncTimestamp();\n\n      return progress;\n\n    } catch (error: any) {\n      progress.phase = 'failed';\n      progress.errors.push(error.message);\n      this.notifyProgress(progress);\n      throw error;\n    }\n  }\n\n  private async prepareSyncPlan(context: SyncContext): Promise<{\n    batches: Array<{ items: StoredItem[]; priority: number; estimatedBytes: number }>;\n    totalItems: number;\n    totalBytes: number;\n    conflicts: ConflictItem[];\n  }> {\n    // Get all items that need syncing\n    const [errors, sessions, networkEvents] = await Promise.all([\n      this.storage.getAllByType<ErrorEvent>('error'),\n      this.storage.getAllByType<SessionEvent>('session'),\n      this.storage.getAllByType<NetworkEvent>('network')\n    ]);\n\n    const allItems = [...errors, ...sessions, ...networkEvents];\n    \n    // Filter items that need syncing (newer than last sync)\n    const itemsToSync = allItems.filter(item => \n      item.timestamp > context.lastSyncTimestamp\n    );\n\n    // Sort by priority and timestamp\n    itemsToSync.sort((a, b) => {\n      const priorityWeight = this.config.priorityWeights[a.priority] - this.config.priorityWeights[b.priority];\n      if (priorityWeight !== 0) return -priorityWeight; // Higher priority first\n      return a.timestamp - b.timestamp; // Older first within same priority\n    });\n\n    // Adapt batch size based on network quality and context\n    const adaptedBatchSize = this.calculateAdaptiveBatchSize(context);\n\n    // Create intelligent batches\n    const batches = this.createIntelligentBatches(itemsToSync, adaptedBatchSize);\n\n    // Check for potential conflicts (simplified implementation)\n    const conflicts = await this.detectConflicts(itemsToSync);\n\n    const totalBytes = itemsToSync.reduce((sum, item) => sum + item.size, 0);\n\n    return {\n      batches,\n      totalItems: itemsToSync.length,\n      totalBytes,\n      conflicts\n    };\n  }\n\n  private calculateAdaptiveBatchSize(context: SyncContext): number {\n    let adaptedSize = this.config.batchSize;\n\n    // Adjust based on network quality\n    switch (context.networkQuality) {\n      case 'poor':\n        adaptedSize = Math.max(5, adaptedSize * 0.3);\n        break;\n      case 'good':\n        adaptedSize = Math.floor(adaptedSize * 0.8);\n        break;\n      case 'excellent':\n        adaptedSize = Math.floor(adaptedSize * 1.5);\n        break;\n    }\n\n    // Adjust based on battery level\n    if (context.batteryLevel && context.batteryLevel < 0.2) {\n      adaptedSize = Math.max(3, adaptedSize * 0.5);\n    }\n\n    // Adjust based on background status\n    if (context.isBackground) {\n      adaptedSize = Math.max(5, adaptedSize * 0.6);\n    }\n\n    // Adjust based on offline duration\n    if (context.offlineDuration > 3600000) { // More than 1 hour\n      adaptedSize = Math.max(10, adaptedSize * 0.7); // Smaller batches for large backlogs\n    }\n\n    return Math.floor(adaptedSize);\n  }\n\n  private createIntelligentBatches(\n    items: StoredItem[],\n    batchSize: number\n  ): Array<{ items: StoredItem[]; priority: number; estimatedBytes: number }> {\n    const batches: Array<{ items: StoredItem[]; priority: number; estimatedBytes: number }> = [];\n    \n    // Group by priority first\n    const priorityGroups = new Map<string, StoredItem[]>();\n    items.forEach(item => {\n      if (!priorityGroups.has(item.priority)) {\n        priorityGroups.set(item.priority, []);\n      }\n      priorityGroups.get(item.priority)!.push(item);\n    });\n\n    // Create batches within each priority group\n    const priorities = ['critical', 'high', 'medium', 'low'];\n    priorities.forEach(priority => {\n      const groupItems = priorityGroups.get(priority) || [];\n      \n      for (let i = 0; i < groupItems.length; i += batchSize) {\n        const batchItems = groupItems.slice(i, i + batchSize);\n        const estimatedBytes = batchItems.reduce((sum, item) => sum + item.size, 0);\n        \n        batches.push({\n          items: batchItems,\n          priority: this.config.priorityWeights[priority],\n          estimatedBytes\n        });\n      }\n    });\n\n    return batches;\n  }\n\n  private async executeSyncBatches(\n    syncPlan: ReturnType<IntelligentSyncManager['prepareSyncPlan']> extends Promise<infer T> ? T : never,\n    progress: SyncProgress\n  ): Promise<void> {\n    const concurrentBatches: Promise<void>[] = [];\n    let activeBatches = 0;\n\n    for (let i = 0; i < syncPlan.batches.length; i++) {\n      const batch = syncPlan.batches[i];\n      \n      // Wait if we've hit the concurrency limit\n      while (activeBatches >= this.config.maxConcurrentBatches) {\n        await Promise.race(concurrentBatches);\n        activeBatches = concurrentBatches.filter(p => this.isPromisePending(p)).length;\n      }\n\n      // Check if sync was aborted\n      if (this.abortController?.signal.aborted) {\n        throw new Error('Sync aborted');\n      }\n\n      // Execute batch\n      const batchPromise = this.syncBatch(batch, i + 1, progress);\n      concurrentBatches.push(batchPromise);\n      activeBatches++;\n\n      // Update progress\n      progress.currentBatch = i + 1;\n      this.updateEstimatedTime(progress, syncPlan);\n      this.notifyProgress(progress);\n\n      // Add progressive delay for bandwidth throttling\n      if (this.config.bandwidthThrottling && this.syncContext?.networkQuality === 'poor') {\n        await this.sleep(1000 * (i % 3)); // 0, 1, 2 second delays\n      }\n    }\n\n    // Wait for all batches to complete\n    await Promise.allSettled(concurrentBatches);\n  }\n\n  private async syncBatch(\n    batch: { items: StoredItem[]; priority: number; estimatedBytes: number },\n    batchNumber: number,\n    progress: SyncProgress\n  ): Promise<void> {\n    try {\n      // Group items by type for efficient API calls\n      const errorItems = batch.items.filter(item => item.id.startsWith('error_'));\n      const sessionItems = batch.items.filter(item => item.id.startsWith('session_'));\n      const networkItems = batch.items.filter(item => item.id.startsWith('network_'));\n\n      // Sync each type with appropriate retry strategies\n      await Promise.all([\n        errorItems.length > 0 ? this.syncErrorItems(errorItems) : Promise.resolve(),\n        sessionItems.length > 0 ? this.syncSessionItems(sessionItems) : Promise.resolve(),\n        networkItems.length > 0 ? this.syncNetworkItems(networkItems) : Promise.resolve()\n      ]);\n\n      // Update progress\n      progress.syncedItems += batch.items.length;\n      progress.bytesTransferred += batch.estimatedBytes;\n\n      // Remove synced items from storage\n      await Promise.all(\n        batch.items.map(item => this.storage.remove(item.id))\n      );\n\n    } catch (error: any) {\n      progress.failedItems += batch.items.length;\n      progress.errors.push(`Batch ${batchNumber} failed: ${error.message}`);\n      \n      // Don't remove failed items - they'll be retried later\n      console.error(`[SyncManager] Batch ${batchNumber} sync failed:`, error);\n    }\n  }\n\n  private async syncErrorItems(items: StoredItem<ErrorEvent>[]): Promise<void> {\n    const payload = {\n      errors: items.map(item => ({\n        ...item.data,\n        client_timestamp: item.timestamp,\n        retry_count: item.retryCount,\n        offline_duration: this.syncContext?.offlineDuration || 0\n      }))\n    };\n\n    return this.retryManager.executeWithRetry(\n      'sync-errors',\n      async () => {\n        const response = await fetch('/api/capture/error', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'X-Sync-Session': this.syncContext?.sessionId || ''\n          },\n          body: JSON.stringify(payload),\n          signal: this.abortController?.signal\n        });\n\n        if (!response.ok) {\n          throw new Error(`Error sync failed: ${response.status}`);\n        }\n\n        return response.json();\n      },\n      {\n        priority: 'high',\n        payloadSize: JSON.stringify(payload).length,\n        deduplicationKey: `errors-${items.map(i => i.id).join('-')}`\n      }\n    );\n  }\n\n  private async syncSessionItems(items: StoredItem<SessionEvent>[]): Promise<void> {\n    // Group by session ID for more efficient syncing\n    const sessionGroups = new Map<string, StoredItem<SessionEvent>[]>();\n    items.forEach(item => {\n      const sessionId = item.data.sessionId;\n      if (!sessionGroups.has(sessionId)) {\n        sessionGroups.set(sessionId, []);\n      }\n      sessionGroups.get(sessionId)!.push(item);\n    });\n\n    // Sync each session group\n    for (const [sessionId, sessionItems] of sessionGroups) {\n      const payload = {\n        session_id: sessionId,\n        events: sessionItems.map(item => ({\n          ...item.data,\n          client_timestamp: item.timestamp,\n          retry_count: item.retryCount\n        }))\n      };\n\n      await this.retryManager.executeWithRetry(\n        `sync-session-${sessionId}`,\n        async () => {\n          const response = await fetch('/api/capture/session-event', {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n              'X-Sync-Session': this.syncContext?.sessionId || ''\n            },\n            body: JSON.stringify(payload),\n            signal: this.abortController?.signal\n          });\n\n          if (!response.ok) {\n            throw new Error(`Session sync failed: ${response.status}`);\n          }\n\n          return response.json();\n        },\n        {\n          priority: 'medium',\n          payloadSize: JSON.stringify(payload).length,\n          deduplicationKey: `session-${sessionId}`\n        }\n      );\n    }\n  }\n\n  private async syncNetworkItems(items: StoredItem<NetworkEvent>[]): Promise<void> {\n    const payload = {\n      events: items.map(item => ({\n        ...item.data,\n        client_timestamp: item.timestamp,\n        retry_count: item.retryCount\n      }))\n    };\n\n    return this.retryManager.executeWithRetry(\n      'sync-network',\n      async () => {\n        const response = await fetch('/api/capture/network-event', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'X-Sync-Session': this.syncContext?.sessionId || ''\n          },\n          body: JSON.stringify(payload),\n          signal: this.abortController?.signal\n        });\n\n        if (!response.ok) {\n          throw new Error(`Network sync failed: ${response.status}`);\n        }\n\n        return response.json();\n      },\n      {\n        priority: 'low',\n        payloadSize: JSON.stringify(payload).length,\n        deduplicationKey: `network-${items.length}`\n      }\n    );\n  }\n\n  private async detectConflicts(items: StoredItem[]): Promise<ConflictItem[]> {\n    // Simplified conflict detection - in practice, this would check against server state\n    const conflicts: ConflictItem[] = [];\n    \n    // For demo purposes, assume some items might conflict\n    items.forEach(item => {\n      if (item.retryCount > 3) { // Items that have failed multiple times might conflict\n        conflicts.push({\n          localItem: item,\n          conflictType: 'timestamp',\n          resolution: 'pending',\n          resolvedWith: 'local'\n        });\n      }\n    });\n\n    return conflicts;\n  }\n\n  private async resolveConflicts(conflicts: ConflictItem[]): Promise<void> {\n    for (const conflict of conflicts) {\n      switch (this.config.conflictResolution) {\n        case 'client-wins':\n          conflict.resolvedWith = 'local';\n          break;\n        case 'server-wins':\n          conflict.resolvedWith = 'server';\n          break;\n        case 'timestamp-wins':\n          // Use timestamp to determine winner\n          conflict.resolvedWith = 'local'; // Simplified\n          break;\n      }\n      conflict.resolution = 'resolved';\n    }\n  }\n\n  private updateEstimatedTime(progress: SyncProgress, syncPlan: any): void {\n    if (progress.syncedItems > 0) {\n      const elapsedTime = Date.now() - (this.syncContext?.lastSyncTimestamp || Date.now());\n      const timePerItem = elapsedTime / progress.syncedItems;\n      const remainingItems = progress.totalItems - progress.syncedItems;\n      progress.estimatedTimeRemaining = Math.floor(remainingItems * timePerItem);\n    }\n  }\n\n  /**\n   * Cancel current sync operation\n   */\n  cancelSync(): void {\n    if (this.abortController) {\n      this.abortController.abort();\n    }\n  }\n\n  /**\n   * Get sync progress if sync is running\n   */\n  getCurrentProgress(): SyncProgress | null {\n    return this.currentSync ? null : null; // Would need to track progress state\n  }\n\n  /**\n   * Check if sync is currently running\n   */\n  isSyncRunning(): boolean {\n    return this.currentSync !== null;\n  }\n\n  /**\n   * Listen for sync progress updates\n   */\n  onProgress(callback: (progress: SyncProgress) => void): () => void {\n    this.listeners.push(callback);\n    return () => {\n      const index = this.listeners.indexOf(callback);\n      if (index > -1) {\n        this.listeners.splice(index, 1);\n      }\n    };\n  }\n\n  private notifyProgress(progress: SyncProgress): void {\n    this.listeners.forEach(callback => {\n      try {\n        callback({ ...progress });\n      } catch (error) {\n        console.error('Sync progress listener error:', error);\n      }\n    });\n  }\n\n  // Helper methods\n  private generateSessionId(): string {\n    return `sync_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private getDeviceId(): string {\n    // Simple device ID generation - in practice, use more sophisticated approach\n    let deviceId = localStorage.getItem('revi_device_id');\n    if (!deviceId) {\n      deviceId = `device_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      localStorage.setItem('revi_device_id', deviceId);\n    }\n    return deviceId;\n  }\n\n  private getLastSyncTimestamp(): number {\n    const stored = localStorage.getItem('revi_last_sync');\n    return stored ? parseInt(stored) : 0;\n  }\n\n  private updateLastSyncTimestamp(): void {\n    localStorage.setItem('revi_last_sync', Date.now().toString());\n  }\n\n  private async assessNetworkQuality(): Promise<'excellent' | 'good' | 'poor' | 'unknown'> {\n    if (!this.healthMonitor) return 'unknown';\n    \n    const health = this.healthMonitor.getHealthStatus();\n    \n    if (health.responseTime && health.responseTime < 1000 && health.metrics.successRate > 0.95) {\n      return 'excellent';\n    } else if (health.responseTime && health.responseTime < 3000 && health.metrics.successRate > 0.8) {\n      return 'good';\n    } else if (health.metrics.successRate < 0.5) {\n      return 'poor';\n    }\n    \n    return 'unknown';\n  }\n\n  private getBatteryLevel(): number | undefined {\n    if ('getBattery' in navigator) {\n      // Note: getBattery() is deprecated, this is for demonstration\n      return undefined;\n    }\n    return undefined;\n  }\n\n  private recordSyncHistory(progress: SyncProgress): void {\n    this.syncHistory.push({\n      timestamp: Date.now(),\n      duration: Date.now() - (this.syncContext?.lastSyncTimestamp || Date.now()),\n      itemsSynced: progress.syncedItems,\n      success: progress.phase === 'completed'\n    });\n\n    // Keep only last 20 sync records\n    if (this.syncHistory.length > 20) {\n      this.syncHistory.shift();\n    }\n  }\n\n  private isPromisePending(promise: Promise<any>): boolean {\n    // Simplified check - in practice, you'd track promise states\n    return true;\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Get sync history\n   */\n  getSyncHistory(): typeof this.syncHistory {\n    return [...this.syncHistory];\n  }\n\n  /**\n   * Update sync configuration\n   */\n  updateConfig(newConfig: Partial<SyncConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n  }\n\n  /**\n   * Get current sync configuration\n   */\n  getConfig(): SyncConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Get statistics\n   */\n  getStats(): any {\n    return {\n      activeSyncs: this.activeSyncs.size,\n      syncHistory: this.syncHistory.length,\n      lastSync: this.syncHistory.length > 0 ? this.syncHistory[this.syncHistory.length - 1] : null,\n      totalSyncs: this.syncHistory.length,\n      successfulSyncs: this.syncHistory.filter(s => s.success).length\n    };\n  }\n\n  /**\n   * Reset statistics\n   */\n  resetStats(): void {\n    this.syncHistory = [];\n    this.activeSyncs.clear();\n  }\n\n  /**\n   * Destroy and cleanup\n   */\n  destroy(): void {\n    this.activeSyncs.clear();\n    this.syncHistory = [];\n  }\n}","/**\n * Idempotency and Request Deduplication Manager\n * Ensures safe retries and prevents duplicate operations across the resilience system\n */\n\nexport interface IdempotencyConfig {\n  keyTTL: number; // How long to remember idempotency keys (ms)\n  maxConcurrentRequests: number; // Max concurrent requests for same key\n  enableResponseCaching: boolean; // Cache successful responses\n  responseCacheTTL: number; // How long to cache responses (ms)\n  enableRequestFingerprinting: boolean; // Generate fingerprints for complex requests\n  maxStoredKeys: number; // Maximum number of keys to store in memory\n}\n\nexport interface RequestFingerprint {\n  method: string;\n  url: string;\n  headers: Record<string, string>;\n  bodyHash?: string;\n  timestamp: number;\n}\n\nexport interface IdempotentRequest {\n  key: string;\n  fingerprint: RequestFingerprint;\n  status: 'pending' | 'completed' | 'failed';\n  promise?: Promise<any>;\n  response?: any;\n  error?: Error;\n  attempts: number;\n  createdAt: number;\n  lastAttemptAt: number;\n  completedAt?: number;\n}\n\nexport interface DeduplicationStats {\n  totalRequests: number;\n  deduplicatedRequests: number;\n  cacheHits: number;\n  activePendingRequests: number;\n  memoryUsage: number;\n  keyCleanups: number;\n}\n\nexport class IdempotencyManager {\n  private config: IdempotencyConfig;\n  private requestMap = new Map<string, IdempotentRequest>();\n  private responseCache = new Map<string, { response: any; cachedAt: number }>();\n  private pendingRequests = new Map<string, Promise<any>>();\n  private keyCleanupInterval: NodeJS.Timeout | null = null;\n  private stats: DeduplicationStats = {\n    totalRequests: 0,\n    deduplicatedRequests: 0,\n    cacheHits: 0,\n    activePendingRequests: 0,\n    memoryUsage: 0,\n    keyCleanups: 0\n  };\n\n  constructor(config: Partial<IdempotencyConfig> = {}) {\n    this.config = {\n      keyTTL: 300000, // 5 minutes\n      maxConcurrentRequests: 10,\n      enableResponseCaching: true,\n      responseCacheTTL: 60000, // 1 minute\n      enableRequestFingerprinting: true,\n      maxStoredKeys: 1000,\n      ...config\n    };\n\n    this.startKeyCleanup();\n  }\n\n  /**\n   * Execute request with idempotency protection\n   */\n  async executeIdempotent<T>(\n    key: string,\n    operation: () => Promise<T>,\n    options: {\n      method?: string;\n      url?: string;\n      headers?: Record<string, string>;\n      body?: any;\n      bypassCache?: boolean;\n      priority?: 'critical' | 'high' | 'medium' | 'low';\n    } = {}\n  ): Promise<T> {\n    this.stats.totalRequests++;\n\n    // Generate request fingerprint if enabled\n    const fingerprint = this.config.enableRequestFingerprinting\n      ? await this.generateRequestFingerprint(options)\n      : null;\n\n    // Check for existing cached response\n    if (!options.bypassCache && this.config.enableResponseCaching) {\n      const cachedResponse = this.getCachedResponse(key);\n      if (cachedResponse) {\n        this.stats.cacheHits++;\n        return cachedResponse;\n      }\n    }\n\n    // Check for existing pending request\n    const existingRequest = this.requestMap.get(key);\n    if (existingRequest && existingRequest.status === 'pending') {\n      this.stats.deduplicatedRequests++;\n      \n      // Wait for existing request to complete\n      if (existingRequest.promise) {\n        try {\n          return await existingRequest.promise;\n        } catch (error) {\n          // If existing request failed, allow this one to proceed\n          if (existingRequest.attempts < 3) {\n            // Update existing request for retry\n            existingRequest.attempts++;\n            existingRequest.lastAttemptAt = Date.now();\n          } else {\n            // Too many attempts, create new request\n            this.requestMap.delete(key);\n          }\n        }\n      }\n    }\n\n    // Create new idempotent request\n    const idempotentRequest: IdempotentRequest = {\n      key,\n      fingerprint: fingerprint || {\n        method: options.method || 'unknown',\n        url: options.url || 'unknown',\n        headers: options.headers || {},\n        timestamp: Date.now()\n      },\n      status: 'pending',\n      attempts: 1,\n      createdAt: Date.now(),\n      lastAttemptAt: Date.now()\n    };\n\n    // Check concurrent request limits\n    const pendingCount = Array.from(this.requestMap.values())\n      .filter(req => req.status === 'pending').length;\n    \n    if (pendingCount >= this.config.maxConcurrentRequests) {\n      throw new Error(`Too many concurrent idempotent requests (${pendingCount}/${this.config.maxConcurrentRequests})`);\n    }\n\n    // Execute the operation with proper cleanup\n    const executePromise = this.performIdempotentOperation(key, operation, idempotentRequest);\n    idempotentRequest.promise = executePromise;\n    \n    this.requestMap.set(key, idempotentRequest);\n    this.pendingRequests.set(key, executePromise);\n    this.updateStats();\n\n    try {\n      const result = await executePromise;\n      return result;\n    } finally {\n      this.pendingRequests.delete(key);\n      this.updateStats();\n    }\n  }\n\n  private async performIdempotentOperation<T>(\n    key: string,\n    operation: () => Promise<T>,\n    request: IdempotentRequest\n  ): Promise<T> {\n    try {\n      const result = await operation();\n      \n      // Mark request as completed\n      request.status = 'completed';\n      request.response = result;\n      request.completedAt = Date.now();\n\n      // Cache successful response if enabled\n      if (this.config.enableResponseCaching) {\n        this.cacheResponse(key, result);\n      }\n\n      return result;\n\n    } catch (error: any) {\n      // Mark request as failed\n      request.status = 'failed';\n      request.error = error;\n      request.completedAt = Date.now();\n\n      // Don't cache failed responses\n      throw error;\n    }\n  }\n\n  /**\n   * Generate request fingerprint for complex deduplication\n   */\n  private async generateRequestFingerprint(options: {\n    method?: string;\n    url?: string;\n    headers?: Record<string, string>;\n    body?: any;\n  }): Promise<RequestFingerprint> {\n    const fingerprint: RequestFingerprint = {\n      method: options.method || 'GET',\n      url: options.url || '',\n      headers: this.normalizeHeaders(options.headers || {}),\n      timestamp: Date.now()\n    };\n\n    // Generate body hash for POST/PUT requests\n    if (options.body && (options.method === 'POST' || options.method === 'PUT')) {\n      fingerprint.bodyHash = await this.hashRequestBody(options.body);\n    }\n\n    return fingerprint;\n  }\n\n  private normalizeHeaders(headers: Record<string, string>): Record<string, string> {\n    const normalized: Record<string, string> = {};\n    \n    // Only include headers that affect request semantics\n    const importantHeaders = ['content-type', 'accept', 'authorization'];\n    \n    for (const [key, value] of Object.entries(headers)) {\n      const normalizedKey = key.toLowerCase();\n      if (importantHeaders.includes(normalizedKey)) {\n        normalized[normalizedKey] = value;\n      }\n    }\n\n    return normalized;\n  }\n\n  private async hashRequestBody(body: any): Promise<string> {\n    try {\n      const bodyString = typeof body === 'string' ? body : JSON.stringify(body);\n      \n      // Simple hash function for browser compatibility\n      let hash = 0;\n      for (let i = 0; i < bodyString.length; i++) {\n        const char = bodyString.charCodeAt(i);\n        hash = ((hash << 5) - hash) + char;\n        hash = hash & hash; // Convert to 32-bit integer\n      }\n      \n      return Math.abs(hash).toString(16);\n    } catch (error) {\n      return 'hash-error';\n    }\n  }\n\n  /**\n   * Get cached response if available and not expired\n   */\n  private getCachedResponse<T>(key: string): T | null {\n    if (!this.config.enableResponseCaching) {\n      return null;\n    }\n\n    const cached = this.responseCache.get(key);\n    if (!cached) {\n      return null;\n    }\n\n    const age = Date.now() - cached.cachedAt;\n    if (age > this.config.responseCacheTTL) {\n      this.responseCache.delete(key);\n      return null;\n    }\n\n    return cached.response;\n  }\n\n  /**\n   * Cache successful response\n   */\n  private cacheResponse(key: string, response: any): void {\n    if (!this.config.enableResponseCaching) {\n      return;\n    }\n\n    this.responseCache.set(key, {\n      response,\n      cachedAt: Date.now()\n    });\n\n    // Prevent unbounded cache growth\n    if (this.responseCache.size > this.config.maxStoredKeys) {\n      const oldestKey = this.responseCache.keys().next().value;\n      if (oldestKey) {\n        this.responseCache.delete(oldestKey);\n      }\n    }\n  }\n\n  /**\n   * Generate idempotency key from request data\n   */\n  generateIdempotencyKey(\n    method: string,\n    url: string,\n    body?: any,\n    userContext?: string\n  ): string {\n    const components = [\n      method.toUpperCase(),\n      url,\n      userContext || 'anonymous'\n    ];\n\n    if (body) {\n      try {\n        const bodyString = typeof body === 'string' ? body : JSON.stringify(body);\n        components.push(bodyString);\n      } catch (error) {\n        components.push('body-serialize-error');\n      }\n    }\n\n    return components.join('|');\n  }\n\n  /**\n   * Check if request is currently pending\n   */\n  isPending(key: string): boolean {\n    const request = this.requestMap.get(key);\n    return request?.status === 'pending' || false;\n  }\n\n  /**\n   * Get request information\n   */\n  getRequestInfo(key: string): IdempotentRequest | null {\n    return this.requestMap.get(key) || null;\n  }\n\n  /**\n   * Cancel pending request\n   */\n  cancelRequest(key: string): boolean {\n    const request = this.requestMap.get(key);\n    if (request && request.status === 'pending') {\n      request.status = 'failed';\n      request.error = new Error('Request cancelled');\n      request.completedAt = Date.now();\n      \n      this.pendingRequests.delete(key);\n      this.updateStats();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Clear expired entries and manage memory\n   */\n  private startKeyCleanup(): void {\n    this.keyCleanupInterval = setInterval(() => {\n      this.cleanupExpiredEntries();\n    }, 30000); // Clean up every 30 seconds\n  }\n\n  private cleanupExpiredEntries(): void {\n    const now = Date.now();\n    let cleanedCount = 0;\n\n    // Clean up expired requests\n    for (const [key, request] of this.requestMap.entries()) {\n      const age = now - request.createdAt;\n      if (age > this.config.keyTTL || request.status !== 'pending') {\n        this.requestMap.delete(key);\n        cleanedCount++;\n      }\n    }\n\n    // Clean up expired cached responses\n    for (const [key, cached] of this.responseCache.entries()) {\n      const age = now - cached.cachedAt;\n      if (age > this.config.responseCacheTTL) {\n        this.responseCache.delete(key);\n        cleanedCount++;\n      }\n    }\n\n    // Enforce memory limits\n    if (this.requestMap.size > this.config.maxStoredKeys) {\n      const excess = this.requestMap.size - this.config.maxStoredKeys;\n      const oldestKeys = Array.from(this.requestMap.entries())\n        .sort((a, b) => a[1].createdAt - b[1].createdAt)\n        .slice(0, excess)\n        .map(([key]) => key);\n\n      for (const key of oldestKeys) {\n        this.requestMap.delete(key);\n        cleanedCount++;\n      }\n    }\n\n    this.stats.keyCleanups += cleanedCount;\n    this.updateStats();\n  }\n\n  private updateStats(): void {\n    this.stats.activePendingRequests = this.pendingRequests.size;\n    this.stats.memoryUsage = this.requestMap.size + this.responseCache.size;\n  }\n\n  /**\n   * Get deduplication statistics\n   */\n  getStats(): DeduplicationStats {\n    this.updateStats();\n    return { ...this.stats };\n  }\n\n  /**\n   * Reset statistics (useful for testing)\n   */\n  resetStats(): void {\n    this.stats = {\n      totalRequests: 0,\n      deduplicatedRequests: 0,\n      cacheHits: 0,\n      activePendingRequests: 0,\n      memoryUsage: 0,\n      keyCleanups: 0\n    };\n  }\n\n  /**\n   * Clear all stored data\n   */\n  clear(): void {\n    this.requestMap.clear();\n    this.responseCache.clear();\n    this.pendingRequests.clear();\n    this.resetStats();\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(newConfig: Partial<IdempotencyConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n  }\n\n  /**\n   * Cleanup resources\n   */\n  destroy(): void {\n    if (this.keyCleanupInterval) {\n      clearInterval(this.keyCleanupInterval);\n      this.keyCleanupInterval = null;\n    }\n    this.clear();\n  }\n}\n\n/**\n * Utility functions for common idempotency patterns\n */\nexport class IdempotencyUtils {\n  /**\n   * Generate idempotency key for error reporting\n   */\n  static errorReportingKey(\n    projectId: string,\n    errorHash: string,\n    sessionId: string,\n    timestamp?: number\n  ): string {\n    const timeWindow = timestamp ? Math.floor(timestamp / 60000) * 60000 : 0; // 1-minute windows\n    return `error:${projectId}:${errorHash}:${sessionId}:${timeWindow}`;\n  }\n\n  /**\n   * Generate idempotency key for session events\n   */\n  static sessionEventKey(\n    projectId: string,\n    sessionId: string,\n    eventType: string,\n    sequence: number\n  ): string {\n    return `session:${projectId}:${sessionId}:${eventType}:${sequence}`;\n  }\n\n  /**\n   * Generate idempotency key for network events\n   */\n  static networkEventKey(\n    projectId: string,\n    sessionId: string,\n    method: string,\n    url: string,\n    timestamp: number\n  ): string {\n    return `network:${projectId}:${sessionId}:${method}:${url}:${timestamp}`;\n  }\n\n  /**\n   * Generate idempotency key for batch operations\n   */\n  static batchOperationKey(\n    operation: string,\n    batchId: string,\n    checksum: string\n  ): string {\n    return `batch:${operation}:${batchId}:${checksum}`;\n  }\n}","/**\n * Resilience Coordinator - Central orchestrator for all resilience components\n * Coordinates retry management, circuit breakers, storage, health monitoring, and idempotency\n */\n\nimport { RetryManager, RetryConfig } from './retry-manager';\nimport { CircuitBreakerManager, CircuitBreakerConfig } from './circuit-breaker';\nimport { ResilientStorage, ResilientStorageConfig } from './resilient-storage';\nimport { MultiRegionalHealthMonitor, HealthMonitorConfig } from './health-monitor';\nimport { IntelligentSyncManager, SyncConfig } from './sync-manager';\nimport { IdempotencyManager, IdempotencyConfig } from './idempotency-manager';\n\nexport interface ResilienceConfig {\n  retry: Partial<RetryConfig>;\n  circuitBreaker: Partial<CircuitBreakerConfig>;\n  storage: Partial<ResilientStorageConfig>;\n  healthMonitor: Partial<HealthMonitorConfig>;\n  sync: Partial<SyncConfig>;\n  idempotency: Partial<IdempotencyConfig>;\n  enableAdaptiveBehavior: boolean;\n  performanceThresholds: {\n    slowRequestMs: number;\n    verySlowRequestMs: number;\n    highErrorRate: number;\n    criticalErrorRate: number;\n  };\n}\n\nexport interface ResilienceStats {\n  retry: any;\n  circuitBreaker: any;\n  storage: any;\n  healthMonitor: any;\n  sync: any;\n  idempotency: any;\n  adaptiveBehavior: {\n    currentMode: 'normal' | 'degraded' | 'emergency';\n    adaptationCount: number;\n    lastAdaptation: number;\n  };\n}\n\nexport interface RequestOptions {\n  priority: 'critical' | 'high' | 'medium' | 'low';\n  timeout?: number;\n  payloadSize?: number;\n  idempotencyKey?: string;\n  bypassCache?: boolean;\n  feature: string;\n  region?: string;\n}\n\nexport class ResilienceCoordinator {\n  private config: ResilienceConfig;\n  private retryManager: RetryManager;\n  private circuitBreakerManager: CircuitBreakerManager;\n  private storage: ResilientStorage;\n  private healthMonitor: MultiRegionalHealthMonitor;\n  private syncManager: IntelligentSyncManager;\n  private idempotencyManager: IdempotencyManager;\n  \n  private adaptiveBehavior = {\n    currentMode: 'normal' as 'normal' | 'degraded' | 'emergency',\n    adaptationCount: 0,\n    lastAdaptation: 0\n  };\n\n  private performanceHistory: Array<{\n    timestamp: number;\n    duration: number;\n    success: boolean;\n    feature: string;\n  }> = [];\n\n  constructor(config: Partial<ResilienceConfig> = {}) {\n    this.config = {\n      retry: {},\n      circuitBreaker: {},\n      storage: {},\n      healthMonitor: {},\n      sync: {},\n      idempotency: {},\n      enableAdaptiveBehavior: true,\n      performanceThresholds: {\n        slowRequestMs: 2000,\n        verySlowRequestMs: 5000,\n        highErrorRate: 0.1, // 10%\n        criticalErrorRate: 0.25 // 25%\n      },\n      ...config\n    };\n\n    // Initialize all resilience components\n    this.retryManager = new RetryManager(this.config.retry);\n    this.circuitBreakerManager = new CircuitBreakerManager(this.config.circuitBreaker);\n    this.storage = new ResilientStorage(this.config.storage);\n    this.healthMonitor = new MultiRegionalHealthMonitor(this.config.healthMonitor);\n    this.syncManager = new IntelligentSyncManager(this.config.sync);\n    this.idempotencyManager = new IdempotencyManager(this.config.idempotency);\n\n    // Set up adaptive behavior monitoring\n    if (this.config.enableAdaptiveBehavior) {\n      this.startAdaptiveBehaviorMonitoring();\n    }\n  }\n\n  /**\n   * Execute request with full resilience protection\n   */\n  async executeResilientRequest<T>(\n    operation: () => Promise<T>,\n    options: RequestOptions\n  ): Promise<T> {\n    const startTime = Date.now();\n    const { feature, priority, idempotencyKey, region } = options;\n\n    try {\n      // Check circuit breaker first\n      await this.circuitBreakerManager.executeWithBreaker(\n        feature,\n        async () => {\n          // Execute with idempotency protection if key provided\n          if (idempotencyKey) {\n            return await this.idempotencyManager.executeIdempotent(\n              idempotencyKey,\n              () => this.executeWithRetryAndHealth(operation, options),\n              {\n                method: 'POST',\n                url: feature,\n                priority,\n                bypassCache: options.bypassCache\n              }\n            );\n          } else {\n            return await this.executeWithRetryAndHealth(operation, options);\n          }\n        },\n        { priority, region }\n      );\n\n      // Record successful performance\n      this.recordPerformance(startTime, true, feature);\n\n      return await operation();\n\n    } catch (error: any) {\n      // Record failed performance\n      this.recordPerformance(startTime, false, feature);\n\n      // Check if we should store for later sync\n      if (this.shouldStoreForLaterSync(error, priority)) {\n        await this.storeForLaterSync(operation, options, error);\n      }\n\n      throw error;\n    }\n  }\n\n  private async executeWithRetryAndHealth<T>(\n    operation: () => Promise<T>,\n    options: RequestOptions\n  ): Promise<T> {\n    const { feature, priority, timeout, payloadSize, region } = options;\n\n    // Get health recommendation\n    const healthRecommendation = this.healthMonitor.getAdaptiveRecommendation(\n      feature,\n      region\n    );\n\n    // Adapt request based on health status\n    const adaptedOptions = this.adaptRequestToHealth(options, healthRecommendation);\n\n    // Execute with retry protection\n    return await this.retryManager.executeWithRetry(\n      `${feature}:${region || 'default'}`,\n      operation,\n      {\n        priority,\n        timeout: adaptedOptions.timeout,\n        payloadSize,\n        deduplicationKey: adaptedOptions.deduplicationKey\n      }\n    );\n  }\n\n  private adaptRequestToHealth(\n    options: RequestOptions,\n    healthRecommendation: any\n  ): RequestOptions {\n    const adapted = { ...options };\n\n    if (healthRecommendation) {\n      // Adjust timeout based on health\n      if (healthRecommendation.adjustedTimeout) {\n        adapted.timeout = healthRecommendation.adjustedTimeout;\n      }\n\n      // Add deduplication for unhealthy services\n      if (healthRecommendation.useDeduplication && !adapted.idempotencyKey) {\n        adapted.idempotencyKey = `auto-dedup:${options.feature}:${Date.now()}`;\n      }\n    }\n\n    return adapted;\n  }\n\n  private shouldStoreForLaterSync(error: any, priority: string): boolean {\n    // Don't store critical requests (they should fail fast)\n    if (priority === 'critical') {\n      return false;\n    }\n\n    // Store network errors for later retry\n    if (error.name === 'TypeError' && error.message.includes('fetch')) {\n      return true;\n    }\n\n    // Store timeout errors\n    if (error.message?.includes('timeout')) {\n      return true;\n    }\n\n    // Store server errors (5xx)\n    if (error.status >= 500) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private async storeForLaterSync<T>(\n    operation: () => Promise<T>,\n    options: RequestOptions,\n    error: Error\n  ): Promise<void> {\n    const requestData = {\n      operation: operation.toString(), // Note: This is a simplified approach\n      options,\n      error: {\n        message: error.message,\n        name: error.name,\n        stack: error.stack\n      },\n      timestamp: Date.now()\n    };\n\n    await this.storage.storeData(\n      `failed-request:${options.feature}:${Date.now()}`,\n      requestData,\n      {\n        priority: options.priority,\n        compress: true,\n        encrypt: false,\n        tier: options.priority === 'high' ? 'hot' : 'warm'\n      }\n    );\n  }\n\n  /**\n   * Sync failed requests when connectivity is restored\n   */\n  async syncFailedRequests(): Promise<void> {\n    // Get all failed requests from storage\n    const failedRequests = await this.storage.getAllDataByPattern('failed-request:*');\n\n    if (failedRequests.length === 0) {\n      return;\n    }\n\n    // Use intelligent sync manager for optimal batching\n    await this.syncManager.performIntelligentSync(\n      'failed-requests',\n      failedRequests.map(req => ({\n        id: req.key,\n        data: req.data,\n        priority: req.metadata?.priority || 'medium',\n        size: JSON.stringify(req.data).length,\n        timestamp: req.metadata?.timestamp || Date.now(),\n        dependencies: []\n      })),\n      {\n        maxBatchSize: 50,\n        timeoutMs: 30000,\n        priority: 'high'\n      }\n    );\n\n    // Clean up successfully synced requests\n    for (const request of failedRequests) {\n      await this.storage.deleteData(request.key);\n    }\n  }\n\n  /**\n   * Start adaptive behavior monitoring\n   */\n  private startAdaptiveBehaviorMonitoring(): void {\n    setInterval(() => {\n      this.evaluateAndAdaptBehavior();\n    }, 30000); // Check every 30 seconds\n  }\n\n  private evaluateAndAdaptBehavior(): void {\n    if (!this.config.enableAdaptiveBehavior) {\n      return;\n    }\n\n    const recentPerformance = this.getRecentPerformance(300000); // Last 5 minutes\n    if (recentPerformance.length === 0) {\n      return;\n    }\n\n    const errorRate = recentPerformance.filter(p => !p.success).length / recentPerformance.length;\n    const averageDuration = recentPerformance.reduce((sum, p) => sum + p.duration, 0) / recentPerformance.length;\n\n    const currentMode = this.adaptiveBehavior.currentMode;\n    let newMode: 'normal' | 'degraded' | 'emergency' = 'normal';\n\n    // Determine new mode based on performance\n    if (errorRate >= this.config.performanceThresholds.criticalErrorRate) {\n      newMode = 'emergency';\n    } else if (\n      errorRate >= this.config.performanceThresholds.highErrorRate ||\n      averageDuration >= this.config.performanceThresholds.verySlowRequestMs\n    ) {\n      newMode = 'degraded';\n    } else if (averageDuration >= this.config.performanceThresholds.slowRequestMs) {\n      newMode = 'degraded';\n    }\n\n    // Apply mode change if needed\n    if (newMode !== currentMode) {\n      this.applyAdaptiveBehaviorMode(newMode);\n      this.adaptiveBehavior.currentMode = newMode;\n      this.adaptiveBehavior.adaptationCount++;\n      this.adaptiveBehavior.lastAdaptation = Date.now();\n    }\n  }\n\n  private applyAdaptiveBehaviorMode(mode: 'normal' | 'degraded' | 'emergency'): void {\n    switch (mode) {\n      case 'emergency':\n        // Emergency mode: Aggressive protection\n        this.retryManager.updateConfig({\n          maxAttempts: 2,\n          baseDelay: 5000,\n          retryBudget: 20\n        });\n        this.circuitBreakerManager.updateGlobalConfig({\n          failureThreshold: 3,\n          recoveryTimeout: 30000,\n          emergencyMode: true\n        });\n        break;\n\n      case 'degraded':\n        // Degraded mode: Reduced retries, increased delays\n        this.retryManager.updateConfig({\n          maxAttempts: 3,\n          baseDelay: 2000,\n          retryBudget: 50\n        });\n        this.circuitBreakerManager.updateGlobalConfig({\n          failureThreshold: 5,\n          recoveryTimeout: 15000,\n          emergencyMode: false\n        });\n        break;\n\n      case 'normal':\n        // Normal mode: Standard settings\n        this.retryManager.updateConfig({\n          maxAttempts: 5,\n          baseDelay: 1000,\n          retryBudget: 100\n        });\n        this.circuitBreakerManager.updateGlobalConfig({\n          failureThreshold: 10,\n          recoveryTimeout: 10000,\n          emergencyMode: false\n        });\n        break;\n    }\n  }\n\n  private recordPerformance(startTime: number, success: boolean, feature: string): void {\n    const duration = Date.now() - startTime;\n    \n    this.performanceHistory.push({\n      timestamp: Date.now(),\n      duration,\n      success,\n      feature\n    });\n\n    // Keep only recent performance data (last hour)\n    const oneHourAgo = Date.now() - 3600000;\n    this.performanceHistory = this.performanceHistory.filter(\n      p => p.timestamp > oneHourAgo\n    );\n  }\n\n  private getRecentPerformance(timeWindowMs: number) {\n    const cutoff = Date.now() - timeWindowMs;\n    return this.performanceHistory.filter(p => p.timestamp > cutoff);\n  }\n\n  /**\n   * Get comprehensive resilience statistics\n   */\n  getStats(): ResilienceStats {\n    return {\n      retry: this.retryManager.getStats(),\n      circuitBreaker: this.circuitBreakerManager.getGlobalStats(),\n      storage: this.storage.getStats(),\n      healthMonitor: this.healthMonitor.getGlobalStats(),\n      sync: this.syncManager.getStats(),\n      idempotency: this.idempotencyManager.getStats(),\n      adaptiveBehavior: { ...this.adaptiveBehavior }\n    };\n  }\n\n  /**\n   * Reset all statistics (useful for testing)\n   */\n  resetAllStats(): void {\n    this.retryManager.resetStats();\n    this.circuitBreakerManager.resetStats();\n    this.storage.resetStats();\n    this.healthMonitor.resetStats();\n    this.syncManager.resetStats();\n    this.idempotencyManager.resetStats();\n    this.performanceHistory = [];\n    this.adaptiveBehavior = {\n      currentMode: 'normal',\n      adaptationCount: 0,\n      lastAdaptation: 0\n    };\n  }\n\n  /**\n   * Update configuration for all components\n   */\n  updateConfig(newConfig: Partial<ResilienceConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n\n    if (newConfig.retry) {\n      this.retryManager.updateConfig(newConfig.retry);\n    }\n    if (newConfig.circuitBreaker) {\n      this.circuitBreakerManager.updateGlobalConfig(newConfig.circuitBreaker);\n    }\n    if (newConfig.storage) {\n      this.storage.updateConfig(newConfig.storage);\n    }\n    if (newConfig.healthMonitor) {\n      this.healthMonitor.updateConfig(newConfig.healthMonitor);\n    }\n    if (newConfig.sync) {\n      this.syncManager.updateConfig(newConfig.sync);\n    }\n    if (newConfig.idempotency) {\n      this.idempotencyManager.updateConfig(newConfig.idempotency);\n    }\n  }\n\n  /**\n   * Cleanup all resources\n   */\n  destroy(): void {\n    this.idempotencyManager.destroy();\n    this.healthMonitor.destroy();\n    this.syncManager.destroy();\n    // Other components don't have destroy methods currently\n  }\n}"],"names":["generateId","replace","c","r","Math","random","toString","formatStackTrace","error","stack","split","map","line","trim","filter","length","join","TraceManager","constructor","this","spanCounter","spanData","Map","generateNewTrace","currentTraceId","generateTraceId","currentSpanId","undefined","startSpan","operationName","parentSpanId","generateSpanId","setSpanData","startTime","Date","now","finishSpan","spanId","data","getSpanData","endTime","getCurrentTraceId","getCurrentSpanId","getTraceContext","traceId","getParentSpanId","extractTraceFromHeaders","headers","_a","_b","_c","_d","injectTraceHeaders","correlateWithBackendTrace","backendTraceId","backendSpanId","generateRandomHex","array","Uint8Array","crypto","getRandomValues","i","floor","Array","from","byte","padStart","get","set","cleanupSpanData","cutoff","entries","delete","ErrorHandler","config","traceManager","breadcrumbs","userContext","setupGlobalHandlers","window","addEventListener","event","captureError","message","filename","lineno","colno","reason","Error","JSON","stringify","originalConsoleError","console","args","addBreadcrumb","timestamp","category","level","apply","originalConsoleWarn","warn","errorData","sampleRate","errorId","traceContext","errorEvent","id","url","location","href","userId","sessionId","userAgent","navigator","environment","release","tags","extra","beforeSend","call","captureException","options","captureMessage","breadcrumb","push","maxBreadcrumbs","splice","setUserContext","user","setTags","setExtra","getBreadcrumbs","clearBreadcrumbs","SessionManager","events","storage","sessionStorage","setItem","removeItem","getSessionStorage","getOrCreateSessionId","setupEventListeners","trackPageLoad","storageKey","existingId","getItem","newId","getSessionId","scrollTimeout","resizeTimeout","forEach","eventType","document","captureEvent","serializeDOMEvent","capture","passive","type","hidden","clearTimeout","setTimeout","x","scrollX","y","scrollY","width","innerWidth","height","innerHeight","duration","flush","target","tagName","className","textContent","shouldMaskText","slice","coordinates","clientX","clientY","inputEvent","value","shouldMaskInput","element","privacy","maskInputs","includes","name","toLowerCase","some","sensitive","replay","maskAllText","maskSelector","matches","captureLoadEvent","title","referrer","loadTime","performance","readyState","sessionSampleRate","filteredEvent","beforeSendSession","getEvents","clearEvents","endSession","NetworkMonitor","originalFetch","fetch","originalXHROpen","XMLHttpRequest","prototype","open","originalXHRSend","send","setupInterceptors","interceptFetch","interceptXHR","async","method","toUpperCase","shouldMonitorRequest","traceHeaders","modifiedArgs","requestBody","requestSize","body","serializeRequestBody","calculateBodySize","response","responseBody","responseSize","shouldCaptureResponseBody","clonedResponse","clone","extractResponseBody","calculateResponseSize","responseTrace","extractResponseHeaders","statusCode","status","responseTime","captureNetworkEvent","requestHeaders","extractHeaders","responseHeaders","String","self","_reviData","shouldMonitor","reviData","responseType","responseText","FormData","formObject","key","File","URLSearchParams","Object","fromEntries","parse","contentType","json","text","Headers","headerObj","isArray","ArrayBuffer","byteLength","Blob","size","pattern","test","normalizedApiUrl","apiUrl","startsWith","developmentHosts","find","excludeUrls","denyUrls","RegExp","allowUrls","destroy","IndexedDBStorage","db","dbName","version","storeName","maxQueueSize","maxAge","initialize","indexedDB","Promise","resolve","reject","request","onerror","onsuccess","result","onupgradeneeded","objectStoreNames","contains","objectStore","createObjectStore","keyPath","createIndex","unique","store","cleanupExpiredItems","queueSize","getQueueSize","removeOldestItems","item","compress","compressed","transaction","add","getAll","items","errors","sessionEvents","networkEvents","decompressedData","decompress","clear","count","cutoffTime","index","range","IDBKeyRange","upperBound","openCursor","cursor","continue","deletedCount","btoa","unescape","encodeURIComponent","decoded","decodeURIComponent","escape","atob","parseError","substr","LocalStorageAdapter","localStorage","getLocalStorage","existing","storedData","StorageManager","isInitialized","localStorageError","NoOpStorage","storeErrors","ensureInitialized","storeSessionEvents","storeNetworkEvents","getAllData","clearAll","NetworkManager","isOnline","onLine","connectionType","listeners","notifyListeners","detectConnectionType","getConnectionStatus","online","onConnectionChange","callback","indexOf","getBatchSize","getUploadDelay","shouldRetry","attempt","getRetryDelay","min","pow","connection","effectiveType","testConnectivity","testUrl","mode","cache","compressData","jsonString","CompressionStream","stream","writer","writable","getWriter","reader","readable","getReader","bytes","TextEncoder","encode","write","close","done","readerDone","read","compressedBytes","reduce","acc","chunk","offset","base64","fromCharCode","deduplicateEvents","compressionRatio","originalSize","grouped","keys","sort","has","groupedEvents","commonValues","keyArray","values","e","firstValue","every","v","compressedEvent","_common","createOptimalBatches","maxBatchSize","maxBatchBytes","batches","currentBatch","currentBatchSize","eventSize","DataManager","uploadTimer","isUploading","retryAttempts","uploadQueue","storageManager","networkManager","loadQueueFromStorage","startNetworkAwareUploadTimer","setupBeforeUnloadHandler","setupNetworkChangeHandler","saveQueueToStorage","scheduleNextUpload","delay","hasQueuedData","uploadData","finally","uploadDataSync","queueError","catch","err","queueSessionEvents","queueNetworkEvents","batchSize","dedupedErrors","errorBatches","batch","uploadErrorsWithRetry","dedupedEvents","sessionBatches","uploadSessionEventsWithRetry","networkBatches","uploadNetworkEventsWithRetry","createBatches","sendBeacon","payload","session_id","event_type","uploadErrors","stack_trace","user_agent","metadata","compressedData","apiKey","ok","uploadSessionEvents","uploadNetworkEvents","promises","status_code","response_time","request_data","response_data","failures","allSettled","executeWithRetry","operation","currentAttempt","clearQueue","UserJourneyTracker","journeyEvents","isTracking","deviceFingerprint","generateDeviceFingerprint","sessionStartTime","currentPageStartTime","setupJourneyTracking","startTracking","trackPageView","stopTracking","setUserId","viewport","scroll_position","device_fingerprint","language","timezone","Intl","DateTimeFormat","resolvedOptions","timeZone","connection_type","getConnectionType","addJourneyEvent","trackClick","journeyEvent","tag","class","getElementText","attributes","getRelevantAttributes","page_x","pageX","page_y","pageY","trackFormSubmit","form","formData","fields","input","querySelector","has_value","value_length","action","field_count","trackApiCall","duration_ms","api","success","page_context","time_on_page","trackError","context","user_context","session_duration","page_interactions","countPageInteractions","custom_context","currentUrl","handleNavigation","timeSpent","updateLastPageViewDuration","originalPushState","history","pushState","originalReplaceState","replaceState","shouldTrackClick","setInterval","components","screen","colorDepth","platform","cookieEnabled","canvas","createElement","ctx","getContext","textBaseline","font","fillText","toDataURL","fingerprint","hash","charCodeAt","abs","sendJourneyEvents","unshift","user_id","hasAttribute","innerText","substring","attrs","attr","getAttribute","lastEvent","SamplingManager","activityLevel","lastActivity","errorFrequency","performanceImpact","startPerformanceMonitoring","assessPerformanceImpact","recentLongTasks","getEntriesByType","entry","updateActivityLevel","activity","high","medium","low","idle","incrementErrorFrequency","max","shouldSampleError","baseSampleRate","sampling","errorSampleRate","adjustedRate","shouldSampleSession","finalRate","shouldSamplePerformance","performanceSampleRate","shouldSampleNetwork","networkSampleRate","shouldSampleReplay","replaySampleRate","getAdaptiveBatchSize","baseSize","getAdaptiveUploadDelay","baseDelay","shouldSkipCapture","getPerformanceImpact","getActivityLevel","getErrorFrequency","PerformanceMonitor","webVitals","performanceEntries","captureWebVitals","setupWebVitals","captureResourceTiming","setupResourceTiming","captureNavigationTiming","setupNavigationTiming","PerformanceObserver","list","getEntries","lcp","observe","entryTypes","fid","processingStart","clsValue","hadRecentInput","cls","fcp","calculateTTFB","navigationTiming","ttfb","responseStart","requestStart","entryType","transferSize","encodedBodySize","decodedBodySize","domContentLoadedEventEnd","domContentLoadedEventStart","loadEventEnd","loadEventStart","domComplete","domInteractive","getWebVitals","getPerformanceEntries","clearPerformanceEntries","mark","measure","startMark","endMark","getEntriesByName","DOMSerializer","nodeIdMap","WeakMap","nodeMap","nextNodeId","isObserving","takeSnapshot","snapshot","scroll","nodes","stylesheets","resources","serializeDocument","serializeStylesheets","serializeResources","startObserving","onDOMChange","observer","MutationObserver","handleMutations","bind","childList","characterData","subtree","attributeOldValue","characterDataOldValue","stopObserving","disconnect","doc","doctype","publicId","systemId","getNodeId","documentElement","serialized","serializeNode","node","shouldIgnoreNode","nodeId","getNodeType","nodeType","Node","ELEMENT_NODE","serializeAttributes","children","serializeChildren","TEXT_NODE","textNode","COMMENT_NODE","shouldIgnoreAttribute","shouldMaskAttribute","childNodes","serializedChild","styleSheets","stylesheet","cssText","cssRules","rule","disabled","querySelectorAll","img","src","shouldIgnoreResource","failed","complete","naturalWidth","backgroundImage","getComputedStyle","urlMatch","match","mutations","mutation","targetId","change","addedNodes","removedNodes","attributeName","attributeValue","oldValue","DOCUMENT_NODE","blockSelector","parent","parentElement","urlObj","URL","protocol","params","search","parseInt","ConsoleRecorder","originalMethods","isRecording","maxEntries","captureStackTrace","serializeObjects","maxObjectDepth","maxStringLength","ignoredLevels","start","originalMethod","recordEntry","stop","serializeArgs","cleanStackTrace","sourceLine","lineNumber","columnNumber","addEntry","arg","serializeValue","depth","__type","toISOString","fromTimestamp","toTimestamp","filtered","getEntriesByLevel","toSessionEvents","consoleId","exportData","levelCounts","minTime","Infinity","maxTime","stats","totalEntries","errorCount","warningCount","timeRange","end","generateInsights","errorPatterns","findErrorPatterns","performanceIssues","detectPerformanceIssues","recommendations","generateRecommendations","patterns","firstArg","a","b","examples","issues","recentEntries","severity","details","errorCounts","debug","HeatmapGenerator","container","radius","maxIntensity","gradient","blur","minOpacity","maxOpacity","style","position","top","left","pointerEvents","zIndex","appendChild","resizeCanvas","rect","getBoundingClientRect","addDataPoint","intensity","generateFromEvents","_e","_f","render","clearRect","filteredData","d","intensityData","createIntensityMap","createGradient","renderHeatmap","shadowCanvas","shadowCtx","point","createRadialGradient","addColorStop","fillStyle","fillRect","drawImage","getImageData","gradientCanvas","gradientCtx","createLinearGradient","color","parseFloat","gradientData","output","createImageData","alpha","gradientIndex","putImageData","removeChild","removeEventListener","eventTypes","minX","maxX","minY","maxY","totalEvents","bounds","hotSpots","findHotSpots","clickPatterns","analyzeClickPatterns","userBehavior","analyzeUserBehavior","clusters","clusterRadius","foundCluster","cluster","sqrt","round","clicks","current","next","frequency","scrolls","sortedByIntensity","topHalf","scrollDepth","s","engagementScore","mostActiveArea","averageClicksPerSession","SessionReplayManager","heatmapGenerator","consoleLogs","networkRequests","originalConsole","domSerializer","consoleRecorder","maxConsoleEntries","ignoredConsoleLevels","_g","enabled","setupReplay","_j","_h","heatmaps","_l","_k","_o","_m","_q","_p","_s","_r","startRecording","takeFullSnapshot","handleDOMChange","setupNetworkCapture","setupInteractionTracking","stopRecording","restoreOriginalNetwork","getReplayData","consoleEntries","consoleInsights","heatmapData","heatmapInsights","console_logs","network_requests","heatmap_data","session_info","start_time","page_url","analytics","console_insights","heatmap_insights","clearReplayData","addCustomEvent","addEvent","source","toggleHeatmap","visible","getHeatmapInsights","init","requestId","generateRequestId","Request","getRequestHeaders","networkRequest","getResponseHeaders","originalXMLHttpRequest","xhr","originalOpen","originalSend","m","u","shouldCaptureXHRResponse","getElementId","shouldIgnoreKeystroke","sanitizeKey","code","serializeConsoleArgs","assign","contentLength","getResponseHeader","Monitor","process","env","REVI_API_URL","maskPasswords","maskCreditCards","maskAllInputs","errorHandler","sessionManager","networkMonitor","performanceMonitor","dataManager","userJourneyTracker","sessionReplayManager","samplingManager","setupAdaptiveFlush","lastFlushTime","adaptiveFlush","timeSinceLastFlush","flushInterval","originalCaptureException","startSessionReplay","stopSessionReplay","getSessionReplayData","RetryManager","retryStats","retryBudgetUsed","lastBudgetReset","budgetResetInterval","requestDeduplication","rateLimitedUntil","maxAttempts","maxDelay","jitterRatio","timeoutMultiplier","retryBudget","enableJitter","priority","timeout","payloadSize","deduplicationKey","resetBudgetIfNeeded","hasBudgetAvailable","getOrCreateStats","executePromise","performRetryLoop","attempts","attemptStart","createRetryableError","executeWithTimeout","totalAttempts","successfulRetries","lastSuccess","attemptRecord","retryableError","classifyError","lastFailure","handleRateLimit","failedRetries","calculateDelay","totalDelay","sum","att","averageDelay","sleep","consumeRetryBudget","race","_","retryable","critical","retryAfter","retryAfterMs","budgetUsed","ms","getStats","resetStats","isRateLimited","getRemainingBudget","updateConfig","newConfig","CircuitBreaker","state","requestWindow","failureThreshold","recoveryTime","successThreshold","maxFailureRate","windowSize","minRequests","metrics","requests","successes","failureRate","averageResponseTime","execute","fallback","nextRetryTime","transitionToHalfOpen","recordSuccess","recordFailure","fallbackError","cleanupOldRequests","updateMetrics","lastSuccessTime","transitionToClosed","lastFailureTime","shouldOpen","transitionToOpen","openTime","req","totalRequests","successfulRequests","failedRequests","totalDuration","getMetrics","getState","forceState","reset","onStateChange","CircuitBreakerManager","circuitBreakers","featureConfigs","degradedFeatures","Set","globalCircuitBreaker","enableEmergencyMode","disableEmergencyMode","registerFeature","feature","circuitBreaker","handleFeatureStateChange","executeProtected","featureName","featureBreaker","featureConfig","gracefulDegradation","evaluateSystemHealth","totalFeatures","cb","enableProgressiveDegradation","disableProgressiveDegradation","breaker","getSystemHealth","featuresTotal","featuresFailed","featuresHealthy","featuresDegraded","globalState","emergencyMode","progressiveDegradation","getAllMetrics","getCircuitBreaker","isFeatureDegraded","resetAll","onEvent","executeWithBreaker","degradeGracefully","degradedResponse","fallbackEnabled","updateGlobalConfig","getGlobalStats","global","features","systemHealth","ResilientStorage","tiers","memoryStore","initialized","compressionWorker","initializeTiers","quotaManager","StorageQuotaManager","initializeCompressionWorker","maxSize","compressionEnabled","encryptionEnabled","retentionTime","Worker","blob","createObjectURL","all","initializeIndexedDB","initializeLocalStorage","startBackgroundCleanup","ttl","forceSync","dataSize","calculateSize","tier","selectOptimalTier","encrypted","retryCount","expiresAt","checksum","calculateChecksum","storeInTier","checkQuotaAvailable","makeSpace","storeInMemory","storeInIndexedDB","storeInLocalStorage","getStoreNameFromId","put","processedData","encryptData","retrieve","tierName","retrieveFromTier","validateItemIntegrity","shouldPromote","promoteItem","retrieveFromIndexedDB","retrieveFromLocalStorage","decompressed","decompressData","itemJson","decryptData","getAllByType","tierItems","getAllFromTier","priorityOrder","priorityDiff","getAllFromIndexedDB","getAllFromLocalStorage","getStoreName","remove","keysToRemove","requiredSize","getUsage","available","evictLowPriorityItems","stores","cleanupIndexedDBStore","cleanupLocalStorage","evictedSize","sortedItems","str","hotTier","handleMessage","postMessage","encryptedData","storeData","storageProviders","getData","parsed","deleteData","getAllDataByPattern","results","regex","totalItems","totalSize","itemsByPriority","itemsByTier","hot","warm","cold","quotaUsage","getTotalUsage","tierUsage","itemCount","sizeBytes","quotaUsed","quotas","estimate","total","quota","used","usage","percentage","EndpointHealthMonitor","checkInterval","requestHistory","isRunning","interval","endpoint","expectedStatus","recoveryThreshold","degradationThreshold","initializeMetrics","successRate","errorRate","availability","lastCheck","consecutiveFailures","consecutiveSuccesses","p95ResponseTime","p99ResponseTime","totalErrors","uptime","downtime","scheduleCheck","performHealthCheck","checkStartTime","executeHealthCheck","attemptError","checkError","recordCheckResult","controller","AbortController","timeoutId","abort","signal","cleanupOldHistory","calculateHealthStatus","shift","windowRequests","windowSuccesses","windowErrors","totalTime","sorted","trend","confidence","recentHalf","earlierHalf","recentSuccessRate","earlierSuccessRate","lastChecked","getHealthStatus","forceCheck","onStatusChange","oldInterval","MultiRegionalHealthMonitor","regionalMonitors","primaryRegion","failoverHistory","adaptiveBehavior","AdaptiveBehavior","registerRegion","region","monitor","handleRegionalStatusChange","startAll","stopAll","performFailover","recordRegionalHealth","fromRegion","availableRegions","aHealth","bHealth","newPrimaryRegion","to","recordFailover","getPrimaryRegion","getAllRegionalHealth","lastFailover","f","getFailoverHistory","getAdaptiveBehaviorRecommendations","getRecommendations","forceFailover","toRegion","allStats","avgLatency","averageLatency","avgErrorRate","regions","endpoints","totalChecks","averageErrorRate","failovers","regionalHealthHistory","failoverPatterns","adaptiveSettings","uploadFrequency","updateAdaptiveSettings","reasoning","IntelligentSyncManager","healthMonitor","currentSync","syncContext","abortController","syncHistory","retryManager","maxConcurrentBatches","priorityWeights","bandwidthThrottling","progressiveSync","conflictResolution","maxSyncTime","resumeIncomplete","apiEndpoint","setupNetworkListeners","handleNetworkReconnection","startIntelligentSync","generateSessionId","deviceId","getDeviceId","lastSyncTimestamp","getLastSyncTimestamp","offlineDuration","networkQuality","assessNetworkQuality","batteryLevel","getBatteryLevel","isBackground","performIntelligentSync","recordSyncHistory","progress","phase","syncedItems","failedItems","totalBatches","estimatedTimeRemaining","bytesTransferred","totalBytes","notifyProgress","syncPlan","prepareSyncPlan","executeSyncBatches","conflicts","resolveConflicts","updateLastSyncTimestamp","sessions","itemsToSync","priorityWeight","adaptedBatchSize","calculateAdaptiveBatchSize","createIntelligentBatches","detectConflicts","adaptedSize","priorityGroups","groupItems","batchItems","estimatedBytes","concurrentBatches","activeBatches","p","isPromisePending","aborted","batchPromise","syncBatch","updateEstimatedTime","batchNumber","errorItems","sessionItems","networkItems","syncErrorItems","syncSessionItems","syncNetworkItems","client_timestamp","retry_count","offline_duration","sessionGroups","localItem","conflictType","resolution","resolvedWith","conflict","elapsedTime","cancelSync","getCurrentProgress","isSyncRunning","onProgress","stored","health","itemsSynced","promise","getSyncHistory","getConfig","activeSyncs","lastSync","totalSyncs","successfulSyncs","IdempotencyManager","requestMap","responseCache","pendingRequests","keyCleanupInterval","deduplicatedRequests","cacheHits","activePendingRequests","memoryUsage","keyCleanups","keyTTL","maxConcurrentRequests","enableResponseCaching","responseCacheTTL","enableRequestFingerprinting","maxStoredKeys","startKeyCleanup","executeIdempotent","generateRequestFingerprint","bypassCache","cachedResponse","getCachedResponse","existingRequest","lastAttemptAt","idempotentRequest","createdAt","pendingCount","performIdempotentOperation","updateStats","completedAt","cacheResponse","normalizeHeaders","bodyHash","hashRequestBody","normalized","importantHeaders","normalizedKey","bodyString","cached","cachedAt","oldestKey","generateIdempotencyKey","isPending","getRequestInfo","cancelRequest","cleanupExpiredEntries","cleanedCount","excess","oldestKeys","clearInterval","currentMode","adaptationCount","lastAdaptation","performanceHistory","retry","sync","idempotency","enableAdaptiveBehavior","performanceThresholds","slowRequestMs","verySlowRequestMs","highErrorRate","criticalErrorRate","circuitBreakerManager","syncManager","idempotencyManager","startAdaptiveBehaviorMonitoring","executeResilientRequest","idempotencyKey","executeWithRetryAndHealth","recordPerformance","shouldStoreForLaterSync","storeForLaterSync","healthRecommendation","getAdaptiveRecommendation","adaptedOptions","adaptRequestToHealth","adapted","adjustedTimeout","useDeduplication","requestData","encrypt","syncFailedRequests","dependencies","timeoutMs","evaluateAndAdaptBehavior","recentPerformance","getRecentPerformance","averageDuration","newMode","applyAdaptiveBehaviorMode","recoveryTimeout","oneHourAgo","timeWindowMs","resetAllStats"],"mappings":"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"}