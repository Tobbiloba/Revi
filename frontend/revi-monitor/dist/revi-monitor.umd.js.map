{"version":3,"file":"revi-monitor.umd.js","sources":["../src/utils.ts","../src/trace-manager.ts","../src/error-handler.ts","../src/session.ts","../src/network-monitor.ts","../src/performance-monitor.ts","../src/indexed-db-storage.ts","../src/storage-manager.ts","../src/network-manager.ts","../src/data-manager.ts","../src/user-journey.ts","../src/dom-serializer.ts","../src/console-recorder.ts","../src/heatmap-generator.ts","../src/session-replay.ts","../src/monitor.ts"],"sourcesContent":["export function generateId(): string {\n  return 'xxxx-xxxx-4xxx-yxxx-xxxx'.replace(/[xy]/g, function(c) {\n    const r = Math.random() * 16 | 0;\n    const v = c === 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\nexport function formatStackTrace(error: Error): string {\n  if (!error.stack) return '';\n  \n  return error.stack\n    .split('\\n')\n    .map(line => line.trim())\n    .filter(line => line.length > 0)\n    .join('\\n');\n}\n\nexport function sanitizeUrl(url: string, allowUrls: string[] = [], denyUrls: string[] = []): string {\n  // Check deny list first\n  if (denyUrls.some(pattern => new RegExp(pattern).test(url))) {\n    return '[Filtered]';\n  }\n  \n  // If allow list is provided, ensure URL matches\n  if (allowUrls.length > 0 && !allowUrls.some(pattern => new RegExp(pattern).test(url))) {\n    return '[Filtered]';\n  }\n  \n  // Remove sensitive query parameters\n  try {\n    const urlObj = new URL(url);\n    const sensitiveParams = ['password', 'token', 'key', 'secret', 'auth', 'api_key'];\n    \n    sensitiveParams.forEach(param => {\n      if (urlObj.searchParams.has(param)) {\n        urlObj.searchParams.set(param, '[Filtered]');\n      }\n    });\n    \n    return urlObj.toString();\n  } catch {\n    return url;\n  }\n}\n\nexport function maskSensitiveData(data: any, maskInputs = true): any {\n  if (typeof data !== 'object' || data === null) {\n    return data;\n  }\n  \n  if (Array.isArray(data)) {\n    return data.map(item => maskSensitiveData(item, maskInputs));\n  }\n  \n  const masked: any = {};\n  const sensitiveKeys = ['password', 'token', 'key', 'secret', 'auth', 'api_key', 'credit_card', 'ssn'];\n  \n  Object.keys(data).forEach(key => {\n    const lowerKey = key.toLowerCase();\n    if (sensitiveKeys.some(sensitive => lowerKey.includes(sensitive))) {\n      masked[key] = '[Masked]';\n    } else if (typeof data[key] === 'object') {\n      masked[key] = maskSensitiveData(data[key], maskInputs);\n    } else {\n      masked[key] = data[key];\n    }\n  });\n  \n  return masked;\n}\n\nexport function debounce<T extends (...args: any[]) => any>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout;\n  \n  return function executedFunction(...args: Parameters<T>) {\n    const later = () => {\n      clearTimeout(timeout);\n      func(...args);\n    };\n    \n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n}\n\nexport function throttle<T extends (...args: any[]) => any>(\n  func: T,\n  limit: number\n): (...args: Parameters<T>) => void {\n  let inThrottle = false;\n  \n  return function executedFunction(...args: Parameters<T>) {\n    if (!inThrottle) {\n      func(...args);\n      inThrottle = true;\n      setTimeout(() => inThrottle = false, limit);\n    }\n  };\n}\n\nexport function isBot(): boolean {\n  if (typeof navigator === 'undefined') return false;\n  \n  const botPatterns = [\n    /bot/i,\n    /spider/i,\n    /crawl/i,\n    /headless/i,\n    /phantom/i,\n    /selenium/i\n  ];\n  \n  return botPatterns.some(pattern => pattern.test(navigator.userAgent));\n}\n\nexport function getSessionStorage(): Storage | null {\n  try {\n    if (typeof window !== 'undefined' && window.sessionStorage) {\n      window.sessionStorage.setItem('test', 'test');\n      window.sessionStorage.removeItem('test');\n      return window.sessionStorage;\n    }\n  } catch {\n    // Storage not available\n  }\n  return null;\n}\n\nexport function getLocalStorage(): Storage | null {\n  try {\n    if (typeof window !== 'undefined' && window.localStorage) {\n      window.localStorage.setItem('test', 'test');\n      window.localStorage.removeItem('test');\n      return window.localStorage;\n    }\n  } catch {\n    // Storage not available\n  }\n  return null;\n}\n","export class TraceManager {\n  private currentTraceId?: string;\n  private currentSpanId?: string;\n  private spanCounter = 0;\n\n  constructor() {\n    // Initialize with session-level trace ID if needed\n    this.generateNewTrace();\n  }\n\n  generateNewTrace(): string {\n    this.currentTraceId = this.generateTraceId();\n    this.currentSpanId = undefined;\n    this.spanCounter = 0;\n    return this.currentTraceId;\n  }\n\n  startSpan(operationName?: string): string {\n    const parentSpanId = this.currentSpanId;\n    this.currentSpanId = this.generateSpanId();\n    this.spanCounter++;\n    \n    // Store span context for later correlation\n    if (operationName) {\n      this.setSpanData(operationName, { \n        parentSpanId,\n        operationName,\n        startTime: Date.now()\n      });\n    }\n\n    return this.currentSpanId;\n  }\n\n  finishSpan(spanId?: string, data?: Record<string, any>): void {\n    if (spanId && this.currentSpanId === spanId) {\n      // Mark span as finished\n      if (data) {\n        this.setSpanData(spanId, { \n          ...this.getSpanData(spanId),\n          ...data,\n          endTime: Date.now()\n        });\n      }\n    }\n  }\n\n  getCurrentTraceId(): string | undefined {\n    return this.currentTraceId;\n  }\n\n  getCurrentSpanId(): string | undefined {\n    return this.currentSpanId;\n  }\n\n  getTraceContext(): { traceId?: string; spanId?: string; parentSpanId?: string } {\n    return {\n      traceId: this.currentTraceId,\n      spanId: this.currentSpanId,\n      parentSpanId: this.getParentSpanId()\n    };\n  }\n\n  // Extract trace ID from headers (for network requests)\n  extractTraceFromHeaders(headers: Record<string, string>): { traceId?: string; spanId?: string } {\n    // Support various tracing standards\n    const traceId = headers['x-trace-id'] || \n                   headers['traceparent']?.split('-')[1] ||\n                   headers['b3-traceid'] ||\n                   headers['uber-trace-id']?.split(':')[0];\n\n    const spanId = headers['x-span-id'] || \n                  headers['traceparent']?.split('-')[2] ||\n                  headers['b3-spanid'] ||\n                  headers['uber-trace-id']?.split(':')[1];\n\n    return { traceId, spanId };\n  }\n\n  // Inject trace headers for outgoing requests\n  injectTraceHeaders(): Record<string, string> {\n    if (!this.currentTraceId) {\n      return {};\n    }\n\n    const headers: Record<string, string> = {};\n    \n    // Add custom headers\n    headers['x-trace-id'] = this.currentTraceId;\n    if (this.currentSpanId) {\n      headers['x-span-id'] = this.currentSpanId;\n      headers['x-parent-span-id'] = this.getParentSpanId() || '';\n    }\n\n    // Add W3C Trace Context (traceparent header)\n    if (this.currentSpanId) {\n      headers['traceparent'] = `00-${this.currentTraceId}-${this.currentSpanId}-01`;\n    }\n\n    return headers;\n  }\n\n  // Correlate with backend trace (when available)\n  correlateWithBackendTrace(backendTraceId?: string, backendSpanId?: string): void {\n    if (backendTraceId) {\n      this.currentTraceId = backendTraceId;\n    }\n    if (backendSpanId) {\n      this.currentSpanId = backendSpanId;\n    }\n  }\n\n  private generateTraceId(): string {\n    // Generate 128-bit trace ID (32 hex characters)\n    return this.generateRandomHex(32);\n  }\n\n  private generateSpanId(): string {\n    // Generate 64-bit span ID (16 hex characters)\n    return this.generateRandomHex(16);\n  }\n\n  private generateRandomHex(length: number): string {\n    const array = new Uint8Array(length / 2);\n    if (typeof crypto !== 'undefined' && crypto.getRandomValues) {\n      crypto.getRandomValues(array);\n    } else {\n      // Fallback for environments without crypto\n      for (let i = 0; i < array.length; i++) {\n        array[i] = Math.floor(Math.random() * 256);\n      }\n    }\n    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');\n  }\n\n  private getParentSpanId(): string | undefined {\n    // This would typically track a span stack, simplified for now\n    return this.spanData.get(this.currentSpanId || '')?.parentSpanId;\n  }\n\n  private spanData = new Map<string, any>();\n\n  private setSpanData(spanId: string, data: any): void {\n    this.spanData.set(spanId, data);\n  }\n\n  private getSpanData(spanId: string): any {\n    return this.spanData.get(spanId) || {};\n  }\n\n  // Clean up old span data to prevent memory leaks\n  cleanupSpanData(): void {\n    const cutoff = Date.now() - 5 * 60 * 1000; // 5 minutes ago\n    for (const [spanId, data] of this.spanData.entries()) {\n      if (data.endTime && data.endTime < cutoff) {\n        this.spanData.delete(spanId);\n      }\n    }\n  }\n}","import { formatStackTrace, generateId } from './utils';\nimport type { ErrorEvent, Breadcrumb, ReviConfig } from './types';\nimport { TraceManager } from './trace-manager';\n\nexport class ErrorHandler {\n  private config: ReviConfig;\n  private breadcrumbs: Breadcrumb[] = [];\n  private userContext: any = {};\n  private traceManager: TraceManager;\n\n  constructor(config: ReviConfig, traceManager?: TraceManager) {\n    this.config = config;\n    this.traceManager = traceManager || new TraceManager();\n    this.setupGlobalHandlers();\n  }\n\n  private setupGlobalHandlers(): void {\n    if (typeof window === 'undefined') return;\n\n    // Global error handler\n    window.addEventListener('error', (event) => {\n      this.captureError({\n        message: event.message,\n        filename: event.filename,\n        lineno: event.lineno,\n        colno: event.colno,\n        error: event.error\n      });\n    });\n\n    // Unhandled promise rejections\n    window.addEventListener('unhandledrejection', (event) => {\n      const error = event.reason;\n      let message = 'Unhandled Promise Rejection';\n      let stack = '';\n\n      if (error instanceof Error) {\n        message = error.message;\n        stack = formatStackTrace(error);\n      } else if (typeof error === 'string') {\n        message = error;\n      } else {\n        message = JSON.stringify(error);\n      }\n\n      this.captureError({\n        message,\n        stack,\n        error\n      });\n    });\n\n    // Console error interception\n    const originalConsoleError = console.error;\n    console.error = (...args: any[]) => {\n      this.addBreadcrumb({\n        timestamp: Date.now(),\n        message: args.join(' '),\n        category: 'console',\n        level: 'error'\n      });\n      originalConsoleError.apply(console, args);\n    };\n\n    // Console warn interception\n    const originalConsoleWarn = console.warn;\n    console.warn = (...args: any[]) => {\n      this.addBreadcrumb({\n        timestamp: Date.now(),\n        message: args.join(' '),\n        category: 'console',\n        level: 'warning'\n      });\n      originalConsoleWarn.apply(console, args);\n    };\n  }\n\n  captureError(errorData: {\n    message: string;\n    stack?: string;\n    filename?: string;\n    lineno?: number;\n    colno?: number;\n    error?: Error;\n    level?: 'error' | 'warning' | 'info' | 'debug';\n    tags?: Record<string, string>;\n    extra?: Record<string, any>;\n  }): string {\n    // Apply sampling\n    if (this.config.sampleRate && Math.random() > this.config.sampleRate) {\n      return '';\n    }\n\n    const errorId = generateId();\n    \n    // Start a new span for this error\n    const spanId = this.traceManager.startSpan(`error:${errorData.message}`);\n    const traceContext = this.traceManager.getTraceContext();\n    \n    const errorEvent: ErrorEvent = {\n      id: errorId,\n      timestamp: Date.now(),\n      message: errorData.message,\n      stack: errorData.stack || (errorData.error ? formatStackTrace(errorData.error) : undefined),\n      url: errorData.filename || window.location.href,\n      lineno: errorData.lineno,\n      colno: errorData.colno,\n      filename: errorData.filename,\n      userId: this.config.userId || this.userContext.id,\n      sessionId: '', // Will be set by Monitor class\n      userAgent: navigator.userAgent,\n      environment: this.config.environment,\n      release: this.config.release,\n      tags: errorData.tags,\n      extra: errorData.extra,\n      breadcrumbs: [...this.breadcrumbs],\n      level: errorData.level || 'error',\n      traceId: traceContext.traceId,\n      spanId: spanId,\n      parentSpanId: traceContext.parentSpanId\n    };\n\n    // Apply beforeSend filter\n    const filteredError = this.config.beforeSend?.(errorEvent) || errorEvent;\n    if (!filteredError) return '';\n\n    return errorId;\n  }\n\n  captureException(error: Error, options: {\n    level?: 'error' | 'warning' | 'info' | 'debug';\n    tags?: Record<string, string>;\n    extra?: Record<string, any>;\n  } = {}): string {\n    return this.captureError({\n      message: error.message,\n      stack: formatStackTrace(error),\n      error,\n      level: options.level,\n      tags: options.tags,\n      extra: options.extra\n    });\n  }\n\n  captureMessage(message: string, options: {\n    level?: 'error' | 'warning' | 'info' | 'debug';\n    tags?: Record<string, string>;\n    extra?: Record<string, any>;\n  } = {}): string {\n    return this.captureError({\n      message,\n      level: options.level || 'info',\n      tags: options.tags,\n      extra: options.extra\n    });\n  }\n\n  addBreadcrumb(breadcrumb: Breadcrumb): void {\n    this.breadcrumbs.push(breadcrumb);\n    \n    const maxBreadcrumbs = this.config.maxBreadcrumbs || 50;\n    if (this.breadcrumbs.length > maxBreadcrumbs) {\n      this.breadcrumbs.splice(0, this.breadcrumbs.length - maxBreadcrumbs);\n    }\n  }\n\n  setUserContext(user: any): void {\n    this.userContext = { ...this.userContext, ...user };\n  }\n\n  setTags(tags: Record<string, string>): void {\n    // Tags will be applied to future errors\n  }\n\n  setExtra(extra: Record<string, any>): void {\n    // Extra data will be applied to future errors\n  }\n\n  getBreadcrumbs(): Breadcrumb[] {\n    return [...this.breadcrumbs];\n  }\n\n  clearBreadcrumbs(): void {\n    this.breadcrumbs = [];\n  }\n}\n","import { generateId, getSessionStorage } from './utils';\nimport type { SessionEvent, ReviConfig } from './types';\nimport { TraceManager } from './trace-manager';\n\nexport class SessionManager {\n  private sessionId: string;\n  private startTime: number;\n  private events: SessionEvent[] = [];\n  private config: ReviConfig;\n  private storage: Storage | null;\n  private traceManager?: TraceManager;\n\n  constructor(config: ReviConfig, traceManager?: TraceManager) {\n    this.config = config;\n    this.traceManager = traceManager;\n    this.storage = getSessionStorage();\n    this.sessionId = this.getOrCreateSessionId();\n    this.startTime = Date.now();\n    \n    this.setupEventListeners();\n    this.trackPageLoad();\n  }\n\n  private getOrCreateSessionId(): string {\n    const storageKey = 'revi_session_id';\n    \n    if (this.storage) {\n      const existingId = this.storage.getItem(storageKey);\n      if (existingId) return existingId;\n    }\n    \n    const newId = generateId();\n    if (this.storage) {\n      this.storage.setItem(storageKey, newId);\n    }\n    \n    return newId;\n  }\n\n  getSessionId(): string {\n    return this.sessionId;\n  }\n\n  private setupEventListeners(): void {\n    if (typeof window === 'undefined') return;\n\n    // DOM events\n    const eventTypes = ['click', 'input', 'change', 'submit', 'focus', 'blur'];\n    eventTypes.forEach(eventType => {\n      document.addEventListener(eventType, (event) => {\n        this.captureEvent(eventType, this.serializeDOMEvent(event));\n      }, { capture: true, passive: true });\n    });\n\n    // Navigation events\n    window.addEventListener('popstate', () => {\n      this.captureEvent('navigation', {\n        type: 'popstate',\n        url: window.location.href,\n        timestamp: Date.now()\n      });\n    });\n\n    // Page visibility\n    document.addEventListener('visibilitychange', () => {\n      this.captureEvent('visibility', {\n        hidden: document.hidden,\n        timestamp: Date.now()\n      });\n    });\n\n    // Scroll events (throttled)\n    let scrollTimeout: NodeJS.Timeout;\n    window.addEventListener('scroll', () => {\n      clearTimeout(scrollTimeout);\n      scrollTimeout = setTimeout(() => {\n        this.captureEvent('scroll', {\n          x: window.scrollX,\n          y: window.scrollY,\n          timestamp: Date.now()\n        });\n      }, 100);\n    }, { passive: true });\n\n    // Resize events (throttled)\n    let resizeTimeout: NodeJS.Timeout;\n    window.addEventListener('resize', () => {\n      clearTimeout(resizeTimeout);\n      resizeTimeout = setTimeout(() => {\n        this.captureEvent('resize', {\n          width: window.innerWidth,\n          height: window.innerHeight,\n          timestamp: Date.now()\n        });\n      }, 100);\n    }, { passive: true });\n\n    // Before unload\n    window.addEventListener('beforeunload', () => {\n      this.captureEvent('beforeunload', {\n        timestamp: Date.now(),\n        duration: Date.now() - this.startTime\n      });\n      this.flush();\n    });\n  }\n\n  private serializeDOMEvent(event: Event): Record<string, any> {\n    const target = event.target as HTMLElement;\n    if (!target) return {};\n\n    const data: Record<string, any> = {\n      type: event.type,\n      timestamp: Date.now(),\n      target: {\n        tagName: target.tagName,\n        id: target.id,\n        className: target.className,\n        textContent: this.shouldMaskText(target) ? '[Masked]' : target.textContent?.slice(0, 100)\n      }\n    };\n\n    // Add specific event data\n    if (event.type === 'click') {\n      const mouseEvent = event as MouseEvent;\n      data.coordinates = {\n        x: mouseEvent.clientX,\n        y: mouseEvent.clientY\n      };\n    }\n\n    if (event.type === 'input' || event.type === 'change') {\n      const inputEvent = event.target as HTMLInputElement;\n      if (inputEvent && inputEvent.value !== undefined) {\n        data.value = this.shouldMaskInput(inputEvent) ? '[Masked]' : inputEvent.value;\n      }\n    }\n\n    return data;\n  }\n\n  private shouldMaskInput(element: HTMLInputElement): boolean {\n    if (!this.config.privacy?.maskInputs) return false;\n    \n    const sensitiveTypes = ['password', 'email', 'tel', 'credit-card-number'];\n    const sensitiveNames = ['password', 'email', 'phone', 'credit', 'card', 'ssn'];\n    \n    if (sensitiveTypes.includes(element.type)) return true;\n    \n    const name = element.name?.toLowerCase() || '';\n    const id = element.id?.toLowerCase() || '';\n    \n    return sensitiveNames.some(sensitive => \n      name.includes(sensitive) || id.includes(sensitive)\n    );\n  }\n\n  private shouldMaskText(element: HTMLElement): boolean {\n    if (!this.config.replay?.maskAllText) return false;\n    \n    // Check for specific selectors that should be masked\n    if (this.config.replay?.maskSelector) {\n      try {\n        return element.matches(this.config.replay.maskSelector);\n      } catch {\n        return false;\n      }\n    }\n    \n    return false;\n  }\n\n  private trackPageLoad(): void {\n    if (typeof window === 'undefined') return;\n\n    const captureLoadEvent = () => {\n      this.captureEvent('page_load', {\n        url: window.location.href,\n        title: document.title,\n        referrer: document.referrer,\n        timestamp: Date.now(),\n        loadTime: performance.now()\n      });\n    };\n\n    if (document.readyState === 'complete') {\n      captureLoadEvent();\n    } else {\n      window.addEventListener('load', captureLoadEvent);\n    }\n  }\n\n  captureEvent(type: string, data: Record<string, any>): void {\n    // Apply sampling\n    if (this.config.sessionSampleRate && Math.random() > this.config.sessionSampleRate) {\n      return;\n    }\n\n    // Start a new span for this session event if trace manager is available\n    const traceContext = this.traceManager?.getTraceContext();\n    const spanId = this.traceManager?.startSpan(`session:${type}`);\n\n    const event: SessionEvent = {\n      sessionId: this.sessionId,\n      timestamp: Date.now(),\n      type,\n      data,\n      traceId: traceContext?.traceId,\n      spanId: spanId\n    };\n\n    // Apply beforeSendSession filter\n    const filteredEvent = this.config.beforeSendSession?.(event) || event;\n    if (!filteredEvent) return;\n\n    this.events.push(filteredEvent);\n\n    // Auto-flush when buffer is full\n    if (this.events.length >= 100) {\n      this.flush();\n    }\n  }\n\n  getEvents(): SessionEvent[] {\n    return [...this.events];\n  }\n\n  clearEvents(): void {\n    this.events = [];\n  }\n\n  flush(): SessionEvent[] {\n    const events = this.getEvents();\n    this.clearEvents();\n    return events;\n  }\n\n  endSession(): void {\n    this.captureEvent('session_end', {\n      timestamp: Date.now(),\n      duration: Date.now() - this.startTime\n    });\n    \n    if (this.storage) {\n      this.storage.removeItem('revi_session_id');\n    }\n  }\n}\n","import { generateId } from './utils';\nimport type { NetworkEvent, ReviConfig } from './types';\nimport { TraceManager } from './trace-manager';\n\nexport class NetworkMonitor {\n  private config: ReviConfig;\n  private events: NetworkEvent[] = [];\n  private originalFetch: typeof fetch;\n  private originalXHROpen: typeof XMLHttpRequest.prototype.open;\n  private originalXHRSend: typeof XMLHttpRequest.prototype.send;\n  private traceManager: TraceManager;\n\n  constructor(config: ReviConfig, traceManager?: TraceManager) {\n    this.config = config;\n    this.traceManager = traceManager || new TraceManager();\n    this.originalFetch = window.fetch;\n    this.originalXHROpen = XMLHttpRequest.prototype.open;\n    this.originalXHRSend = XMLHttpRequest.prototype.send;\n    \n    this.setupInterceptors();\n  }\n\n  private setupInterceptors(): void {\n    if (typeof window === 'undefined') return;\n\n    this.interceptFetch();\n    this.interceptXHR();\n  }\n\n  private interceptFetch(): void {\n    window.fetch = async (...args: Parameters<typeof fetch>): Promise<Response> => {\n      const startTime = Date.now();\n      const url = typeof args[0] === 'string' ? args[0] : args[0].url;\n      const method = (args[1]?.method || 'GET').toUpperCase();\n      \n      // Check if this request should be monitored\n      if (!this.shouldMonitorRequest(url)) {\n        return await this.originalFetch.apply(window, args);\n      }\n      \n      // Start a new span for this network request\n      const spanId = this.traceManager.startSpan(`http:${method} ${url}`);\n      \n      // Inject trace headers into the request\n      const traceHeaders = this.traceManager.injectTraceHeaders();\n      const originalHeaders = args[1]?.headers || {};\n      const headers = { ...originalHeaders, ...traceHeaders };\n      \n      // Update request args with trace headers\n      const modifiedArgs: Parameters<typeof fetch> = [\n        args[0],\n        {\n          ...args[1],\n          headers: headers\n        }\n      ];\n      \n      let requestSize = 0;\n      let requestBody: any;\n      \n      if (args[1]?.body) {\n        requestBody = this.serializeRequestBody(args[1].body);\n        requestSize = this.calculateBodySize(args[1].body);\n      }\n\n      try {\n        const response = await this.originalFetch.apply(window, modifiedArgs);\n        const endTime = Date.now();\n        \n        let responseBody: any;\n        let responseSize = 0;\n        \n        if (this.shouldCaptureResponseBody(url)) {\n          const clonedResponse = response.clone();\n          try {\n            responseBody = await this.extractResponseBody(clonedResponse);\n            responseSize = this.calculateResponseSize(responseBody);\n          } catch {\n            // Failed to extract response body\n          }\n        }\n\n        // Extract trace context from response headers\n        const responseTrace = this.traceManager.extractTraceFromHeaders(\n          this.extractResponseHeaders(response.headers)\n        );\n        \n        // Correlate with backend trace if available\n        if (responseTrace.traceId) {\n          this.traceManager.correlateWithBackendTrace(responseTrace.traceId, responseTrace.spanId);\n        }\n        \n        // Finish the span\n        this.traceManager.finishSpan(spanId, {\n          statusCode: response.status,\n          responseTime: endTime - startTime\n        });\n        \n        const traceContext = this.traceManager.getTraceContext();\n        \n        this.captureNetworkEvent({\n          method,\n          url,\n          statusCode: response.status,\n          responseTime: endTime - startTime,\n          requestSize,\n          responseSize,\n          requestHeaders: this.extractHeaders(headers),\n          responseHeaders: this.extractResponseHeaders(response.headers),\n          requestBody,\n          responseBody,\n          timestamp: startTime,\n          traceId: traceContext.traceId,\n          spanId: spanId,\n          parentSpanId: traceContext.parentSpanId\n        });\n\n        return response;\n      } catch (error) {\n        const endTime = Date.now();\n        \n        // Finish the span with error\n        this.traceManager.finishSpan(spanId, {\n          statusCode: 0,\n          responseTime: endTime - startTime,\n          error: error instanceof Error ? error.message : String(error)\n        });\n        \n        const traceContext = this.traceManager.getTraceContext();\n        \n        this.captureNetworkEvent({\n          method,\n          url,\n          statusCode: 0, // Network error\n          responseTime: endTime - startTime,\n          requestSize,\n          responseSize: 0,\n          requestHeaders: this.extractHeaders(headers),\n          requestBody,\n          timestamp: startTime,\n          traceId: traceContext.traceId,\n          spanId: spanId,\n          parentSpanId: traceContext.parentSpanId\n        });\n\n        throw error;\n      }\n    };\n  }\n\n  private interceptXHR(): void {\n    const self = this;\n\n    XMLHttpRequest.prototype.open = function(method: string, url: string, ...args: any[]) {\n      (this as any)._reviData = {\n        method: method.toUpperCase(),\n        url,\n        startTime: Date.now(),\n        shouldMonitor: self.shouldMonitorRequest(url)\n      };\n      \n      return self.originalXHROpen.call(this, method, url, ...args);\n    };\n\n    XMLHttpRequest.prototype.send = function(body?: any) {\n      const reviData = (this as any)._reviData;\n      if (!reviData || !reviData.shouldMonitor) {\n        return self.originalXHRSend.call(this, body);\n      }\n\n      reviData.requestBody = self.serializeRequestBody(body);\n      reviData.requestSize = self.calculateBodySize(body);\n\n      this.addEventListener('loadend', () => {\n        const endTime = Date.now();\n        \n        let responseBody: any;\n        try {\n          if (this.responseType === '' || this.responseType === 'text') {\n            responseBody = this.responseText;\n          } else if (this.responseType === 'json') {\n            responseBody = this.response;\n          }\n        } catch {\n          // Failed to extract response\n        }\n\n        self.captureNetworkEvent({\n          method: reviData.method,\n          url: reviData.url,\n          statusCode: this.status,\n          responseTime: endTime - reviData.startTime,\n          requestSize: reviData.requestSize,\n          responseSize: self.calculateResponseSize(responseBody),\n          requestBody: reviData.requestBody,\n          responseBody: self.shouldCaptureResponseBody(reviData.url) ? responseBody : undefined,\n          timestamp: reviData.startTime\n        });\n      });\n\n      return self.originalXHRSend.call(this, body);\n    };\n  }\n\n  private serializeRequestBody(body: any): any {\n    if (!body) return undefined;\n    \n    if (typeof body === 'string') return body;\n    if (body instanceof FormData) {\n      const formObject: Record<string, any> = {};\n      body.forEach((value, key) => {\n        formObject[key] = value instanceof File ? `[File: ${value.name}]` : value;\n      });\n      return formObject;\n    }\n    if (body instanceof URLSearchParams) {\n      return Object.fromEntries(body);\n    }\n    \n    try {\n      return JSON.parse(JSON.stringify(body));\n    } catch {\n      return '[Unserializable]';\n    }\n  }\n\n  private async extractResponseBody(response: Response): Promise<any> {\n    const contentType = response.headers.get('content-type') || '';\n    \n    if (contentType.includes('application/json')) {\n      return await response.json();\n    } else if (contentType.includes('text/')) {\n      return await response.text();\n    }\n    \n    return '[Binary Data]';\n  }\n\n  private extractHeaders(headers?: HeadersInit): Record<string, string> {\n    if (!headers) return {};\n    \n    if (headers instanceof Headers) {\n      const headerObj: Record<string, string> = {};\n      headers.forEach((value, key) => {\n        headerObj[key] = value;\n      });\n      return headerObj;\n    }\n    \n    if (Array.isArray(headers)) {\n      const headerObj: Record<string, string> = {};\n      headers.forEach(([key, value]) => {\n        headerObj[key] = value;\n      });\n      return headerObj;\n    }\n    \n    return headers as Record<string, string>;\n  }\n\n  private extractResponseHeaders(headers: Headers): Record<string, string> {\n    const headerObj: Record<string, string> = {};\n    headers.forEach((value, key) => {\n      headerObj[key] = value;\n    });\n    return headerObj;\n  }\n\n  private calculateBodySize(body: any): number {\n    if (!body) return 0;\n    \n    if (typeof body === 'string') return body.length;\n    if (body instanceof ArrayBuffer) return body.byteLength;\n    if (body instanceof Blob) return body.size;\n    \n    try {\n      return JSON.stringify(body).length;\n    } catch {\n      return 0;\n    }\n  }\n\n  private calculateResponseSize(response: any): number {\n    if (!response) return 0;\n    \n    try {\n      return JSON.stringify(response).length;\n    } catch {\n      return 0;\n    }\n  }\n\n  private shouldCaptureResponseBody(url: string): boolean {\n    // Only capture response bodies for specific URLs to avoid memory issues\n    const allowedPatterns = [\n      /\\/api\\//,\n      /\\/graphql/,\n    ];\n    \n    return allowedPatterns.some(pattern => pattern.test(url));\n  }\n\n  private shouldMonitorRequest(url: string): boolean {\n    // Don't monitor the SDK's own API calls to prevent feedback loops\n    const apiUrl = this.config.apiUrl || 'https://api.revi.dev';\n    \n    // Remove trailing slash for consistent comparison\n    const normalizedApiUrl = apiUrl.replace(/\\/$/, '');\n    const normalizedUrl = url.replace(/\\/$/, '');\n    \n    // Debug logging to identify filtering issues\n    if (this.config.debug) {\n      console.log('[Revi Debug] Network filter check:', { \n        url, \n        normalizedUrl, \n        apiUrl, \n        normalizedApiUrl \n      });\n    }\n    \n    // Exclude any requests to the Revi API backend\n    if (normalizedUrl.startsWith(normalizedApiUrl)) {\n      if (this.config.debug) {\n        console.log('[Revi Debug] Filtering API URL:', url, '(matches configured apiUrl)');\n      }\n      return false;\n    }\n    \n    // Use configurable development hosts or default patterns\n    const developmentHosts = this.config.developmentHosts || [\n      /^https?:\\/\\/localhost:\\d+/,\n      /^https?:\\/\\/127\\.0\\.0\\.1:\\d+/,\n      /^https?:\\/\\/0\\.0\\.0\\.0:\\d+/,\n      /^https?:\\/\\/.*\\.local:\\d+/\n    ];\n    \n    const matchedPattern = developmentHosts.find(pattern => pattern.test(url));\n    if (matchedPattern) {\n      if (this.config.debug) {\n        console.log('[Revi Debug] Filtering development host URL:', url, '(matched pattern:', matchedPattern, ')');\n      }\n      return false;\n    }\n    \n    // Additional API endpoint patterns to filter\n    const apiEndpointPatterns = [\n      /\\/api\\/capture\\//,\n      /\\/api\\/errors/,\n      /\\/api\\/session/,\n      /\\/api\\/projects/,\n      /\\/api\\/database/,\n      /\\/api\\/analytics/,\n      /\\/health$/,\n    ];\n    \n    const matchedApiPattern = apiEndpointPatterns.find(pattern => pattern.test(url));\n    if (matchedApiPattern) {\n      if (this.config.debug) {\n        console.log('[Revi Debug] Filtering API endpoint:', url, '(matched pattern:', matchedApiPattern, ')');\n      }\n      return false;\n    }\n    \n    // Check configurable exclude URLs\n    if (this.config.excludeUrls) {\n      const excluded = this.config.excludeUrls.some(pattern => pattern.test(url));\n      if (excluded) {\n        if (this.config.debug) {\n          console.log('[Revi Debug] Filtering excluded URL:', url);\n        }\n        return false;\n      }\n    }\n    \n    // Check privacy configuration if available\n    if (this.config.privacy?.denyUrls) {\n      const denied = this.config.privacy.denyUrls.some(pattern => {\n        const regex = new RegExp(pattern);\n        return regex.test(url);\n      });\n      if (denied) {\n        if (this.config.debug) {\n          console.log('[Revi Debug] Filtering denied URL:', url);\n        }\n        return false;\n      }\n    }\n    \n    if (this.config.privacy?.allowUrls) {\n      const allowed = this.config.privacy.allowUrls.some(pattern => {\n        const regex = new RegExp(pattern);\n        return regex.test(url);\n      });\n      if (this.config.debug) {\n        console.log('[Revi Debug] Allow list result for:', url, '- allowed:', allowed);\n      }\n      return allowed;\n    }\n    \n    if (this.config.debug) {\n      console.log('[Revi Debug] Monitoring URL:', url, '(no filters matched)');\n    }\n    return true;\n  }\n\n  private captureNetworkEvent(data: Partial<NetworkEvent> & { method: string; url: string; timestamp: number }): void {\n    const event: NetworkEvent = {\n      sessionId: '', // Will be set by Monitor class\n      timestamp: data.timestamp,\n      method: data.method,\n      url: data.url,\n      statusCode: data.statusCode,\n      responseTime: data.responseTime,\n      requestSize: data.requestSize,\n      responseSize: data.responseSize,\n      requestHeaders: data.requestHeaders,\n      responseHeaders: data.responseHeaders,\n      requestBody: data.requestBody,\n      responseBody: data.responseBody\n    };\n\n    this.events.push(event);\n\n    // Auto-flush when buffer is full\n    if (this.events.length >= 50) {\n      this.flush();\n    }\n  }\n\n  getEvents(): NetworkEvent[] {\n    return [...this.events];\n  }\n\n  clearEvents(): void {\n    this.events = [];\n  }\n\n  flush(): NetworkEvent[] {\n    const events = this.getEvents();\n    this.clearEvents();\n    return events;\n  }\n\n  destroy(): void {\n    // Restore original implementations\n    if (this.originalFetch) {\n      window.fetch = this.originalFetch;\n    }\n    \n    XMLHttpRequest.prototype.open = this.originalXHROpen;\n    XMLHttpRequest.prototype.send = this.originalXHRSend;\n  }\n}\n","import type { PerformanceEntry, WebVitals, ReviConfig } from './types';\n\nexport class PerformanceMonitor {\n  private config: ReviConfig;\n  private webVitals: WebVitals = {};\n  private performanceEntries: PerformanceEntry[] = [];\n\n  constructor(config: ReviConfig) {\n    this.config = config;\n    \n    if (this.config.performance?.captureWebVitals) {\n      this.setupWebVitals();\n    }\n    \n    if (this.config.performance?.captureResourceTiming) {\n      this.setupResourceTiming();\n    }\n    \n    if (this.config.performance?.captureNavigationTiming) {\n      this.setupNavigationTiming();\n    }\n  }\n\n  private setupWebVitals(): void {\n    if (typeof window === 'undefined' || !('PerformanceObserver' in window)) return;\n\n    // Largest Contentful Paint (LCP)\n    try {\n      const lcpObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        const lastEntry = entries[entries.length - 1];\n        this.webVitals.lcp = lastEntry.startTime;\n      });\n      lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });\n    } catch (e) {\n      // LCP not supported\n    }\n\n    // First Input Delay (FID)\n    try {\n      const fidObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries() as any[];\n        entries.forEach((entry) => {\n          this.webVitals.fid = entry.processingStart - entry.startTime;\n        });\n      });\n      fidObserver.observe({ entryTypes: ['first-input'] });\n    } catch (e) {\n      // FID not supported\n    }\n\n    // Cumulative Layout Shift (CLS)\n    try {\n      let clsValue = 0;\n      const clsObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries() as any[];\n        entries.forEach((entry) => {\n          if (!entry.hadRecentInput) {\n            clsValue += entry.value;\n            this.webVitals.cls = clsValue;\n          }\n        });\n      });\n      clsObserver.observe({ entryTypes: ['layout-shift'] });\n    } catch (e) {\n      // CLS not supported\n    }\n\n    // First Contentful Paint (FCP)\n    try {\n      const fcpObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        entries.forEach((entry) => {\n          if (entry.name === 'first-contentful-paint') {\n            this.webVitals.fcp = entry.startTime;\n          }\n        });\n      });\n      fcpObserver.observe({ entryTypes: ['paint'] });\n    } catch (e) {\n      // FCP not supported\n    }\n\n    // Time to First Byte (TTFB)\n    this.calculateTTFB();\n  }\n\n  private calculateTTFB(): void {\n    if (typeof window === 'undefined' || !window.performance) return;\n\n    try {\n      const navigationTiming = performance.getEntriesByType('navigation')[0] as any;\n      if (navigationTiming) {\n        this.webVitals.ttfb = navigationTiming.responseStart - navigationTiming.requestStart;\n      }\n    } catch (e) {\n      // TTFB calculation failed\n    }\n  }\n\n  private setupResourceTiming(): void {\n    if (typeof window === 'undefined' || !window.performance) return;\n\n    try {\n      const resourceObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        entries.forEach((entry) => {\n          this.performanceEntries.push({\n            name: entry.name,\n            entryType: entry.entryType,\n            startTime: entry.startTime,\n            duration: entry.duration,\n            transferSize: (entry as any).transferSize,\n            encodedBodySize: (entry as any).encodedBodySize,\n            decodedBodySize: (entry as any).decodedBodySize\n          });\n        });\n      });\n      \n      resourceObserver.observe({ entryTypes: ['resource'] });\n    } catch (e) {\n      // Resource timing not supported\n    }\n  }\n\n  private setupNavigationTiming(): void {\n    if (typeof window === 'undefined' || !window.performance) return;\n\n    window.addEventListener('load', () => {\n      try {\n        const navigationTiming = performance.getEntriesByType('navigation')[0] as any;\n        if (navigationTiming) {\n          this.performanceEntries.push({\n            name: 'navigation',\n            entryType: 'navigation',\n            startTime: navigationTiming.startTime,\n            duration: navigationTiming.duration,\n            domContentLoadedEventEnd: navigationTiming.domContentLoadedEventEnd,\n            domContentLoadedEventStart: navigationTiming.domContentLoadedEventStart,\n            loadEventEnd: navigationTiming.loadEventEnd,\n            loadEventStart: navigationTiming.loadEventStart,\n            domComplete: navigationTiming.domComplete,\n            domInteractive: navigationTiming.domInteractive\n          });\n        }\n      } catch (e) {\n        // Navigation timing failed\n      }\n    });\n  }\n\n  getWebVitals(): WebVitals {\n    return { ...this.webVitals };\n  }\n\n  getPerformanceEntries(): PerformanceEntry[] {\n    return [...this.performanceEntries];\n  }\n\n  clearPerformanceEntries(): void {\n    this.performanceEntries = [];\n  }\n\n  // Custom performance marks\n  mark(name: string): void {\n    if (typeof window !== 'undefined' && window.performance && window.performance.mark) {\n      try {\n        performance.mark(name);\n      } catch (e) {\n        // Mark failed\n      }\n    }\n  }\n\n  measure(name: string, startMark?: string, endMark?: string): number | null {\n    if (typeof window === 'undefined' || !window.performance || !window.performance.measure) {\n      return null;\n    }\n\n    try {\n      performance.measure(name, startMark, endMark);\n      const measure = performance.getEntriesByName(name, 'measure')[0];\n      return measure ? measure.duration : null;\n    } catch (e) {\n      return null;\n    }\n  }\n}\n","import type { ErrorEvent, SessionEvent, NetworkEvent } from './types';\n\ninterface StorageItem {\n  id: string;\n  type: 'error' | 'session' | 'network';\n  data: any;\n  timestamp: number;\n  compressed: boolean;\n}\n\nexport class IndexedDBStorage {\n  private db: IDBDatabase | null = null;\n  private dbName = 'revi-storage';\n  private version = 1;\n  private storeName = 'queue';\n  private maxQueueSize = 1000;\n  private maxAge = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds\n\n  async initialize(): Promise<void> {\n    if (typeof window === 'undefined' || !window.indexedDB) {\n      throw new Error('IndexedDB not supported');\n    }\n\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, this.version);\n\n      request.onerror = () => {\n        reject(new Error('Failed to open IndexedDB'));\n      };\n\n      request.onsuccess = () => {\n        this.db = request.result;\n        resolve();\n      };\n\n      request.onupgradeneeded = (event) => {\n        const db = (event.target as IDBOpenDBRequest).result;\n        \n        if (!db.objectStoreNames.contains(this.storeName)) {\n          const objectStore = db.createObjectStore(this.storeName, { keyPath: 'id' });\n          objectStore.createIndex('timestamp', 'timestamp', { unique: false });\n          objectStore.createIndex('type', 'type', { unique: false });\n        }\n      };\n    });\n  }\n\n  async store(type: 'error' | 'session' | 'network', data: any): Promise<void> {\n    if (!this.db) {\n      await this.initialize();\n    }\n\n    await this.cleanupExpiredItems();\n    \n    const queueSize = await this.getQueueSize();\n    if (queueSize >= this.maxQueueSize) {\n      await this.removeOldestItems(100);\n    }\n\n    const item: StorageItem = {\n      id: this.generateId(),\n      type,\n      data: await this.compress(data),\n      timestamp: Date.now(),\n      compressed: true\n    };\n\n    return new Promise((resolve, reject) => {\n      if (!this.db) {\n        reject(new Error('Database not initialized'));\n        return;\n      }\n\n      const transaction = this.db.transaction([this.storeName], 'readwrite');\n      const objectStore = transaction.objectStore(this.storeName);\n      const request = objectStore.add(item);\n\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(new Error('Failed to store item'));\n    });\n  }\n\n  async getAll(): Promise<{ errors: ErrorEvent[]; sessionEvents: SessionEvent[]; networkEvents: NetworkEvent[] }> {\n    if (!this.db) {\n      await this.initialize();\n    }\n\n    return new Promise((resolve, reject) => {\n      if (!this.db) {\n        reject(new Error('Database not initialized'));\n        return;\n      }\n\n      const transaction = this.db.transaction([this.storeName], 'readonly');\n      const objectStore = transaction.objectStore(this.storeName);\n      const request = objectStore.getAll();\n\n      request.onsuccess = async () => {\n        const items = request.result as StorageItem[];\n        const result = {\n          errors: [] as ErrorEvent[],\n          sessionEvents: [] as SessionEvent[],\n          networkEvents: [] as NetworkEvent[]\n        };\n\n        for (const item of items) {\n          const decompressedData = await this.decompress(item.data);\n          \n          switch (item.type) {\n            case 'error':\n              result.errors.push(...(Array.isArray(decompressedData) ? decompressedData : [decompressedData]));\n              break;\n            case 'session':\n              result.sessionEvents.push(...(Array.isArray(decompressedData) ? decompressedData : [decompressedData]));\n              break;\n            case 'network':\n              result.networkEvents.push(...(Array.isArray(decompressedData) ? decompressedData : [decompressedData]));\n              break;\n          }\n        }\n\n        resolve(result);\n      };\n\n      request.onerror = () => reject(new Error('Failed to retrieve items'));\n    });\n  }\n\n  async clear(): Promise<void> {\n    if (!this.db) {\n      await this.initialize();\n    }\n\n    return new Promise((resolve, reject) => {\n      if (!this.db) {\n        reject(new Error('Database not initialized'));\n        return;\n      }\n\n      const transaction = this.db.transaction([this.storeName], 'readwrite');\n      const objectStore = transaction.objectStore(this.storeName);\n      const request = objectStore.clear();\n\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(new Error('Failed to clear storage'));\n    });\n  }\n\n  async getQueueSize(): Promise<number> {\n    if (!this.db) {\n      await this.initialize();\n    }\n\n    return new Promise((resolve, reject) => {\n      if (!this.db) {\n        reject(new Error('Database not initialized'));\n        return;\n      }\n\n      const transaction = this.db.transaction([this.storeName], 'readonly');\n      const objectStore = transaction.objectStore(this.storeName);\n      const request = objectStore.count();\n\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(new Error('Failed to get queue size'));\n    });\n  }\n\n  private async cleanupExpiredItems(): Promise<void> {\n    if (!this.db) return;\n\n    const cutoffTime = Date.now() - this.maxAge;\n\n    return new Promise((resolve) => {\n      if (!this.db) {\n        resolve();\n        return;\n      }\n\n      const transaction = this.db.transaction([this.storeName], 'readwrite');\n      const objectStore = transaction.objectStore(this.storeName);\n      const index = objectStore.index('timestamp');\n      const range = IDBKeyRange.upperBound(cutoffTime);\n      const request = index.openCursor(range);\n\n      request.onsuccess = (event) => {\n        const cursor = (event.target as IDBRequest).result;\n        if (cursor) {\n          cursor.delete();\n          cursor.continue();\n        } else {\n          resolve();\n        }\n      };\n\n      request.onerror = () => resolve();\n    });\n  }\n\n  private async removeOldestItems(count: number): Promise<void> {\n    if (!this.db) return;\n\n    return new Promise((resolve) => {\n      if (!this.db) {\n        resolve();\n        return;\n      }\n\n      const transaction = this.db.transaction([this.storeName], 'readwrite');\n      const objectStore = transaction.objectStore(this.storeName);\n      const index = objectStore.index('timestamp');\n      const request = index.openCursor();\n\n      let deletedCount = 0;\n      request.onsuccess = (event) => {\n        const cursor = (event.target as IDBRequest).result;\n        if (cursor && deletedCount < count) {\n          cursor.delete();\n          deletedCount++;\n          cursor.continue();\n        } else {\n          resolve();\n        }\n      };\n\n      request.onerror = () => resolve();\n    });\n  }\n\n  private async compress(data: any): Promise<string> {\n    try {\n      const json = JSON.stringify(data);\n      // Simple base64 compression for now - can be upgraded to gzip\n      return btoa(unescape(encodeURIComponent(json)));\n    } catch (error) {\n      // Fallback to uncompressed JSON string\n      return JSON.stringify(data);\n    }\n  }\n\n  private async decompress(data: string): Promise<any> {\n    try {\n      // Try to decode base64 first\n      const decoded = decodeURIComponent(escape(atob(data)));\n      return JSON.parse(decoded);\n    } catch (error) {\n      // Fallback to direct JSON parse\n      try {\n        return JSON.parse(data);\n      } catch (parseError) {\n        return data;\n      }\n    }\n  }\n\n  private generateId(): string {\n    return `revi-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n}","import { IndexedDBStorage } from './indexed-db-storage';\nimport { getLocalStorage } from './utils';\nimport type { ErrorEvent, SessionEvent, NetworkEvent } from './types';\n\ninterface StorageInterface {\n  store(type: 'error' | 'session' | 'network', data: any): Promise<void>;\n  getAll(): Promise<{ errors: ErrorEvent[]; sessionEvents: SessionEvent[]; networkEvents: NetworkEvent[] }>;\n  clear(): Promise<void>;\n  getQueueSize?(): Promise<number>;\n}\n\nclass LocalStorageAdapter implements StorageInterface {\n  private storage: Storage;\n  private storageKey = 'revi_upload_queue';\n\n  constructor() {\n    const localStorage = getLocalStorage();\n    if (!localStorage) {\n      throw new Error('No storage available');\n    }\n    this.storage = localStorage;\n  }\n\n  async store(type: 'error' | 'session' | 'network', data: any): Promise<void> {\n    try {\n      const existing = await this.getAll();\n      \n      switch (type) {\n        case 'error':\n          existing.errors.push(...(Array.isArray(data) ? data : [data]));\n          break;\n        case 'session':\n          existing.sessionEvents.push(...(Array.isArray(data) ? data : [data]));\n          break;\n        case 'network':\n          existing.networkEvents.push(...(Array.isArray(data) ? data : [data]));\n          break;\n      }\n\n      this.storage.setItem(this.storageKey, JSON.stringify(existing));\n    } catch (error) {\n      // Storage quota exceeded or other error\n      throw new Error('Failed to store data');\n    }\n  }\n\n  async getAll(): Promise<{ errors: ErrorEvent[]; sessionEvents: SessionEvent[]; networkEvents: NetworkEvent[] }> {\n    try {\n      const storedData = this.storage.getItem(this.storageKey);\n      if (storedData) {\n        return JSON.parse(storedData);\n      }\n    } catch (error) {\n      // Failed to parse or retrieve data\n    }\n    \n    return {\n      errors: [],\n      sessionEvents: [],\n      networkEvents: []\n    };\n  }\n\n  async clear(): Promise<void> {\n    try {\n      this.storage.removeItem(this.storageKey);\n    } catch (error) {\n      // Ignore errors\n    }\n  }\n}\n\nexport class StorageManager {\n  private storage: StorageInterface | null = null;\n  private isInitialized = false;\n\n  async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n\n    try {\n      // Try IndexedDB first\n      const indexedDB = new IndexedDBStorage();\n      await indexedDB.initialize();\n      this.storage = indexedDB;\n      console.log('[Revi] Using IndexedDB for offline storage');\n    } catch (error) {\n      // Fallback to localStorage\n      try {\n        this.storage = new LocalStorageAdapter();\n        console.log('[Revi] Using localStorage for offline storage');\n      } catch (localStorageError) {\n        console.warn('[Revi] No storage available, data will not persist offline');\n        this.storage = new NoOpStorage();\n      }\n    }\n\n    this.isInitialized = true;\n  }\n\n  async storeErrors(errors: ErrorEvent[]): Promise<void> {\n    await this.ensureInitialized();\n    if (errors.length > 0) {\n      await this.storage!.store('error', errors);\n    }\n  }\n\n  async storeSessionEvents(events: SessionEvent[]): Promise<void> {\n    await this.ensureInitialized();\n    if (events.length > 0) {\n      await this.storage!.store('session', events);\n    }\n  }\n\n  async storeNetworkEvents(events: NetworkEvent[]): Promise<void> {\n    await this.ensureInitialized();\n    if (events.length > 0) {\n      await this.storage!.store('network', events);\n    }\n  }\n\n  async getAllData(): Promise<{ errors: ErrorEvent[]; sessionEvents: SessionEvent[]; networkEvents: NetworkEvent[] }> {\n    await this.ensureInitialized();\n    return await this.storage!.getAll();\n  }\n\n  async clearAll(): Promise<void> {\n    await this.ensureInitialized();\n    await this.storage!.clear();\n  }\n\n  async getQueueSize(): Promise<number> {\n    await this.ensureInitialized();\n    if (this.storage && 'getQueueSize' in this.storage && this.storage.getQueueSize) {\n      return await this.storage.getQueueSize();\n    } else {\n      // Fallback for localStorage\n      const data = await this.getAllData();\n      return data.errors.length + data.sessionEvents.length + data.networkEvents.length;\n    }\n  }\n\n  private async ensureInitialized(): Promise<void> {\n    if (!this.isInitialized) {\n      await this.initialize();\n    }\n  }\n}\n\nclass NoOpStorage implements StorageInterface {\n  async store(): Promise<void> {\n    // Do nothing\n  }\n\n  async getAll(): Promise<{ errors: ErrorEvent[]; sessionEvents: SessionEvent[]; networkEvents: NetworkEvent[] }> {\n    return {\n      errors: [],\n      sessionEvents: [],\n      networkEvents: []\n    };\n  }\n\n  async clear(): Promise<void> {\n    // Do nothing\n  }\n}","export class NetworkManager {\n  private isOnline = typeof navigator !== 'undefined' ? navigator.onLine : true;\n  private connectionType: string = 'unknown';\n  private listeners: Array<(online: boolean) => void> = [];\n\n  constructor() {\n    if (typeof window !== 'undefined') {\n      // Listen for online/offline events\n      window.addEventListener('online', () => {\n        this.isOnline = true;\n        this.notifyListeners(true);\n      });\n\n      window.addEventListener('offline', () => {\n        this.isOnline = false;\n        this.notifyListeners(false);\n      });\n\n      // Detect connection type if available\n      this.detectConnectionType();\n    }\n  }\n\n  getConnectionStatus(): { online: boolean; connectionType: string } {\n    return {\n      online: this.isOnline,\n      connectionType: this.connectionType\n    };\n  }\n\n  onConnectionChange(callback: (online: boolean) => void): () => void {\n    this.listeners.push(callback);\n    \n    // Return unsubscribe function\n    return () => {\n      const index = this.listeners.indexOf(callback);\n      if (index > -1) {\n        this.listeners.splice(index, 1);\n      }\n    };\n  }\n\n  getBatchSize(): number {\n    if (!this.isOnline) {\n      return 0; // Don't upload when offline\n    }\n\n    // Adjust batch size based on connection quality\n    switch (this.connectionType) {\n      case 'slow-2g':\n        return 5;\n      case '2g':\n        return 10;\n      case '3g':\n        return 25;\n      case '4g':\n        return 50;\n      default:\n        return 25;\n    }\n  }\n\n  getUploadDelay(): number {\n    if (!this.isOnline) {\n      return 0; // Don't upload when offline\n    }\n\n    // Adjust upload frequency based on connection\n    switch (this.connectionType) {\n      case 'slow-2g':\n        return 30000; // 30 seconds\n      case '2g':\n        return 15000; // 15 seconds\n      case '3g':\n        return 10000; // 10 seconds\n      case '4g':\n        return 5000;  // 5 seconds\n      default:\n        return 10000; // 10 seconds\n    }\n  }\n\n  shouldRetry(attempt: number): boolean {\n    if (!this.isOnline) {\n      return false; // Don't retry when offline\n    }\n\n    // Exponential backoff with max attempts\n    const maxAttempts = 5;\n    return attempt < maxAttempts;\n  }\n\n  getRetryDelay(attempt: number): number {\n    // Exponential backoff: 1s, 2s, 4s, 8s, 16s\n    return Math.min(1000 * Math.pow(2, attempt), 16000);\n  }\n\n  private detectConnectionType(): void {\n    if ('connection' in navigator) {\n      const connection = (navigator as any).connection;\n      this.connectionType = connection.effectiveType || connection.type || 'unknown';\n      \n      // Listen for connection changes\n      connection.addEventListener('change', () => {\n        this.connectionType = connection.effectiveType || connection.type || 'unknown';\n      });\n    }\n  }\n\n  private notifyListeners(online: boolean): void {\n    this.listeners.forEach(callback => {\n      try {\n        callback(online);\n      } catch (error) {\n        console.error('[Revi] Error in connection change callback:', error);\n      }\n    });\n  }\n\n  // Ping test to verify actual connectivity\n  async testConnectivity(url?: string): Promise<boolean> {\n    if (!this.isOnline) {\n      return false;\n    }\n\n    try {\n      const testUrl = url || 'https://api.revi.dev/health';\n      const response = await fetch(testUrl, {\n        method: 'HEAD',\n        mode: 'no-cors',\n        cache: 'no-cache'\n      });\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n}","import { StorageManager } from './storage-manager';\nimport { NetworkManager } from './network-manager';\nimport type { ErrorEvent, SessionEvent, NetworkEvent, ReviConfig } from './types';\n\nexport class DataManager {\n  private config: ReviConfig;\n  private storageManager: StorageManager;\n  private networkManager: NetworkManager;\n  private uploadTimer: NodeJS.Timeout | null = null;\n  private isUploading = false;\n  private retryAttempts = new Map<string, number>();\n  private uploadQueue: {\n    errors: ErrorEvent[];\n    sessionEvents: SessionEvent[];\n    networkEvents: NetworkEvent[];\n  } = {\n    errors: [],\n    sessionEvents: [],\n    networkEvents: []\n  };\n\n  constructor(config: ReviConfig) {\n    this.config = config;\n    this.storageManager = new StorageManager();\n    this.networkManager = new NetworkManager();\n    \n    this.initialize();\n  }\n\n  private async initialize(): Promise<void> {\n    try {\n      await this.storageManager.initialize();\n      await this.loadQueueFromStorage();\n      this.startNetworkAwareUploadTimer();\n      this.setupBeforeUnloadHandler();\n      this.setupNetworkChangeHandler();\n    } catch (error) {\n      console.error('[Revi] Failed to initialize data manager:', error);\n    }\n  }\n\n  private async loadQueueFromStorage(): Promise<void> {\n    try {\n      const storedData = await this.storageManager.getAllData();\n      this.uploadQueue = storedData;\n    } catch (error) {\n      console.error('[Revi] Failed to load queue from storage:', error);\n    }\n  }\n\n  private async saveQueueToStorage(): Promise<void> {\n    try {\n      await this.storageManager.clearAll();\n      if (this.uploadQueue.errors.length > 0) {\n        await this.storageManager.storeErrors(this.uploadQueue.errors);\n      }\n      if (this.uploadQueue.sessionEvents.length > 0) {\n        await this.storageManager.storeSessionEvents(this.uploadQueue.sessionEvents);\n      }\n      if (this.uploadQueue.networkEvents.length > 0) {\n        await this.storageManager.storeNetworkEvents(this.uploadQueue.networkEvents);\n      }\n    } catch (error) {\n      console.error('[Revi] Failed to save queue to storage:', error);\n    }\n  }\n\n  private startNetworkAwareUploadTimer(): void {\n    const scheduleNextUpload = () => {\n      if (this.uploadTimer) {\n        clearTimeout(this.uploadTimer);\n      }\n\n      const delay = this.networkManager.getUploadDelay();\n      if (delay > 0) {\n        this.uploadTimer = setTimeout(() => {\n          if (!this.isUploading && this.hasQueuedData()) {\n            this.uploadData().finally(() => {\n              scheduleNextUpload();\n            });\n          } else {\n            scheduleNextUpload();\n          }\n        }, delay);\n      }\n    };\n\n    scheduleNextUpload();\n  }\n\n  private setupNetworkChangeHandler(): void {\n    this.networkManager.onConnectionChange((online) => {\n      if (online) {\n        console.log('[Revi] Network connection restored, resuming uploads');\n        if (this.hasQueuedData() && !this.isUploading) {\n          // Wait a bit before starting uploads to ensure connection is stable\n          setTimeout(() => {\n            this.uploadData();\n          }, 1000);\n        }\n      } else {\n        console.log('[Revi] Network connection lost, uploads paused');\n      }\n    });\n  }\n\n  private setupBeforeUnloadHandler(): void {\n    if (typeof window === 'undefined') return;\n\n    window.addEventListener('beforeunload', () => {\n      if (this.hasQueuedData()) {\n        this.uploadDataSync();\n      }\n    });\n  }\n\n  queueError(error: ErrorEvent): void {\n    this.uploadQueue.errors.push(error);\n    this.saveQueueToStorage().catch(err => {\n      console.error('[Revi] Failed to save error to storage:', err);\n    });\n  }\n\n  queueSessionEvents(events: SessionEvent[]): void {\n    this.uploadQueue.sessionEvents.push(...events);\n    this.saveQueueToStorage().catch(err => {\n      console.error('[Revi] Failed to save session events to storage:', err);\n    });\n  }\n\n  queueNetworkEvents(events: NetworkEvent[]): void {\n    this.uploadQueue.networkEvents.push(...events);\n    this.saveQueueToStorage().catch(err => {\n      console.error('[Revi] Failed to save network events to storage:', err);\n    });\n  }\n\n  private hasQueuedData(): boolean {\n    return this.uploadQueue.errors.length > 0 ||\n           this.uploadQueue.sessionEvents.length > 0 ||\n           this.uploadQueue.networkEvents.length > 0;\n  }\n\n  private async uploadData(): Promise<void> {\n    if (this.isUploading || !this.hasQueuedData()) return;\n\n    const { online } = this.networkManager.getConnectionStatus();\n    if (!online) {\n      console.log('[Revi] Skipping upload - device is offline');\n      return;\n    }\n\n    this.isUploading = true;\n    const apiUrl = this.config.apiUrl || 'https://api.revi.dev';\n    const batchSize = this.networkManager.getBatchSize();\n\n    try {\n      // Upload errors in batches\n      if (this.uploadQueue.errors.length > 0) {\n        const errorBatches = this.createBatches(this.uploadQueue.errors, batchSize);\n        for (const batch of errorBatches) {\n          await this.uploadErrorsWithRetry(apiUrl, batch);\n        }\n        this.uploadQueue.errors = [];\n      }\n\n      // Upload session events in batches\n      if (this.uploadQueue.sessionEvents.length > 0) {\n        const sessionBatches = this.createBatches(this.uploadQueue.sessionEvents, batchSize);\n        for (const batch of sessionBatches) {\n          await this.uploadSessionEventsWithRetry(apiUrl, batch);\n        }\n        this.uploadQueue.sessionEvents = [];\n      }\n\n      // Upload network events in batches\n      if (this.uploadQueue.networkEvents.length > 0) {\n        const networkBatches = this.createBatches(this.uploadQueue.networkEvents, batchSize);\n        for (const batch of networkBatches) {\n          await this.uploadNetworkEventsWithRetry(apiUrl, batch);\n        }\n        this.uploadQueue.networkEvents = [];\n      }\n\n      await this.saveQueueToStorage();\n      \n      // Reset retry attempts on successful upload\n      this.retryAttempts.clear();\n      \n    } catch (error) {\n      if (this.config.debug) {\n        console.error('Revi: Failed to upload data', error);\n      }\n      // Keep data in queue for retry\n    } finally {\n      this.isUploading = false;\n    }\n  }\n\n  private createBatches<T>(items: T[], batchSize: number): T[][] {\n    if (batchSize <= 0) return [];\n    \n    const batches: T[][] = [];\n    for (let i = 0; i < items.length; i += batchSize) {\n      batches.push(items.slice(i, i + batchSize));\n    }\n    return batches;\n  }\n\n  private uploadDataSync(): void {\n    if (!this.hasQueuedData()) return;\n\n    const apiUrl = this.config.apiUrl || 'https://api.revi.dev';\n\n    // Use sendBeacon for synchronous upload on page unload\n    if (navigator.sendBeacon) {\n      if (this.uploadQueue.errors.length > 0) {\n        const payload = JSON.stringify({ errors: this.uploadQueue.errors });\n        navigator.sendBeacon(`${apiUrl}/api/capture/error`, payload);\n      }\n\n      if (this.uploadQueue.sessionEvents.length > 0) {\n        const payload = JSON.stringify({ \n          session_id: this.uploadQueue.sessionEvents[0]?.sessionId,\n          events: this.uploadQueue.sessionEvents.map(e => ({\n            event_type: e.type,\n            data: e.data,\n            timestamp: e.timestamp,\n            session_id: e.sessionId\n          }))\n        });\n        navigator.sendBeacon(`${apiUrl}/api/capture/session-event`, payload);\n      }\n\n      if (this.uploadQueue.networkEvents.length > 0) {\n        const payload = JSON.stringify({ events: this.uploadQueue.networkEvents });\n        navigator.sendBeacon(`${apiUrl}/api/capture/network-event`, payload);\n      }\n    }\n  }\n\n  private async uploadErrors(apiUrl: string, errors: ErrorEvent[]): Promise<void> {\n    const response = await fetch(`${apiUrl}/api/capture/error`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-API-Key': this.config.apiKey\n      },\n      body: JSON.stringify({\n        errors: errors.map(error => ({\n          message: error.message,\n          stack_trace: error.stack,\n          url: error.url,\n          user_agent: error.userAgent,\n          session_id: error.sessionId,\n          metadata: {\n            id: error.id,\n            userId: error.userId,\n            environment: error.environment,\n            release: error.release,\n            tags: error.tags,\n            extra: error.extra,\n            breadcrumbs: error.breadcrumbs,\n            level: error.level,\n            lineno: error.lineno,\n            colno: error.colno,\n            filename: error.filename\n          }\n        }))\n      })\n    });\n\n    if (!response.ok) {\n      throw new Error(`Upload failed: ${response.status}`);\n    }\n  }\n\n  private async uploadSessionEvents(apiUrl: string, events: SessionEvent[]): Promise<void> {\n    if (events.length === 0) return;\n\n    const sessionId = events[0].sessionId;\n    const response = await fetch(`${apiUrl}/api/capture/session-event`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-API-Key': this.config.apiKey\n      },\n      body: JSON.stringify({\n        session_id: sessionId,\n        events: events.map(event => ({\n          event_type: event.type,\n          data: event.data,\n          timestamp: event.timestamp,\n          session_id: event.sessionId\n        }))\n      })\n    });\n\n    if (!response.ok) {\n      throw new Error(`Upload failed: ${response.status}`);\n    }\n  }\n\n  private async uploadNetworkEvents(apiUrl: string, events: NetworkEvent[]): Promise<void> {\n    const promises = events.map(event => \n      fetch(`${apiUrl}/api/capture/network-event`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-API-Key': this.config.apiKey\n        },\n        body: JSON.stringify({\n          session_id: event.sessionId,\n          events: [{\n            method: event.method,\n            url: event.url,\n            status_code: event.statusCode,\n            response_time: event.responseTime,\n            timestamp: event.timestamp,\n            session_id: event.sessionId,\n            request_data: {\n              headers: event.requestHeaders || {},\n              body: event.requestBody || null,\n              size: event.requestSize || 0\n            },\n            response_data: {\n              headers: event.responseHeaders || {},\n              body: event.responseBody || null,\n              size: event.responseSize || 0\n            }\n          }]\n        })\n      })\n    );\n\n    const responses = await Promise.allSettled(promises);\n    const failures = responses.filter(r => r.status === 'rejected');\n    \n    if (failures.length > 0) {\n      throw new Error(`${failures.length} network event uploads failed`);\n    }\n  }\n\n  private async uploadErrorsWithRetry(apiUrl: string, errors: ErrorEvent[]): Promise<void> {\n    const key = 'errors';\n    return this.executeWithRetry(key, () => this.uploadErrors(apiUrl, errors));\n  }\n\n  private async uploadSessionEventsWithRetry(apiUrl: string, events: SessionEvent[]): Promise<void> {\n    const key = 'session_events';\n    return this.executeWithRetry(key, () => this.uploadSessionEvents(apiUrl, events));\n  }\n\n  private async uploadNetworkEventsWithRetry(apiUrl: string, events: NetworkEvent[]): Promise<void> {\n    const key = 'network_events';  \n    return this.executeWithRetry(key, () => this.uploadNetworkEvents(apiUrl, events));\n  }\n\n  private async executeWithRetry<T>(key: string, operation: () => Promise<T>): Promise<T> {\n    const currentAttempt = this.retryAttempts.get(key) || 0;\n\n    if (!this.networkManager.shouldRetry(currentAttempt)) {\n      throw new Error(`Max retry attempts exceeded for ${key}`);\n    }\n\n    try {\n      const result = await operation();\n      this.retryAttempts.delete(key); // Success, reset retry count\n      return result;\n    } catch (error) {\n      this.retryAttempts.set(key, currentAttempt + 1);\n      \n      if (this.networkManager.shouldRetry(currentAttempt + 1)) {\n        const delay = this.networkManager.getRetryDelay(currentAttempt + 1);\n        console.log(`[Revi] Upload failed for ${key}, retrying in ${delay}ms (attempt ${currentAttempt + 2})`);\n        \n        await new Promise(resolve => setTimeout(resolve, delay));\n        return this.executeWithRetry(key, operation);\n      } else {\n        console.error(`[Revi] Max retry attempts exceeded for ${key}:`, error);\n        throw error;\n      }\n    }\n  }\n\n  async clearQueue(): Promise<void> {\n    this.uploadQueue = {\n      errors: [],\n      sessionEvents: [],\n      networkEvents: []\n    };\n    \n    await this.storageManager.clearAll();\n  }\n\n  destroy(): void {\n    if (this.uploadTimer) {\n      clearTimeout(this.uploadTimer);\n      this.uploadTimer = null;\n    }\n    \n    // Final upload attempt\n    if (this.hasQueuedData()) {\n      this.uploadDataSync();\n    }\n  }\n}\n","import type { ReviConfig } from './types';\nimport { generateId } from './utils';\nimport crypto from 'crypto';\n\nexport interface JourneyEvent {\n  event_type: 'page_view' | 'click' | 'form_submit' | 'api_call' | 'error';\n  url: string;\n  referrer?: string;\n  timestamp: number;\n  duration_ms?: number;\n  metadata: Record<string, any>;\n}\n\nexport interface DeviceFingerprint {\n  screen_resolution: string;\n  color_depth: number;\n  timezone: string;\n  language: string;\n  platform: string;\n  user_agent: string;\n  canvas_fingerprint?: string;\n  webgl_fingerprint?: string;\n}\n\n/**\n * Advanced user journey tracking with device fingerprinting\n */\nexport class UserJourneyTracker {\n  private config: ReviConfig;\n  private userId?: string;\n  private deviceFingerprint: string;\n  private sessionStartTime: number;\n  private currentPageStartTime: number;\n  private journeyEvents: JourneyEvent[] = [];\n  private isTracking = false;\n\n  constructor(config: ReviConfig) {\n    this.config = config;\n    this.deviceFingerprint = this.generateDeviceFingerprint();\n    this.sessionStartTime = Date.now();\n    this.currentPageStartTime = Date.now();\n    \n    if (typeof window !== 'undefined') {\n      this.setupJourneyTracking();\n    }\n  }\n\n  /**\n   * Start tracking user journey\n   */\n  startTracking(userId?: string): void {\n    this.userId = userId;\n    this.isTracking = true;\n    \n    // Track initial page view\n    this.trackPageView();\n    \n    if (this.config.debug) {\n      console.log('Revi: User journey tracking started', { userId, deviceFingerprint: this.deviceFingerprint });\n    }\n  }\n\n  /**\n   * Stop tracking user journey\n   */\n  stopTracking(): void {\n    this.isTracking = false;\n    this.flush();\n  }\n\n  /**\n   * Set user ID for tracking\n   */\n  setUserId(userId: string): void {\n    this.userId = userId;\n  }\n\n  /**\n   * Track page view with timing\n   */\n  private trackPageView(): void {\n    if (!this.isTracking) return;\n\n    const event: JourneyEvent = {\n      event_type: 'page_view',\n      url: window.location.href,\n      referrer: document.referrer || undefined,\n      timestamp: Date.now(),\n      metadata: {\n        title: document.title,\n        viewport: {\n          width: window.innerWidth,\n          height: window.innerHeight\n        },\n        scroll_position: {\n          x: window.scrollX,\n          y: window.scrollY\n        },\n        device_fingerprint: this.deviceFingerprint,\n        user_agent: navigator.userAgent,\n        language: navigator.language,\n        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n        connection_type: this.getConnectionType()\n      }\n    };\n\n    this.addJourneyEvent(event);\n  }\n\n  /**\n   * Track user clicks with context\n   */\n  private trackClick(element: HTMLElement, event: MouseEvent): void {\n    if (!this.isTracking) return;\n\n    const journeyEvent: JourneyEvent = {\n      event_type: 'click',\n      url: window.location.href,\n      timestamp: Date.now(),\n      metadata: {\n        element: {\n          tag: element.tagName.toLowerCase(),\n          id: element.id,\n          class: element.className,\n          text: this.getElementText(element),\n          attributes: this.getRelevantAttributes(element)\n        },\n        coordinates: {\n          x: event.clientX,\n          y: event.clientY,\n          page_x: event.pageX,\n          page_y: event.pageY\n        },\n        viewport: {\n          width: window.innerWidth,\n          height: window.innerHeight\n        },\n        scroll_position: {\n          x: window.scrollX,\n          y: window.scrollY\n        }\n      }\n    };\n\n    this.addJourneyEvent(journeyEvent);\n  }\n\n  /**\n   * Track form submissions\n   */\n  private trackFormSubmit(form: HTMLFormElement): void {\n    if (!this.isTracking) return;\n\n    const formData = new FormData(form);\n    const fields: Record<string, any> = {};\n    \n    formData.forEach((value, key) => {\n      // Only track field names and types, not values for privacy\n      const input = form.querySelector(`[name=\"${key}\"]`) as HTMLInputElement;\n      fields[key] = {\n        type: input?.type || 'unknown',\n        has_value: !!value,\n        value_length: typeof value === 'string' ? value.length : 0\n      };\n    });\n\n    const journeyEvent: JourneyEvent = {\n      event_type: 'form_submit',\n      url: window.location.href,\n      timestamp: Date.now(),\n      metadata: {\n        form: {\n          id: form.id,\n          class: form.className,\n          method: form.method,\n          action: form.action,\n          field_count: formData.entries().length\n        },\n        fields: this.config.privacy?.maskInputs ? {} : fields\n      }\n    };\n\n    this.addJourneyEvent(journeyEvent);\n  }\n\n  /**\n   * Track API calls and their performance\n   */\n  trackApiCall(url: string, method: string, status: number, duration: number, size?: number): void {\n    if (!this.isTracking) return;\n\n    const journeyEvent: JourneyEvent = {\n      event_type: 'api_call',\n      url: window.location.href,\n      timestamp: Date.now(),\n      duration_ms: duration,\n      metadata: {\n        api: {\n          url,\n          method,\n          status,\n          duration,\n          size: size || 0,\n          success: status >= 200 && status < 300\n        },\n        page_context: {\n          title: document.title,\n          time_on_page: Date.now() - this.currentPageStartTime\n        }\n      }\n    };\n\n    this.addJourneyEvent(journeyEvent);\n  }\n\n  /**\n   * Track errors in user journey context\n   */\n  trackError(error: Error, context?: Record<string, any>): void {\n    if (!this.isTracking) return;\n\n    const journeyEvent: JourneyEvent = {\n      event_type: 'error',\n      url: window.location.href,\n      timestamp: Date.now(),\n      metadata: {\n        error: {\n          message: error.message,\n          name: error.name,\n          stack: error.stack?.split('\\n').slice(0, 5).join('\\n') // Limit stack trace\n        },\n        user_context: {\n          time_on_page: Date.now() - this.currentPageStartTime,\n          session_duration: Date.now() - this.sessionStartTime,\n          page_interactions: this.countPageInteractions()\n        },\n        custom_context: context || {}\n      }\n    };\n\n    this.addJourneyEvent(journeyEvent);\n  }\n\n  /**\n   * Setup event listeners for journey tracking\n   */\n  private setupJourneyTracking(): void {\n    // Track page views on navigation\n    let currentUrl = window.location.href;\n    \n    const handleNavigation = () => {\n      if (window.location.href !== currentUrl) {\n        // Track time spent on previous page\n        const timeSpent = Date.now() - this.currentPageStartTime;\n        this.updateLastPageViewDuration(timeSpent);\n        \n        // Track new page view\n        currentUrl = window.location.href;\n        this.currentPageStartTime = Date.now();\n        this.trackPageView();\n      }\n    };\n\n    // Handle navigation events\n    window.addEventListener('popstate', handleNavigation);\n    \n    // Override pushState and replaceState to catch programmatic navigation\n    const originalPushState = history.pushState;\n    const originalReplaceState = history.replaceState;\n    \n    history.pushState = function(...args) {\n      originalPushState.apply(history, args);\n      setTimeout(handleNavigation, 0);\n    };\n    \n    history.replaceState = function(...args) {\n      originalReplaceState.apply(history, args);\n      setTimeout(handleNavigation, 0);\n    };\n\n    // Track clicks\n    document.addEventListener('click', (event) => {\n      const target = event.target as HTMLElement;\n      if (target && this.shouldTrackClick(target)) {\n        this.trackClick(target, event);\n      }\n    }, { capture: true, passive: true });\n\n    // Track form submissions\n    document.addEventListener('submit', (event) => {\n      const form = event.target as HTMLFormElement;\n      if (form && form.tagName === 'FORM') {\n        this.trackFormSubmit(form);\n      }\n    }, { capture: true, passive: true });\n\n    // Track page exit\n    window.addEventListener('beforeunload', () => {\n      const timeSpent = Date.now() - this.currentPageStartTime;\n      this.updateLastPageViewDuration(timeSpent);\n      this.flush();\n    });\n\n    // Periodic flush\n    setInterval(() => {\n      if (this.journeyEvents.length > 0) {\n        this.flush();\n      }\n    }, 30000); // Flush every 30 seconds\n  }\n\n  /**\n   * Generate device fingerprint for user tracking\n   */\n  private generateDeviceFingerprint(): string {\n    if (typeof window === 'undefined') return 'server';\n\n    const components = [\n      navigator.userAgent,\n      navigator.language,\n      screen.width + 'x' + screen.height,\n      screen.colorDepth,\n      Intl.DateTimeFormat().resolvedOptions().timeZone,\n      navigator.platform,\n      navigator.cookieEnabled,\n      typeof window.localStorage !== 'undefined',\n      typeof window.sessionStorage !== 'undefined'\n    ];\n\n    // Add canvas fingerprint if available\n    try {\n      const canvas = document.createElement('canvas');\n      const ctx = canvas.getContext('2d');\n      if (ctx) {\n        ctx.textBaseline = 'top';\n        ctx.font = '14px Arial';\n        ctx.fillText('Device fingerprint', 2, 2);\n        components.push(canvas.toDataURL());\n      }\n    } catch (e) {\n      // Canvas fingerprinting failed\n    }\n\n    // Create hash of all components\n    const fingerprint = components.join('|');\n    \n    // Simple hash function (in production, use a proper crypto library)\n    let hash = 0;\n    for (let i = 0; i < fingerprint.length; i++) {\n      const char = fingerprint.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    \n    return Math.abs(hash).toString(36);\n  }\n\n  /**\n   * Add journey event to buffer\n   */\n  private addJourneyEvent(event: JourneyEvent): void {\n    this.journeyEvents.push(event);\n\n    // Auto-flush if buffer is full\n    if (this.journeyEvents.length >= 50) {\n      this.flush();\n    }\n  }\n\n  /**\n   * Flush journey events to backend\n   */\n  private flush(): void {\n    if (this.journeyEvents.length === 0) return;\n\n    const events = [...this.journeyEvents];\n    this.journeyEvents = [];\n\n    // Send to backend (implement based on your API structure)\n    this.sendJourneyEvents(events).catch(error => {\n      if (this.config.debug) {\n        console.error('Revi: Failed to send journey events', error);\n      }\n      // Re-add events to buffer for retry\n      this.journeyEvents.unshift(...events);\n    });\n  }\n\n  /**\n   * Send journey events to analytics backend\n   */\n  private async sendJourneyEvents(events: JourneyEvent[]): Promise<void> {\n    const apiUrl = this.config.apiUrl || 'https://api.revi.dev';\n    \n    // Send each event individually (could be optimized for batch sending)\n    const promises = events.map(event => \n      fetch(`${apiUrl}/api/analytics/user-event`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-API-Key': this.config.apiKey\n        },\n        body: JSON.stringify({\n          user_id: this.userId,\n          session_id: this.getSessionId(),\n          ...event\n        })\n      })\n    );\n\n    await Promise.allSettled(promises);\n  }\n\n  /**\n   * Helper methods\n   */\n  private shouldTrackClick(element: HTMLElement): boolean {\n    // Don't track clicks on sensitive elements\n    const tag = element.tagName.toLowerCase();\n    if (['input', 'textarea'].includes(tag)) {\n      const input = element as HTMLInputElement;\n      if (['password', 'hidden'].includes(input.type)) {\n        return false;\n      }\n    }\n\n    // Don't track if element has data-revi-ignore attribute\n    return !element.hasAttribute('data-revi-ignore');\n  }\n\n  private getElementText(element: HTMLElement): string {\n    const text = element.textContent || element.innerText || '';\n    return text.trim().substring(0, 100);\n  }\n\n  private getRelevantAttributes(element: HTMLElement): Record<string, string> {\n    const attrs: Record<string, string> = {};\n    const relevantAttrs = ['href', 'src', 'alt', 'title', 'data-testid', 'role'];\n    \n    relevantAttrs.forEach(attr => {\n      const value = element.getAttribute(attr);\n      if (value) {\n        attrs[attr] = value;\n      }\n    });\n    \n    return attrs;\n  }\n\n  private getConnectionType(): string {\n    if ('connection' in navigator) {\n      const connection = (navigator as any).connection;\n      return connection?.effectiveType || connection?.type || 'unknown';\n    }\n    return 'unknown';\n  }\n\n  private countPageInteractions(): number {\n    return this.journeyEvents.filter(event => \n      ['click', 'form_submit'].includes(event.event_type)\n    ).length;\n  }\n\n  private updateLastPageViewDuration(duration: number): void {\n    if (this.journeyEvents.length > 0) {\n      const lastEvent = this.journeyEvents[this.journeyEvents.length - 1];\n      if (lastEvent.event_type === 'page_view') {\n        lastEvent.duration_ms = duration;\n      }\n    }\n  }\n\n  private getSessionId(): string {\n    // This should be implemented to get session ID from session manager\n    // For now, return a placeholder\n    return 'session-' + Date.now();\n  }\n}","import type { ReviConfig } from './types';\n\nexport interface SerializedNode {\n  type: 'document' | 'element' | 'text' | 'comment';\n  tagName?: string;\n  attributes?: Record<string, string>;\n  textContent?: string;\n  children?: SerializedNode[];\n  id?: number;\n  parentId?: number;\n}\n\nexport interface DOMSnapshot {\n  timestamp: number;\n  url: string;\n  viewport: {\n    width: number;\n    height: number;\n  };\n  scroll: {\n    x: number;\n    y: number;\n  };\n  nodes: SerializedNode[];\n  stylesheets: SerializedStylesheet[];\n  resources: SerializedResource[];\n}\n\nexport interface SerializedStylesheet {\n  href?: string;\n  cssText: string;\n  disabled: boolean;\n}\n\nexport interface SerializedResource {\n  url: string;\n  type: 'image' | 'font' | 'media';\n  data?: string; // Base64 encoded data for small resources\n  failed?: boolean;\n}\n\nexport interface DOMChange {\n  timestamp: number;\n  type: 'childList' | 'attributes' | 'characterData';\n  target: number; // Node ID\n  addedNodes?: SerializedNode[];\n  removedNodes?: number[]; // Node IDs\n  attributeName?: string;\n  attributeValue?: string;\n  oldValue?: string;\n}\n\n/**\n * Advanced DOM serializer for session replay with rrweb-like capabilities\n */\nexport class DOMSerializer {\n  private config: ReviConfig;\n  private nodeIdMap = new WeakMap<Node, number>();\n  private nodeMap = new Map<number, Node>();\n  private nextNodeId = 1;\n  private observer?: MutationObserver;\n  private isObserving = false;\n  private onDOMChange?: (change: DOMChange) => void;\n\n  constructor(config: ReviConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Take a complete snapshot of the DOM\n   */\n  takeSnapshot(): DOMSnapshot {\n    const snapshot: DOMSnapshot = {\n      timestamp: Date.now(),\n      url: window.location.href,\n      viewport: {\n        width: window.innerWidth,\n        height: window.innerHeight\n      },\n      scroll: {\n        x: window.scrollX,\n        y: window.scrollY\n      },\n      nodes: [],\n      stylesheets: [],\n      resources: []\n    };\n\n    // Serialize DOM\n    snapshot.nodes = this.serializeDocument(document);\n    \n    // Capture stylesheets\n    snapshot.stylesheets = this.serializeStylesheets();\n    \n    // Capture resources (images, fonts, etc.)\n    snapshot.resources = this.serializeResources();\n\n    return snapshot;\n  }\n\n  /**\n   * Start observing DOM changes\n   */\n  startObserving(onDOMChange: (change: DOMChange) => void): void {\n    if (this.isObserving) return;\n\n    this.onDOMChange = onDOMChange;\n    this.observer = new MutationObserver(this.handleMutations.bind(this));\n    \n    this.observer.observe(document, {\n      childList: true,\n      attributes: true,\n      characterData: true,\n      subtree: true,\n      attributeOldValue: true,\n      characterDataOldValue: true\n    });\n\n    this.isObserving = true;\n  }\n\n  /**\n   * Stop observing DOM changes\n   */\n  stopObserving(): void {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = undefined;\n    }\n    this.isObserving = false;\n    this.onDOMChange = undefined;\n  }\n\n  /**\n   * Serialize the entire document\n   */\n  private serializeDocument(doc: Document): SerializedNode[] {\n    const doctype = doc.doctype;\n    const nodes: SerializedNode[] = [];\n\n    // Add doctype if present\n    if (doctype) {\n      nodes.push({\n        type: 'document',\n        tagName: 'DOCTYPE',\n        attributes: {\n          name: doctype.name,\n          publicId: doctype.publicId,\n          systemId: doctype.systemId\n        },\n        id: this.getNodeId(doctype)\n      });\n    }\n\n    // Serialize document element (html)\n    if (doc.documentElement) {\n      const serialized = this.serializeNode(doc.documentElement);\n      if (serialized) {\n        nodes.push(serialized);\n      }\n    }\n\n    return nodes;\n  }\n\n  /**\n   * Serialize a single DOM node\n   */\n  private serializeNode(node: Node): SerializedNode | null {\n    if (this.shouldIgnoreNode(node)) {\n      return null;\n    }\n\n    const nodeId = this.getNodeId(node);\n    const serialized: SerializedNode = {\n      type: this.getNodeType(node),\n      id: nodeId\n    };\n\n    switch (node.nodeType) {\n      case Node.ELEMENT_NODE:\n        const element = node as Element;\n        serialized.tagName = element.tagName.toLowerCase();\n        serialized.attributes = this.serializeAttributes(element);\n        serialized.children = this.serializeChildren(element);\n        break;\n\n      case Node.TEXT_NODE:\n        const textNode = node as Text;\n        serialized.textContent = this.shouldMaskText(textNode) ? '[Masked]' : textNode.textContent || '';\n        break;\n\n      case Node.COMMENT_NODE:\n        const commentNode = node as Comment;\n        serialized.textContent = commentNode.textContent || '';\n        break;\n\n      default:\n        return null;\n    }\n\n    return serialized;\n  }\n\n  /**\n   * Serialize element attributes\n   */\n  private serializeAttributes(element: Element): Record<string, string> {\n    const attributes: Record<string, string> = {};\n    \n    for (let i = 0; i < element.attributes.length; i++) {\n      const attr = element.attributes[i];\n      const name = attr.name.toLowerCase();\n      \n      // Skip sensitive attributes\n      if (this.shouldIgnoreAttribute(name, attr.value)) {\n        continue;\n      }\n\n      // Mask sensitive values\n      if (this.shouldMaskAttribute(name, element)) {\n        attributes[name] = '[Masked]';\n      } else {\n        attributes[name] = attr.value;\n      }\n    }\n\n    return attributes;\n  }\n\n  /**\n   * Serialize element children\n   */\n  private serializeChildren(element: Element): SerializedNode[] {\n    const children: SerializedNode[] = [];\n    \n    for (let i = 0; i < element.childNodes.length; i++) {\n      const child = element.childNodes[i];\n      const serializedChild = this.serializeNode(child);\n      \n      if (serializedChild) {\n        children.push(serializedChild);\n      }\n    }\n\n    return children;\n  }\n\n  /**\n   * Serialize all stylesheets\n   */\n  private serializeStylesheets(): SerializedStylesheet[] {\n    const stylesheets: SerializedStylesheet[] = [];\n\n    for (let i = 0; i < document.styleSheets.length; i++) {\n      const stylesheet = document.styleSheets[i];\n      \n      try {\n        let cssText = '';\n        \n        if (stylesheet.href) {\n          // External stylesheet - we'll capture the URL\n          // In production, you might want to fetch and inline the CSS\n          cssText = `/* External stylesheet: ${stylesheet.href} */`;\n        } else {\n          // Inline stylesheet - capture the rules\n          if (stylesheet.cssRules) {\n            const rules = Array.from(stylesheet.cssRules);\n            cssText = rules.map(rule => rule.cssText).join('\\n');\n          }\n        }\n\n        stylesheets.push({\n          href: stylesheet.href || undefined,\n          cssText,\n          disabled: stylesheet.disabled\n        });\n      } catch (error) {\n        // CORS issues or other access problems\n        if (stylesheet.href) {\n          stylesheets.push({\n            href: stylesheet.href,\n            cssText: `/* Could not access stylesheet: ${stylesheet.href} */`,\n            disabled: stylesheet.disabled\n          });\n        }\n      }\n    }\n\n    return stylesheets;\n  }\n\n  /**\n   * Serialize resources (images, fonts, etc.)\n   */\n  private serializeResources(): SerializedResource[] {\n    const resources: SerializedResource[] = [];\n\n    // Capture images\n    const images = document.querySelectorAll('img');\n    images.forEach(img => {\n      if (img.src && !this.shouldIgnoreResource(img.src)) {\n        resources.push({\n          url: img.src,\n          type: 'image',\n          failed: !img.complete || img.naturalWidth === 0\n        });\n      }\n    });\n\n    // Capture background images from computed styles\n    const elementsWithBackgrounds = document.querySelectorAll('*');\n    elementsWithBackgrounds.forEach(element => {\n      const style = window.getComputedStyle(element);\n      const backgroundImage = style.backgroundImage;\n      \n      if (backgroundImage && backgroundImage !== 'none') {\n        const urlMatch = backgroundImage.match(/url\\(['\"]?([^'\")]+)['\"]?\\)/);\n        if (urlMatch && urlMatch[1] && !this.shouldIgnoreResource(urlMatch[1])) {\n          resources.push({\n            url: urlMatch[1],\n            type: 'image'\n          });\n        }\n      }\n    });\n\n    return resources;\n  }\n\n  /**\n   * Handle mutation events\n   */\n  private handleMutations(mutations: MutationRecord[]): void {\n    mutations.forEach(mutation => {\n      const targetId = this.nodeIdMap.get(mutation.target);\n      if (!targetId) return;\n\n      const change: DOMChange = {\n        timestamp: Date.now(),\n        type: mutation.type,\n        target: targetId\n      };\n\n      switch (mutation.type) {\n        case 'childList':\n          if (mutation.addedNodes.length > 0) {\n            change.addedNodes = Array.from(mutation.addedNodes)\n              .map(node => this.serializeNode(node))\n              .filter((node): node is SerializedNode => node !== null);\n          }\n          \n          if (mutation.removedNodes.length > 0) {\n            change.removedNodes = Array.from(mutation.removedNodes)\n              .map(node => this.nodeIdMap.get(node))\n              .filter((id): id is number => id !== undefined);\n          }\n          break;\n\n        case 'attributes':\n          change.attributeName = mutation.attributeName || undefined;\n          if (mutation.target.nodeType === Node.ELEMENT_NODE) {\n            const element = mutation.target as Element;\n            const value = element.getAttribute(mutation.attributeName || '');\n            change.attributeValue = this.shouldMaskAttribute(\n              mutation.attributeName || '', element\n            ) ? '[Masked]' : value || '';\n          }\n          change.oldValue = mutation.oldValue || undefined;\n          break;\n\n        case 'characterData':\n          change.attributeValue = this.shouldMaskText(mutation.target as Text) \n            ? '[Masked]' \n            : mutation.target.textContent || '';\n          change.oldValue = mutation.oldValue || undefined;\n          break;\n      }\n\n      if (this.onDOMChange) {\n        this.onDOMChange(change);\n      }\n    });\n  }\n\n  /**\n   * Utility methods\n   */\n  private getNodeId(node: Node): number {\n    if (this.nodeIdMap.has(node)) {\n      return this.nodeIdMap.get(node)!;\n    }\n    \n    const id = this.nextNodeId++;\n    this.nodeIdMap.set(node, id);\n    this.nodeMap.set(id, node);\n    \n    return id;\n  }\n\n  private getNodeType(node: Node): SerializedNode['type'] {\n    switch (node.nodeType) {\n      case Node.ELEMENT_NODE:\n        return 'element';\n      case Node.TEXT_NODE:\n        return 'text';\n      case Node.COMMENT_NODE:\n        return 'comment';\n      case Node.DOCUMENT_NODE:\n        return 'document';\n      default:\n        return 'element';\n    }\n  }\n\n  private shouldIgnoreNode(node: Node): boolean {\n    if (node.nodeType === Node.ELEMENT_NODE) {\n      const element = node as Element;\n      const tagName = element.tagName.toLowerCase();\n      \n      // Ignore script tags and other sensitive elements\n      if (['script', 'noscript', 'meta'].includes(tagName)) {\n        return true;\n      }\n      \n      // Ignore elements with data-revi-ignore attribute\n      if (element.hasAttribute('data-revi-ignore')) {\n        return true;\n      }\n      \n      // Ignore elements that match block selector\n      if (this.config.replay?.blockSelector) {\n        try {\n          if (element.matches(this.config.replay.blockSelector)) {\n            return true;\n          }\n        } catch (e) {\n          // Invalid selector\n        }\n      }\n    }\n    \n    return false;\n  }\n\n  private shouldIgnoreAttribute(name: string, value: string): boolean {\n    // Ignore sensitive attributes\n    const sensitiveAttrs = ['data-revi-ignore', 'data-password', 'data-sensitive'];\n    return sensitiveAttrs.includes(name);\n  }\n\n  private shouldMaskAttribute(name: string, element: Element): boolean {\n    if (!this.config.privacy?.maskInputs) return false;\n    \n    // Mask values of sensitive input fields\n    if (element.tagName.toLowerCase() === 'input') {\n      const input = element as HTMLInputElement;\n      const sensitiveTypes = ['password', 'email', 'tel'];\n      if (sensitiveTypes.includes(input.type)) {\n        return name === 'value';\n      }\n    }\n    \n    return false;\n  }\n\n  private shouldMaskText(textNode: Text): boolean {\n    if (!this.config.replay?.maskAllText && !this.config.privacy?.maskInputs) {\n      return false;\n    }\n    \n    const parent = textNode.parentElement;\n    if (!parent) return false;\n    \n    // Mask text in sensitive elements\n    const sensitiveElements = ['input', 'textarea'];\n    if (sensitiveElements.includes(parent.tagName.toLowerCase())) {\n      return true;\n    }\n    \n    // Check for mask selector\n    if (this.config.replay?.maskSelector) {\n      try {\n        return parent.matches(this.config.replay.maskSelector);\n      } catch (e) {\n        return false;\n      }\n    }\n    \n    return this.config.replay?.maskAllText || false;\n  }\n\n  private shouldIgnoreResource(url: string): boolean {\n    try {\n      const urlObj = new URL(url, window.location.href);\n      \n      // Ignore data URLs (they're inline)\n      if (urlObj.protocol === 'data:') return true;\n      \n      // Ignore very large images\n      if (url.includes('?')) {\n        const params = new URLSearchParams(urlObj.search);\n        const width = params.get('w') || params.get('width');\n        const height = params.get('h') || params.get('height');\n        if (width && parseInt(width) > 2000) return true;\n        if (height && parseInt(height) > 2000) return true;\n      }\n      \n      return false;\n    } catch (e) {\n      return true; // Invalid URL\n    }\n  }\n}","import { SessionEvent } from './types';\n\nexport interface ConsoleLogEntry {\n  id: string;\n  timestamp: number;\n  level: 'log' | 'info' | 'warn' | 'error' | 'debug' | 'trace';\n  args: any[];\n  stack?: string;\n  url?: string;\n  lineNumber?: number;\n  columnNumber?: number;\n}\n\nexport interface ConsoleRecorderConfig {\n  maxEntries: number;\n  captureStackTrace: boolean;\n  serializeObjects: boolean;\n  maxObjectDepth: number;\n  maxStringLength: number;\n  ignoredLevels: string[];\n}\n\nexport class ConsoleRecorder {\n  private originalMethods: Record<string, Function> = {};\n  private entries: ConsoleLogEntry[] = [];\n  private config: ConsoleRecorderConfig;\n  private isRecording = false;\n  private sessionId: string;\n\n  constructor(sessionId: string, config: Partial<ConsoleRecorderConfig> = {}) {\n    this.sessionId = sessionId;\n    this.config = {\n      maxEntries: 1000,\n      captureStackTrace: true,\n      serializeObjects: true,\n      maxObjectDepth: 3,\n      maxStringLength: 10000,\n      ignoredLevels: [],\n      ...config\n    };\n  }\n\n  start(): void {\n    if (this.isRecording) return;\n\n    const levels: Array<keyof Console> = ['log', 'info', 'warn', 'error', 'debug', 'trace'];\n    \n    levels.forEach(level => {\n      if (this.config.ignoredLevels.includes(level)) return;\n      \n      const originalMethod = console[level];\n      this.originalMethods[level] = originalMethod;\n      \n      console[level] = (...args: any[]) => {\n        // Call original method first\n        originalMethod.apply(console, args);\n        \n        // Record the log entry\n        this.recordEntry(level as ConsoleLogEntry['level'], args);\n      };\n    });\n\n    this.isRecording = true;\n  }\n\n  stop(): void {\n    if (!this.isRecording) return;\n\n    // Restore original console methods\n    Object.entries(this.originalMethods).forEach(([level, method]) => {\n      (console as any)[level] = method;\n    });\n\n    this.originalMethods = {};\n    this.isRecording = false;\n  }\n\n  private recordEntry(level: ConsoleLogEntry['level'], args: any[]): void {\n    try {\n      const entry: ConsoleLogEntry = {\n        id: this.generateId(),\n        timestamp: Date.now(),\n        level,\n        args: this.serializeArgs(args)\n      };\n\n      // Capture stack trace for errors and warnings\n      if ((level === 'error' || level === 'warn') && this.config.captureStackTrace) {\n        const error = new Error();\n        if (error.stack) {\n          entry.stack = this.cleanStackTrace(error.stack);\n        }\n      }\n\n      // Add source location if available\n      if (level === 'error' && args[0] instanceof Error) {\n        const error = args[0] as Error;\n        // Try to extract location from error stack\n        const stackLines = error.stack?.split('\\n') || [];\n        const sourceLine = stackLines.find(line => \n          line.includes('.js:') || line.includes('.ts:') || line.includes('.tsx:')\n        );\n        \n        if (sourceLine) {\n          const match = sourceLine.match(/([^/]+):(\\d+):(\\d+)/);\n          if (match) {\n            entry.url = match[1];\n            entry.lineNumber = parseInt(match[2]);\n            entry.columnNumber = parseInt(match[3]);\n          }\n        }\n      }\n\n      this.addEntry(entry);\n    } catch (error) {\n      // Fail silently to avoid infinite loops\n      this.originalMethods.warn?.call(console, 'ConsoleRecorder error:', error);\n    }\n  }\n\n  private serializeArgs(args: any[]): any[] {\n    return args.map(arg => this.serializeValue(arg, 0));\n  }\n\n  private serializeValue(value: any, depth: number): any {\n    if (depth > this.config.maxObjectDepth) {\n      return '[Object too deep]';\n    }\n\n    if (value === null || value === undefined) {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      return value.length > this.config.maxStringLength \n        ? value.substring(0, this.config.maxStringLength) + '...'\n        : value;\n    }\n\n    if (typeof value === 'number' || typeof value === 'boolean') {\n      return value;\n    }\n\n    if (typeof value === 'function') {\n      return `[Function: ${value.name || 'anonymous'}]`;\n    }\n\n    if (value instanceof Error) {\n      return {\n        name: value.name,\n        message: value.message,\n        stack: this.config.captureStackTrace ? this.cleanStackTrace(value.stack || '') : undefined\n      };\n    }\n\n    if (value instanceof Date) {\n      return {\n        __type: 'Date',\n        value: value.toISOString()\n      };\n    }\n\n    if (value instanceof RegExp) {\n      return {\n        __type: 'RegExp',\n        value: value.toString()\n      };\n    }\n\n    if (Array.isArray(value)) {\n      if (!this.config.serializeObjects) return '[Array]';\n      \n      return value.slice(0, 100).map(item => this.serializeValue(item, depth + 1));\n    }\n\n    if (typeof value === 'object') {\n      if (!this.config.serializeObjects) return '[Object]';\n      \n      try {\n        const serialized: Record<string, any> = {};\n        const keys = Object.keys(value).slice(0, 50); // Limit keys\n        \n        for (const key of keys) {\n          try {\n            serialized[key] = this.serializeValue(value[key], depth + 1);\n          } catch {\n            serialized[key] = '[Unserializable]';\n          }\n        }\n        \n        if (Object.keys(value).length > 50) {\n          serialized['...'] = `[${Object.keys(value).length - 50} more keys]`;\n        }\n        \n        return serialized;\n      } catch {\n        return '[Unserializable Object]';\n      }\n    }\n\n    return String(value);\n  }\n\n  private cleanStackTrace(stack: string): string {\n    return stack\n      .split('\\n')\n      .filter(line => \n        !line.includes('console-recorder.ts') && \n        !line.includes('ConsoleRecorder')\n      )\n      .slice(0, 10) // Limit stack depth\n      .join('\\n');\n  }\n\n  private addEntry(entry: ConsoleLogEntry): void {\n    this.entries.push(entry);\n    \n    // Maintain max entries limit\n    if (this.entries.length > this.config.maxEntries) {\n      this.entries = this.entries.slice(-this.config.maxEntries * 0.8);\n    }\n  }\n\n  private generateId(): string {\n    return `console-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  getEntries(fromTimestamp?: number, toTimestamp?: number): ConsoleLogEntry[] {\n    let filtered = this.entries;\n    \n    if (fromTimestamp) {\n      filtered = filtered.filter(entry => entry.timestamp >= fromTimestamp);\n    }\n    \n    if (toTimestamp) {\n      filtered = filtered.filter(entry => entry.timestamp <= toTimestamp);\n    }\n    \n    return [...filtered];\n  }\n\n  getEntriesByLevel(level: ConsoleLogEntry['level']): ConsoleLogEntry[] {\n    return this.entries.filter(entry => entry.level === level);\n  }\n\n  clear(): void {\n    this.entries = [];\n  }\n\n  // Convert console entries to session events format\n  toSessionEvents(): SessionEvent[] {\n    return this.entries.map(entry => ({\n      session_id: this.sessionId,\n      event_type: 'console',\n      data: {\n        level: entry.level,\n        args: entry.args,\n        stack: entry.stack,\n        url: entry.url,\n        lineNumber: entry.lineNumber,\n        columnNumber: entry.columnNumber,\n        consoleId: entry.id\n      },\n      timestamp: entry.timestamp,\n      url: entry.url || window.location.href,\n      user_agent: navigator.userAgent\n    }));\n  }\n\n  // Export for analysis\n  exportData(): {\n    sessionId: string;\n    config: ConsoleRecorderConfig;\n    entries: ConsoleLogEntry[];\n    stats: {\n      totalEntries: number;\n      levelCounts: Record<string, number>;\n      errorCount: number;\n      warningCount: number;\n      timeRange: { start: number; end: number };\n    };\n  } {\n    const levelCounts: Record<string, number> = {};\n    let minTime = Infinity;\n    let maxTime = -Infinity;\n\n    this.entries.forEach(entry => {\n      levelCounts[entry.level] = (levelCounts[entry.level] || 0) + 1;\n      minTime = Math.min(minTime, entry.timestamp);\n      maxTime = Math.max(maxTime, entry.timestamp);\n    });\n\n    return {\n      sessionId: this.sessionId,\n      config: this.config,\n      entries: [...this.entries],\n      stats: {\n        totalEntries: this.entries.length,\n        levelCounts,\n        errorCount: levelCounts.error || 0,\n        warningCount: levelCounts.warn || 0,\n        timeRange: {\n          start: minTime === Infinity ? 0 : minTime,\n          end: maxTime === -Infinity ? 0 : maxTime\n        }\n      }\n    };\n  }\n\n  // Generate insights from console logs\n  generateInsights(): {\n    errorPatterns: Array<{ pattern: string; count: number; examples: ConsoleLogEntry[] }>;\n    performanceIssues: Array<{ type: string; severity: 'low' | 'medium' | 'high'; details: string }>;\n    recommendations: string[];\n  } {\n    const errorPatterns = this.findErrorPatterns();\n    const performanceIssues = this.detectPerformanceIssues();\n    const recommendations = this.generateRecommendations();\n\n    return {\n      errorPatterns,\n      performanceIssues,\n      recommendations\n    };\n  }\n\n  private findErrorPatterns(): Array<{ pattern: string; count: number; examples: ConsoleLogEntry[] }> {\n    const errors = this.entries.filter(entry => entry.level === 'error');\n    const patterns: Record<string, ConsoleLogEntry[]> = {};\n\n    errors.forEach(error => {\n      let pattern = 'Unknown Error';\n      \n      if (error.args.length > 0) {\n        const firstArg = error.args[0];\n        if (typeof firstArg === 'string') {\n          // Extract error pattern from message\n          pattern = firstArg\n            .replace(/\\d+/g, 'N') // Replace numbers with N\n            .replace(/[\"'][^\"']*[\"']/g, 'STRING') // Replace strings with STRING\n            .replace(/\\b\\w+@\\w+\\.\\w+/g, 'EMAIL') // Replace emails\n            .replace(/https?:\\/\\/[^\\s]+/g, 'URL') // Replace URLs\n            .substring(0, 100);\n        } else if (typeof firstArg === 'object' && firstArg.name) {\n          pattern = `${firstArg.name}: ${firstArg.message}`.substring(0, 100);\n        }\n      }\n\n      if (!patterns[pattern]) {\n        patterns[pattern] = [];\n      }\n      patterns[pattern].push(error);\n    });\n\n    return Object.entries(patterns)\n      .sort(([, a], [, b]) => b.length - a.length)\n      .slice(0, 10)\n      .map(([pattern, examples]) => ({\n        pattern,\n        count: examples.length,\n        examples: examples.slice(0, 3) // Show first 3 examples\n      }));\n  }\n\n  private detectPerformanceIssues(): Array<{ type: string; severity: 'low' | 'medium' | 'high'; details: string }> {\n    const issues: Array<{ type: string; severity: 'low' | 'medium' | 'high'; details: string }> = [];\n    \n    // Check for excessive logging\n    const recentEntries = this.entries.filter(entry => \n      entry.timestamp > Date.now() - 60000 // Last minute\n    );\n    \n    if (recentEntries.length > 100) {\n      issues.push({\n        type: 'Excessive Logging',\n        severity: 'medium',\n        details: `${recentEntries.length} console entries in the last minute may impact performance`\n      });\n    }\n\n    // Check for repeated errors\n    const errorCounts: Record<string, number> = {};\n    this.entries\n      .filter(entry => entry.level === 'error')\n      .forEach(entry => {\n        const key = JSON.stringify(entry.args);\n        errorCounts[key] = (errorCounts[key] || 0) + 1;\n      });\n\n    Object.entries(errorCounts).forEach(([error, count]) => {\n      if (count > 10) {\n        issues.push({\n          type: 'Repeated Error',\n          severity: count > 50 ? 'high' : 'medium',\n          details: `Same error occurred ${count} times`\n        });\n      }\n    });\n\n    // Check for potential memory leaks (objects not being cleaned up)\n    const objectLogs = this.entries.filter(entry => \n      entry.args.some(arg => \n        typeof arg === 'object' && \n        arg !== null && \n        !Array.isArray(arg)\n      )\n    );\n    \n    if (objectLogs.length > this.entries.length * 0.5) {\n      issues.push({\n        type: 'Object Logging',\n        severity: 'low',\n        details: 'High percentage of object logging may indicate memory leaks'\n      });\n    }\n\n    return issues;\n  }\n\n  private generateRecommendations(): string[] {\n    const recommendations: string[] = [];\n    const stats = this.exportData().stats;\n\n    if (stats.errorCount > 0) {\n      recommendations.push(\n        `Found ${stats.errorCount} console errors. Review error patterns and fix underlying issues.`\n      );\n    }\n\n    if (stats.warningCount > stats.errorCount * 2) {\n      recommendations.push(\n        'High warning-to-error ratio suggests proactive error handling could prevent issues.'\n      );\n    }\n\n    if (stats.totalEntries > 500) {\n      recommendations.push(\n        'Consider reducing console logging in production to improve performance.'\n      );\n    }\n\n    if (stats.levelCounts.debug && stats.levelCounts.debug > 100) {\n      recommendations.push(\n        'Debug logs should be disabled in production environments.'\n      );\n    }\n\n    if (recommendations.length === 0) {\n      recommendations.push('Console logging patterns look healthy.');\n    }\n\n    return recommendations;\n  }\n}","import { SessionEvent } from './types';\n\nexport interface HeatmapData {\n  x: number;\n  y: number;\n  intensity: number;\n  event_type: 'click' | 'move' | 'scroll' | 'hover';\n  timestamp: number;\n}\n\nexport interface HeatmapConfig {\n  radius: number;\n  maxIntensity: number;\n  gradient: Record<string, string>;\n  blur: number;\n  minOpacity: number;\n  maxOpacity: number;\n}\n\nexport class HeatmapGenerator {\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n  private config: HeatmapConfig;\n  private data: HeatmapData[] = [];\n\n  constructor(container: HTMLElement, config: Partial<HeatmapConfig> = {}) {\n    this.config = {\n      radius: 20,\n      maxIntensity: 100,\n      gradient: {\n        0.4: 'blue',\n        0.6: 'cyan',\n        0.7: 'lime',\n        0.8: 'yellow',\n        1.0: 'red'\n      },\n      blur: 15,\n      minOpacity: 0,\n      maxOpacity: 0.6,\n      ...config\n    };\n\n    this.canvas = document.createElement('canvas');\n    this.canvas.style.position = 'absolute';\n    this.canvas.style.top = '0';\n    this.canvas.style.left = '0';\n    this.canvas.style.pointerEvents = 'none';\n    this.canvas.style.zIndex = '9999';\n    \n    container.appendChild(this.canvas);\n    \n    const ctx = this.canvas.getContext('2d');\n    if (!ctx) {\n      throw new Error('Failed to get canvas context');\n    }\n    this.ctx = ctx;\n\n    this.resizeCanvas();\n    window.addEventListener('resize', () => this.resizeCanvas());\n  }\n\n  private resizeCanvas(): void {\n    const rect = this.canvas.parentElement!.getBoundingClientRect();\n    this.canvas.width = rect.width;\n    this.canvas.height = rect.height;\n    this.canvas.style.width = rect.width + 'px';\n    this.canvas.style.height = rect.height + 'px';\n  }\n\n  addDataPoint(x: number, y: number, intensity: number, eventType: HeatmapData['event_type']): void {\n    this.data.push({\n      x,\n      y,\n      intensity,\n      event_type: eventType,\n      timestamp: Date.now()\n    });\n    \n    // Limit data points to prevent memory issues\n    if (this.data.length > 10000) {\n      this.data = this.data.slice(-8000);\n    }\n  }\n\n  generateFromEvents(events: SessionEvent[]): void {\n    this.data = [];\n    \n    events.forEach(event => {\n      if (event.event_type === 'click' && event.data?.x && event.data?.y) {\n        this.addDataPoint(\n          event.data.x,\n          event.data.y,\n          10,\n          'click'\n        );\n      } else if (event.event_type === 'mousemove' && event.data?.x && event.data?.y) {\n        this.addDataPoint(\n          event.data.x,\n          event.data.y,\n          2,\n          'move'\n        );\n      } else if (event.event_type === 'scroll' && event.data?.scrollX !== undefined && event.data?.scrollY !== undefined) {\n        // Convert scroll position to viewport coordinates\n        this.addDataPoint(\n          event.data.scrollX || 0,\n          event.data.scrollY || 0,\n          5,\n          'scroll'\n        );\n      }\n    });\n  }\n\n  render(filter?: HeatmapData['event_type'][]): void {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    \n    if (this.data.length === 0) return;\n\n    const filteredData = filter \n      ? this.data.filter(d => filter.includes(d.event_type))\n      : this.data;\n\n    // Create intensity map\n    const intensityData = this.createIntensityMap(filteredData);\n    \n    // Create gradient\n    const gradient = this.createGradient();\n    \n    // Render heatmap\n    this.renderHeatmap(intensityData, gradient);\n  }\n\n  private createIntensityMap(data: HeatmapData[]): ImageData {\n    const shadowCanvas = document.createElement('canvas');\n    shadowCanvas.width = this.canvas.width;\n    shadowCanvas.height = this.canvas.height;\n    const shadowCtx = shadowCanvas.getContext('2d')!;\n\n    // Draw intensity points\n    data.forEach(point => {\n      const radius = this.config.radius;\n      const gradient = shadowCtx.createRadialGradient(\n        point.x, point.y, 0,\n        point.x, point.y, radius\n      );\n\n      const alpha = Math.min(point.intensity / this.config.maxIntensity, 1);\n      gradient.addColorStop(0, `rgba(0, 0, 0, ${alpha})`);\n      gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\n\n      shadowCtx.fillStyle = gradient;\n      shadowCtx.fillRect(\n        point.x - radius,\n        point.y - radius,\n        radius * 2,\n        radius * 2\n      );\n    });\n\n    // Apply blur\n    shadowCtx.filter = `blur(${this.config.blur}px)`;\n    shadowCtx.drawImage(shadowCanvas, 0, 0);\n\n    return shadowCtx.getImageData(0, 0, shadowCanvas.width, shadowCanvas.height);\n  }\n\n  private createGradient(): ImageData {\n    const gradientCanvas = document.createElement('canvas');\n    gradientCanvas.width = 256;\n    gradientCanvas.height = 1;\n    const gradientCtx = gradientCanvas.getContext('2d')!;\n\n    const gradient = gradientCtx.createLinearGradient(0, 0, 256, 0);\n    Object.entries(this.config.gradient).forEach(([stop, color]) => {\n      gradient.addColorStop(parseFloat(stop), color);\n    });\n\n    gradientCtx.fillStyle = gradient;\n    gradientCtx.fillRect(0, 0, 256, 1);\n\n    return gradientCtx.getImageData(0, 0, 256, 1);\n  }\n\n  private renderHeatmap(intensityData: ImageData, gradientData: ImageData): void {\n    const output = this.ctx.createImageData(intensityData.width, intensityData.height);\n    \n    for (let i = 0; i < intensityData.data.length; i += 4) {\n      const alpha = intensityData.data[i + 3];\n      \n      if (alpha > 0) {\n        const gradientIndex = Math.floor((alpha / 255) * 255) * 4;\n        \n        output.data[i] = gradientData.data[gradientIndex];     // R\n        output.data[i + 1] = gradientData.data[gradientIndex + 1]; // G\n        output.data[i + 2] = gradientData.data[gradientIndex + 2]; // B\n        output.data[i + 3] = Math.floor(alpha * this.config.maxOpacity); // A\n      }\n    }\n\n    this.ctx.putImageData(output, 0, 0);\n  }\n\n  clear(): void {\n    this.data = [];\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n\n  destroy(): void {\n    this.clear();\n    if (this.canvas.parentElement) {\n      this.canvas.parentElement.removeChild(this.canvas);\n    }\n    window.removeEventListener('resize', () => this.resizeCanvas());\n  }\n\n  // Export heatmap data for analysis\n  exportData(): {\n    config: HeatmapConfig;\n    data: HeatmapData[];\n    stats: {\n      totalEvents: number;\n      eventTypes: Record<string, number>;\n      timeRange: { start: number; end: number };\n      bounds: { minX: number; maxX: number; minY: number; maxY: number };\n    };\n  } {\n    const eventTypes: Record<string, number> = {};\n    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;\n    let minTime = Infinity, maxTime = -Infinity;\n\n    this.data.forEach(point => {\n      eventTypes[point.event_type] = (eventTypes[point.event_type] || 0) + 1;\n      \n      minX = Math.min(minX, point.x);\n      maxX = Math.max(maxX, point.x);\n      minY = Math.min(minY, point.y);\n      maxY = Math.max(maxY, point.y);\n      \n      minTime = Math.min(minTime, point.timestamp);\n      maxTime = Math.max(maxTime, point.timestamp);\n    });\n\n    return {\n      config: this.config,\n      data: [...this.data],\n      stats: {\n        totalEvents: this.data.length,\n        eventTypes,\n        timeRange: { start: minTime, end: maxTime },\n        bounds: { minX, maxX, minY, maxY }\n      }\n    };\n  }\n\n  // Generate insights from heatmap data\n  generateInsights(): {\n    hotSpots: Array<{ x: number; y: number; intensity: number; radius: number }>;\n    clickPatterns: Array<{ pattern: string; frequency: number }>;\n    userBehavior: {\n      mostActiveArea: { x: number; y: number; width: number; height: number };\n      averageClicksPerSession: number;\n      scrollDepth: number;\n      engagementScore: number;\n    };\n  } {\n    // Find hot spots using clustering\n    const hotSpots = this.findHotSpots();\n    \n    // Analyze click patterns\n    const clickPatterns = this.analyzeClickPatterns();\n    \n    // Generate user behavior insights\n    const userBehavior = this.analyzeUserBehavior();\n\n    return {\n      hotSpots,\n      clickPatterns,\n      userBehavior\n    };\n  }\n\n  private findHotSpots(): Array<{ x: number; y: number; intensity: number; radius: number }> {\n    const clusters: Array<{ x: number; y: number; intensity: number; count: number }> = [];\n    const clusterRadius = this.config.radius * 2;\n\n    this.data.forEach(point => {\n      let foundCluster = false;\n      \n      for (const cluster of clusters) {\n        const distance = Math.sqrt(\n          Math.pow(point.x - cluster.x, 2) + Math.pow(point.y - cluster.y, 2)\n        );\n        \n        if (distance <= clusterRadius) {\n          // Add to existing cluster\n          cluster.x = (cluster.x * cluster.count + point.x) / (cluster.count + 1);\n          cluster.y = (cluster.y * cluster.count + point.y) / (cluster.count + 1);\n          cluster.intensity += point.intensity;\n          cluster.count++;\n          foundCluster = true;\n          break;\n        }\n      }\n      \n      if (!foundCluster) {\n        clusters.push({\n          x: point.x,\n          y: point.y,\n          intensity: point.intensity,\n          count: 1\n        });\n      }\n    });\n\n    return clusters\n      .filter(cluster => cluster.count >= 3) // Only significant clusters\n      .sort((a, b) => b.intensity - a.intensity)\n      .slice(0, 10) // Top 10 hot spots\n      .map(cluster => ({\n        x: Math.round(cluster.x),\n        y: Math.round(cluster.y),\n        intensity: Math.round(cluster.intensity),\n        radius: Math.min(clusterRadius, cluster.count * 5)\n      }));\n  }\n\n  private analyzeClickPatterns(): Array<{ pattern: string; frequency: number }> {\n    const clicks = this.data.filter(d => d.event_type === 'click');\n    const patterns: Record<string, number> = {};\n\n    // Analyze sequential click patterns\n    for (let i = 0; i < clicks.length - 1; i++) {\n      const current = clicks[i];\n      const next = clicks[i + 1];\n      \n      const timeDiff = next.timestamp - current.timestamp;\n      if (timeDiff < 5000) { // Within 5 seconds\n        const pattern = `(${Math.round(current.x)},${Math.round(current.y)}) -> (${Math.round(next.x)},${Math.round(next.y)})`;\n        patterns[pattern] = (patterns[pattern] || 0) + 1;\n      }\n    }\n\n    return Object.entries(patterns)\n      .sort(([, a], [, b]) => b - a)\n      .slice(0, 5)\n      .map(([pattern, frequency]) => ({ pattern, frequency }));\n  }\n\n  private analyzeUserBehavior(): {\n    mostActiveArea: { x: number; y: number; width: number; height: number };\n    averageClicksPerSession: number;\n    scrollDepth: number;\n    engagementScore: number;\n  } {\n    const clicks = this.data.filter(d => d.event_type === 'click');\n    const scrolls = this.data.filter(d => d.event_type === 'scroll');\n\n    // Find most active area (bounding box of top 50% of events)\n    const sortedByIntensity = [...this.data].sort((a, b) => b.intensity - a.intensity);\n    const topHalf = sortedByIntensity.slice(0, Math.floor(sortedByIntensity.length * 0.5));\n    \n    const minX = Math.min(...topHalf.map(d => d.x));\n    const maxX = Math.max(...topHalf.map(d => d.x));\n    const minY = Math.min(...topHalf.map(d => d.y));\n    const maxY = Math.max(...topHalf.map(d => d.y));\n\n    const scrollDepth = scrolls.length > 0 \n      ? Math.max(...scrolls.map(s => s.y)) / this.canvas.height \n      : 0;\n\n    const engagementScore = Math.min(100, \n      (clicks.length * 2) + \n      (scrollDepth * 50) + \n      (this.data.filter(d => d.event_type === 'move').length * 0.1)\n    );\n\n    return {\n      mostActiveArea: {\n        x: Math.round(minX),\n        y: Math.round(minY),\n        width: Math.round(maxX - minX),\n        height: Math.round(maxY - minY)\n      },\n      averageClicksPerSession: Math.round(clicks.length),\n      scrollDepth: Math.round(scrollDepth * 100) / 100,\n      engagementScore: Math.round(engagementScore)\n    };\n  }\n}","import type { ReviConfig } from './types';\nimport { DOMSerializer, DOMSnapshot, DOMChange } from './dom-serializer';\nimport { ConsoleRecorder, ConsoleLogEntry } from './console-recorder';\nimport { HeatmapGenerator, HeatmapData } from './heatmap-generator';\n\nexport interface ReplayEvent {\n  type: 'full_snapshot' | 'incremental_snapshot' | 'meta' | 'custom';\n  timestamp: number;\n  data: any;\n}\n\nexport interface ConsoleLog {\n  timestamp: number;\n  level: 'log' | 'info' | 'warn' | 'error' | 'debug';\n  args: any[];\n  stack?: string;\n}\n\nexport interface NetworkRequest {\n  timestamp: number;\n  id: string;\n  method: string;\n  url: string;\n  status?: number;\n  duration?: number;\n  requestHeaders?: Record<string, string>;\n  responseHeaders?: Record<string, string>;\n  requestBody?: any;\n  responseBody?: any;\n  failed?: boolean;\n}\n\n/**\n * Advanced session replay system with console logs and network requests\n */\nexport class SessionReplayManager {\n  private config: ReviConfig;\n  private domSerializer: DOMSerializer;\n  private consoleRecorder: ConsoleRecorder;\n  private heatmapGenerator: HeatmapGenerator | null = null;\n  private events: ReplayEvent[] = [];\n  private consoleLogs: ConsoleLog[] = [];\n  private networkRequests: Map<string, NetworkRequest> = new Map();\n  private isRecording = false;\n  private sessionId: string;\n  private startTime: number;\n  private originalConsole: any = {};\n  private originalFetch: any;\n  private originalXMLHttpRequest: any;\n\n  constructor(config: ReviConfig, sessionId: string) {\n    this.config = config;\n    this.sessionId = sessionId;\n    this.startTime = Date.now();\n    this.domSerializer = new DOMSerializer(config);\n    this.consoleRecorder = new ConsoleRecorder(sessionId, {\n      maxEntries: config.replay?.maxConsoleEntries || 1000,\n      captureStackTrace: config.replay?.captureStackTrace !== false,\n      serializeObjects: config.replay?.serializeObjects !== false,\n      maxObjectDepth: config.replay?.maxObjectDepth || 3,\n      maxStringLength: config.replay?.maxStringLength || 10000,\n      ignoredLevels: config.replay?.ignoredConsoleLevels || []\n    });\n    \n    if (this.config.replay?.enabled) {\n      this.setupReplay();\n      \n      // Initialize heatmap generator if enabled\n      if (this.config.replay?.heatmaps?.enabled && typeof document !== 'undefined') {\n        const container = document.body || document.documentElement;\n        if (container) {\n          this.heatmapGenerator = new HeatmapGenerator(container, {\n            radius: config.replay?.heatmaps?.radius || 20,\n            maxIntensity: config.replay?.heatmaps?.maxIntensity || 100,\n            blur: config.replay?.heatmaps?.blur || 15,\n            maxOpacity: config.replay?.heatmaps?.maxOpacity || 0.6\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Start recording session replay\n   */\n  startRecording(): void {\n    if (this.isRecording || !this.config.replay?.enabled) return;\n\n    this.isRecording = true;\n    \n    // Take initial snapshot\n    this.takeFullSnapshot();\n    \n    // Start observing DOM changes\n    this.domSerializer.startObserving(this.handleDOMChange.bind(this));\n    \n    // Start console recording\n    this.consoleRecorder.start();\n    \n    // Setup network monitoring\n    this.setupNetworkCapture();\n    \n    // Setup mouse and keyboard tracking\n    this.setupInteractionTracking();\n    \n    // Periodic full snapshots\n    setInterval(() => {\n      if (this.isRecording) {\n        this.takeFullSnapshot();\n      }\n    }, 60000); // Every minute\n    \n    if (this.config.debug) {\n      console.log('Revi: Session replay started');\n    }\n  }\n\n  /**\n   * Stop recording session replay\n   */\n  stopRecording(): void {\n    if (!this.isRecording) return;\n\n    this.isRecording = false;\n    this.domSerializer.stopObserving();\n    this.consoleRecorder.stop();\n    this.restoreOriginalNetwork();\n    \n    if (this.heatmapGenerator) {\n      this.heatmapGenerator.destroy();\n      this.heatmapGenerator = null;\n    }\n    \n    if (this.config.debug) {\n      console.log('Revi: Session replay stopped');\n    }\n  }\n\n  /**\n   * Get all replay events\n   */\n  getReplayData(): {\n    events: ReplayEvent[];\n    console_logs: ConsoleLogEntry[];\n    network_requests: NetworkRequest[];\n    heatmap_data?: HeatmapData[];\n    session_info: {\n      session_id: string;\n      start_time: number;\n      duration: number;\n      page_url: string;\n    };\n    analytics: {\n      console_insights: any;\n      heatmap_insights?: any;\n    };\n  } {\n    const consoleEntries = this.consoleRecorder.getEntries();\n    const consoleInsights = this.consoleRecorder.generateInsights();\n    \n    let heatmapData: HeatmapData[] | undefined;\n    let heatmapInsights: any;\n    \n    if (this.heatmapGenerator) {\n      const heatmapExport = this.heatmapGenerator.exportData();\n      heatmapData = heatmapExport.data;\n      heatmapInsights = this.heatmapGenerator.generateInsights();\n    }\n\n    return {\n      events: [...this.events],\n      console_logs: consoleEntries,\n      network_requests: Array.from(this.networkRequests.values()),\n      heatmap_data: heatmapData,\n      session_info: {\n        session_id: this.sessionId,\n        start_time: this.startTime,\n        duration: Date.now() - this.startTime,\n        page_url: window.location.href\n      },\n      analytics: {\n        console_insights: consoleInsights,\n        heatmap_insights: heatmapInsights\n      }\n    };\n  }\n\n  /**\n   * Clear replay data\n   */\n  clearReplayData(): void {\n    this.events = [];\n    this.consoleLogs = [];\n    this.networkRequests.clear();\n    this.consoleRecorder.clear();\n    \n    if (this.heatmapGenerator) {\n      this.heatmapGenerator.clear();\n    }\n  }\n\n  /**\n   * Setup basic replay tracking\n   */\n  private setupReplay(): void {\n    if (typeof window === 'undefined') return;\n\n    // Track page visibility changes\n    document.addEventListener('visibilitychange', () => {\n      this.addCustomEvent('visibility_change', {\n        hidden: document.hidden\n      });\n    });\n\n    // Track window focus/blur\n    window.addEventListener('focus', () => {\n      this.addCustomEvent('window_focus', {});\n    });\n\n    window.addEventListener('blur', () => {\n      this.addCustomEvent('window_blur', {});\n    });\n\n    // Track viewport changes\n    window.addEventListener('resize', () => {\n      this.addCustomEvent('viewport_change', {\n        width: window.innerWidth,\n        height: window.innerHeight\n      });\n    });\n\n    // Track scroll events (throttled)\n    let scrollTimeout: NodeJS.Timeout;\n    window.addEventListener('scroll', () => {\n      clearTimeout(scrollTimeout);\n      scrollTimeout = setTimeout(() => {\n        // Add to heatmap data\n        if (this.heatmapGenerator) {\n          this.heatmapGenerator.addDataPoint(\n            window.scrollX || 0,\n            window.scrollY || 0,\n            5,\n            'scroll'\n          );\n        }\n        \n        this.addCustomEvent('scroll', {\n          x: window.scrollX,\n          y: window.scrollY\n        });\n      }, 100);\n    }, { passive: true });\n  }\n\n  /**\n   * Take a full DOM snapshot\n   */\n  private takeFullSnapshot(): void {\n    if (!this.isRecording) return;\n\n    try {\n      const snapshot = this.domSerializer.takeSnapshot();\n      \n      this.addEvent({\n        type: 'full_snapshot',\n        timestamp: Date.now(),\n        data: snapshot\n      });\n    } catch (error) {\n      if (this.config.debug) {\n        console.error('Revi: Failed to take DOM snapshot', error);\n      }\n    }\n  }\n\n  /**\n   * Handle DOM changes\n   */\n  private handleDOMChange(change: DOMChange): void {\n    if (!this.isRecording) return;\n\n    this.addEvent({\n      type: 'incremental_snapshot',\n      timestamp: change.timestamp,\n      data: {\n        source: 'mutation',\n        ...change\n      }\n    });\n  }\n\n  /**\n   * Add heatmap methods\n   */\n  renderHeatmap(filter?: ('click' | 'move' | 'scroll')[]): void {\n    if (this.heatmapGenerator) {\n      this.heatmapGenerator.render(filter);\n    }\n  }\n\n  toggleHeatmap(visible: boolean): void {\n    if (this.heatmapGenerator) {\n      if (visible) {\n        this.heatmapGenerator.render();\n      } else {\n        this.heatmapGenerator.clear();\n      }\n    }\n  }\n\n  getHeatmapInsights(): any {\n    return this.heatmapGenerator?.generateInsights() || null;\n  }\n\n  /**\n   * Setup network request capture\n   */\n  private setupNetworkCapture(): void {\n    // Capture fetch requests\n    if (typeof window.fetch !== 'undefined') {\n      this.originalFetch = window.fetch;\n      \n      window.fetch = async (input: RequestInfo | URL, init?: RequestInit): Promise<Response> => {\n        const startTime = Date.now();\n        const requestId = this.generateRequestId();\n        const url = input instanceof Request ? input.url : input.toString();\n        const method = init?.method || (input instanceof Request ? input.method : 'GET');\n        \n        if (this.isRecording) {\n          this.networkRequests.set(requestId, {\n            timestamp: startTime,\n            id: requestId,\n            method,\n            url,\n            requestHeaders: this.getRequestHeaders(init, input),\n            requestBody: await this.serializeRequestBody(init, input)\n          });\n        }\n        \n        try {\n          const response = await this.originalFetch(input, init);\n          const duration = Date.now() - startTime;\n          \n          if (this.isRecording) {\n            const networkRequest = this.networkRequests.get(requestId);\n            if (networkRequest) {\n              networkRequest.status = response.status;\n              networkRequest.duration = duration;\n              networkRequest.responseHeaders = this.getResponseHeaders(response);\n              \n              // Optionally capture response body (be careful with large responses)\n              if (this.shouldCaptureResponseBody(response)) {\n                try {\n                  const clonedResponse = response.clone();\n                  networkRequest.responseBody = await clonedResponse.text();\n                } catch (e) {\n                  // Response body couldn't be captured\n                }\n              }\n            }\n          }\n          \n          return response;\n        } catch (error) {\n          const duration = Date.now() - startTime;\n          \n          if (this.isRecording) {\n            const networkRequest = this.networkRequests.get(requestId);\n            if (networkRequest) {\n              networkRequest.duration = duration;\n              networkRequest.failed = true;\n            }\n          }\n          \n          throw error;\n        }\n      };\n    }\n\n    // Capture XMLHttpRequest\n    if (typeof XMLHttpRequest !== 'undefined') {\n      this.originalXMLHttpRequest = XMLHttpRequest;\n      \n      const self = this;\n      \n      window.XMLHttpRequest = function() {\n        const xhr = new self.originalXMLHttpRequest();\n        const requestId = self.generateRequestId();\n        let method = 'GET';\n        let url = '';\n        let startTime = 0;\n        \n        const originalOpen = xhr.open;\n        const originalSend = xhr.send;\n        \n        xhr.open = function(m: string, u: string | URL, ...args: any[]) {\n          method = m;\n          url = u.toString();\n          return originalOpen.call(this, m, u, ...args);\n        };\n        \n        xhr.send = function(body?: any) {\n          startTime = Date.now();\n          \n          if (self.isRecording) {\n            self.networkRequests.set(requestId, {\n              timestamp: startTime,\n              id: requestId,\n              method,\n              url,\n              requestBody: body\n            });\n          }\n          \n          return originalSend.call(this, body);\n        };\n        \n        xhr.addEventListener('loadend', () => {\n          const duration = Date.now() - startTime;\n          \n          if (self.isRecording) {\n            const networkRequest = self.networkRequests.get(requestId);\n            if (networkRequest) {\n              networkRequest.status = xhr.status;\n              networkRequest.duration = duration;\n              networkRequest.failed = xhr.status === 0 || xhr.status >= 400;\n              \n              if (self.shouldCaptureXHRResponse(xhr)) {\n                networkRequest.responseBody = xhr.responseText;\n              }\n            }\n          }\n        });\n        \n        return xhr;\n      };\n    }\n  }\n\n  /**\n   * Setup mouse and keyboard interaction tracking\n   */\n  private setupInteractionTracking(): void {\n    // Mouse events\n    const mouseEvents = ['mousedown', 'mouseup', 'click', 'dblclick', 'mousemove'];\n    \n    mouseEvents.forEach(eventType => {\n      document.addEventListener(eventType, (event: MouseEvent) => {\n        if (!this.isRecording) return;\n        \n        // Throttle mousemove events\n        if (eventType === 'mousemove' && Math.random() > 0.1) return;\n        \n        // Add to heatmap data\n        if (this.heatmapGenerator) {\n          let intensity = 1;\n          if (eventType === 'click') intensity = 10;\n          else if (eventType === 'mousemove') intensity = 2;\n          else if (eventType === 'mousedown') intensity = 5;\n          \n          this.heatmapGenerator.addDataPoint(\n            event.clientX,\n            event.clientY,\n            intensity,\n            eventType === 'click' ? 'click' : 'move'\n          );\n        }\n        \n        this.addEvent({\n          type: 'incremental_snapshot',\n          timestamp: Date.now(),\n          data: {\n            source: 'mouse',\n            type: eventType,\n            x: event.clientX,\n            y: event.clientY,\n            id: this.getElementId(event.target as Element)\n          }\n        });\n      }, { capture: true, passive: true });\n    });\n\n    // Keyboard events\n    document.addEventListener('keydown', (event: KeyboardEvent) => {\n      if (!this.isRecording) return;\n      \n      // Don't capture sensitive keystrokes\n      if (this.shouldIgnoreKeystroke(event)) return;\n      \n      this.addEvent({\n        type: 'incremental_snapshot',\n        timestamp: Date.now(),\n        data: {\n          source: 'keyboard',\n          type: 'keydown',\n          key: this.sanitizeKey(event.key),\n          code: event.code,\n          id: this.getElementId(event.target as Element)\n        }\n      });\n    }, { capture: true, passive: true });\n  }\n\n  /**\n   * Utility methods\n   */\n  private addEvent(event: ReplayEvent): void {\n    this.events.push(event);\n    \n    // Limit event buffer\n    if (this.events.length > 10000) {\n      this.events = this.events.slice(-8000);\n    }\n  }\n\n  private addCustomEvent(type: string, data: any): void {\n    this.addEvent({\n      type: 'custom',\n      timestamp: Date.now(),\n      data: { type, ...data }\n    });\n  }\n\n  private serializeConsoleArgs(args: any[]): any[] {\n    return args.map(arg => {\n      try {\n        if (typeof arg === 'object' && arg !== null) {\n          return JSON.parse(JSON.stringify(arg));\n        }\n        return arg;\n      } catch (e) {\n        return '[Unserializable Object]';\n      }\n    });\n  }\n\n  private generateRequestId(): string {\n    return Date.now().toString(36) + Math.random().toString(36).substr(2);\n  }\n\n  private getRequestHeaders(init?: RequestInit, input?: RequestInfo | URL): Record<string, string> {\n    const headers: Record<string, string> = {};\n    \n    if (init?.headers) {\n      if (init.headers instanceof Headers) {\n        init.headers.forEach((value, key) => {\n          headers[key] = value;\n        });\n      } else if (Array.isArray(init.headers)) {\n        init.headers.forEach(([key, value]) => {\n          headers[key] = value;\n        });\n      } else {\n        Object.assign(headers, init.headers);\n      }\n    }\n    \n    if (input instanceof Request) {\n      input.headers.forEach((value, key) => {\n        headers[key] = value;\n      });\n    }\n    \n    return headers;\n  }\n\n  private getResponseHeaders(response: Response): Record<string, string> {\n    const headers: Record<string, string> = {};\n    response.headers.forEach((value, key) => {\n      headers[key] = value;\n    });\n    return headers;\n  }\n\n  private async serializeRequestBody(init?: RequestInit, input?: RequestInfo | URL): Promise<any> {\n    let body = init?.body;\n    \n    if (input instanceof Request && !body) {\n      try {\n        body = await input.clone().text();\n      } catch (e) {\n        return null;\n      }\n    }\n    \n    if (!body) return null;\n    \n    if (typeof body === 'string') {\n      return body.length > 10000 ? body.substring(0, 10000) + '...[truncated]' : body;\n    }\n    \n    if (body instanceof FormData) {\n      const formData: Record<string, any> = {};\n      body.forEach((value, key) => {\n        formData[key] = value instanceof File ? `[File: ${value.name}]` : value;\n      });\n      return formData;\n    }\n    \n    return '[Binary Data]';\n  }\n\n  private shouldCaptureResponseBody(response: Response): boolean {\n    const contentType = response.headers.get('content-type') || '';\n    const contentLength = parseInt(response.headers.get('content-length') || '0');\n    \n    // Only capture text-based responses under 100KB\n    return contentType.includes('application/json') ||\n           contentType.includes('text/') ||\n           (contentLength > 0 && contentLength < 100000);\n  }\n\n  private shouldCaptureXHRResponse(xhr: XMLHttpRequest): boolean {\n    const contentType = xhr.getResponseHeader('content-type') || '';\n    \n    return contentType.includes('application/json') ||\n           contentType.includes('text/') ||\n           (xhr.responseText && xhr.responseText.length < 100000);\n  }\n\n  private getElementId(element: Element | null): number | undefined {\n    // This would ideally use the same node ID system as the DOM serializer\n    return element ? Math.random() : undefined;\n  }\n\n  private shouldIgnoreKeystroke(event: KeyboardEvent): boolean {\n    const target = event.target as HTMLElement;\n    \n    if (target && target.tagName) {\n      const tagName = target.tagName.toLowerCase();\n      const type = (target as HTMLInputElement).type;\n      \n      // Ignore keystrokes in password fields\n      if (tagName === 'input' && type === 'password') return true;\n      \n      // Ignore keystrokes in elements marked as sensitive\n      if (target.hasAttribute('data-revi-ignore')) return true;\n    }\n    \n    return false;\n  }\n\n  private sanitizeKey(key: string): string {\n    // Don't capture the actual key for sensitive inputs\n    if (key.length === 1 && /[a-zA-Z0-9]/.test(key)) {\n      return '*'; // Mask alphanumeric characters\n    }\n    return key;\n  }\n\n\n  private restoreOriginalNetwork(): void {\n    if (this.originalFetch) {\n      window.fetch = this.originalFetch;\n    }\n    \n    if (this.originalXMLHttpRequest) {\n      window.XMLHttpRequest = this.originalXMLHttpRequest;\n    }\n  }\n}","import { ErrorHandler } from './error-handler';\nimport { SessionManager } from './session';\nimport { NetworkMonitor } from './network-monitor';\nimport { PerformanceMonitor } from './performance-monitor';\nimport { DataManager } from './data-manager';\nimport { UserJourneyTracker } from './user-journey';\nimport { SessionReplayManager } from './session-replay';\nimport { TraceManager } from './trace-manager';\nimport { isBot } from './utils';\nimport type { ReviConfig, ErrorEvent, UserContext } from './types';\n\nexport class Monitor {\n  private config: ReviConfig;\n  private traceManager: TraceManager;\n  private errorHandler: ErrorHandler;\n  private sessionManager: SessionManager;\n  private networkMonitor: NetworkMonitor;\n  private performanceMonitor: PerformanceMonitor;\n  private dataManager: DataManager;\n  private userJourneyTracker: UserJourneyTracker;\n  private sessionReplayManager: SessionReplayManager;\n  private isInitialized = false;\n\n  constructor(config: ReviConfig) {\n    this.config = {\n      apiUrl: process.env.REVI_API_URL || 'https://api.revi.dev',\n      environment: 'production',\n      debug: false,\n      sampleRate: 1.0,\n      sessionSampleRate: 1.0,\n      maxBreadcrumbs: 50,\n      privacy: {\n        maskInputs: true,\n        maskPasswords: true,\n        maskCreditCards: true\n      },\n      performance: {\n        captureWebVitals: true,\n        captureResourceTiming: false,\n        captureNavigationTiming: true\n      },\n      replay: {\n        enabled: true,\n        maskAllInputs: false,\n        maskAllText: false\n      },\n      ...config\n    };\n\n    if (!this.config.apiKey) {\n      throw new Error('Revi: API key is required');\n    }\n\n    if (isBot()) {\n      if (this.config.debug) {\n        console.log('Revi: Bot detected, skipping initialization');\n      }\n      return;\n    }\n\n    this.init();\n  }\n\n  private init(): void {\n    if (this.isInitialized) return;\n\n    try {\n      // Create shared trace manager\n      this.traceManager = new TraceManager();\n      \n      // Initialize components with shared trace manager\n      this.errorHandler = new ErrorHandler(this.config, this.traceManager);\n      this.sessionManager = new SessionManager(this.config, this.traceManager);\n      this.networkMonitor = new NetworkMonitor(this.config, this.traceManager);\n      this.performanceMonitor = new PerformanceMonitor(this.config);\n      this.dataManager = new DataManager(this.config);\n      this.userJourneyTracker = new UserJourneyTracker(this.config);\n      this.sessionReplayManager = new SessionReplayManager(this.config, this.sessionManager.getSessionId());\n\n      this.setupPeriodicFlush();\n      \n      // Start session replay if enabled\n      if (this.config.replay?.enabled) {\n        this.sessionReplayManager.startRecording();\n      }\n      \n      this.isInitialized = true;\n\n      if (this.config.debug) {\n        console.log('Revi: Initialized successfully');\n      }\n    } catch (error) {\n      if (this.config.debug) {\n        console.error('Revi: Initialization failed', error);\n      }\n    }\n  }\n\n  private setupPeriodicFlush(): void {\n    // Flush data every 10 seconds\n    setInterval(() => {\n      this.flush();\n    }, 10000);\n  }\n\n  // Public API methods\n  captureException(error: Error, options: {\n    level?: 'error' | 'warning' | 'info' | 'debug';\n    tags?: Record<string, string>;\n    extra?: Record<string, any>;\n  } = {}): string {\n    if (!this.isInitialized) return '';\n\n    const errorId = this.errorHandler.captureException(error, options);\n    if (errorId) {\n      // Create error event and queue for upload\n      const errorEvent: ErrorEvent = {\n        id: errorId,\n        timestamp: Date.now(),\n        message: error.message,\n        stack: error.stack,\n        url: window.location.href,\n        userId: this.config.userId,\n        sessionId: this.sessionManager.getSessionId(),\n        userAgent: navigator.userAgent,\n        environment: this.config.environment,\n        release: this.config.release,\n        tags: options.tags,\n        extra: options.extra,\n        breadcrumbs: this.errorHandler.getBreadcrumbs(),\n        level: options.level || 'error'\n      };\n\n      this.dataManager.queueError(errorEvent);\n      \n      // Track error in user journey\n      if (this.userJourneyTracker) {\n        this.userJourneyTracker.trackError(error, {\n          level: options.level,\n          tags: options.tags,\n          extra: options.extra\n        });\n      }\n    }\n\n    return errorId;\n  }\n\n  captureMessage(message: string, options: {\n    level?: 'error' | 'warning' | 'info' | 'debug';\n    tags?: Record<string, string>;\n    extra?: Record<string, any>;\n  } = {}): string {\n    if (!this.isInitialized) return '';\n\n    const errorId = this.errorHandler.captureMessage(message, options);\n    if (errorId) {\n      const errorEvent: ErrorEvent = {\n        id: errorId,\n        timestamp: Date.now(),\n        message,\n        url: window.location.href,\n        userId: this.config.userId,\n        sessionId: this.sessionManager.getSessionId(),\n        userAgent: navigator.userAgent,\n        environment: this.config.environment,\n        release: this.config.release,\n        tags: options.tags,\n        extra: options.extra,\n        breadcrumbs: this.errorHandler.getBreadcrumbs(),\n        level: options.level || 'info'\n      };\n\n      this.dataManager.queueError(errorEvent);\n    }\n\n    return errorId;\n  }\n\n  addBreadcrumb(breadcrumb: {\n    message: string;\n    category?: string;\n    level?: 'error' | 'warning' | 'info' | 'debug';\n    data?: Record<string, any>;\n  }): void {\n    if (!this.isInitialized) return;\n\n    this.errorHandler.addBreadcrumb({\n      timestamp: Date.now(),\n      message: breadcrumb.message,\n      category: breadcrumb.category || 'manual',\n      level: breadcrumb.level || 'info',\n      data: breadcrumb.data\n    });\n  }\n\n  setUserContext(user: UserContext): void {\n    if (!this.isInitialized) return;\n\n    this.config.userId = user.id;\n    this.errorHandler.setUserContext(user);\n    this.userJourneyTracker.setUserId(user.id || '');\n    this.userJourneyTracker.startTracking(user.id);\n  }\n\n  setTags(tags: Record<string, string>): void {\n    if (!this.isInitialized) return;\n    this.errorHandler.setTags(tags);\n  }\n\n  setExtra(extra: Record<string, any>): void {\n    if (!this.isInitialized) return;\n    this.errorHandler.setExtra(extra);\n  }\n\n  // Session management\n  getSessionId(): string {\n    if (!this.isInitialized) return '';\n    return this.sessionManager.getSessionId();\n  }\n\n  endSession(): void {\n    if (!this.isInitialized) return;\n    \n    this.flush();\n    this.sessionManager.endSession();\n  }\n\n  // Performance monitoring\n  mark(name: string): void {\n    if (!this.isInitialized) return;\n    this.performanceMonitor.mark(name);\n  }\n\n  measure(name: string, startMark?: string, endMark?: string): number | null {\n    if (!this.isInitialized) return null;\n    return this.performanceMonitor.measure(name, startMark, endMark);\n  }\n\n  getWebVitals() {\n    if (!this.isInitialized) return {};\n    return this.performanceMonitor.getWebVitals();\n  }\n\n  // Session Replay methods\n  startSessionReplay(): void {\n    if (!this.isInitialized || !this.sessionReplayManager) return;\n    this.sessionReplayManager.startRecording();\n  }\n\n  stopSessionReplay(): void {\n    if (!this.isInitialized || !this.sessionReplayManager) return;\n    this.sessionReplayManager.stopRecording();\n  }\n\n  getSessionReplayData() {\n    if (!this.isInitialized || !this.sessionReplayManager) return null;\n    return this.sessionReplayManager.getReplayData();\n  }\n\n  // Data management\n  flush(): void {\n    if (!this.isInitialized) return;\n\n    // Get all queued events\n    const sessionEvents = this.sessionManager.flush();\n    const networkEvents = this.networkMonitor.flush();\n\n    // Add session ID to network events\n    networkEvents.forEach(event => {\n      event.sessionId = this.sessionManager.getSessionId();\n    });\n\n    // Queue for upload\n    if (sessionEvents.length > 0) {\n      this.dataManager.queueSessionEvents(sessionEvents);\n    }\n    \n    if (networkEvents.length > 0) {\n      this.dataManager.queueNetworkEvents(networkEvents);\n    }\n  }\n\n  // Cleanup\n  // Trace context methods\n  getCurrentTraceId(): string | undefined {\n    return this.traceManager?.getCurrentTraceId();\n  }\n\n  getCurrentSpanId(): string | undefined {\n    return this.traceManager?.getCurrentSpanId();\n  }\n\n  getTraceContext(): { traceId?: string; spanId?: string; parentSpanId?: string } {\n    return this.traceManager?.getTraceContext() || {};\n  }\n\n  startSpan(operationName: string): string | undefined {\n    return this.traceManager?.startSpan(operationName);\n  }\n\n  finishSpan(spanId?: string, data?: Record<string, any>): void {\n    this.traceManager?.finishSpan(spanId, data);\n  }\n\n  destroy(): void {\n    if (!this.isInitialized) return;\n\n    this.flush();\n    \n    if (this.networkMonitor) {\n      this.networkMonitor.destroy();\n    }\n    \n    if (this.dataManager) {\n      this.dataManager.destroy();\n    }\n\n    if (this.sessionReplayManager) {\n      this.sessionReplayManager.stopRecording();\n    }\n\n    if (this.userJourneyTracker) {\n      this.userJourneyTracker.stopTracking();\n    }\n    \n    // Cleanup trace manager\n    if (this.traceManager) {\n      this.traceManager.cleanupSpanData();\n    }\n\n    this.isInitialized = false;\n  }\n}\n"],"names":["generateId","replace","c","r","Math","random","toString","formatStackTrace","error","stack","split","map","line","trim","filter","length","join","TraceManager","constructor","this","spanCounter","spanData","Map","generateNewTrace","currentTraceId","generateTraceId","currentSpanId","undefined","startSpan","operationName","parentSpanId","generateSpanId","setSpanData","startTime","Date","now","finishSpan","spanId","data","getSpanData","endTime","getCurrentTraceId","getCurrentSpanId","getTraceContext","traceId","getParentSpanId","extractTraceFromHeaders","headers","_a","_b","_c","_d","injectTraceHeaders","correlateWithBackendTrace","backendTraceId","backendSpanId","generateRandomHex","array","Uint8Array","crypto","getRandomValues","i","floor","Array","from","byte","padStart","get","set","cleanupSpanData","cutoff","entries","delete","ErrorHandler","config","traceManager","breadcrumbs","userContext","setupGlobalHandlers","window","addEventListener","event","captureError","message","filename","lineno","colno","reason","Error","JSON","stringify","originalConsoleError","console","args","addBreadcrumb","timestamp","category","level","apply","originalConsoleWarn","warn","errorData","sampleRate","errorId","traceContext","errorEvent","id","url","location","href","userId","sessionId","userAgent","navigator","environment","release","tags","extra","beforeSend","call","captureException","options","captureMessage","breadcrumb","push","maxBreadcrumbs","splice","setUserContext","user","setTags","setExtra","getBreadcrumbs","clearBreadcrumbs","SessionManager","events","storage","sessionStorage","setItem","removeItem","getSessionStorage","getOrCreateSessionId","setupEventListeners","trackPageLoad","storageKey","existingId","getItem","newId","getSessionId","scrollTimeout","resizeTimeout","forEach","eventType","document","captureEvent","serializeDOMEvent","capture","passive","type","hidden","clearTimeout","setTimeout","x","scrollX","y","scrollY","width","innerWidth","height","innerHeight","duration","flush","target","tagName","className","textContent","shouldMaskText","slice","mouseEvent","coordinates","clientX","clientY","inputEvent","value","shouldMaskInput","element","privacy","maskInputs","includes","name","toLowerCase","some","sensitive","replay","maskAllText","maskSelector","matches","captureLoadEvent","title","referrer","loadTime","performance","readyState","sessionSampleRate","filteredEvent","beforeSendSession","getEvents","clearEvents","endSession","NetworkMonitor","originalFetch","fetch","originalXHROpen","XMLHttpRequest","prototype","open","originalXHRSend","send","setupInterceptors","interceptFetch","interceptXHR","async","method","toUpperCase","shouldMonitorRequest","traceHeaders","modifiedArgs","requestBody","requestSize","body","serializeRequestBody","calculateBodySize","response","responseBody","responseSize","shouldCaptureResponseBody","clonedResponse","clone","extractResponseBody","calculateResponseSize","responseTrace","extractResponseHeaders","statusCode","status","responseTime","captureNetworkEvent","requestHeaders","extractHeaders","responseHeaders","String","self","_reviData","shouldMonitor","reviData","responseType","responseText","FormData","formObject","key","File","URLSearchParams","Object","fromEntries","parse","contentType","json","text","Headers","headerObj","isArray","ArrayBuffer","byteLength","Blob","size","pattern","test","apiUrl","normalizedApiUrl","normalizedUrl","debug","log","startsWith","matchedPattern","developmentHosts","find","matchedApiPattern","excludeUrls","denyUrls","RegExp","allowUrls","allowed","destroy","PerformanceMonitor","webVitals","performanceEntries","captureWebVitals","setupWebVitals","captureResourceTiming","setupResourceTiming","captureNavigationTiming","setupNavigationTiming","PerformanceObserver","list","getEntries","lastEntry","lcp","observe","entryTypes","e","entry","fid","processingStart","clsValue","hadRecentInput","cls","fcp","calculateTTFB","navigationTiming","getEntriesByType","ttfb","responseStart","requestStart","entryType","transferSize","encodedBodySize","decodedBodySize","domContentLoadedEventEnd","domContentLoadedEventStart","loadEventEnd","loadEventStart","domComplete","domInteractive","getWebVitals","getPerformanceEntries","clearPerformanceEntries","mark","measure","startMark","endMark","getEntriesByName","IndexedDBStorage","db","dbName","version","storeName","maxQueueSize","maxAge","initialize","indexedDB","Promise","resolve","reject","request","onerror","onsuccess","result","onupgradeneeded","objectStoreNames","contains","objectStore","createObjectStore","keyPath","createIndex","unique","store","cleanupExpiredItems","getQueueSize","removeOldestItems","item","compress","compressed","transaction","add","getAll","items","errors","sessionEvents","networkEvents","decompressedData","decompress","clear","count","cutoffTime","index","range","IDBKeyRange","upperBound","openCursor","cursor","continue","deletedCount","btoa","unescape","encodeURIComponent","decoded","decodeURIComponent","escape","atob","parseError","substr","LocalStorageAdapter","localStorage","getLocalStorage","existing","storedData","StorageManager","isInitialized","localStorageError","NoOpStorage","storeErrors","ensureInitialized","storeSessionEvents","storeNetworkEvents","getAllData","clearAll","NetworkManager","isOnline","onLine","connectionType","listeners","notifyListeners","detectConnectionType","getConnectionStatus","online","onConnectionChange","callback","indexOf","getBatchSize","getUploadDelay","shouldRetry","attempt","getRetryDelay","min","pow","connection","effectiveType","testConnectivity","testUrl","mode","cache","DataManager","uploadTimer","isUploading","retryAttempts","uploadQueue","storageManager","networkManager","loadQueueFromStorage","startNetworkAwareUploadTimer","setupBeforeUnloadHandler","setupNetworkChangeHandler","saveQueueToStorage","scheduleNextUpload","delay","hasQueuedData","uploadData","finally","uploadDataSync","queueError","catch","err","queueSessionEvents","queueNetworkEvents","batchSize","errorBatches","createBatches","batch","uploadErrorsWithRetry","sessionBatches","uploadSessionEventsWithRetry","networkBatches","uploadNetworkEventsWithRetry","batches","sendBeacon","payload","session_id","event_type","uploadErrors","apiKey","stack_trace","user_agent","metadata","ok","uploadSessionEvents","uploadNetworkEvents","promises","status_code","response_time","request_data","response_data","failures","allSettled","executeWithRetry","operation","currentAttempt","clearQueue","UserJourneyTracker","journeyEvents","isTracking","deviceFingerprint","generateDeviceFingerprint","sessionStartTime","currentPageStartTime","setupJourneyTracking","startTracking","trackPageView","stopTracking","setUserId","viewport","scroll_position","device_fingerprint","language","timezone","Intl","DateTimeFormat","resolvedOptions","timeZone","connection_type","getConnectionType","addJourneyEvent","trackClick","journeyEvent","tag","class","getElementText","attributes","getRelevantAttributes","page_x","pageX","page_y","pageY","trackFormSubmit","form","formData","fields","input","querySelector","has_value","value_length","action","field_count","trackApiCall","duration_ms","api","success","page_context","time_on_page","trackError","context","user_context","session_duration","page_interactions","countPageInteractions","custom_context","currentUrl","handleNavigation","timeSpent","updateLastPageViewDuration","originalPushState","history","pushState","originalReplaceState","replaceState","shouldTrackClick","setInterval","components","screen","colorDepth","platform","cookieEnabled","canvas","createElement","ctx","getContext","textBaseline","font","fillText","toDataURL","fingerprint","hash","charCodeAt","abs","sendJourneyEvents","unshift","user_id","hasAttribute","innerText","substring","attrs","attr","getAttribute","lastEvent","DOMSerializer","nodeIdMap","WeakMap","nodeMap","nextNodeId","isObserving","takeSnapshot","snapshot","scroll","nodes","stylesheets","resources","serializeDocument","serializeStylesheets","serializeResources","startObserving","onDOMChange","observer","MutationObserver","handleMutations","bind","childList","characterData","subtree","attributeOldValue","characterDataOldValue","stopObserving","disconnect","doc","doctype","publicId","systemId","getNodeId","documentElement","serialized","serializeNode","node","shouldIgnoreNode","nodeId","getNodeType","nodeType","Node","ELEMENT_NODE","serializeAttributes","children","serializeChildren","TEXT_NODE","textNode","COMMENT_NODE","commentNode","shouldIgnoreAttribute","shouldMaskAttribute","childNodes","child","serializedChild","styleSheets","stylesheet","cssText","cssRules","rule","disabled","querySelectorAll","img","src","shouldIgnoreResource","failed","complete","naturalWidth","backgroundImage","getComputedStyle","urlMatch","match","mutations","mutation","targetId","change","addedNodes","removedNodes","attributeName","attributeValue","oldValue","has","DOCUMENT_NODE","blockSelector","parent","parentElement","urlObj","URL","protocol","params","search","parseInt","ConsoleRecorder","originalMethods","isRecording","maxEntries","captureStackTrace","serializeObjects","maxObjectDepth","maxStringLength","ignoredLevels","start","originalMethod","recordEntry","stop","serializeArgs","cleanStackTrace","sourceLine","lineNumber","columnNumber","addEntry","arg","serializeValue","depth","__type","toISOString","keys","fromTimestamp","toTimestamp","filtered","getEntriesByLevel","toSessionEvents","consoleId","exportData","levelCounts","minTime","Infinity","maxTime","max","stats","totalEntries","errorCount","warningCount","timeRange","end","generateInsights","errorPatterns","findErrorPatterns","performanceIssues","detectPerformanceIssues","recommendations","generateRecommendations","patterns","firstArg","sort","a","b","examples","issues","recentEntries","severity","details","errorCounts","HeatmapGenerator","container","radius","maxIntensity","gradient","blur","minOpacity","maxOpacity","style","position","top","left","pointerEvents","zIndex","appendChild","resizeCanvas","rect","getBoundingClientRect","addDataPoint","intensity","generateFromEvents","_e","_f","render","clearRect","filteredData","d","intensityData","createIntensityMap","createGradient","renderHeatmap","shadowCanvas","shadowCtx","point","createRadialGradient","alpha","addColorStop","fillStyle","fillRect","drawImage","getImageData","gradientCanvas","gradientCtx","createLinearGradient","color","parseFloat","gradientData","output","createImageData","gradientIndex","putImageData","removeChild","removeEventListener","eventTypes","minX","maxX","minY","maxY","totalEvents","bounds","hotSpots","findHotSpots","clickPatterns","analyzeClickPatterns","userBehavior","analyzeUserBehavior","clusters","clusterRadius","foundCluster","cluster","sqrt","round","clicks","current","next","frequency","scrolls","sortedByIntensity","topHalf","scrollDepth","s","engagementScore","mostActiveArea","averageClicksPerSession","SessionReplayManager","heatmapGenerator","consoleLogs","networkRequests","originalConsole","domSerializer","consoleRecorder","maxConsoleEntries","ignoredConsoleLevels","_g","enabled","setupReplay","_j","_h","heatmaps","_l","_k","_o","_m","_q","_p","_s","_r","startRecording","takeFullSnapshot","handleDOMChange","setupNetworkCapture","setupInteractionTracking","stopRecording","restoreOriginalNetwork","getReplayData","consoleEntries","consoleInsights","heatmapData","heatmapInsights","console_logs","network_requests","values","heatmap_data","session_info","start_time","page_url","analytics","console_insights","heatmap_insights","clearReplayData","addCustomEvent","addEvent","source","toggleHeatmap","visible","getHeatmapInsights","init","requestId","generateRequestId","Request","getRequestHeaders","networkRequest","getResponseHeaders","originalXMLHttpRequest","xhr","originalOpen","originalSend","m","u","shouldCaptureXHRResponse","getElementId","shouldIgnoreKeystroke","sanitizeKey","code","serializeConsoleArgs","assign","contentLength","getResponseHeader","Monitor","process","env","REVI_API_URL","maskPasswords","maskCreditCards","maskAllInputs","errorHandler","sessionManager","networkMonitor","performanceMonitor","dataManager","userJourneyTracker","sessionReplayManager","setupPeriodicFlush","startSessionReplay","stopSessionReplay","getSessionReplayData"],"mappings":"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"}