{"version":3,"file":"index.js","sources":["../src/utils.ts","../src/error-handler.ts","../src/session.ts","../src/network-monitor.ts","../src/performance-monitor.ts","../src/data-manager.ts","../src/user-journey.ts","../src/dom-serializer.ts","../src/console-recorder.ts","../src/heatmap-generator.ts","../src/session-replay.ts","../src/monitor.ts"],"sourcesContent":["export function generateId(): string {\n  return 'xxxx-xxxx-4xxx-yxxx-xxxx'.replace(/[xy]/g, function(c) {\n    const r = Math.random() * 16 | 0;\n    const v = c === 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\nexport function formatStackTrace(error: Error): string {\n  if (!error.stack) return '';\n  \n  return error.stack\n    .split('\\n')\n    .map(line => line.trim())\n    .filter(line => line.length > 0)\n    .join('\\n');\n}\n\nexport function sanitizeUrl(url: string, allowUrls: string[] = [], denyUrls: string[] = []): string {\n  // Check deny list first\n  if (denyUrls.some(pattern => new RegExp(pattern).test(url))) {\n    return '[Filtered]';\n  }\n  \n  // If allow list is provided, ensure URL matches\n  if (allowUrls.length > 0 && !allowUrls.some(pattern => new RegExp(pattern).test(url))) {\n    return '[Filtered]';\n  }\n  \n  // Remove sensitive query parameters\n  try {\n    const urlObj = new URL(url);\n    const sensitiveParams = ['password', 'token', 'key', 'secret', 'auth', 'api_key'];\n    \n    sensitiveParams.forEach(param => {\n      if (urlObj.searchParams.has(param)) {\n        urlObj.searchParams.set(param, '[Filtered]');\n      }\n    });\n    \n    return urlObj.toString();\n  } catch {\n    return url;\n  }\n}\n\nexport function maskSensitiveData(data: any, maskInputs = true): any {\n  if (typeof data !== 'object' || data === null) {\n    return data;\n  }\n  \n  if (Array.isArray(data)) {\n    return data.map(item => maskSensitiveData(item, maskInputs));\n  }\n  \n  const masked: any = {};\n  const sensitiveKeys = ['password', 'token', 'key', 'secret', 'auth', 'api_key', 'credit_card', 'ssn'];\n  \n  Object.keys(data).forEach(key => {\n    const lowerKey = key.toLowerCase();\n    if (sensitiveKeys.some(sensitive => lowerKey.includes(sensitive))) {\n      masked[key] = '[Masked]';\n    } else if (typeof data[key] === 'object') {\n      masked[key] = maskSensitiveData(data[key], maskInputs);\n    } else {\n      masked[key] = data[key];\n    }\n  });\n  \n  return masked;\n}\n\nexport function debounce<T extends (...args: any[]) => any>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout;\n  \n  return function executedFunction(...args: Parameters<T>) {\n    const later = () => {\n      clearTimeout(timeout);\n      func(...args);\n    };\n    \n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n}\n\nexport function throttle<T extends (...args: any[]) => any>(\n  func: T,\n  limit: number\n): (...args: Parameters<T>) => void {\n  let inThrottle = false;\n  \n  return function executedFunction(...args: Parameters<T>) {\n    if (!inThrottle) {\n      func(...args);\n      inThrottle = true;\n      setTimeout(() => inThrottle = false, limit);\n    }\n  };\n}\n\nexport function isBot(): boolean {\n  if (typeof navigator === 'undefined') return false;\n  \n  const botPatterns = [\n    /bot/i,\n    /spider/i,\n    /crawl/i,\n    /headless/i,\n    /phantom/i,\n    /selenium/i\n  ];\n  \n  return botPatterns.some(pattern => pattern.test(navigator.userAgent));\n}\n\nexport function getSessionStorage(): Storage | null {\n  try {\n    if (typeof window !== 'undefined' && window.sessionStorage) {\n      window.sessionStorage.setItem('test', 'test');\n      window.sessionStorage.removeItem('test');\n      return window.sessionStorage;\n    }\n  } catch {\n    // Storage not available\n  }\n  return null;\n}\n\nexport function getLocalStorage(): Storage | null {\n  try {\n    if (typeof window !== 'undefined' && window.localStorage) {\n      window.localStorage.setItem('test', 'test');\n      window.localStorage.removeItem('test');\n      return window.localStorage;\n    }\n  } catch {\n    // Storage not available\n  }\n  return null;\n}\n","import { formatStackTrace, generateId } from './utils';\nimport type { ErrorEvent, Breadcrumb, ReviConfig } from './types';\n\nexport class ErrorHandler {\n  private config: ReviConfig;\n  private breadcrumbs: Breadcrumb[] = [];\n  private userContext: any = {};\n\n  constructor(config: ReviConfig) {\n    this.config = config;\n    this.setupGlobalHandlers();\n  }\n\n  private setupGlobalHandlers(): void {\n    if (typeof window === 'undefined') return;\n\n    // Global error handler\n    window.addEventListener('error', (event) => {\n      this.captureError({\n        message: event.message,\n        filename: event.filename,\n        lineno: event.lineno,\n        colno: event.colno,\n        error: event.error\n      });\n    });\n\n    // Unhandled promise rejections\n    window.addEventListener('unhandledrejection', (event) => {\n      const error = event.reason;\n      let message = 'Unhandled Promise Rejection';\n      let stack = '';\n\n      if (error instanceof Error) {\n        message = error.message;\n        stack = formatStackTrace(error);\n      } else if (typeof error === 'string') {\n        message = error;\n      } else {\n        message = JSON.stringify(error);\n      }\n\n      this.captureError({\n        message,\n        stack,\n        error\n      });\n    });\n\n    // Console error interception\n    const originalConsoleError = console.error;\n    console.error = (...args: any[]) => {\n      this.addBreadcrumb({\n        timestamp: Date.now(),\n        message: args.join(' '),\n        category: 'console',\n        level: 'error'\n      });\n      originalConsoleError.apply(console, args);\n    };\n\n    // Console warn interception\n    const originalConsoleWarn = console.warn;\n    console.warn = (...args: any[]) => {\n      this.addBreadcrumb({\n        timestamp: Date.now(),\n        message: args.join(' '),\n        category: 'console',\n        level: 'warning'\n      });\n      originalConsoleWarn.apply(console, args);\n    };\n  }\n\n  captureError(errorData: {\n    message: string;\n    stack?: string;\n    filename?: string;\n    lineno?: number;\n    colno?: number;\n    error?: Error;\n    level?: 'error' | 'warning' | 'info' | 'debug';\n    tags?: Record<string, string>;\n    extra?: Record<string, any>;\n  }): string {\n    // Apply sampling\n    if (this.config.sampleRate && Math.random() > this.config.sampleRate) {\n      return '';\n    }\n\n    const errorId = generateId();\n    \n    const errorEvent: ErrorEvent = {\n      id: errorId,\n      timestamp: Date.now(),\n      message: errorData.message,\n      stack: errorData.stack || (errorData.error ? formatStackTrace(errorData.error) : undefined),\n      url: errorData.filename || window.location.href,\n      lineno: errorData.lineno,\n      colno: errorData.colno,\n      filename: errorData.filename,\n      userId: this.config.userId || this.userContext.id,\n      sessionId: '', // Will be set by Monitor class\n      userAgent: navigator.userAgent,\n      environment: this.config.environment,\n      release: this.config.release,\n      tags: errorData.tags,\n      extra: errorData.extra,\n      breadcrumbs: [...this.breadcrumbs],\n      level: errorData.level || 'error'\n    };\n\n    // Apply beforeSend filter\n    const filteredError = this.config.beforeSend?.(errorEvent) || errorEvent;\n    if (!filteredError) return '';\n\n    return errorId;\n  }\n\n  captureException(error: Error, options: {\n    level?: 'error' | 'warning' | 'info' | 'debug';\n    tags?: Record<string, string>;\n    extra?: Record<string, any>;\n  } = {}): string {\n    return this.captureError({\n      message: error.message,\n      stack: formatStackTrace(error),\n      error,\n      level: options.level,\n      tags: options.tags,\n      extra: options.extra\n    });\n  }\n\n  captureMessage(message: string, options: {\n    level?: 'error' | 'warning' | 'info' | 'debug';\n    tags?: Record<string, string>;\n    extra?: Record<string, any>;\n  } = {}): string {\n    return this.captureError({\n      message,\n      level: options.level || 'info',\n      tags: options.tags,\n      extra: options.extra\n    });\n  }\n\n  addBreadcrumb(breadcrumb: Breadcrumb): void {\n    this.breadcrumbs.push(breadcrumb);\n    \n    const maxBreadcrumbs = this.config.maxBreadcrumbs || 50;\n    if (this.breadcrumbs.length > maxBreadcrumbs) {\n      this.breadcrumbs.splice(0, this.breadcrumbs.length - maxBreadcrumbs);\n    }\n  }\n\n  setUserContext(user: any): void {\n    this.userContext = { ...this.userContext, ...user };\n  }\n\n  setTags(tags: Record<string, string>): void {\n    // Tags will be applied to future errors\n  }\n\n  setExtra(extra: Record<string, any>): void {\n    // Extra data will be applied to future errors\n  }\n\n  getBreadcrumbs(): Breadcrumb[] {\n    return [...this.breadcrumbs];\n  }\n\n  clearBreadcrumbs(): void {\n    this.breadcrumbs = [];\n  }\n}\n","import { generateId, getSessionStorage } from './utils';\nimport type { SessionEvent, ReviConfig } from './types';\n\nexport class SessionManager {\n  private sessionId: string;\n  private startTime: number;\n  private events: SessionEvent[] = [];\n  private config: ReviConfig;\n  private storage: Storage | null;\n\n  constructor(config: ReviConfig) {\n    this.config = config;\n    this.storage = getSessionStorage();\n    this.sessionId = this.getOrCreateSessionId();\n    this.startTime = Date.now();\n    \n    this.setupEventListeners();\n    this.trackPageLoad();\n  }\n\n  private getOrCreateSessionId(): string {\n    const storageKey = 'revi_session_id';\n    \n    if (this.storage) {\n      const existingId = this.storage.getItem(storageKey);\n      if (existingId) return existingId;\n    }\n    \n    const newId = generateId();\n    if (this.storage) {\n      this.storage.setItem(storageKey, newId);\n    }\n    \n    return newId;\n  }\n\n  getSessionId(): string {\n    return this.sessionId;\n  }\n\n  private setupEventListeners(): void {\n    if (typeof window === 'undefined') return;\n\n    // DOM events\n    const eventTypes = ['click', 'input', 'change', 'submit', 'focus', 'blur'];\n    eventTypes.forEach(eventType => {\n      document.addEventListener(eventType, (event) => {\n        this.captureEvent(eventType, this.serializeDOMEvent(event));\n      }, { capture: true, passive: true });\n    });\n\n    // Navigation events\n    window.addEventListener('popstate', () => {\n      this.captureEvent('navigation', {\n        type: 'popstate',\n        url: window.location.href,\n        timestamp: Date.now()\n      });\n    });\n\n    // Page visibility\n    document.addEventListener('visibilitychange', () => {\n      this.captureEvent('visibility', {\n        hidden: document.hidden,\n        timestamp: Date.now()\n      });\n    });\n\n    // Scroll events (throttled)\n    let scrollTimeout: NodeJS.Timeout;\n    window.addEventListener('scroll', () => {\n      clearTimeout(scrollTimeout);\n      scrollTimeout = setTimeout(() => {\n        this.captureEvent('scroll', {\n          x: window.scrollX,\n          y: window.scrollY,\n          timestamp: Date.now()\n        });\n      }, 100);\n    }, { passive: true });\n\n    // Resize events (throttled)\n    let resizeTimeout: NodeJS.Timeout;\n    window.addEventListener('resize', () => {\n      clearTimeout(resizeTimeout);\n      resizeTimeout = setTimeout(() => {\n        this.captureEvent('resize', {\n          width: window.innerWidth,\n          height: window.innerHeight,\n          timestamp: Date.now()\n        });\n      }, 100);\n    }, { passive: true });\n\n    // Before unload\n    window.addEventListener('beforeunload', () => {\n      this.captureEvent('beforeunload', {\n        timestamp: Date.now(),\n        duration: Date.now() - this.startTime\n      });\n      this.flush();\n    });\n  }\n\n  private serializeDOMEvent(event: Event): Record<string, any> {\n    const target = event.target as HTMLElement;\n    if (!target) return {};\n\n    const data: Record<string, any> = {\n      type: event.type,\n      timestamp: Date.now(),\n      target: {\n        tagName: target.tagName,\n        id: target.id,\n        className: target.className,\n        textContent: this.shouldMaskText(target) ? '[Masked]' : target.textContent?.slice(0, 100)\n      }\n    };\n\n    // Add specific event data\n    if (event.type === 'click') {\n      const mouseEvent = event as MouseEvent;\n      data.coordinates = {\n        x: mouseEvent.clientX,\n        y: mouseEvent.clientY\n      };\n    }\n\n    if (event.type === 'input' || event.type === 'change') {\n      const inputEvent = event.target as HTMLInputElement;\n      if (inputEvent && inputEvent.value !== undefined) {\n        data.value = this.shouldMaskInput(inputEvent) ? '[Masked]' : inputEvent.value;\n      }\n    }\n\n    return data;\n  }\n\n  private shouldMaskInput(element: HTMLInputElement): boolean {\n    if (!this.config.privacy?.maskInputs) return false;\n    \n    const sensitiveTypes = ['password', 'email', 'tel', 'credit-card-number'];\n    const sensitiveNames = ['password', 'email', 'phone', 'credit', 'card', 'ssn'];\n    \n    if (sensitiveTypes.includes(element.type)) return true;\n    \n    const name = element.name?.toLowerCase() || '';\n    const id = element.id?.toLowerCase() || '';\n    \n    return sensitiveNames.some(sensitive => \n      name.includes(sensitive) || id.includes(sensitive)\n    );\n  }\n\n  private shouldMaskText(element: HTMLElement): boolean {\n    if (!this.config.replay?.maskAllText) return false;\n    \n    // Check for specific selectors that should be masked\n    if (this.config.replay?.maskSelector) {\n      try {\n        return element.matches(this.config.replay.maskSelector);\n      } catch {\n        return false;\n      }\n    }\n    \n    return false;\n  }\n\n  private trackPageLoad(): void {\n    if (typeof window === 'undefined') return;\n\n    const captureLoadEvent = () => {\n      this.captureEvent('page_load', {\n        url: window.location.href,\n        title: document.title,\n        referrer: document.referrer,\n        timestamp: Date.now(),\n        loadTime: performance.now()\n      });\n    };\n\n    if (document.readyState === 'complete') {\n      captureLoadEvent();\n    } else {\n      window.addEventListener('load', captureLoadEvent);\n    }\n  }\n\n  captureEvent(type: string, data: Record<string, any>): void {\n    // Apply sampling\n    if (this.config.sessionSampleRate && Math.random() > this.config.sessionSampleRate) {\n      return;\n    }\n\n    const event: SessionEvent = {\n      sessionId: this.sessionId,\n      timestamp: Date.now(),\n      type,\n      data\n    };\n\n    // Apply beforeSendSession filter\n    const filteredEvent = this.config.beforeSendSession?.(event) || event;\n    if (!filteredEvent) return;\n\n    this.events.push(filteredEvent);\n\n    // Auto-flush when buffer is full\n    if (this.events.length >= 100) {\n      this.flush();\n    }\n  }\n\n  getEvents(): SessionEvent[] {\n    return [...this.events];\n  }\n\n  clearEvents(): void {\n    this.events = [];\n  }\n\n  flush(): SessionEvent[] {\n    const events = this.getEvents();\n    this.clearEvents();\n    return events;\n  }\n\n  endSession(): void {\n    this.captureEvent('session_end', {\n      timestamp: Date.now(),\n      duration: Date.now() - this.startTime\n    });\n    \n    if (this.storage) {\n      this.storage.removeItem('revi_session_id');\n    }\n  }\n}\n","import { generateId } from './utils';\nimport type { NetworkEvent, ReviConfig } from './types';\n\nexport class NetworkMonitor {\n  private config: ReviConfig;\n  private events: NetworkEvent[] = [];\n  private originalFetch: typeof fetch;\n  private originalXHROpen: typeof XMLHttpRequest.prototype.open;\n  private originalXHRSend: typeof XMLHttpRequest.prototype.send;\n\n  constructor(config: ReviConfig) {\n    this.config = config;\n    this.originalFetch = window.fetch;\n    this.originalXHROpen = XMLHttpRequest.prototype.open;\n    this.originalXHRSend = XMLHttpRequest.prototype.send;\n    \n    this.setupInterceptors();\n  }\n\n  private setupInterceptors(): void {\n    if (typeof window === 'undefined') return;\n\n    this.interceptFetch();\n    this.interceptXHR();\n  }\n\n  private interceptFetch(): void {\n    window.fetch = async (...args: Parameters<typeof fetch>): Promise<Response> => {\n      const startTime = Date.now();\n      const url = typeof args[0] === 'string' ? args[0] : args[0].url;\n      const method = (args[1]?.method || 'GET').toUpperCase();\n      \n      // Check if this request should be monitored\n      if (!this.shouldMonitorRequest(url)) {\n        return await this.originalFetch.apply(window, args);\n      }\n      \n      let requestSize = 0;\n      let requestBody: any;\n      \n      if (args[1]?.body) {\n        requestBody = this.serializeRequestBody(args[1].body);\n        requestSize = this.calculateBodySize(args[1].body);\n      }\n\n      try {\n        const response = await this.originalFetch.apply(window, args);\n        const endTime = Date.now();\n        \n        let responseBody: any;\n        let responseSize = 0;\n        \n        if (this.shouldCaptureResponseBody(url)) {\n          const clonedResponse = response.clone();\n          try {\n            responseBody = await this.extractResponseBody(clonedResponse);\n            responseSize = this.calculateResponseSize(responseBody);\n          } catch {\n            // Failed to extract response body\n          }\n        }\n\n        this.captureNetworkEvent({\n          method,\n          url,\n          statusCode: response.status,\n          responseTime: endTime - startTime,\n          requestSize,\n          responseSize,\n          requestHeaders: this.extractHeaders(args[1]?.headers),\n          responseHeaders: this.extractResponseHeaders(response.headers),\n          requestBody,\n          responseBody,\n          timestamp: startTime\n        });\n\n        return response;\n      } catch (error) {\n        const endTime = Date.now();\n        \n        this.captureNetworkEvent({\n          method,\n          url,\n          statusCode: 0, // Network error\n          responseTime: endTime - startTime,\n          requestSize,\n          responseSize: 0,\n          requestHeaders: this.extractHeaders(args[1]?.headers),\n          requestBody,\n          timestamp: startTime,\n          error: error instanceof Error ? error.message : String(error)\n        });\n\n        throw error;\n      }\n    };\n  }\n\n  private interceptXHR(): void {\n    const self = this;\n\n    XMLHttpRequest.prototype.open = function(method: string, url: string, ...args: any[]) {\n      (this as any)._reviData = {\n        method: method.toUpperCase(),\n        url,\n        startTime: Date.now(),\n        shouldMonitor: self.shouldMonitorRequest(url)\n      };\n      \n      return self.originalXHROpen.call(this, method, url, ...args);\n    };\n\n    XMLHttpRequest.prototype.send = function(body?: any) {\n      const reviData = (this as any)._reviData;\n      if (!reviData || !reviData.shouldMonitor) {\n        return self.originalXHRSend.call(this, body);\n      }\n\n      reviData.requestBody = self.serializeRequestBody(body);\n      reviData.requestSize = self.calculateBodySize(body);\n\n      this.addEventListener('loadend', () => {\n        const endTime = Date.now();\n        \n        let responseBody: any;\n        try {\n          if (this.responseType === '' || this.responseType === 'text') {\n            responseBody = this.responseText;\n          } else if (this.responseType === 'json') {\n            responseBody = this.response;\n          }\n        } catch {\n          // Failed to extract response\n        }\n\n        self.captureNetworkEvent({\n          method: reviData.method,\n          url: reviData.url,\n          statusCode: this.status,\n          responseTime: endTime - reviData.startTime,\n          requestSize: reviData.requestSize,\n          responseSize: self.calculateResponseSize(responseBody),\n          requestBody: reviData.requestBody,\n          responseBody: self.shouldCaptureResponseBody(reviData.url) ? responseBody : undefined,\n          timestamp: reviData.startTime\n        });\n      });\n\n      return self.originalXHRSend.call(this, body);\n    };\n  }\n\n  private serializeRequestBody(body: any): any {\n    if (!body) return undefined;\n    \n    if (typeof body === 'string') return body;\n    if (body instanceof FormData) {\n      const formObject: Record<string, any> = {};\n      body.forEach((value, key) => {\n        formObject[key] = value instanceof File ? `[File: ${value.name}]` : value;\n      });\n      return formObject;\n    }\n    if (body instanceof URLSearchParams) {\n      return Object.fromEntries(body);\n    }\n    \n    try {\n      return JSON.parse(JSON.stringify(body));\n    } catch {\n      return '[Unserializable]';\n    }\n  }\n\n  private async extractResponseBody(response: Response): Promise<any> {\n    const contentType = response.headers.get('content-type') || '';\n    \n    if (contentType.includes('application/json')) {\n      return await response.json();\n    } else if (contentType.includes('text/')) {\n      return await response.text();\n    }\n    \n    return '[Binary Data]';\n  }\n\n  private extractHeaders(headers?: HeadersInit): Record<string, string> {\n    if (!headers) return {};\n    \n    if (headers instanceof Headers) {\n      const headerObj: Record<string, string> = {};\n      headers.forEach((value, key) => {\n        headerObj[key] = value;\n      });\n      return headerObj;\n    }\n    \n    if (Array.isArray(headers)) {\n      const headerObj: Record<string, string> = {};\n      headers.forEach(([key, value]) => {\n        headerObj[key] = value;\n      });\n      return headerObj;\n    }\n    \n    return headers as Record<string, string>;\n  }\n\n  private extractResponseHeaders(headers: Headers): Record<string, string> {\n    const headerObj: Record<string, string> = {};\n    headers.forEach((value, key) => {\n      headerObj[key] = value;\n    });\n    return headerObj;\n  }\n\n  private calculateBodySize(body: any): number {\n    if (!body) return 0;\n    \n    if (typeof body === 'string') return body.length;\n    if (body instanceof ArrayBuffer) return body.byteLength;\n    if (body instanceof Blob) return body.size;\n    \n    try {\n      return JSON.stringify(body).length;\n    } catch {\n      return 0;\n    }\n  }\n\n  private calculateResponseSize(response: any): number {\n    if (!response) return 0;\n    \n    try {\n      return JSON.stringify(response).length;\n    } catch {\n      return 0;\n    }\n  }\n\n  private shouldCaptureResponseBody(url: string): boolean {\n    // Only capture response bodies for specific URLs to avoid memory issues\n    const allowedPatterns = [\n      /\\/api\\//,\n      /\\/graphql/,\n    ];\n    \n    return allowedPatterns.some(pattern => pattern.test(url));\n  }\n\n  private shouldMonitorRequest(url: string): boolean {\n    // Don't monitor the SDK's own API calls to prevent feedback loops\n    const apiUrl = this.config.apiUrl || 'https://api.revi.dev';\n    \n    // Remove trailing slash for consistent comparison\n    const normalizedApiUrl = apiUrl.replace(/\\/$/, '');\n    const normalizedUrl = url.replace(/\\/$/, '');\n    \n    // Debug logging to identify filtering issues\n    if (this.config.debug) {\n      console.log('[Revi Debug] Network filter check:', { \n        url, \n        normalizedUrl, \n        apiUrl, \n        normalizedApiUrl \n      });\n    }\n    \n    // Exclude any requests to the Revi API backend\n    if (normalizedUrl.startsWith(normalizedApiUrl)) {\n      if (this.config.debug) {\n        console.log('[Revi Debug] Filtering API URL:', url, '(matches configured apiUrl)');\n      }\n      return false;\n    }\n    \n    // Don't monitor requests to common localhost development ports that might be the backend\n    const localhostPatterns = [\n      /^https?:\\/\\/localhost:4000/,\n      /^https?:\\/\\/127\\.0\\.0\\.1:4000/,\n      /^https?:\\/\\/localhost:4001/, \n      /^https?:\\/\\/127\\.0\\.0\\.1:4001/,\n    ];\n    \n    const matchedPattern = localhostPatterns.find(pattern => pattern.test(url));\n    if (matchedPattern) {\n      if (this.config.debug) {\n        console.log('[Revi Debug] Filtering localhost URL:', url, '(matched pattern:', matchedPattern, ')');\n      }\n      return false;\n    }\n    \n    // Additional API endpoint patterns to filter\n    const apiEndpointPatterns = [\n      /\\/api\\/capture\\//,\n      /\\/api\\/errors/,\n      /\\/api\\/session/,\n      /\\/api\\/projects/,\n      /\\/api\\/database/,\n      /\\/api\\/analytics/,\n      /\\/health$/,\n    ];\n    \n    const matchedApiPattern = apiEndpointPatterns.find(pattern => pattern.test(url));\n    if (matchedApiPattern) {\n      if (this.config.debug) {\n        console.log('[Revi Debug] Filtering API endpoint:', url, '(matched pattern:', matchedApiPattern, ')');\n      }\n      return false;\n    }\n    \n    // Check privacy configuration if available\n    if (this.config.privacy?.denyUrls) {\n      const denied = this.config.privacy.denyUrls.some(pattern => {\n        const regex = new RegExp(pattern);\n        return regex.test(url);\n      });\n      if (denied) {\n        if (this.config.debug) {\n          console.log('[Revi Debug] Filtering denied URL:', url);\n        }\n        return false;\n      }\n    }\n    \n    if (this.config.privacy?.allowUrls) {\n      const allowed = this.config.privacy.allowUrls.some(pattern => {\n        const regex = new RegExp(pattern);\n        return regex.test(url);\n      });\n      if (this.config.debug) {\n        console.log('[Revi Debug] Allow list result for:', url, '- allowed:', allowed);\n      }\n      return allowed;\n    }\n    \n    if (this.config.debug) {\n      console.log('[Revi Debug] Monitoring URL:', url, '(no filters matched)');\n    }\n    return true;\n  }\n\n  private captureNetworkEvent(data: Partial<NetworkEvent> & { method: string; url: string; timestamp: number }): void {\n    const event: NetworkEvent = {\n      sessionId: '', // Will be set by Monitor class\n      timestamp: data.timestamp,\n      method: data.method,\n      url: data.url,\n      statusCode: data.statusCode,\n      responseTime: data.responseTime,\n      requestSize: data.requestSize,\n      responseSize: data.responseSize,\n      requestHeaders: data.requestHeaders,\n      responseHeaders: data.responseHeaders,\n      requestBody: data.requestBody,\n      responseBody: data.responseBody\n    };\n\n    this.events.push(event);\n\n    // Auto-flush when buffer is full\n    if (this.events.length >= 50) {\n      this.flush();\n    }\n  }\n\n  getEvents(): NetworkEvent[] {\n    return [...this.events];\n  }\n\n  clearEvents(): void {\n    this.events = [];\n  }\n\n  flush(): NetworkEvent[] {\n    const events = this.getEvents();\n    this.clearEvents();\n    return events;\n  }\n\n  destroy(): void {\n    // Restore original implementations\n    if (this.originalFetch) {\n      window.fetch = this.originalFetch;\n    }\n    \n    XMLHttpRequest.prototype.open = this.originalXHROpen;\n    XMLHttpRequest.prototype.send = this.originalXHRSend;\n  }\n}\n","import type { PerformanceEntry, WebVitals, ReviConfig } from './types';\n\nexport class PerformanceMonitor {\n  private config: ReviConfig;\n  private webVitals: WebVitals = {};\n  private performanceEntries: PerformanceEntry[] = [];\n\n  constructor(config: ReviConfig) {\n    this.config = config;\n    \n    if (this.config.performance?.captureWebVitals) {\n      this.setupWebVitals();\n    }\n    \n    if (this.config.performance?.captureResourceTiming) {\n      this.setupResourceTiming();\n    }\n    \n    if (this.config.performance?.captureNavigationTiming) {\n      this.setupNavigationTiming();\n    }\n  }\n\n  private setupWebVitals(): void {\n    if (typeof window === 'undefined' || !('PerformanceObserver' in window)) return;\n\n    // Largest Contentful Paint (LCP)\n    try {\n      const lcpObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        const lastEntry = entries[entries.length - 1];\n        this.webVitals.lcp = lastEntry.startTime;\n      });\n      lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });\n    } catch (e) {\n      // LCP not supported\n    }\n\n    // First Input Delay (FID)\n    try {\n      const fidObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries() as any[];\n        entries.forEach((entry) => {\n          this.webVitals.fid = entry.processingStart - entry.startTime;\n        });\n      });\n      fidObserver.observe({ entryTypes: ['first-input'] });\n    } catch (e) {\n      // FID not supported\n    }\n\n    // Cumulative Layout Shift (CLS)\n    try {\n      let clsValue = 0;\n      const clsObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries() as any[];\n        entries.forEach((entry) => {\n          if (!entry.hadRecentInput) {\n            clsValue += entry.value;\n            this.webVitals.cls = clsValue;\n          }\n        });\n      });\n      clsObserver.observe({ entryTypes: ['layout-shift'] });\n    } catch (e) {\n      // CLS not supported\n    }\n\n    // First Contentful Paint (FCP)\n    try {\n      const fcpObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        entries.forEach((entry) => {\n          if (entry.name === 'first-contentful-paint') {\n            this.webVitals.fcp = entry.startTime;\n          }\n        });\n      });\n      fcpObserver.observe({ entryTypes: ['paint'] });\n    } catch (e) {\n      // FCP not supported\n    }\n\n    // Time to First Byte (TTFB)\n    this.calculateTTFB();\n  }\n\n  private calculateTTFB(): void {\n    if (typeof window === 'undefined' || !window.performance) return;\n\n    try {\n      const navigationTiming = performance.getEntriesByType('navigation')[0] as any;\n      if (navigationTiming) {\n        this.webVitals.ttfb = navigationTiming.responseStart - navigationTiming.requestStart;\n      }\n    } catch (e) {\n      // TTFB calculation failed\n    }\n  }\n\n  private setupResourceTiming(): void {\n    if (typeof window === 'undefined' || !window.performance) return;\n\n    try {\n      const resourceObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        entries.forEach((entry) => {\n          this.performanceEntries.push({\n            name: entry.name,\n            entryType: entry.entryType,\n            startTime: entry.startTime,\n            duration: entry.duration,\n            transferSize: (entry as any).transferSize,\n            encodedBodySize: (entry as any).encodedBodySize,\n            decodedBodySize: (entry as any).decodedBodySize\n          });\n        });\n      });\n      \n      resourceObserver.observe({ entryTypes: ['resource'] });\n    } catch (e) {\n      // Resource timing not supported\n    }\n  }\n\n  private setupNavigationTiming(): void {\n    if (typeof window === 'undefined' || !window.performance) return;\n\n    window.addEventListener('load', () => {\n      try {\n        const navigationTiming = performance.getEntriesByType('navigation')[0] as any;\n        if (navigationTiming) {\n          this.performanceEntries.push({\n            name: 'navigation',\n            entryType: 'navigation',\n            startTime: navigationTiming.startTime,\n            duration: navigationTiming.duration,\n            domContentLoadedEventEnd: navigationTiming.domContentLoadedEventEnd,\n            domContentLoadedEventStart: navigationTiming.domContentLoadedEventStart,\n            loadEventEnd: navigationTiming.loadEventEnd,\n            loadEventStart: navigationTiming.loadEventStart,\n            domComplete: navigationTiming.domComplete,\n            domInteractive: navigationTiming.domInteractive\n          });\n        }\n      } catch (e) {\n        // Navigation timing failed\n      }\n    });\n  }\n\n  getWebVitals(): WebVitals {\n    return { ...this.webVitals };\n  }\n\n  getPerformanceEntries(): PerformanceEntry[] {\n    return [...this.performanceEntries];\n  }\n\n  clearPerformanceEntries(): void {\n    this.performanceEntries = [];\n  }\n\n  // Custom performance marks\n  mark(name: string): void {\n    if (typeof window !== 'undefined' && window.performance && window.performance.mark) {\n      try {\n        performance.mark(name);\n      } catch (e) {\n        // Mark failed\n      }\n    }\n  }\n\n  measure(name: string, startMark?: string, endMark?: string): number | null {\n    if (typeof window === 'undefined' || !window.performance || !window.performance.measure) {\n      return null;\n    }\n\n    try {\n      performance.measure(name, startMark, endMark);\n      const measure = performance.getEntriesByName(name, 'measure')[0];\n      return measure ? measure.duration : null;\n    } catch (e) {\n      return null;\n    }\n  }\n}\n","import { getLocalStorage } from './utils';\nimport type { ErrorEvent, SessionEvent, NetworkEvent, ReviConfig } from './types';\n\ninterface QueuedData {\n  errors: ErrorEvent[];\n  sessionEvents: SessionEvent[];\n  networkEvents: NetworkEvent[];\n}\n\nexport class DataManager {\n  private config: ReviConfig;\n  private storage: Storage | null;\n  private uploadQueue: QueuedData = {\n    errors: [],\n    sessionEvents: [],\n    networkEvents: []\n  };\n  private uploadTimer: NodeJS.Timeout | null = null;\n  private isUploading = false;\n\n  constructor(config: ReviConfig) {\n    this.config = config;\n    this.storage = getLocalStorage();\n    \n    this.loadQueueFromStorage();\n    this.startUploadTimer();\n    this.setupBeforeUnloadHandler();\n  }\n\n  private loadQueueFromStorage(): void {\n    if (!this.storage) return;\n\n    try {\n      const storedData = this.storage.getItem('revi_upload_queue');\n      if (storedData) {\n        this.uploadQueue = JSON.parse(storedData);\n      }\n    } catch (e) {\n      // Failed to load from storage\n    }\n  }\n\n  private saveQueueToStorage(): void {\n    if (!this.storage) return;\n\n    try {\n      this.storage.setItem('revi_upload_queue', JSON.stringify(this.uploadQueue));\n    } catch (e) {\n      // Failed to save to storage, probably quota exceeded\n      this.clearQueue();\n    }\n  }\n\n  private startUploadTimer(): void {\n    const interval = 5000; // Upload every 5 seconds\n    \n    this.uploadTimer = setInterval(() => {\n      if (!this.isUploading && this.hasQueuedData()) {\n        this.uploadData();\n      }\n    }, interval);\n  }\n\n  private setupBeforeUnloadHandler(): void {\n    if (typeof window === 'undefined') return;\n\n    window.addEventListener('beforeunload', () => {\n      if (this.hasQueuedData()) {\n        this.uploadDataSync();\n      }\n    });\n  }\n\n  queueError(error: ErrorEvent): void {\n    this.uploadQueue.errors.push(error);\n    this.saveQueueToStorage();\n  }\n\n  queueSessionEvents(events: SessionEvent[]): void {\n    this.uploadQueue.sessionEvents.push(...events);\n    this.saveQueueToStorage();\n  }\n\n  queueNetworkEvents(events: NetworkEvent[]): void {\n    this.uploadQueue.networkEvents.push(...events);\n    this.saveQueueToStorage();\n  }\n\n  private hasQueuedData(): boolean {\n    return this.uploadQueue.errors.length > 0 ||\n           this.uploadQueue.sessionEvents.length > 0 ||\n           this.uploadQueue.networkEvents.length > 0;\n  }\n\n  private async uploadData(): Promise<void> {\n    if (this.isUploading || !this.hasQueuedData()) return;\n\n    this.isUploading = true;\n    const apiUrl = this.config.apiUrl || 'https://api.revi.dev';\n\n    try {\n      // Upload errors\n      if (this.uploadQueue.errors.length > 0) {\n        await this.uploadErrors(apiUrl, this.uploadQueue.errors);\n        this.uploadQueue.errors = [];\n      }\n\n      // Upload session events\n      if (this.uploadQueue.sessionEvents.length > 0) {\n        await this.uploadSessionEvents(apiUrl, this.uploadQueue.sessionEvents);\n        this.uploadQueue.sessionEvents = [];\n      }\n\n      // Upload network events\n      if (this.uploadQueue.networkEvents.length > 0) {\n        await this.uploadNetworkEvents(apiUrl, this.uploadQueue.networkEvents);\n        this.uploadQueue.networkEvents = [];\n      }\n\n      this.saveQueueToStorage();\n    } catch (error) {\n      if (this.config.debug) {\n        console.error('Revi: Failed to upload data', error);\n      }\n      // Keep data in queue for retry\n    } finally {\n      this.isUploading = false;\n    }\n  }\n\n  private uploadDataSync(): void {\n    if (!this.hasQueuedData()) return;\n\n    const apiUrl = this.config.apiUrl || 'https://api.revi.dev';\n\n    // Use sendBeacon for synchronous upload on page unload\n    if (navigator.sendBeacon) {\n      if (this.uploadQueue.errors.length > 0) {\n        const payload = JSON.stringify({ errors: this.uploadQueue.errors });\n        navigator.sendBeacon(`${apiUrl}/api/capture/error`, payload);\n      }\n\n      if (this.uploadQueue.sessionEvents.length > 0) {\n        const payload = JSON.stringify({ \n          session_id: this.uploadQueue.sessionEvents[0]?.sessionId,\n          events: this.uploadQueue.sessionEvents.map(e => ({\n            event_type: e.type,\n            data: e.data,\n            timestamp: e.timestamp,\n            session_id: e.sessionId\n          }))\n        });\n        navigator.sendBeacon(`${apiUrl}/api/capture/session-event`, payload);\n      }\n\n      if (this.uploadQueue.networkEvents.length > 0) {\n        const payload = JSON.stringify({ events: this.uploadQueue.networkEvents });\n        navigator.sendBeacon(`${apiUrl}/api/capture/network-event`, payload);\n      }\n    }\n  }\n\n  private async uploadErrors(apiUrl: string, errors: ErrorEvent[]): Promise<void> {\n    const response = await fetch(`${apiUrl}/api/capture/error`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-API-Key': this.config.apiKey\n      },\n      body: JSON.stringify({\n        errors: errors.map(error => ({\n          message: error.message,\n          stack_trace: error.stack,\n          url: error.url,\n          user_agent: error.userAgent,\n          session_id: error.sessionId,\n          metadata: {\n            id: error.id,\n            userId: error.userId,\n            environment: error.environment,\n            release: error.release,\n            tags: error.tags,\n            extra: error.extra,\n            breadcrumbs: error.breadcrumbs,\n            level: error.level,\n            lineno: error.lineno,\n            colno: error.colno,\n            filename: error.filename\n          }\n        }))\n      })\n    });\n\n    if (!response.ok) {\n      throw new Error(`Upload failed: ${response.status}`);\n    }\n  }\n\n  private async uploadSessionEvents(apiUrl: string, events: SessionEvent[]): Promise<void> {\n    if (events.length === 0) return;\n\n    const sessionId = events[0].sessionId;\n    const response = await fetch(`${apiUrl}/api/capture/session-event`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-API-Key': this.config.apiKey\n      },\n      body: JSON.stringify({\n        session_id: sessionId,\n        events: events.map(event => ({\n          event_type: event.type,\n          data: event.data,\n          timestamp: event.timestamp,\n          session_id: event.sessionId\n        }))\n      })\n    });\n\n    if (!response.ok) {\n      throw new Error(`Upload failed: ${response.status}`);\n    }\n  }\n\n  private async uploadNetworkEvents(apiUrl: string, events: NetworkEvent[]): Promise<void> {\n    const promises = events.map(event => \n      fetch(`${this.config.apiUrl}/api/capture/network-event`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-API-Key': this.config.apiKey\n        },\n        body: JSON.stringify({\n          session_id: event.sessionId,\n          events: [{\n            method: event.method,\n            url: event.url,\n            status_code: event.statusCode,\n            response_time: event.responseTime,\n            timestamp: event.timestamp,\n            session_id: event.sessionId,\n            request_data: {\n              headers: event.requestHeaders || {},\n              body: event.requestBody || null,\n              size: event.requestSize || 0\n            },\n            response_data: {\n              headers: event.responseHeaders || {},\n              body: event.responseBody || null,\n              size: event.responseSize || 0\n            }\n          }]\n        })\n      })\n    );\n\n    const responses = await Promise.allSettled(promises);\n    const failures = responses.filter(r => r.status === 'rejected');\n    \n    if (failures.length > 0) {\n      throw new Error(`${failures.length} network event uploads failed`);\n    }\n  }\n\n  clearQueue(): void {\n    this.uploadQueue = {\n      errors: [],\n      sessionEvents: [],\n      networkEvents: []\n    };\n    \n    if (this.storage) {\n      this.storage.removeItem('revi_upload_queue');\n    }\n  }\n\n  destroy(): void {\n    if (this.uploadTimer) {\n      clearInterval(this.uploadTimer);\n      this.uploadTimer = null;\n    }\n    \n    // Final upload attempt\n    if (this.hasQueuedData()) {\n      this.uploadDataSync();\n    }\n  }\n}\n","import type { ReviConfig } from './types';\nimport { generateId } from './utils';\nimport crypto from 'crypto';\n\nexport interface JourneyEvent {\n  event_type: 'page_view' | 'click' | 'form_submit' | 'api_call' | 'error';\n  url: string;\n  referrer?: string;\n  timestamp: number;\n  duration_ms?: number;\n  metadata: Record<string, any>;\n}\n\nexport interface DeviceFingerprint {\n  screen_resolution: string;\n  color_depth: number;\n  timezone: string;\n  language: string;\n  platform: string;\n  user_agent: string;\n  canvas_fingerprint?: string;\n  webgl_fingerprint?: string;\n}\n\n/**\n * Advanced user journey tracking with device fingerprinting\n */\nexport class UserJourneyTracker {\n  private config: ReviConfig;\n  private userId?: string;\n  private deviceFingerprint: string;\n  private sessionStartTime: number;\n  private currentPageStartTime: number;\n  private journeyEvents: JourneyEvent[] = [];\n  private isTracking = false;\n\n  constructor(config: ReviConfig) {\n    this.config = config;\n    this.deviceFingerprint = this.generateDeviceFingerprint();\n    this.sessionStartTime = Date.now();\n    this.currentPageStartTime = Date.now();\n    \n    if (typeof window !== 'undefined') {\n      this.setupJourneyTracking();\n    }\n  }\n\n  /**\n   * Start tracking user journey\n   */\n  startTracking(userId?: string): void {\n    this.userId = userId;\n    this.isTracking = true;\n    \n    // Track initial page view\n    this.trackPageView();\n    \n    if (this.config.debug) {\n      console.log('Revi: User journey tracking started', { userId, deviceFingerprint: this.deviceFingerprint });\n    }\n  }\n\n  /**\n   * Stop tracking user journey\n   */\n  stopTracking(): void {\n    this.isTracking = false;\n    this.flush();\n  }\n\n  /**\n   * Set user ID for tracking\n   */\n  setUserId(userId: string): void {\n    this.userId = userId;\n  }\n\n  /**\n   * Track page view with timing\n   */\n  private trackPageView(): void {\n    if (!this.isTracking) return;\n\n    const event: JourneyEvent = {\n      event_type: 'page_view',\n      url: window.location.href,\n      referrer: document.referrer || undefined,\n      timestamp: Date.now(),\n      metadata: {\n        title: document.title,\n        viewport: {\n          width: window.innerWidth,\n          height: window.innerHeight\n        },\n        scroll_position: {\n          x: window.scrollX,\n          y: window.scrollY\n        },\n        device_fingerprint: this.deviceFingerprint,\n        user_agent: navigator.userAgent,\n        language: navigator.language,\n        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n        connection_type: this.getConnectionType()\n      }\n    };\n\n    this.addJourneyEvent(event);\n  }\n\n  /**\n   * Track user clicks with context\n   */\n  private trackClick(element: HTMLElement, event: MouseEvent): void {\n    if (!this.isTracking) return;\n\n    const journeyEvent: JourneyEvent = {\n      event_type: 'click',\n      url: window.location.href,\n      timestamp: Date.now(),\n      metadata: {\n        element: {\n          tag: element.tagName.toLowerCase(),\n          id: element.id,\n          class: element.className,\n          text: this.getElementText(element),\n          attributes: this.getRelevantAttributes(element)\n        },\n        coordinates: {\n          x: event.clientX,\n          y: event.clientY,\n          page_x: event.pageX,\n          page_y: event.pageY\n        },\n        viewport: {\n          width: window.innerWidth,\n          height: window.innerHeight\n        },\n        scroll_position: {\n          x: window.scrollX,\n          y: window.scrollY\n        }\n      }\n    };\n\n    this.addJourneyEvent(journeyEvent);\n  }\n\n  /**\n   * Track form submissions\n   */\n  private trackFormSubmit(form: HTMLFormElement): void {\n    if (!this.isTracking) return;\n\n    const formData = new FormData(form);\n    const fields: Record<string, any> = {};\n    \n    formData.forEach((value, key) => {\n      // Only track field names and types, not values for privacy\n      const input = form.querySelector(`[name=\"${key}\"]`) as HTMLInputElement;\n      fields[key] = {\n        type: input?.type || 'unknown',\n        has_value: !!value,\n        value_length: typeof value === 'string' ? value.length : 0\n      };\n    });\n\n    const journeyEvent: JourneyEvent = {\n      event_type: 'form_submit',\n      url: window.location.href,\n      timestamp: Date.now(),\n      metadata: {\n        form: {\n          id: form.id,\n          class: form.className,\n          method: form.method,\n          action: form.action,\n          field_count: formData.entries().length\n        },\n        fields: this.config.privacy?.maskInputs ? {} : fields\n      }\n    };\n\n    this.addJourneyEvent(journeyEvent);\n  }\n\n  /**\n   * Track API calls and their performance\n   */\n  trackApiCall(url: string, method: string, status: number, duration: number, size?: number): void {\n    if (!this.isTracking) return;\n\n    const journeyEvent: JourneyEvent = {\n      event_type: 'api_call',\n      url: window.location.href,\n      timestamp: Date.now(),\n      duration_ms: duration,\n      metadata: {\n        api: {\n          url,\n          method,\n          status,\n          duration,\n          size: size || 0,\n          success: status >= 200 && status < 300\n        },\n        page_context: {\n          title: document.title,\n          time_on_page: Date.now() - this.currentPageStartTime\n        }\n      }\n    };\n\n    this.addJourneyEvent(journeyEvent);\n  }\n\n  /**\n   * Track errors in user journey context\n   */\n  trackError(error: Error, context?: Record<string, any>): void {\n    if (!this.isTracking) return;\n\n    const journeyEvent: JourneyEvent = {\n      event_type: 'error',\n      url: window.location.href,\n      timestamp: Date.now(),\n      metadata: {\n        error: {\n          message: error.message,\n          name: error.name,\n          stack: error.stack?.split('\\n').slice(0, 5).join('\\n') // Limit stack trace\n        },\n        user_context: {\n          time_on_page: Date.now() - this.currentPageStartTime,\n          session_duration: Date.now() - this.sessionStartTime,\n          page_interactions: this.countPageInteractions()\n        },\n        custom_context: context || {}\n      }\n    };\n\n    this.addJourneyEvent(journeyEvent);\n  }\n\n  /**\n   * Setup event listeners for journey tracking\n   */\n  private setupJourneyTracking(): void {\n    // Track page views on navigation\n    let currentUrl = window.location.href;\n    \n    const handleNavigation = () => {\n      if (window.location.href !== currentUrl) {\n        // Track time spent on previous page\n        const timeSpent = Date.now() - this.currentPageStartTime;\n        this.updateLastPageViewDuration(timeSpent);\n        \n        // Track new page view\n        currentUrl = window.location.href;\n        this.currentPageStartTime = Date.now();\n        this.trackPageView();\n      }\n    };\n\n    // Handle navigation events\n    window.addEventListener('popstate', handleNavigation);\n    \n    // Override pushState and replaceState to catch programmatic navigation\n    const originalPushState = history.pushState;\n    const originalReplaceState = history.replaceState;\n    \n    history.pushState = function(...args) {\n      originalPushState.apply(history, args);\n      setTimeout(handleNavigation, 0);\n    };\n    \n    history.replaceState = function(...args) {\n      originalReplaceState.apply(history, args);\n      setTimeout(handleNavigation, 0);\n    };\n\n    // Track clicks\n    document.addEventListener('click', (event) => {\n      const target = event.target as HTMLElement;\n      if (target && this.shouldTrackClick(target)) {\n        this.trackClick(target, event);\n      }\n    }, { capture: true, passive: true });\n\n    // Track form submissions\n    document.addEventListener('submit', (event) => {\n      const form = event.target as HTMLFormElement;\n      if (form && form.tagName === 'FORM') {\n        this.trackFormSubmit(form);\n      }\n    }, { capture: true, passive: true });\n\n    // Track page exit\n    window.addEventListener('beforeunload', () => {\n      const timeSpent = Date.now() - this.currentPageStartTime;\n      this.updateLastPageViewDuration(timeSpent);\n      this.flush();\n    });\n\n    // Periodic flush\n    setInterval(() => {\n      if (this.journeyEvents.length > 0) {\n        this.flush();\n      }\n    }, 30000); // Flush every 30 seconds\n  }\n\n  /**\n   * Generate device fingerprint for user tracking\n   */\n  private generateDeviceFingerprint(): string {\n    if (typeof window === 'undefined') return 'server';\n\n    const components = [\n      navigator.userAgent,\n      navigator.language,\n      screen.width + 'x' + screen.height,\n      screen.colorDepth,\n      Intl.DateTimeFormat().resolvedOptions().timeZone,\n      navigator.platform,\n      navigator.cookieEnabled,\n      typeof window.localStorage !== 'undefined',\n      typeof window.sessionStorage !== 'undefined'\n    ];\n\n    // Add canvas fingerprint if available\n    try {\n      const canvas = document.createElement('canvas');\n      const ctx = canvas.getContext('2d');\n      if (ctx) {\n        ctx.textBaseline = 'top';\n        ctx.font = '14px Arial';\n        ctx.fillText('Device fingerprint', 2, 2);\n        components.push(canvas.toDataURL());\n      }\n    } catch (e) {\n      // Canvas fingerprinting failed\n    }\n\n    // Create hash of all components\n    const fingerprint = components.join('|');\n    \n    // Simple hash function (in production, use a proper crypto library)\n    let hash = 0;\n    for (let i = 0; i < fingerprint.length; i++) {\n      const char = fingerprint.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    \n    return Math.abs(hash).toString(36);\n  }\n\n  /**\n   * Add journey event to buffer\n   */\n  private addJourneyEvent(event: JourneyEvent): void {\n    this.journeyEvents.push(event);\n\n    // Auto-flush if buffer is full\n    if (this.journeyEvents.length >= 50) {\n      this.flush();\n    }\n  }\n\n  /**\n   * Flush journey events to backend\n   */\n  private flush(): void {\n    if (this.journeyEvents.length === 0) return;\n\n    const events = [...this.journeyEvents];\n    this.journeyEvents = [];\n\n    // Send to backend (implement based on your API structure)\n    this.sendJourneyEvents(events).catch(error => {\n      if (this.config.debug) {\n        console.error('Revi: Failed to send journey events', error);\n      }\n      // Re-add events to buffer for retry\n      this.journeyEvents.unshift(...events);\n    });\n  }\n\n  /**\n   * Send journey events to analytics backend\n   */\n  private async sendJourneyEvents(events: JourneyEvent[]): Promise<void> {\n    const apiUrl = this.config.apiUrl || 'https://api.revi.dev';\n    \n    // Send each event individually (could be optimized for batch sending)\n    const promises = events.map(event => \n      fetch(`${apiUrl}/api/analytics/user-event`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-API-Key': this.config.apiKey\n        },\n        body: JSON.stringify({\n          user_id: this.userId,\n          session_id: this.getSessionId(),\n          ...event\n        })\n      })\n    );\n\n    await Promise.allSettled(promises);\n  }\n\n  /**\n   * Helper methods\n   */\n  private shouldTrackClick(element: HTMLElement): boolean {\n    // Don't track clicks on sensitive elements\n    const tag = element.tagName.toLowerCase();\n    if (['input', 'textarea'].includes(tag)) {\n      const input = element as HTMLInputElement;\n      if (['password', 'hidden'].includes(input.type)) {\n        return false;\n      }\n    }\n\n    // Don't track if element has data-revi-ignore attribute\n    return !element.hasAttribute('data-revi-ignore');\n  }\n\n  private getElementText(element: HTMLElement): string {\n    const text = element.textContent || element.innerText || '';\n    return text.trim().substring(0, 100);\n  }\n\n  private getRelevantAttributes(element: HTMLElement): Record<string, string> {\n    const attrs: Record<string, string> = {};\n    const relevantAttrs = ['href', 'src', 'alt', 'title', 'data-testid', 'role'];\n    \n    relevantAttrs.forEach(attr => {\n      const value = element.getAttribute(attr);\n      if (value) {\n        attrs[attr] = value;\n      }\n    });\n    \n    return attrs;\n  }\n\n  private getConnectionType(): string {\n    if ('connection' in navigator) {\n      const connection = (navigator as any).connection;\n      return connection?.effectiveType || connection?.type || 'unknown';\n    }\n    return 'unknown';\n  }\n\n  private countPageInteractions(): number {\n    return this.journeyEvents.filter(event => \n      ['click', 'form_submit'].includes(event.event_type)\n    ).length;\n  }\n\n  private updateLastPageViewDuration(duration: number): void {\n    if (this.journeyEvents.length > 0) {\n      const lastEvent = this.journeyEvents[this.journeyEvents.length - 1];\n      if (lastEvent.event_type === 'page_view') {\n        lastEvent.duration_ms = duration;\n      }\n    }\n  }\n\n  private getSessionId(): string {\n    // This should be implemented to get session ID from session manager\n    // For now, return a placeholder\n    return 'session-' + Date.now();\n  }\n}","import type { ReviConfig } from './types';\n\nexport interface SerializedNode {\n  type: 'document' | 'element' | 'text' | 'comment';\n  tagName?: string;\n  attributes?: Record<string, string>;\n  textContent?: string;\n  children?: SerializedNode[];\n  id?: number;\n  parentId?: number;\n}\n\nexport interface DOMSnapshot {\n  timestamp: number;\n  url: string;\n  viewport: {\n    width: number;\n    height: number;\n  };\n  scroll: {\n    x: number;\n    y: number;\n  };\n  nodes: SerializedNode[];\n  stylesheets: SerializedStylesheet[];\n  resources: SerializedResource[];\n}\n\nexport interface SerializedStylesheet {\n  href?: string;\n  cssText: string;\n  disabled: boolean;\n}\n\nexport interface SerializedResource {\n  url: string;\n  type: 'image' | 'font' | 'media';\n  data?: string; // Base64 encoded data for small resources\n  failed?: boolean;\n}\n\nexport interface DOMChange {\n  timestamp: number;\n  type: 'childList' | 'attributes' | 'characterData';\n  target: number; // Node ID\n  addedNodes?: SerializedNode[];\n  removedNodes?: number[]; // Node IDs\n  attributeName?: string;\n  attributeValue?: string;\n  oldValue?: string;\n}\n\n/**\n * Advanced DOM serializer for session replay with rrweb-like capabilities\n */\nexport class DOMSerializer {\n  private config: ReviConfig;\n  private nodeIdMap = new WeakMap<Node, number>();\n  private nodeMap = new Map<number, Node>();\n  private nextNodeId = 1;\n  private observer?: MutationObserver;\n  private isObserving = false;\n  private onDOMChange?: (change: DOMChange) => void;\n\n  constructor(config: ReviConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Take a complete snapshot of the DOM\n   */\n  takeSnapshot(): DOMSnapshot {\n    const snapshot: DOMSnapshot = {\n      timestamp: Date.now(),\n      url: window.location.href,\n      viewport: {\n        width: window.innerWidth,\n        height: window.innerHeight\n      },\n      scroll: {\n        x: window.scrollX,\n        y: window.scrollY\n      },\n      nodes: [],\n      stylesheets: [],\n      resources: []\n    };\n\n    // Serialize DOM\n    snapshot.nodes = this.serializeDocument(document);\n    \n    // Capture stylesheets\n    snapshot.stylesheets = this.serializeStylesheets();\n    \n    // Capture resources (images, fonts, etc.)\n    snapshot.resources = this.serializeResources();\n\n    return snapshot;\n  }\n\n  /**\n   * Start observing DOM changes\n   */\n  startObserving(onDOMChange: (change: DOMChange) => void): void {\n    if (this.isObserving) return;\n\n    this.onDOMChange = onDOMChange;\n    this.observer = new MutationObserver(this.handleMutations.bind(this));\n    \n    this.observer.observe(document, {\n      childList: true,\n      attributes: true,\n      characterData: true,\n      subtree: true,\n      attributeOldValue: true,\n      characterDataOldValue: true\n    });\n\n    this.isObserving = true;\n  }\n\n  /**\n   * Stop observing DOM changes\n   */\n  stopObserving(): void {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = undefined;\n    }\n    this.isObserving = false;\n    this.onDOMChange = undefined;\n  }\n\n  /**\n   * Serialize the entire document\n   */\n  private serializeDocument(doc: Document): SerializedNode[] {\n    const doctype = doc.doctype;\n    const nodes: SerializedNode[] = [];\n\n    // Add doctype if present\n    if (doctype) {\n      nodes.push({\n        type: 'document',\n        tagName: 'DOCTYPE',\n        attributes: {\n          name: doctype.name,\n          publicId: doctype.publicId,\n          systemId: doctype.systemId\n        },\n        id: this.getNodeId(doctype)\n      });\n    }\n\n    // Serialize document element (html)\n    if (doc.documentElement) {\n      const serialized = this.serializeNode(doc.documentElement);\n      if (serialized) {\n        nodes.push(serialized);\n      }\n    }\n\n    return nodes;\n  }\n\n  /**\n   * Serialize a single DOM node\n   */\n  private serializeNode(node: Node): SerializedNode | null {\n    if (this.shouldIgnoreNode(node)) {\n      return null;\n    }\n\n    const nodeId = this.getNodeId(node);\n    const serialized: SerializedNode = {\n      type: this.getNodeType(node),\n      id: nodeId\n    };\n\n    switch (node.nodeType) {\n      case Node.ELEMENT_NODE:\n        const element = node as Element;\n        serialized.tagName = element.tagName.toLowerCase();\n        serialized.attributes = this.serializeAttributes(element);\n        serialized.children = this.serializeChildren(element);\n        break;\n\n      case Node.TEXT_NODE:\n        const textNode = node as Text;\n        serialized.textContent = this.shouldMaskText(textNode) ? '[Masked]' : textNode.textContent || '';\n        break;\n\n      case Node.COMMENT_NODE:\n        const commentNode = node as Comment;\n        serialized.textContent = commentNode.textContent || '';\n        break;\n\n      default:\n        return null;\n    }\n\n    return serialized;\n  }\n\n  /**\n   * Serialize element attributes\n   */\n  private serializeAttributes(element: Element): Record<string, string> {\n    const attributes: Record<string, string> = {};\n    \n    for (let i = 0; i < element.attributes.length; i++) {\n      const attr = element.attributes[i];\n      const name = attr.name.toLowerCase();\n      \n      // Skip sensitive attributes\n      if (this.shouldIgnoreAttribute(name, attr.value)) {\n        continue;\n      }\n\n      // Mask sensitive values\n      if (this.shouldMaskAttribute(name, element)) {\n        attributes[name] = '[Masked]';\n      } else {\n        attributes[name] = attr.value;\n      }\n    }\n\n    return attributes;\n  }\n\n  /**\n   * Serialize element children\n   */\n  private serializeChildren(element: Element): SerializedNode[] {\n    const children: SerializedNode[] = [];\n    \n    for (let i = 0; i < element.childNodes.length; i++) {\n      const child = element.childNodes[i];\n      const serializedChild = this.serializeNode(child);\n      \n      if (serializedChild) {\n        children.push(serializedChild);\n      }\n    }\n\n    return children;\n  }\n\n  /**\n   * Serialize all stylesheets\n   */\n  private serializeStylesheets(): SerializedStylesheet[] {\n    const stylesheets: SerializedStylesheet[] = [];\n\n    for (let i = 0; i < document.styleSheets.length; i++) {\n      const stylesheet = document.styleSheets[i];\n      \n      try {\n        let cssText = '';\n        \n        if (stylesheet.href) {\n          // External stylesheet - we'll capture the URL\n          // In production, you might want to fetch and inline the CSS\n          cssText = `/* External stylesheet: ${stylesheet.href} */`;\n        } else {\n          // Inline stylesheet - capture the rules\n          if (stylesheet.cssRules) {\n            const rules = Array.from(stylesheet.cssRules);\n            cssText = rules.map(rule => rule.cssText).join('\\n');\n          }\n        }\n\n        stylesheets.push({\n          href: stylesheet.href || undefined,\n          cssText,\n          disabled: stylesheet.disabled\n        });\n      } catch (error) {\n        // CORS issues or other access problems\n        if (stylesheet.href) {\n          stylesheets.push({\n            href: stylesheet.href,\n            cssText: `/* Could not access stylesheet: ${stylesheet.href} */`,\n            disabled: stylesheet.disabled\n          });\n        }\n      }\n    }\n\n    return stylesheets;\n  }\n\n  /**\n   * Serialize resources (images, fonts, etc.)\n   */\n  private serializeResources(): SerializedResource[] {\n    const resources: SerializedResource[] = [];\n\n    // Capture images\n    const images = document.querySelectorAll('img');\n    images.forEach(img => {\n      if (img.src && !this.shouldIgnoreResource(img.src)) {\n        resources.push({\n          url: img.src,\n          type: 'image',\n          failed: !img.complete || img.naturalWidth === 0\n        });\n      }\n    });\n\n    // Capture background images from computed styles\n    const elementsWithBackgrounds = document.querySelectorAll('*');\n    elementsWithBackgrounds.forEach(element => {\n      const style = window.getComputedStyle(element);\n      const backgroundImage = style.backgroundImage;\n      \n      if (backgroundImage && backgroundImage !== 'none') {\n        const urlMatch = backgroundImage.match(/url\\(['\"]?([^'\")]+)['\"]?\\)/);\n        if (urlMatch && urlMatch[1] && !this.shouldIgnoreResource(urlMatch[1])) {\n          resources.push({\n            url: urlMatch[1],\n            type: 'image'\n          });\n        }\n      }\n    });\n\n    return resources;\n  }\n\n  /**\n   * Handle mutation events\n   */\n  private handleMutations(mutations: MutationRecord[]): void {\n    mutations.forEach(mutation => {\n      const targetId = this.nodeIdMap.get(mutation.target);\n      if (!targetId) return;\n\n      const change: DOMChange = {\n        timestamp: Date.now(),\n        type: mutation.type,\n        target: targetId\n      };\n\n      switch (mutation.type) {\n        case 'childList':\n          if (mutation.addedNodes.length > 0) {\n            change.addedNodes = Array.from(mutation.addedNodes)\n              .map(node => this.serializeNode(node))\n              .filter((node): node is SerializedNode => node !== null);\n          }\n          \n          if (mutation.removedNodes.length > 0) {\n            change.removedNodes = Array.from(mutation.removedNodes)\n              .map(node => this.nodeIdMap.get(node))\n              .filter((id): id is number => id !== undefined);\n          }\n          break;\n\n        case 'attributes':\n          change.attributeName = mutation.attributeName || undefined;\n          if (mutation.target.nodeType === Node.ELEMENT_NODE) {\n            const element = mutation.target as Element;\n            const value = element.getAttribute(mutation.attributeName || '');\n            change.attributeValue = this.shouldMaskAttribute(\n              mutation.attributeName || '', element\n            ) ? '[Masked]' : value || '';\n          }\n          change.oldValue = mutation.oldValue || undefined;\n          break;\n\n        case 'characterData':\n          change.attributeValue = this.shouldMaskText(mutation.target as Text) \n            ? '[Masked]' \n            : mutation.target.textContent || '';\n          change.oldValue = mutation.oldValue || undefined;\n          break;\n      }\n\n      if (this.onDOMChange) {\n        this.onDOMChange(change);\n      }\n    });\n  }\n\n  /**\n   * Utility methods\n   */\n  private getNodeId(node: Node): number {\n    if (this.nodeIdMap.has(node)) {\n      return this.nodeIdMap.get(node)!;\n    }\n    \n    const id = this.nextNodeId++;\n    this.nodeIdMap.set(node, id);\n    this.nodeMap.set(id, node);\n    \n    return id;\n  }\n\n  private getNodeType(node: Node): SerializedNode['type'] {\n    switch (node.nodeType) {\n      case Node.ELEMENT_NODE:\n        return 'element';\n      case Node.TEXT_NODE:\n        return 'text';\n      case Node.COMMENT_NODE:\n        return 'comment';\n      case Node.DOCUMENT_NODE:\n        return 'document';\n      default:\n        return 'element';\n    }\n  }\n\n  private shouldIgnoreNode(node: Node): boolean {\n    if (node.nodeType === Node.ELEMENT_NODE) {\n      const element = node as Element;\n      const tagName = element.tagName.toLowerCase();\n      \n      // Ignore script tags and other sensitive elements\n      if (['script', 'noscript', 'meta'].includes(tagName)) {\n        return true;\n      }\n      \n      // Ignore elements with data-revi-ignore attribute\n      if (element.hasAttribute('data-revi-ignore')) {\n        return true;\n      }\n      \n      // Ignore elements that match block selector\n      if (this.config.replay?.blockSelector) {\n        try {\n          if (element.matches(this.config.replay.blockSelector)) {\n            return true;\n          }\n        } catch (e) {\n          // Invalid selector\n        }\n      }\n    }\n    \n    return false;\n  }\n\n  private shouldIgnoreAttribute(name: string, value: string): boolean {\n    // Ignore sensitive attributes\n    const sensitiveAttrs = ['data-revi-ignore', 'data-password', 'data-sensitive'];\n    return sensitiveAttrs.includes(name);\n  }\n\n  private shouldMaskAttribute(name: string, element: Element): boolean {\n    if (!this.config.privacy?.maskInputs) return false;\n    \n    // Mask values of sensitive input fields\n    if (element.tagName.toLowerCase() === 'input') {\n      const input = element as HTMLInputElement;\n      const sensitiveTypes = ['password', 'email', 'tel'];\n      if (sensitiveTypes.includes(input.type)) {\n        return name === 'value';\n      }\n    }\n    \n    return false;\n  }\n\n  private shouldMaskText(textNode: Text): boolean {\n    if (!this.config.replay?.maskAllText && !this.config.privacy?.maskInputs) {\n      return false;\n    }\n    \n    const parent = textNode.parentElement;\n    if (!parent) return false;\n    \n    // Mask text in sensitive elements\n    const sensitiveElements = ['input', 'textarea'];\n    if (sensitiveElements.includes(parent.tagName.toLowerCase())) {\n      return true;\n    }\n    \n    // Check for mask selector\n    if (this.config.replay?.maskSelector) {\n      try {\n        return parent.matches(this.config.replay.maskSelector);\n      } catch (e) {\n        return false;\n      }\n    }\n    \n    return this.config.replay?.maskAllText || false;\n  }\n\n  private shouldIgnoreResource(url: string): boolean {\n    try {\n      const urlObj = new URL(url, window.location.href);\n      \n      // Ignore data URLs (they're inline)\n      if (urlObj.protocol === 'data:') return true;\n      \n      // Ignore very large images\n      if (url.includes('?')) {\n        const params = new URLSearchParams(urlObj.search);\n        const width = params.get('w') || params.get('width');\n        const height = params.get('h') || params.get('height');\n        if (width && parseInt(width) > 2000) return true;\n        if (height && parseInt(height) > 2000) return true;\n      }\n      \n      return false;\n    } catch (e) {\n      return true; // Invalid URL\n    }\n  }\n}","import { SessionEvent } from './types';\n\nexport interface ConsoleLogEntry {\n  id: string;\n  timestamp: number;\n  level: 'log' | 'info' | 'warn' | 'error' | 'debug' | 'trace';\n  args: any[];\n  stack?: string;\n  url?: string;\n  lineNumber?: number;\n  columnNumber?: number;\n}\n\nexport interface ConsoleRecorderConfig {\n  maxEntries: number;\n  captureStackTrace: boolean;\n  serializeObjects: boolean;\n  maxObjectDepth: number;\n  maxStringLength: number;\n  ignoredLevels: string[];\n}\n\nexport class ConsoleRecorder {\n  private originalMethods: Record<string, Function> = {};\n  private entries: ConsoleLogEntry[] = [];\n  private config: ConsoleRecorderConfig;\n  private isRecording = false;\n  private sessionId: string;\n\n  constructor(sessionId: string, config: Partial<ConsoleRecorderConfig> = {}) {\n    this.sessionId = sessionId;\n    this.config = {\n      maxEntries: 1000,\n      captureStackTrace: true,\n      serializeObjects: true,\n      maxObjectDepth: 3,\n      maxStringLength: 10000,\n      ignoredLevels: [],\n      ...config\n    };\n  }\n\n  start(): void {\n    if (this.isRecording) return;\n\n    const levels: Array<keyof Console> = ['log', 'info', 'warn', 'error', 'debug', 'trace'];\n    \n    levels.forEach(level => {\n      if (this.config.ignoredLevels.includes(level)) return;\n      \n      const originalMethod = console[level];\n      this.originalMethods[level] = originalMethod;\n      \n      console[level] = (...args: any[]) => {\n        // Call original method first\n        originalMethod.apply(console, args);\n        \n        // Record the log entry\n        this.recordEntry(level as ConsoleLogEntry['level'], args);\n      };\n    });\n\n    this.isRecording = true;\n  }\n\n  stop(): void {\n    if (!this.isRecording) return;\n\n    // Restore original console methods\n    Object.entries(this.originalMethods).forEach(([level, method]) => {\n      (console as any)[level] = method;\n    });\n\n    this.originalMethods = {};\n    this.isRecording = false;\n  }\n\n  private recordEntry(level: ConsoleLogEntry['level'], args: any[]): void {\n    try {\n      const entry: ConsoleLogEntry = {\n        id: this.generateId(),\n        timestamp: Date.now(),\n        level,\n        args: this.serializeArgs(args)\n      };\n\n      // Capture stack trace for errors and warnings\n      if ((level === 'error' || level === 'warn') && this.config.captureStackTrace) {\n        const error = new Error();\n        if (error.stack) {\n          entry.stack = this.cleanStackTrace(error.stack);\n        }\n      }\n\n      // Add source location if available\n      if (level === 'error' && args[0] instanceof Error) {\n        const error = args[0] as Error;\n        // Try to extract location from error stack\n        const stackLines = error.stack?.split('\\n') || [];\n        const sourceLine = stackLines.find(line => \n          line.includes('.js:') || line.includes('.ts:') || line.includes('.tsx:')\n        );\n        \n        if (sourceLine) {\n          const match = sourceLine.match(/([^/]+):(\\d+):(\\d+)/);\n          if (match) {\n            entry.url = match[1];\n            entry.lineNumber = parseInt(match[2]);\n            entry.columnNumber = parseInt(match[3]);\n          }\n        }\n      }\n\n      this.addEntry(entry);\n    } catch (error) {\n      // Fail silently to avoid infinite loops\n      this.originalMethods.warn?.call(console, 'ConsoleRecorder error:', error);\n    }\n  }\n\n  private serializeArgs(args: any[]): any[] {\n    return args.map(arg => this.serializeValue(arg, 0));\n  }\n\n  private serializeValue(value: any, depth: number): any {\n    if (depth > this.config.maxObjectDepth) {\n      return '[Object too deep]';\n    }\n\n    if (value === null || value === undefined) {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      return value.length > this.config.maxStringLength \n        ? value.substring(0, this.config.maxStringLength) + '...'\n        : value;\n    }\n\n    if (typeof value === 'number' || typeof value === 'boolean') {\n      return value;\n    }\n\n    if (typeof value === 'function') {\n      return `[Function: ${value.name || 'anonymous'}]`;\n    }\n\n    if (value instanceof Error) {\n      return {\n        name: value.name,\n        message: value.message,\n        stack: this.config.captureStackTrace ? this.cleanStackTrace(value.stack || '') : undefined\n      };\n    }\n\n    if (value instanceof Date) {\n      return {\n        __type: 'Date',\n        value: value.toISOString()\n      };\n    }\n\n    if (value instanceof RegExp) {\n      return {\n        __type: 'RegExp',\n        value: value.toString()\n      };\n    }\n\n    if (Array.isArray(value)) {\n      if (!this.config.serializeObjects) return '[Array]';\n      \n      return value.slice(0, 100).map(item => this.serializeValue(item, depth + 1));\n    }\n\n    if (typeof value === 'object') {\n      if (!this.config.serializeObjects) return '[Object]';\n      \n      try {\n        const serialized: Record<string, any> = {};\n        const keys = Object.keys(value).slice(0, 50); // Limit keys\n        \n        for (const key of keys) {\n          try {\n            serialized[key] = this.serializeValue(value[key], depth + 1);\n          } catch {\n            serialized[key] = '[Unserializable]';\n          }\n        }\n        \n        if (Object.keys(value).length > 50) {\n          serialized['...'] = `[${Object.keys(value).length - 50} more keys]`;\n        }\n        \n        return serialized;\n      } catch {\n        return '[Unserializable Object]';\n      }\n    }\n\n    return String(value);\n  }\n\n  private cleanStackTrace(stack: string): string {\n    return stack\n      .split('\\n')\n      .filter(line => \n        !line.includes('console-recorder.ts') && \n        !line.includes('ConsoleRecorder')\n      )\n      .slice(0, 10) // Limit stack depth\n      .join('\\n');\n  }\n\n  private addEntry(entry: ConsoleLogEntry): void {\n    this.entries.push(entry);\n    \n    // Maintain max entries limit\n    if (this.entries.length > this.config.maxEntries) {\n      this.entries = this.entries.slice(-this.config.maxEntries * 0.8);\n    }\n  }\n\n  private generateId(): string {\n    return `console-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  getEntries(fromTimestamp?: number, toTimestamp?: number): ConsoleLogEntry[] {\n    let filtered = this.entries;\n    \n    if (fromTimestamp) {\n      filtered = filtered.filter(entry => entry.timestamp >= fromTimestamp);\n    }\n    \n    if (toTimestamp) {\n      filtered = filtered.filter(entry => entry.timestamp <= toTimestamp);\n    }\n    \n    return [...filtered];\n  }\n\n  getEntriesByLevel(level: ConsoleLogEntry['level']): ConsoleLogEntry[] {\n    return this.entries.filter(entry => entry.level === level);\n  }\n\n  clear(): void {\n    this.entries = [];\n  }\n\n  // Convert console entries to session events format\n  toSessionEvents(): SessionEvent[] {\n    return this.entries.map(entry => ({\n      session_id: this.sessionId,\n      event_type: 'console',\n      data: {\n        level: entry.level,\n        args: entry.args,\n        stack: entry.stack,\n        url: entry.url,\n        lineNumber: entry.lineNumber,\n        columnNumber: entry.columnNumber,\n        consoleId: entry.id\n      },\n      timestamp: entry.timestamp,\n      url: entry.url || window.location.href,\n      user_agent: navigator.userAgent\n    }));\n  }\n\n  // Export for analysis\n  exportData(): {\n    sessionId: string;\n    config: ConsoleRecorderConfig;\n    entries: ConsoleLogEntry[];\n    stats: {\n      totalEntries: number;\n      levelCounts: Record<string, number>;\n      errorCount: number;\n      warningCount: number;\n      timeRange: { start: number; end: number };\n    };\n  } {\n    const levelCounts: Record<string, number> = {};\n    let minTime = Infinity;\n    let maxTime = -Infinity;\n\n    this.entries.forEach(entry => {\n      levelCounts[entry.level] = (levelCounts[entry.level] || 0) + 1;\n      minTime = Math.min(minTime, entry.timestamp);\n      maxTime = Math.max(maxTime, entry.timestamp);\n    });\n\n    return {\n      sessionId: this.sessionId,\n      config: this.config,\n      entries: [...this.entries],\n      stats: {\n        totalEntries: this.entries.length,\n        levelCounts,\n        errorCount: levelCounts.error || 0,\n        warningCount: levelCounts.warn || 0,\n        timeRange: {\n          start: minTime === Infinity ? 0 : minTime,\n          end: maxTime === -Infinity ? 0 : maxTime\n        }\n      }\n    };\n  }\n\n  // Generate insights from console logs\n  generateInsights(): {\n    errorPatterns: Array<{ pattern: string; count: number; examples: ConsoleLogEntry[] }>;\n    performanceIssues: Array<{ type: string; severity: 'low' | 'medium' | 'high'; details: string }>;\n    recommendations: string[];\n  } {\n    const errorPatterns = this.findErrorPatterns();\n    const performanceIssues = this.detectPerformanceIssues();\n    const recommendations = this.generateRecommendations();\n\n    return {\n      errorPatterns,\n      performanceIssues,\n      recommendations\n    };\n  }\n\n  private findErrorPatterns(): Array<{ pattern: string; count: number; examples: ConsoleLogEntry[] }> {\n    const errors = this.entries.filter(entry => entry.level === 'error');\n    const patterns: Record<string, ConsoleLogEntry[]> = {};\n\n    errors.forEach(error => {\n      let pattern = 'Unknown Error';\n      \n      if (error.args.length > 0) {\n        const firstArg = error.args[0];\n        if (typeof firstArg === 'string') {\n          // Extract error pattern from message\n          pattern = firstArg\n            .replace(/\\d+/g, 'N') // Replace numbers with N\n            .replace(/[\"'][^\"']*[\"']/g, 'STRING') // Replace strings with STRING\n            .replace(/\\b\\w+@\\w+\\.\\w+/g, 'EMAIL') // Replace emails\n            .replace(/https?:\\/\\/[^\\s]+/g, 'URL') // Replace URLs\n            .substring(0, 100);\n        } else if (typeof firstArg === 'object' && firstArg.name) {\n          pattern = `${firstArg.name}: ${firstArg.message}`.substring(0, 100);\n        }\n      }\n\n      if (!patterns[pattern]) {\n        patterns[pattern] = [];\n      }\n      patterns[pattern].push(error);\n    });\n\n    return Object.entries(patterns)\n      .sort(([, a], [, b]) => b.length - a.length)\n      .slice(0, 10)\n      .map(([pattern, examples]) => ({\n        pattern,\n        count: examples.length,\n        examples: examples.slice(0, 3) // Show first 3 examples\n      }));\n  }\n\n  private detectPerformanceIssues(): Array<{ type: string; severity: 'low' | 'medium' | 'high'; details: string }> {\n    const issues: Array<{ type: string; severity: 'low' | 'medium' | 'high'; details: string }> = [];\n    \n    // Check for excessive logging\n    const recentEntries = this.entries.filter(entry => \n      entry.timestamp > Date.now() - 60000 // Last minute\n    );\n    \n    if (recentEntries.length > 100) {\n      issues.push({\n        type: 'Excessive Logging',\n        severity: 'medium',\n        details: `${recentEntries.length} console entries in the last minute may impact performance`\n      });\n    }\n\n    // Check for repeated errors\n    const errorCounts: Record<string, number> = {};\n    this.entries\n      .filter(entry => entry.level === 'error')\n      .forEach(entry => {\n        const key = JSON.stringify(entry.args);\n        errorCounts[key] = (errorCounts[key] || 0) + 1;\n      });\n\n    Object.entries(errorCounts).forEach(([error, count]) => {\n      if (count > 10) {\n        issues.push({\n          type: 'Repeated Error',\n          severity: count > 50 ? 'high' : 'medium',\n          details: `Same error occurred ${count} times`\n        });\n      }\n    });\n\n    // Check for potential memory leaks (objects not being cleaned up)\n    const objectLogs = this.entries.filter(entry => \n      entry.args.some(arg => \n        typeof arg === 'object' && \n        arg !== null && \n        !Array.isArray(arg)\n      )\n    );\n    \n    if (objectLogs.length > this.entries.length * 0.5) {\n      issues.push({\n        type: 'Object Logging',\n        severity: 'low',\n        details: 'High percentage of object logging may indicate memory leaks'\n      });\n    }\n\n    return issues;\n  }\n\n  private generateRecommendations(): string[] {\n    const recommendations: string[] = [];\n    const stats = this.exportData().stats;\n\n    if (stats.errorCount > 0) {\n      recommendations.push(\n        `Found ${stats.errorCount} console errors. Review error patterns and fix underlying issues.`\n      );\n    }\n\n    if (stats.warningCount > stats.errorCount * 2) {\n      recommendations.push(\n        'High warning-to-error ratio suggests proactive error handling could prevent issues.'\n      );\n    }\n\n    if (stats.totalEntries > 500) {\n      recommendations.push(\n        'Consider reducing console logging in production to improve performance.'\n      );\n    }\n\n    if (stats.levelCounts.debug && stats.levelCounts.debug > 100) {\n      recommendations.push(\n        'Debug logs should be disabled in production environments.'\n      );\n    }\n\n    if (recommendations.length === 0) {\n      recommendations.push('Console logging patterns look healthy.');\n    }\n\n    return recommendations;\n  }\n}","import { SessionEvent } from './types';\n\nexport interface HeatmapData {\n  x: number;\n  y: number;\n  intensity: number;\n  event_type: 'click' | 'move' | 'scroll' | 'hover';\n  timestamp: number;\n}\n\nexport interface HeatmapConfig {\n  radius: number;\n  maxIntensity: number;\n  gradient: Record<string, string>;\n  blur: number;\n  minOpacity: number;\n  maxOpacity: number;\n}\n\nexport class HeatmapGenerator {\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n  private config: HeatmapConfig;\n  private data: HeatmapData[] = [];\n\n  constructor(container: HTMLElement, config: Partial<HeatmapConfig> = {}) {\n    this.config = {\n      radius: 20,\n      maxIntensity: 100,\n      gradient: {\n        0.4: 'blue',\n        0.6: 'cyan',\n        0.7: 'lime',\n        0.8: 'yellow',\n        1.0: 'red'\n      },\n      blur: 15,\n      minOpacity: 0,\n      maxOpacity: 0.6,\n      ...config\n    };\n\n    this.canvas = document.createElement('canvas');\n    this.canvas.style.position = 'absolute';\n    this.canvas.style.top = '0';\n    this.canvas.style.left = '0';\n    this.canvas.style.pointerEvents = 'none';\n    this.canvas.style.zIndex = '9999';\n    \n    container.appendChild(this.canvas);\n    \n    const ctx = this.canvas.getContext('2d');\n    if (!ctx) {\n      throw new Error('Failed to get canvas context');\n    }\n    this.ctx = ctx;\n\n    this.resizeCanvas();\n    window.addEventListener('resize', () => this.resizeCanvas());\n  }\n\n  private resizeCanvas(): void {\n    const rect = this.canvas.parentElement!.getBoundingClientRect();\n    this.canvas.width = rect.width;\n    this.canvas.height = rect.height;\n    this.canvas.style.width = rect.width + 'px';\n    this.canvas.style.height = rect.height + 'px';\n  }\n\n  addDataPoint(x: number, y: number, intensity: number, eventType: HeatmapData['event_type']): void {\n    this.data.push({\n      x,\n      y,\n      intensity,\n      event_type: eventType,\n      timestamp: Date.now()\n    });\n    \n    // Limit data points to prevent memory issues\n    if (this.data.length > 10000) {\n      this.data = this.data.slice(-8000);\n    }\n  }\n\n  generateFromEvents(events: SessionEvent[]): void {\n    this.data = [];\n    \n    events.forEach(event => {\n      if (event.event_type === 'click' && event.data?.x && event.data?.y) {\n        this.addDataPoint(\n          event.data.x,\n          event.data.y,\n          10,\n          'click'\n        );\n      } else if (event.event_type === 'mousemove' && event.data?.x && event.data?.y) {\n        this.addDataPoint(\n          event.data.x,\n          event.data.y,\n          2,\n          'move'\n        );\n      } else if (event.event_type === 'scroll' && event.data?.scrollX !== undefined && event.data?.scrollY !== undefined) {\n        // Convert scroll position to viewport coordinates\n        this.addDataPoint(\n          event.data.scrollX || 0,\n          event.data.scrollY || 0,\n          5,\n          'scroll'\n        );\n      }\n    });\n  }\n\n  render(filter?: HeatmapData['event_type'][]): void {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    \n    if (this.data.length === 0) return;\n\n    const filteredData = filter \n      ? this.data.filter(d => filter.includes(d.event_type))\n      : this.data;\n\n    // Create intensity map\n    const intensityData = this.createIntensityMap(filteredData);\n    \n    // Create gradient\n    const gradient = this.createGradient();\n    \n    // Render heatmap\n    this.renderHeatmap(intensityData, gradient);\n  }\n\n  private createIntensityMap(data: HeatmapData[]): ImageData {\n    const shadowCanvas = document.createElement('canvas');\n    shadowCanvas.width = this.canvas.width;\n    shadowCanvas.height = this.canvas.height;\n    const shadowCtx = shadowCanvas.getContext('2d')!;\n\n    // Draw intensity points\n    data.forEach(point => {\n      const radius = this.config.radius;\n      const gradient = shadowCtx.createRadialGradient(\n        point.x, point.y, 0,\n        point.x, point.y, radius\n      );\n\n      const alpha = Math.min(point.intensity / this.config.maxIntensity, 1);\n      gradient.addColorStop(0, `rgba(0, 0, 0, ${alpha})`);\n      gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\n\n      shadowCtx.fillStyle = gradient;\n      shadowCtx.fillRect(\n        point.x - radius,\n        point.y - radius,\n        radius * 2,\n        radius * 2\n      );\n    });\n\n    // Apply blur\n    shadowCtx.filter = `blur(${this.config.blur}px)`;\n    shadowCtx.drawImage(shadowCanvas, 0, 0);\n\n    return shadowCtx.getImageData(0, 0, shadowCanvas.width, shadowCanvas.height);\n  }\n\n  private createGradient(): ImageData {\n    const gradientCanvas = document.createElement('canvas');\n    gradientCanvas.width = 256;\n    gradientCanvas.height = 1;\n    const gradientCtx = gradientCanvas.getContext('2d')!;\n\n    const gradient = gradientCtx.createLinearGradient(0, 0, 256, 0);\n    Object.entries(this.config.gradient).forEach(([stop, color]) => {\n      gradient.addColorStop(parseFloat(stop), color);\n    });\n\n    gradientCtx.fillStyle = gradient;\n    gradientCtx.fillRect(0, 0, 256, 1);\n\n    return gradientCtx.getImageData(0, 0, 256, 1);\n  }\n\n  private renderHeatmap(intensityData: ImageData, gradientData: ImageData): void {\n    const output = this.ctx.createImageData(intensityData.width, intensityData.height);\n    \n    for (let i = 0; i < intensityData.data.length; i += 4) {\n      const alpha = intensityData.data[i + 3];\n      \n      if (alpha > 0) {\n        const gradientIndex = Math.floor((alpha / 255) * 255) * 4;\n        \n        output.data[i] = gradientData.data[gradientIndex];     // R\n        output.data[i + 1] = gradientData.data[gradientIndex + 1]; // G\n        output.data[i + 2] = gradientData.data[gradientIndex + 2]; // B\n        output.data[i + 3] = Math.floor(alpha * this.config.maxOpacity); // A\n      }\n    }\n\n    this.ctx.putImageData(output, 0, 0);\n  }\n\n  clear(): void {\n    this.data = [];\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n\n  destroy(): void {\n    this.clear();\n    if (this.canvas.parentElement) {\n      this.canvas.parentElement.removeChild(this.canvas);\n    }\n    window.removeEventListener('resize', () => this.resizeCanvas());\n  }\n\n  // Export heatmap data for analysis\n  exportData(): {\n    config: HeatmapConfig;\n    data: HeatmapData[];\n    stats: {\n      totalEvents: number;\n      eventTypes: Record<string, number>;\n      timeRange: { start: number; end: number };\n      bounds: { minX: number; maxX: number; minY: number; maxY: number };\n    };\n  } {\n    const eventTypes: Record<string, number> = {};\n    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;\n    let minTime = Infinity, maxTime = -Infinity;\n\n    this.data.forEach(point => {\n      eventTypes[point.event_type] = (eventTypes[point.event_type] || 0) + 1;\n      \n      minX = Math.min(minX, point.x);\n      maxX = Math.max(maxX, point.x);\n      minY = Math.min(minY, point.y);\n      maxY = Math.max(maxY, point.y);\n      \n      minTime = Math.min(minTime, point.timestamp);\n      maxTime = Math.max(maxTime, point.timestamp);\n    });\n\n    return {\n      config: this.config,\n      data: [...this.data],\n      stats: {\n        totalEvents: this.data.length,\n        eventTypes,\n        timeRange: { start: minTime, end: maxTime },\n        bounds: { minX, maxX, minY, maxY }\n      }\n    };\n  }\n\n  // Generate insights from heatmap data\n  generateInsights(): {\n    hotSpots: Array<{ x: number; y: number; intensity: number; radius: number }>;\n    clickPatterns: Array<{ pattern: string; frequency: number }>;\n    userBehavior: {\n      mostActiveArea: { x: number; y: number; width: number; height: number };\n      averageClicksPerSession: number;\n      scrollDepth: number;\n      engagementScore: number;\n    };\n  } {\n    // Find hot spots using clustering\n    const hotSpots = this.findHotSpots();\n    \n    // Analyze click patterns\n    const clickPatterns = this.analyzeClickPatterns();\n    \n    // Generate user behavior insights\n    const userBehavior = this.analyzeUserBehavior();\n\n    return {\n      hotSpots,\n      clickPatterns,\n      userBehavior\n    };\n  }\n\n  private findHotSpots(): Array<{ x: number; y: number; intensity: number; radius: number }> {\n    const clusters: Array<{ x: number; y: number; intensity: number; count: number }> = [];\n    const clusterRadius = this.config.radius * 2;\n\n    this.data.forEach(point => {\n      let foundCluster = false;\n      \n      for (const cluster of clusters) {\n        const distance = Math.sqrt(\n          Math.pow(point.x - cluster.x, 2) + Math.pow(point.y - cluster.y, 2)\n        );\n        \n        if (distance <= clusterRadius) {\n          // Add to existing cluster\n          cluster.x = (cluster.x * cluster.count + point.x) / (cluster.count + 1);\n          cluster.y = (cluster.y * cluster.count + point.y) / (cluster.count + 1);\n          cluster.intensity += point.intensity;\n          cluster.count++;\n          foundCluster = true;\n          break;\n        }\n      }\n      \n      if (!foundCluster) {\n        clusters.push({\n          x: point.x,\n          y: point.y,\n          intensity: point.intensity,\n          count: 1\n        });\n      }\n    });\n\n    return clusters\n      .filter(cluster => cluster.count >= 3) // Only significant clusters\n      .sort((a, b) => b.intensity - a.intensity)\n      .slice(0, 10) // Top 10 hot spots\n      .map(cluster => ({\n        x: Math.round(cluster.x),\n        y: Math.round(cluster.y),\n        intensity: Math.round(cluster.intensity),\n        radius: Math.min(clusterRadius, cluster.count * 5)\n      }));\n  }\n\n  private analyzeClickPatterns(): Array<{ pattern: string; frequency: number }> {\n    const clicks = this.data.filter(d => d.event_type === 'click');\n    const patterns: Record<string, number> = {};\n\n    // Analyze sequential click patterns\n    for (let i = 0; i < clicks.length - 1; i++) {\n      const current = clicks[i];\n      const next = clicks[i + 1];\n      \n      const timeDiff = next.timestamp - current.timestamp;\n      if (timeDiff < 5000) { // Within 5 seconds\n        const pattern = `(${Math.round(current.x)},${Math.round(current.y)}) -> (${Math.round(next.x)},${Math.round(next.y)})`;\n        patterns[pattern] = (patterns[pattern] || 0) + 1;\n      }\n    }\n\n    return Object.entries(patterns)\n      .sort(([, a], [, b]) => b - a)\n      .slice(0, 5)\n      .map(([pattern, frequency]) => ({ pattern, frequency }));\n  }\n\n  private analyzeUserBehavior(): {\n    mostActiveArea: { x: number; y: number; width: number; height: number };\n    averageClicksPerSession: number;\n    scrollDepth: number;\n    engagementScore: number;\n  } {\n    const clicks = this.data.filter(d => d.event_type === 'click');\n    const scrolls = this.data.filter(d => d.event_type === 'scroll');\n\n    // Find most active area (bounding box of top 50% of events)\n    const sortedByIntensity = [...this.data].sort((a, b) => b.intensity - a.intensity);\n    const topHalf = sortedByIntensity.slice(0, Math.floor(sortedByIntensity.length * 0.5));\n    \n    const minX = Math.min(...topHalf.map(d => d.x));\n    const maxX = Math.max(...topHalf.map(d => d.x));\n    const minY = Math.min(...topHalf.map(d => d.y));\n    const maxY = Math.max(...topHalf.map(d => d.y));\n\n    const scrollDepth = scrolls.length > 0 \n      ? Math.max(...scrolls.map(s => s.y)) / this.canvas.height \n      : 0;\n\n    const engagementScore = Math.min(100, \n      (clicks.length * 2) + \n      (scrollDepth * 50) + \n      (this.data.filter(d => d.event_type === 'move').length * 0.1)\n    );\n\n    return {\n      mostActiveArea: {\n        x: Math.round(minX),\n        y: Math.round(minY),\n        width: Math.round(maxX - minX),\n        height: Math.round(maxY - minY)\n      },\n      averageClicksPerSession: Math.round(clicks.length),\n      scrollDepth: Math.round(scrollDepth * 100) / 100,\n      engagementScore: Math.round(engagementScore)\n    };\n  }\n}","import type { ReviConfig } from './types';\nimport { DOMSerializer, DOMSnapshot, DOMChange } from './dom-serializer';\nimport { ConsoleRecorder, ConsoleLogEntry } from './console-recorder';\nimport { HeatmapGenerator, HeatmapData } from './heatmap-generator';\n\nexport interface ReplayEvent {\n  type: 'full_snapshot' | 'incremental_snapshot' | 'meta' | 'custom';\n  timestamp: number;\n  data: any;\n}\n\nexport interface ConsoleLog {\n  timestamp: number;\n  level: 'log' | 'info' | 'warn' | 'error' | 'debug';\n  args: any[];\n  stack?: string;\n}\n\nexport interface NetworkRequest {\n  timestamp: number;\n  id: string;\n  method: string;\n  url: string;\n  status?: number;\n  duration?: number;\n  requestHeaders?: Record<string, string>;\n  responseHeaders?: Record<string, string>;\n  requestBody?: any;\n  responseBody?: any;\n  failed?: boolean;\n}\n\n/**\n * Advanced session replay system with console logs and network requests\n */\nexport class SessionReplayManager {\n  private config: ReviConfig;\n  private domSerializer: DOMSerializer;\n  private consoleRecorder: ConsoleRecorder;\n  private heatmapGenerator: HeatmapGenerator | null = null;\n  private events: ReplayEvent[] = [];\n  private consoleLogs: ConsoleLog[] = [];\n  private networkRequests: Map<string, NetworkRequest> = new Map();\n  private isRecording = false;\n  private sessionId: string;\n  private startTime: number;\n  private originalConsole: any = {};\n  private originalFetch: any;\n  private originalXMLHttpRequest: any;\n\n  constructor(config: ReviConfig, sessionId: string) {\n    this.config = config;\n    this.sessionId = sessionId;\n    this.startTime = Date.now();\n    this.domSerializer = new DOMSerializer(config);\n    this.consoleRecorder = new ConsoleRecorder(sessionId, {\n      maxEntries: config.replay?.maxConsoleEntries || 1000,\n      captureStackTrace: config.replay?.captureStackTrace !== false,\n      serializeObjects: config.replay?.serializeObjects !== false,\n      maxObjectDepth: config.replay?.maxObjectDepth || 3,\n      maxStringLength: config.replay?.maxStringLength || 10000,\n      ignoredLevels: config.replay?.ignoredConsoleLevels || []\n    });\n    \n    if (this.config.replay?.enabled) {\n      this.setupReplay();\n      \n      // Initialize heatmap generator if enabled\n      if (this.config.replay?.heatmaps?.enabled && typeof document !== 'undefined') {\n        const container = document.body || document.documentElement;\n        if (container) {\n          this.heatmapGenerator = new HeatmapGenerator(container, {\n            radius: config.replay?.heatmaps?.radius || 20,\n            maxIntensity: config.replay?.heatmaps?.maxIntensity || 100,\n            blur: config.replay?.heatmaps?.blur || 15,\n            maxOpacity: config.replay?.heatmaps?.maxOpacity || 0.6\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Start recording session replay\n   */\n  startRecording(): void {\n    if (this.isRecording || !this.config.replay?.enabled) return;\n\n    this.isRecording = true;\n    \n    // Take initial snapshot\n    this.takeFullSnapshot();\n    \n    // Start observing DOM changes\n    this.domSerializer.startObserving(this.handleDOMChange.bind(this));\n    \n    // Start console recording\n    this.consoleRecorder.start();\n    \n    // Setup network monitoring\n    this.setupNetworkCapture();\n    \n    // Setup mouse and keyboard tracking\n    this.setupInteractionTracking();\n    \n    // Periodic full snapshots\n    setInterval(() => {\n      if (this.isRecording) {\n        this.takeFullSnapshot();\n      }\n    }, 60000); // Every minute\n    \n    if (this.config.debug) {\n      console.log('Revi: Session replay started');\n    }\n  }\n\n  /**\n   * Stop recording session replay\n   */\n  stopRecording(): void {\n    if (!this.isRecording) return;\n\n    this.isRecording = false;\n    this.domSerializer.stopObserving();\n    this.consoleRecorder.stop();\n    this.restoreOriginalNetwork();\n    \n    if (this.heatmapGenerator) {\n      this.heatmapGenerator.destroy();\n      this.heatmapGenerator = null;\n    }\n    \n    if (this.config.debug) {\n      console.log('Revi: Session replay stopped');\n    }\n  }\n\n  /**\n   * Get all replay events\n   */\n  getReplayData(): {\n    events: ReplayEvent[];\n    console_logs: ConsoleLogEntry[];\n    network_requests: NetworkRequest[];\n    heatmap_data?: HeatmapData[];\n    session_info: {\n      session_id: string;\n      start_time: number;\n      duration: number;\n      page_url: string;\n    };\n    analytics: {\n      console_insights: any;\n      heatmap_insights?: any;\n    };\n  } {\n    const consoleEntries = this.consoleRecorder.getEntries();\n    const consoleInsights = this.consoleRecorder.generateInsights();\n    \n    let heatmapData: HeatmapData[] | undefined;\n    let heatmapInsights: any;\n    \n    if (this.heatmapGenerator) {\n      const heatmapExport = this.heatmapGenerator.exportData();\n      heatmapData = heatmapExport.data;\n      heatmapInsights = this.heatmapGenerator.generateInsights();\n    }\n\n    return {\n      events: [...this.events],\n      console_logs: consoleEntries,\n      network_requests: Array.from(this.networkRequests.values()),\n      heatmap_data: heatmapData,\n      session_info: {\n        session_id: this.sessionId,\n        start_time: this.startTime,\n        duration: Date.now() - this.startTime,\n        page_url: window.location.href\n      },\n      analytics: {\n        console_insights: consoleInsights,\n        heatmap_insights: heatmapInsights\n      }\n    };\n  }\n\n  /**\n   * Clear replay data\n   */\n  clearReplayData(): void {\n    this.events = [];\n    this.consoleLogs = [];\n    this.networkRequests.clear();\n    this.consoleRecorder.clear();\n    \n    if (this.heatmapGenerator) {\n      this.heatmapGenerator.clear();\n    }\n  }\n\n  /**\n   * Setup basic replay tracking\n   */\n  private setupReplay(): void {\n    if (typeof window === 'undefined') return;\n\n    // Track page visibility changes\n    document.addEventListener('visibilitychange', () => {\n      this.addCustomEvent('visibility_change', {\n        hidden: document.hidden\n      });\n    });\n\n    // Track window focus/blur\n    window.addEventListener('focus', () => {\n      this.addCustomEvent('window_focus', {});\n    });\n\n    window.addEventListener('blur', () => {\n      this.addCustomEvent('window_blur', {});\n    });\n\n    // Track viewport changes\n    window.addEventListener('resize', () => {\n      this.addCustomEvent('viewport_change', {\n        width: window.innerWidth,\n        height: window.innerHeight\n      });\n    });\n\n    // Track scroll events (throttled)\n    let scrollTimeout: NodeJS.Timeout;\n    window.addEventListener('scroll', () => {\n      clearTimeout(scrollTimeout);\n      scrollTimeout = setTimeout(() => {\n        // Add to heatmap data\n        if (this.heatmapGenerator) {\n          this.heatmapGenerator.addDataPoint(\n            window.scrollX || 0,\n            window.scrollY || 0,\n            5,\n            'scroll'\n          );\n        }\n        \n        this.addCustomEvent('scroll', {\n          x: window.scrollX,\n          y: window.scrollY\n        });\n      }, 100);\n    }, { passive: true });\n  }\n\n  /**\n   * Take a full DOM snapshot\n   */\n  private takeFullSnapshot(): void {\n    if (!this.isRecording) return;\n\n    try {\n      const snapshot = this.domSerializer.takeSnapshot();\n      \n      this.addEvent({\n        type: 'full_snapshot',\n        timestamp: Date.now(),\n        data: snapshot\n      });\n    } catch (error) {\n      if (this.config.debug) {\n        console.error('Revi: Failed to take DOM snapshot', error);\n      }\n    }\n  }\n\n  /**\n   * Handle DOM changes\n   */\n  private handleDOMChange(change: DOMChange): void {\n    if (!this.isRecording) return;\n\n    this.addEvent({\n      type: 'incremental_snapshot',\n      timestamp: change.timestamp,\n      data: {\n        source: 'mutation',\n        ...change\n      }\n    });\n  }\n\n  /**\n   * Add heatmap methods\n   */\n  renderHeatmap(filter?: ('click' | 'move' | 'scroll')[]): void {\n    if (this.heatmapGenerator) {\n      this.heatmapGenerator.render(filter);\n    }\n  }\n\n  toggleHeatmap(visible: boolean): void {\n    if (this.heatmapGenerator) {\n      if (visible) {\n        this.heatmapGenerator.render();\n      } else {\n        this.heatmapGenerator.clear();\n      }\n    }\n  }\n\n  getHeatmapInsights(): any {\n    return this.heatmapGenerator?.generateInsights() || null;\n  }\n\n  /**\n   * Setup network request capture\n   */\n  private setupNetworkCapture(): void {\n    // Capture fetch requests\n    if (typeof window.fetch !== 'undefined') {\n      this.originalFetch = window.fetch;\n      \n      window.fetch = async (input: RequestInfo | URL, init?: RequestInit): Promise<Response> => {\n        const startTime = Date.now();\n        const requestId = this.generateRequestId();\n        const url = input instanceof Request ? input.url : input.toString();\n        const method = init?.method || (input instanceof Request ? input.method : 'GET');\n        \n        if (this.isRecording) {\n          this.networkRequests.set(requestId, {\n            timestamp: startTime,\n            id: requestId,\n            method,\n            url,\n            requestHeaders: this.getRequestHeaders(init, input),\n            requestBody: await this.serializeRequestBody(init, input)\n          });\n        }\n        \n        try {\n          const response = await this.originalFetch(input, init);\n          const duration = Date.now() - startTime;\n          \n          if (this.isRecording) {\n            const networkRequest = this.networkRequests.get(requestId);\n            if (networkRequest) {\n              networkRequest.status = response.status;\n              networkRequest.duration = duration;\n              networkRequest.responseHeaders = this.getResponseHeaders(response);\n              \n              // Optionally capture response body (be careful with large responses)\n              if (this.shouldCaptureResponseBody(response)) {\n                try {\n                  const clonedResponse = response.clone();\n                  networkRequest.responseBody = await clonedResponse.text();\n                } catch (e) {\n                  // Response body couldn't be captured\n                }\n              }\n            }\n          }\n          \n          return response;\n        } catch (error) {\n          const duration = Date.now() - startTime;\n          \n          if (this.isRecording) {\n            const networkRequest = this.networkRequests.get(requestId);\n            if (networkRequest) {\n              networkRequest.duration = duration;\n              networkRequest.failed = true;\n            }\n          }\n          \n          throw error;\n        }\n      };\n    }\n\n    // Capture XMLHttpRequest\n    if (typeof XMLHttpRequest !== 'undefined') {\n      this.originalXMLHttpRequest = XMLHttpRequest;\n      \n      const self = this;\n      \n      window.XMLHttpRequest = function() {\n        const xhr = new self.originalXMLHttpRequest();\n        const requestId = self.generateRequestId();\n        let method = 'GET';\n        let url = '';\n        let startTime = 0;\n        \n        const originalOpen = xhr.open;\n        const originalSend = xhr.send;\n        \n        xhr.open = function(m: string, u: string | URL, ...args: any[]) {\n          method = m;\n          url = u.toString();\n          return originalOpen.call(this, m, u, ...args);\n        };\n        \n        xhr.send = function(body?: any) {\n          startTime = Date.now();\n          \n          if (self.isRecording) {\n            self.networkRequests.set(requestId, {\n              timestamp: startTime,\n              id: requestId,\n              method,\n              url,\n              requestBody: body\n            });\n          }\n          \n          return originalSend.call(this, body);\n        };\n        \n        xhr.addEventListener('loadend', () => {\n          const duration = Date.now() - startTime;\n          \n          if (self.isRecording) {\n            const networkRequest = self.networkRequests.get(requestId);\n            if (networkRequest) {\n              networkRequest.status = xhr.status;\n              networkRequest.duration = duration;\n              networkRequest.failed = xhr.status === 0 || xhr.status >= 400;\n              \n              if (self.shouldCaptureXHRResponse(xhr)) {\n                networkRequest.responseBody = xhr.responseText;\n              }\n            }\n          }\n        });\n        \n        return xhr;\n      };\n    }\n  }\n\n  /**\n   * Setup mouse and keyboard interaction tracking\n   */\n  private setupInteractionTracking(): void {\n    // Mouse events\n    const mouseEvents = ['mousedown', 'mouseup', 'click', 'dblclick', 'mousemove'];\n    \n    mouseEvents.forEach(eventType => {\n      document.addEventListener(eventType, (event: MouseEvent) => {\n        if (!this.isRecording) return;\n        \n        // Throttle mousemove events\n        if (eventType === 'mousemove' && Math.random() > 0.1) return;\n        \n        // Add to heatmap data\n        if (this.heatmapGenerator) {\n          let intensity = 1;\n          if (eventType === 'click') intensity = 10;\n          else if (eventType === 'mousemove') intensity = 2;\n          else if (eventType === 'mousedown') intensity = 5;\n          \n          this.heatmapGenerator.addDataPoint(\n            event.clientX,\n            event.clientY,\n            intensity,\n            eventType === 'click' ? 'click' : 'move'\n          );\n        }\n        \n        this.addEvent({\n          type: 'incremental_snapshot',\n          timestamp: Date.now(),\n          data: {\n            source: 'mouse',\n            type: eventType,\n            x: event.clientX,\n            y: event.clientY,\n            id: this.getElementId(event.target as Element)\n          }\n        });\n      }, { capture: true, passive: true });\n    });\n\n    // Keyboard events\n    document.addEventListener('keydown', (event: KeyboardEvent) => {\n      if (!this.isRecording) return;\n      \n      // Don't capture sensitive keystrokes\n      if (this.shouldIgnoreKeystroke(event)) return;\n      \n      this.addEvent({\n        type: 'incremental_snapshot',\n        timestamp: Date.now(),\n        data: {\n          source: 'keyboard',\n          type: 'keydown',\n          key: this.sanitizeKey(event.key),\n          code: event.code,\n          id: this.getElementId(event.target as Element)\n        }\n      });\n    }, { capture: true, passive: true });\n  }\n\n  /**\n   * Utility methods\n   */\n  private addEvent(event: ReplayEvent): void {\n    this.events.push(event);\n    \n    // Limit event buffer\n    if (this.events.length > 10000) {\n      this.events = this.events.slice(-8000);\n    }\n  }\n\n  private addCustomEvent(type: string, data: any): void {\n    this.addEvent({\n      type: 'custom',\n      timestamp: Date.now(),\n      data: { type, ...data }\n    });\n  }\n\n  private serializeConsoleArgs(args: any[]): any[] {\n    return args.map(arg => {\n      try {\n        if (typeof arg === 'object' && arg !== null) {\n          return JSON.parse(JSON.stringify(arg));\n        }\n        return arg;\n      } catch (e) {\n        return '[Unserializable Object]';\n      }\n    });\n  }\n\n  private generateRequestId(): string {\n    return Date.now().toString(36) + Math.random().toString(36).substr(2);\n  }\n\n  private getRequestHeaders(init?: RequestInit, input?: RequestInfo | URL): Record<string, string> {\n    const headers: Record<string, string> = {};\n    \n    if (init?.headers) {\n      if (init.headers instanceof Headers) {\n        init.headers.forEach((value, key) => {\n          headers[key] = value;\n        });\n      } else if (Array.isArray(init.headers)) {\n        init.headers.forEach(([key, value]) => {\n          headers[key] = value;\n        });\n      } else {\n        Object.assign(headers, init.headers);\n      }\n    }\n    \n    if (input instanceof Request) {\n      input.headers.forEach((value, key) => {\n        headers[key] = value;\n      });\n    }\n    \n    return headers;\n  }\n\n  private getResponseHeaders(response: Response): Record<string, string> {\n    const headers: Record<string, string> = {};\n    response.headers.forEach((value, key) => {\n      headers[key] = value;\n    });\n    return headers;\n  }\n\n  private async serializeRequestBody(init?: RequestInit, input?: RequestInfo | URL): Promise<any> {\n    let body = init?.body;\n    \n    if (input instanceof Request && !body) {\n      try {\n        body = await input.clone().text();\n      } catch (e) {\n        return null;\n      }\n    }\n    \n    if (!body) return null;\n    \n    if (typeof body === 'string') {\n      return body.length > 10000 ? body.substring(0, 10000) + '...[truncated]' : body;\n    }\n    \n    if (body instanceof FormData) {\n      const formData: Record<string, any> = {};\n      body.forEach((value, key) => {\n        formData[key] = value instanceof File ? `[File: ${value.name}]` : value;\n      });\n      return formData;\n    }\n    \n    return '[Binary Data]';\n  }\n\n  private shouldCaptureResponseBody(response: Response): boolean {\n    const contentType = response.headers.get('content-type') || '';\n    const contentLength = parseInt(response.headers.get('content-length') || '0');\n    \n    // Only capture text-based responses under 100KB\n    return contentType.includes('application/json') ||\n           contentType.includes('text/') ||\n           (contentLength > 0 && contentLength < 100000);\n  }\n\n  private shouldCaptureXHRResponse(xhr: XMLHttpRequest): boolean {\n    const contentType = xhr.getResponseHeader('content-type') || '';\n    \n    return contentType.includes('application/json') ||\n           contentType.includes('text/') ||\n           (xhr.responseText && xhr.responseText.length < 100000);\n  }\n\n  private getElementId(element: Element | null): number | undefined {\n    // This would ideally use the same node ID system as the DOM serializer\n    return element ? Math.random() : undefined;\n  }\n\n  private shouldIgnoreKeystroke(event: KeyboardEvent): boolean {\n    const target = event.target as HTMLElement;\n    \n    if (target && target.tagName) {\n      const tagName = target.tagName.toLowerCase();\n      const type = (target as HTMLInputElement).type;\n      \n      // Ignore keystrokes in password fields\n      if (tagName === 'input' && type === 'password') return true;\n      \n      // Ignore keystrokes in elements marked as sensitive\n      if (target.hasAttribute('data-revi-ignore')) return true;\n    }\n    \n    return false;\n  }\n\n  private sanitizeKey(key: string): string {\n    // Don't capture the actual key for sensitive inputs\n    if (key.length === 1 && /[a-zA-Z0-9]/.test(key)) {\n      return '*'; // Mask alphanumeric characters\n    }\n    return key;\n  }\n\n\n  private restoreOriginalNetwork(): void {\n    if (this.originalFetch) {\n      window.fetch = this.originalFetch;\n    }\n    \n    if (this.originalXMLHttpRequest) {\n      window.XMLHttpRequest = this.originalXMLHttpRequest;\n    }\n  }\n}","import { ErrorHandler } from './error-handler';\nimport { SessionManager } from './session';\nimport { NetworkMonitor } from './network-monitor';\nimport { PerformanceMonitor } from './performance-monitor';\nimport { DataManager } from './data-manager';\nimport { UserJourneyTracker } from './user-journey';\nimport { SessionReplayManager } from './session-replay';\nimport { isBot } from './utils';\nimport type { ReviConfig, ErrorEvent, UserContext } from './types';\n\nexport class Monitor {\n  private config: ReviConfig;\n  private errorHandler: ErrorHandler;\n  private sessionManager: SessionManager;\n  private networkMonitor: NetworkMonitor;\n  private performanceMonitor: PerformanceMonitor;\n  private dataManager: DataManager;\n  private userJourneyTracker: UserJourneyTracker;\n  private sessionReplayManager: SessionReplayManager;\n  private isInitialized = false;\n\n  constructor(config: ReviConfig) {\n    this.config = {\n      apiUrl: process.env.REVI_API_URL || 'https://api.revi.dev',\n      environment: 'production',\n      debug: false,\n      sampleRate: 1.0,\n      sessionSampleRate: 1.0,\n      maxBreadcrumbs: 50,\n      privacy: {\n        maskInputs: true,\n        maskPasswords: true,\n        maskCreditCards: true\n      },\n      performance: {\n        captureWebVitals: true,\n        captureResourceTiming: false,\n        captureNavigationTiming: true\n      },\n      replay: {\n        enabled: true,\n        maskAllInputs: false,\n        maskAllText: false\n      },\n      ...config\n    };\n\n    if (!this.config.apiKey) {\n      throw new Error('Revi: API key is required');\n    }\n\n    if (isBot()) {\n      if (this.config.debug) {\n        console.log('Revi: Bot detected, skipping initialization');\n      }\n      return;\n    }\n\n    this.init();\n  }\n\n  private init(): void {\n    if (this.isInitialized) return;\n\n    try {\n      this.errorHandler = new ErrorHandler(this.config);\n      this.sessionManager = new SessionManager(this.config);\n      this.networkMonitor = new NetworkMonitor(this.config);\n      this.performanceMonitor = new PerformanceMonitor(this.config);\n      this.dataManager = new DataManager(this.config);\n      this.userJourneyTracker = new UserJourneyTracker(this.config);\n      this.sessionReplayManager = new SessionReplayManager(this.config, this.sessionManager.getSessionId());\n\n      this.setupPeriodicFlush();\n      \n      // Start session replay if enabled\n      if (this.config.replay?.enabled) {\n        this.sessionReplayManager.startRecording();\n      }\n      \n      this.isInitialized = true;\n\n      if (this.config.debug) {\n        console.log('Revi: Initialized successfully');\n      }\n    } catch (error) {\n      if (this.config.debug) {\n        console.error('Revi: Initialization failed', error);\n      }\n    }\n  }\n\n  private setupPeriodicFlush(): void {\n    // Flush data every 10 seconds\n    setInterval(() => {\n      this.flush();\n    }, 10000);\n  }\n\n  // Public API methods\n  captureException(error: Error, options: {\n    level?: 'error' | 'warning' | 'info' | 'debug';\n    tags?: Record<string, string>;\n    extra?: Record<string, any>;\n  } = {}): string {\n    if (!this.isInitialized) return '';\n\n    const errorId = this.errorHandler.captureException(error, options);\n    if (errorId) {\n      // Create error event and queue for upload\n      const errorEvent: ErrorEvent = {\n        id: errorId,\n        timestamp: Date.now(),\n        message: error.message,\n        stack: error.stack,\n        url: window.location.href,\n        userId: this.config.userId,\n        sessionId: this.sessionManager.getSessionId(),\n        userAgent: navigator.userAgent,\n        environment: this.config.environment,\n        release: this.config.release,\n        tags: options.tags,\n        extra: options.extra,\n        breadcrumbs: this.errorHandler.getBreadcrumbs(),\n        level: options.level || 'error'\n      };\n\n      this.dataManager.queueError(errorEvent);\n      \n      // Track error in user journey\n      if (this.userJourneyTracker) {\n        this.userJourneyTracker.trackError(error, {\n          level: options.level,\n          tags: options.tags,\n          extra: options.extra\n        });\n      }\n    }\n\n    return errorId;\n  }\n\n  captureMessage(message: string, options: {\n    level?: 'error' | 'warning' | 'info' | 'debug';\n    tags?: Record<string, string>;\n    extra?: Record<string, any>;\n  } = {}): string {\n    if (!this.isInitialized) return '';\n\n    const errorId = this.errorHandler.captureMessage(message, options);\n    if (errorId) {\n      const errorEvent: ErrorEvent = {\n        id: errorId,\n        timestamp: Date.now(),\n        message,\n        url: window.location.href,\n        userId: this.config.userId,\n        sessionId: this.sessionManager.getSessionId(),\n        userAgent: navigator.userAgent,\n        environment: this.config.environment,\n        release: this.config.release,\n        tags: options.tags,\n        extra: options.extra,\n        breadcrumbs: this.errorHandler.getBreadcrumbs(),\n        level: options.level || 'info'\n      };\n\n      this.dataManager.queueError(errorEvent);\n    }\n\n    return errorId;\n  }\n\n  addBreadcrumb(breadcrumb: {\n    message: string;\n    category?: string;\n    level?: 'error' | 'warning' | 'info' | 'debug';\n    data?: Record<string, any>;\n  }): void {\n    if (!this.isInitialized) return;\n\n    this.errorHandler.addBreadcrumb({\n      timestamp: Date.now(),\n      message: breadcrumb.message,\n      category: breadcrumb.category || 'manual',\n      level: breadcrumb.level || 'info',\n      data: breadcrumb.data\n    });\n  }\n\n  setUserContext(user: UserContext): void {\n    if (!this.isInitialized) return;\n\n    this.config.userId = user.id;\n    this.errorHandler.setUserContext(user);\n    this.userJourneyTracker.setUserId(user.id || '');\n    this.userJourneyTracker.startTracking(user.id);\n  }\n\n  setTags(tags: Record<string, string>): void {\n    if (!this.isInitialized) return;\n    this.errorHandler.setTags(tags);\n  }\n\n  setExtra(extra: Record<string, any>): void {\n    if (!this.isInitialized) return;\n    this.errorHandler.setExtra(extra);\n  }\n\n  // Session management\n  getSessionId(): string {\n    if (!this.isInitialized) return '';\n    return this.sessionManager.getSessionId();\n  }\n\n  endSession(): void {\n    if (!this.isInitialized) return;\n    \n    this.flush();\n    this.sessionManager.endSession();\n  }\n\n  // Performance monitoring\n  mark(name: string): void {\n    if (!this.isInitialized) return;\n    this.performanceMonitor.mark(name);\n  }\n\n  measure(name: string, startMark?: string, endMark?: string): number | null {\n    if (!this.isInitialized) return null;\n    return this.performanceMonitor.measure(name, startMark, endMark);\n  }\n\n  getWebVitals() {\n    if (!this.isInitialized) return {};\n    return this.performanceMonitor.getWebVitals();\n  }\n\n  // Session Replay methods\n  startSessionReplay(): void {\n    if (!this.isInitialized || !this.sessionReplayManager) return;\n    this.sessionReplayManager.startRecording();\n  }\n\n  stopSessionReplay(): void {\n    if (!this.isInitialized || !this.sessionReplayManager) return;\n    this.sessionReplayManager.stopRecording();\n  }\n\n  getSessionReplayData() {\n    if (!this.isInitialized || !this.sessionReplayManager) return null;\n    return this.sessionReplayManager.getReplayData();\n  }\n\n  // Data management\n  flush(): void {\n    if (!this.isInitialized) return;\n\n    // Get all queued events\n    const sessionEvents = this.sessionManager.flush();\n    const networkEvents = this.networkMonitor.flush();\n\n    // Add session ID to network events\n    networkEvents.forEach(event => {\n      event.sessionId = this.sessionManager.getSessionId();\n    });\n\n    // Queue for upload\n    if (sessionEvents.length > 0) {\n      this.dataManager.queueSessionEvents(sessionEvents);\n    }\n    \n    if (networkEvents.length > 0) {\n      this.dataManager.queueNetworkEvents(networkEvents);\n    }\n  }\n\n  // Cleanup\n  destroy(): void {\n    if (!this.isInitialized) return;\n\n    this.flush();\n    \n    if (this.networkMonitor) {\n      this.networkMonitor.destroy();\n    }\n    \n    if (this.dataManager) {\n      this.dataManager.destroy();\n    }\n\n    if (this.sessionReplayManager) {\n      this.sessionReplayManager.stopRecording();\n    }\n\n    if (this.userJourneyTracker) {\n      this.userJourneyTracker.stopTracking();\n    }\n\n    this.isInitialized = false;\n  }\n}\n"],"names":["generateId","replace","c","r","Math","random","toString","formatStackTrace","error","stack","split","map","line","trim","filter","length","join","ErrorHandler","constructor","config","this","breadcrumbs","userContext","setupGlobalHandlers","window","addEventListener","event","captureError","message","filename","lineno","colno","reason","Error","JSON","stringify","originalConsoleError","console","args","addBreadcrumb","timestamp","Date","now","category","level","apply","originalConsoleWarn","warn","errorData","sampleRate","errorId","errorEvent","id","undefined","url","location","href","userId","sessionId","userAgent","navigator","environment","release","tags","extra","_b","beforeSend","call","_a","captureException","options","captureMessage","breadcrumb","push","maxBreadcrumbs","splice","setUserContext","user","setTags","setExtra","getBreadcrumbs","clearBreadcrumbs","SessionManager","events","storage","sessionStorage","setItem","removeItem","getSessionStorage","getOrCreateSessionId","startTime","setupEventListeners","trackPageLoad","storageKey","existingId","getItem","newId","getSessionId","scrollTimeout","resizeTimeout","forEach","eventType","document","captureEvent","serializeDOMEvent","capture","passive","type","hidden","clearTimeout","setTimeout","x","scrollX","y","scrollY","width","innerWidth","height","innerHeight","duration","flush","target","data","tagName","className","textContent","shouldMaskText","slice","mouseEvent","coordinates","clientX","clientY","inputEvent","value","shouldMaskInput","element","privacy","maskInputs","includes","name","toLowerCase","_c","some","sensitive","replay","maskAllText","maskSelector","matches","captureLoadEvent","title","referrer","loadTime","performance","readyState","sessionSampleRate","filteredEvent","beforeSendSession","getEvents","clearEvents","endSession","NetworkMonitor","originalFetch","fetch","originalXHROpen","XMLHttpRequest","prototype","open","originalXHRSend","send","setupInterceptors","interceptFetch","interceptXHR","async","method","toUpperCase","shouldMonitorRequest","requestBody","requestSize","body","serializeRequestBody","calculateBodySize","response","endTime","responseBody","responseSize","shouldCaptureResponseBody","clonedResponse","clone","extractResponseBody","calculateResponseSize","_e","captureNetworkEvent","statusCode","status","responseTime","requestHeaders","extractHeaders","headers","responseHeaders","extractResponseHeaders","_d","String","self","_reviData","shouldMonitor","reviData","responseType","responseText","FormData","formObject","key","File","URLSearchParams","Object","fromEntries","parse","contentType","get","json","text","Headers","headerObj","Array","isArray","ArrayBuffer","byteLength","Blob","size","pattern","test","apiUrl","normalizedApiUrl","normalizedUrl","debug","log","startsWith","matchedPattern","find","matchedApiPattern","denyUrls","RegExp","allowUrls","allowed","destroy","PerformanceMonitor","webVitals","performanceEntries","captureWebVitals","setupWebVitals","captureResourceTiming","setupResourceTiming","captureNavigationTiming","setupNavigationTiming","PerformanceObserver","list","entries","getEntries","lastEntry","lcp","observe","entryTypes","e","entry","fid","processingStart","clsValue","hadRecentInput","cls","fcp","calculateTTFB","navigationTiming","getEntriesByType","ttfb","responseStart","requestStart","entryType","transferSize","encodedBodySize","decodedBodySize","domContentLoadedEventEnd","domContentLoadedEventStart","loadEventEnd","loadEventStart","domComplete","domInteractive","getWebVitals","getPerformanceEntries","clearPerformanceEntries","mark","measure","startMark","endMark","getEntriesByName","DataManager","uploadQueue","errors","sessionEvents","networkEvents","uploadTimer","isUploading","localStorage","getLocalStorage","loadQueueFromStorage","startUploadTimer","setupBeforeUnloadHandler","storedData","saveQueueToStorage","clearQueue","setInterval","hasQueuedData","uploadData","uploadDataSync","queueError","queueSessionEvents","queueNetworkEvents","uploadErrors","uploadSessionEvents","uploadNetworkEvents","sendBeacon","payload","session_id","event_type","apiKey","stack_trace","user_agent","metadata","ok","promises","status_code","response_time","request_data","response_data","failures","Promise","allSettled","clearInterval","UserJourneyTracker","journeyEvents","isTracking","deviceFingerprint","generateDeviceFingerprint","sessionStartTime","currentPageStartTime","setupJourneyTracking","startTracking","trackPageView","stopTracking","setUserId","viewport","scroll_position","device_fingerprint","language","timezone","Intl","DateTimeFormat","resolvedOptions","timeZone","connection_type","getConnectionType","addJourneyEvent","trackClick","journeyEvent","tag","class","getElementText","attributes","getRelevantAttributes","page_x","pageX","page_y","pageY","trackFormSubmit","form","formData","fields","input","querySelector","has_value","value_length","action","field_count","trackApiCall","duration_ms","api","success","page_context","time_on_page","trackError","context","user_context","session_duration","page_interactions","countPageInteractions","custom_context","currentUrl","handleNavigation","timeSpent","updateLastPageViewDuration","originalPushState","history","pushState","originalReplaceState","replaceState","shouldTrackClick","components","screen","colorDepth","platform","cookieEnabled","canvas","createElement","ctx","getContext","textBaseline","font","fillText","toDataURL","fingerprint","hash","i","charCodeAt","abs","sendJourneyEvents","catch","unshift","user_id","hasAttribute","innerText","substring","attrs","attr","getAttribute","connection","effectiveType","lastEvent","DOMSerializer","nodeIdMap","WeakMap","nodeMap","Map","nextNodeId","isObserving","takeSnapshot","snapshot","scroll","nodes","stylesheets","resources","serializeDocument","serializeStylesheets","serializeResources","startObserving","onDOMChange","observer","MutationObserver","handleMutations","bind","childList","characterData","subtree","attributeOldValue","characterDataOldValue","stopObserving","disconnect","doc","doctype","publicId","systemId","getNodeId","documentElement","serialized","serializeNode","node","shouldIgnoreNode","nodeId","getNodeType","nodeType","Node","ELEMENT_NODE","serializeAttributes","children","serializeChildren","TEXT_NODE","textNode","COMMENT_NODE","commentNode","shouldIgnoreAttribute","shouldMaskAttribute","childNodes","child","serializedChild","styleSheets","stylesheet","cssText","cssRules","from","rule","disabled","querySelectorAll","img","src","shouldIgnoreResource","failed","complete","naturalWidth","backgroundImage","getComputedStyle","urlMatch","match","mutations","mutation","targetId","change","addedNodes","removedNodes","attributeName","attributeValue","oldValue","has","set","DOCUMENT_NODE","blockSelector","parent","parentElement","urlObj","URL","protocol","params","search","parseInt","ConsoleRecorder","originalMethods","isRecording","maxEntries","captureStackTrace","serializeObjects","maxObjectDepth","maxStringLength","ignoredLevels","start","originalMethod","recordEntry","stop","serializeArgs","cleanStackTrace","sourceLine","lineNumber","columnNumber","addEntry","arg","serializeValue","depth","__type","toISOString","item","keys","substr","fromTimestamp","toTimestamp","filtered","getEntriesByLevel","clear","toSessionEvents","consoleId","exportData","levelCounts","minTime","Infinity","maxTime","min","max","stats","totalEntries","errorCount","warningCount","timeRange","end","generateInsights","errorPatterns","findErrorPatterns","performanceIssues","detectPerformanceIssues","recommendations","generateRecommendations","patterns","firstArg","sort","a","b","examples","count","issues","recentEntries","severity","details","errorCounts","HeatmapGenerator","container","radius","maxIntensity","gradient","blur","minOpacity","maxOpacity","style","position","top","left","pointerEvents","zIndex","appendChild","resizeCanvas","rect","getBoundingClientRect","addDataPoint","intensity","generateFromEvents","_f","render","clearRect","filteredData","d","intensityData","createIntensityMap","createGradient","renderHeatmap","shadowCanvas","shadowCtx","point","createRadialGradient","alpha","addColorStop","fillStyle","fillRect","drawImage","getImageData","gradientCanvas","gradientCtx","createLinearGradient","color","parseFloat","gradientData","output","createImageData","gradientIndex","floor","putImageData","removeChild","removeEventListener","eventTypes","minX","maxX","minY","maxY","totalEvents","bounds","hotSpots","findHotSpots","clickPatterns","analyzeClickPatterns","userBehavior","analyzeUserBehavior","clusters","clusterRadius","foundCluster","cluster","sqrt","pow","round","clicks","current","next","frequency","scrolls","sortedByIntensity","topHalf","scrollDepth","s","engagementScore","mostActiveArea","averageClicksPerSession","SessionReplayManager","heatmapGenerator","consoleLogs","networkRequests","originalConsole","domSerializer","consoleRecorder","maxConsoleEntries","ignoredConsoleLevels","_g","enabled","setupReplay","_j","_h","heatmaps","_l","_k","_o","_m","_q","_p","_s","_r","startRecording","takeFullSnapshot","handleDOMChange","setupNetworkCapture","setupInteractionTracking","stopRecording","restoreOriginalNetwork","getReplayData","consoleEntries","consoleInsights","heatmapData","heatmapInsights","console_logs","network_requests","values","heatmap_data","session_info","start_time","page_url","analytics","console_insights","heatmap_insights","clearReplayData","addCustomEvent","addEvent","source","toggleHeatmap","visible","getHeatmapInsights","init","requestId","generateRequestId","Request","getRequestHeaders","networkRequest","getResponseHeaders","originalXMLHttpRequest","xhr","originalOpen","originalSend","m","u","shouldCaptureXHRResponse","getElementId","shouldIgnoreKeystroke","sanitizeKey","code","serializeConsoleArgs","assign","contentLength","getResponseHeader","Monitor","isInitialized","process","env","REVI_API_URL","maskPasswords","maskCreditCards","maskAllInputs","errorHandler","sessionManager","networkMonitor","performanceMonitor","dataManager","userJourneyTracker","sessionReplayManager","setupPeriodicFlush","startSessionReplay","stopSessionReplay","getSessionReplayData"],"mappings":"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"}