{"version":3,"file":"index.js","sources":["../src/utils.ts","../src/trace-manager.ts","../src/error-handler.ts","../src/session.ts","../src/network-monitor.ts","../src/indexed-db-storage.ts","../src/storage-manager.ts","../src/network-manager.ts","../src/compression-utils.ts","../src/data-manager.ts","../src/user-journey.ts","../src/sampling-manager.ts","../src/performance-monitor.ts","../src/dom-serializer.ts","../src/console-recorder.ts","../src/heatmap-generator.ts","../src/session-replay.ts","../src/monitor.ts"],"sourcesContent":["export function generateId(): string {\n  return 'xxxx-xxxx-4xxx-yxxx-xxxx'.replace(/[xy]/g, function(c) {\n    const r = Math.random() * 16 | 0;\n    const v = c === 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\nexport function formatStackTrace(error: Error): string {\n  if (!error.stack) return '';\n  \n  return error.stack\n    .split('\\n')\n    .map(line => line.trim())\n    .filter(line => line.length > 0)\n    .join('\\n');\n}\n\nexport function sanitizeUrl(url: string, allowUrls: string[] = [], denyUrls: string[] = []): string {\n  // Check deny list first\n  if (denyUrls.some(pattern => new RegExp(pattern).test(url))) {\n    return '[Filtered]';\n  }\n  \n  // If allow list is provided, ensure URL matches\n  if (allowUrls.length > 0 && !allowUrls.some(pattern => new RegExp(pattern).test(url))) {\n    return '[Filtered]';\n  }\n  \n  // Remove sensitive query parameters\n  try {\n    const urlObj = new URL(url);\n    const sensitiveParams = ['password', 'token', 'key', 'secret', 'auth', 'api_key'];\n    \n    sensitiveParams.forEach(param => {\n      if (urlObj.searchParams.has(param)) {\n        urlObj.searchParams.set(param, '[Filtered]');\n      }\n    });\n    \n    return urlObj.toString();\n  } catch {\n    return url;\n  }\n}\n\nexport function maskSensitiveData(data: any, maskInputs = true): any {\n  if (typeof data !== 'object' || data === null) {\n    return data;\n  }\n  \n  if (Array.isArray(data)) {\n    return data.map(item => maskSensitiveData(item, maskInputs));\n  }\n  \n  const masked: any = {};\n  const sensitiveKeys = ['password', 'token', 'key', 'secret', 'auth', 'api_key', 'credit_card', 'ssn'];\n  \n  Object.keys(data).forEach(key => {\n    const lowerKey = key.toLowerCase();\n    if (sensitiveKeys.some(sensitive => lowerKey.includes(sensitive))) {\n      masked[key] = '[Masked]';\n    } else if (typeof data[key] === 'object') {\n      masked[key] = maskSensitiveData(data[key], maskInputs);\n    } else {\n      masked[key] = data[key];\n    }\n  });\n  \n  return masked;\n}\n\nexport function debounce<T extends (...args: any[]) => any>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout;\n  \n  return function executedFunction(...args: Parameters<T>) {\n    const later = () => {\n      clearTimeout(timeout);\n      func(...args);\n    };\n    \n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n}\n\nexport function throttle<T extends (...args: any[]) => any>(\n  func: T,\n  limit: number\n): (...args: Parameters<T>) => void {\n  let inThrottle = false;\n  \n  return function executedFunction(...args: Parameters<T>) {\n    if (!inThrottle) {\n      func(...args);\n      inThrottle = true;\n      setTimeout(() => inThrottle = false, limit);\n    }\n  };\n}\n\nexport function isBot(): boolean {\n  if (typeof navigator === 'undefined') return false;\n  \n  const botPatterns = [\n    /bot/i,\n    /spider/i,\n    /crawl/i,\n    /headless/i,\n    /phantom/i,\n    /selenium/i\n  ];\n  \n  return botPatterns.some(pattern => pattern.test(navigator.userAgent));\n}\n\nexport function getSessionStorage(): Storage | null {\n  try {\n    if (typeof window !== 'undefined' && window.sessionStorage) {\n      window.sessionStorage.setItem('test', 'test');\n      window.sessionStorage.removeItem('test');\n      return window.sessionStorage;\n    }\n  } catch {\n    // Storage not available\n  }\n  return null;\n}\n\nexport function getLocalStorage(): Storage | null {\n  try {\n    if (typeof window !== 'undefined' && window.localStorage) {\n      window.localStorage.setItem('test', 'test');\n      window.localStorage.removeItem('test');\n      return window.localStorage;\n    }\n  } catch {\n    // Storage not available\n  }\n  return null;\n}\n","export class TraceManager {\n  private currentTraceId?: string;\n  private currentSpanId?: string;\n  private spanCounter = 0;\n\n  constructor() {\n    // Initialize with session-level trace ID if needed\n    this.generateNewTrace();\n  }\n\n  generateNewTrace(): string {\n    this.currentTraceId = this.generateTraceId();\n    this.currentSpanId = undefined;\n    this.spanCounter = 0;\n    return this.currentTraceId;\n  }\n\n  startSpan(operationName?: string): string {\n    const parentSpanId = this.currentSpanId;\n    this.currentSpanId = this.generateSpanId();\n    this.spanCounter++;\n    \n    // Store span context for later correlation\n    if (operationName) {\n      this.setSpanData(operationName, { \n        parentSpanId,\n        operationName,\n        startTime: Date.now()\n      });\n    }\n\n    return this.currentSpanId;\n  }\n\n  finishSpan(spanId?: string, data?: Record<string, any>): void {\n    if (spanId && this.currentSpanId === spanId) {\n      // Mark span as finished\n      if (data) {\n        this.setSpanData(spanId, { \n          ...this.getSpanData(spanId),\n          ...data,\n          endTime: Date.now()\n        });\n      }\n    }\n  }\n\n  getCurrentTraceId(): string | undefined {\n    return this.currentTraceId;\n  }\n\n  getCurrentSpanId(): string | undefined {\n    return this.currentSpanId;\n  }\n\n  getTraceContext(): { traceId?: string; spanId?: string; parentSpanId?: string } {\n    return {\n      traceId: this.currentTraceId,\n      spanId: this.currentSpanId,\n      parentSpanId: this.getParentSpanId()\n    };\n  }\n\n  // Extract trace ID from headers (for network requests)\n  extractTraceFromHeaders(headers: Record<string, string>): { traceId?: string; spanId?: string } {\n    // Support various tracing standards\n    const traceId = headers['x-trace-id'] || \n                   headers['traceparent']?.split('-')[1] ||\n                   headers['b3-traceid'] ||\n                   headers['uber-trace-id']?.split(':')[0];\n\n    const spanId = headers['x-span-id'] || \n                  headers['traceparent']?.split('-')[2] ||\n                  headers['b3-spanid'] ||\n                  headers['uber-trace-id']?.split(':')[1];\n\n    return { traceId, spanId };\n  }\n\n  // Inject trace headers for outgoing requests\n  injectTraceHeaders(): Record<string, string> {\n    if (!this.currentTraceId) {\n      return {};\n    }\n\n    const headers: Record<string, string> = {};\n    \n    // Add custom headers\n    headers['x-trace-id'] = this.currentTraceId;\n    if (this.currentSpanId) {\n      headers['x-span-id'] = this.currentSpanId;\n      headers['x-parent-span-id'] = this.getParentSpanId() || '';\n    }\n\n    // Add W3C Trace Context (traceparent header)\n    if (this.currentSpanId) {\n      headers['traceparent'] = `00-${this.currentTraceId}-${this.currentSpanId}-01`;\n    }\n\n    return headers;\n  }\n\n  // Correlate with backend trace (when available)\n  correlateWithBackendTrace(backendTraceId?: string, backendSpanId?: string): void {\n    if (backendTraceId) {\n      this.currentTraceId = backendTraceId;\n    }\n    if (backendSpanId) {\n      this.currentSpanId = backendSpanId;\n    }\n  }\n\n  private generateTraceId(): string {\n    // Generate 128-bit trace ID (32 hex characters)\n    return this.generateRandomHex(32);\n  }\n\n  private generateSpanId(): string {\n    // Generate 64-bit span ID (16 hex characters)\n    return this.generateRandomHex(16);\n  }\n\n  private generateRandomHex(length: number): string {\n    const array = new Uint8Array(length / 2);\n    if (typeof crypto !== 'undefined' && crypto.getRandomValues) {\n      crypto.getRandomValues(array);\n    } else {\n      // Fallback for environments without crypto\n      for (let i = 0; i < array.length; i++) {\n        array[i] = Math.floor(Math.random() * 256);\n      }\n    }\n    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');\n  }\n\n  private getParentSpanId(): string | undefined {\n    // This would typically track a span stack, simplified for now\n    return this.spanData.get(this.currentSpanId || '')?.parentSpanId;\n  }\n\n  private spanData = new Map<string, any>();\n\n  private setSpanData(spanId: string, data: any): void {\n    this.spanData.set(spanId, data);\n  }\n\n  private getSpanData(spanId: string): any {\n    return this.spanData.get(spanId) || {};\n  }\n\n  // Clean up old span data to prevent memory leaks\n  cleanupSpanData(): void {\n    const cutoff = Date.now() - 5 * 60 * 1000; // 5 minutes ago\n    for (const [spanId, data] of this.spanData.entries()) {\n      if (data.endTime && data.endTime < cutoff) {\n        this.spanData.delete(spanId);\n      }\n    }\n  }\n}","import { formatStackTrace, generateId } from './utils';\nimport type { ErrorEvent, Breadcrumb, ReviConfig } from './types';\nimport { TraceManager } from './trace-manager';\n\nexport class ErrorHandler {\n  private config: ReviConfig;\n  private breadcrumbs: Breadcrumb[] = [];\n  private userContext: any = {};\n  private traceManager: TraceManager;\n\n  constructor(config: ReviConfig, traceManager?: TraceManager) {\n    this.config = config;\n    this.traceManager = traceManager || new TraceManager();\n    this.setupGlobalHandlers();\n  }\n\n  private setupGlobalHandlers(): void {\n    if (typeof window === 'undefined') return;\n\n    // Global error handler\n    window.addEventListener('error', (event) => {\n      this.captureError({\n        message: event.message,\n        filename: event.filename,\n        lineno: event.lineno,\n        colno: event.colno,\n        error: event.error\n      });\n    });\n\n    // Unhandled promise rejections\n    window.addEventListener('unhandledrejection', (event) => {\n      const error = event.reason;\n      let message = 'Unhandled Promise Rejection';\n      let stack = '';\n\n      if (error instanceof Error) {\n        message = error.message;\n        stack = formatStackTrace(error);\n      } else if (typeof error === 'string') {\n        message = error;\n      } else {\n        message = JSON.stringify(error);\n      }\n\n      this.captureError({\n        message,\n        stack,\n        error\n      });\n    });\n\n    // Console error interception\n    const originalConsoleError = console.error;\n    console.error = (...args: any[]) => {\n      this.addBreadcrumb({\n        timestamp: Date.now(),\n        message: args.join(' '),\n        category: 'console',\n        level: 'error'\n      });\n      originalConsoleError.apply(console, args);\n    };\n\n    // Console warn interception\n    const originalConsoleWarn = console.warn;\n    console.warn = (...args: any[]) => {\n      this.addBreadcrumb({\n        timestamp: Date.now(),\n        message: args.join(' '),\n        category: 'console',\n        level: 'warning'\n      });\n      originalConsoleWarn.apply(console, args);\n    };\n  }\n\n  captureError(errorData: {\n    message: string;\n    stack?: string;\n    filename?: string;\n    lineno?: number;\n    colno?: number;\n    error?: Error;\n    level?: 'error' | 'warning' | 'info' | 'debug';\n    tags?: Record<string, string>;\n    extra?: Record<string, any>;\n  }): string {\n    // Apply sampling\n    if (this.config.sampleRate && Math.random() > this.config.sampleRate) {\n      return '';\n    }\n\n    const errorId = generateId();\n    \n    // Start a new span for this error\n    const spanId = this.traceManager.startSpan(`error:${errorData.message}`);\n    const traceContext = this.traceManager.getTraceContext();\n    \n    const errorEvent: ErrorEvent = {\n      id: errorId,\n      timestamp: Date.now(),\n      message: errorData.message,\n      stack: errorData.stack || (errorData.error ? formatStackTrace(errorData.error) : undefined),\n      url: errorData.filename || window.location.href,\n      lineno: errorData.lineno,\n      colno: errorData.colno,\n      filename: errorData.filename,\n      userId: this.config.userId || this.userContext.id,\n      sessionId: '', // Will be set by Monitor class\n      userAgent: navigator.userAgent,\n      environment: this.config.environment,\n      release: this.config.release,\n      tags: errorData.tags,\n      extra: errorData.extra,\n      breadcrumbs: [...this.breadcrumbs],\n      level: errorData.level || 'error',\n      traceId: traceContext.traceId,\n      spanId: spanId,\n      parentSpanId: traceContext.parentSpanId\n    };\n\n    // Apply beforeSend filter\n    const filteredError = this.config.beforeSend?.(errorEvent) || errorEvent;\n    if (!filteredError) return '';\n\n    return errorId;\n  }\n\n  captureException(error: Error, options: {\n    level?: 'error' | 'warning' | 'info' | 'debug';\n    tags?: Record<string, string>;\n    extra?: Record<string, any>;\n  } = {}): string {\n    return this.captureError({\n      message: error.message,\n      stack: formatStackTrace(error),\n      error,\n      level: options.level,\n      tags: options.tags,\n      extra: options.extra\n    });\n  }\n\n  captureMessage(message: string, options: {\n    level?: 'error' | 'warning' | 'info' | 'debug';\n    tags?: Record<string, string>;\n    extra?: Record<string, any>;\n  } = {}): string {\n    return this.captureError({\n      message,\n      level: options.level || 'info',\n      tags: options.tags,\n      extra: options.extra\n    });\n  }\n\n  addBreadcrumb(breadcrumb: Breadcrumb): void {\n    this.breadcrumbs.push(breadcrumb);\n    \n    const maxBreadcrumbs = this.config.maxBreadcrumbs || 50;\n    if (this.breadcrumbs.length > maxBreadcrumbs) {\n      this.breadcrumbs.splice(0, this.breadcrumbs.length - maxBreadcrumbs);\n    }\n  }\n\n  setUserContext(user: any): void {\n    this.userContext = { ...this.userContext, ...user };\n  }\n\n  setTags(tags: Record<string, string>): void {\n    // Tags will be applied to future errors\n  }\n\n  setExtra(extra: Record<string, any>): void {\n    // Extra data will be applied to future errors\n  }\n\n  getBreadcrumbs(): Breadcrumb[] {\n    return [...this.breadcrumbs];\n  }\n\n  clearBreadcrumbs(): void {\n    this.breadcrumbs = [];\n  }\n}\n","import { generateId, getSessionStorage } from './utils';\nimport type { SessionEvent, ReviConfig } from './types';\nimport { TraceManager } from './trace-manager';\n\nexport class SessionManager {\n  private sessionId: string;\n  private startTime: number;\n  private events: SessionEvent[] = [];\n  private config: ReviConfig;\n  private storage: Storage | null;\n  private traceManager?: TraceManager;\n\n  constructor(config: ReviConfig, traceManager?: TraceManager) {\n    this.config = config;\n    this.traceManager = traceManager;\n    this.storage = getSessionStorage();\n    this.sessionId = this.getOrCreateSessionId();\n    this.startTime = Date.now();\n    \n    this.setupEventListeners();\n    this.trackPageLoad();\n  }\n\n  private getOrCreateSessionId(): string {\n    const storageKey = 'revi_session_id';\n    \n    if (this.storage) {\n      const existingId = this.storage.getItem(storageKey);\n      if (existingId) return existingId;\n    }\n    \n    const newId = generateId();\n    if (this.storage) {\n      this.storage.setItem(storageKey, newId);\n    }\n    \n    return newId;\n  }\n\n  getSessionId(): string {\n    return this.sessionId;\n  }\n\n  private setupEventListeners(): void {\n    if (typeof window === 'undefined') return;\n\n    // DOM events\n    const eventTypes = ['click', 'input', 'change', 'submit', 'focus', 'blur'];\n    eventTypes.forEach(eventType => {\n      document.addEventListener(eventType, (event) => {\n        this.captureEvent(eventType, this.serializeDOMEvent(event));\n      }, { capture: true, passive: true });\n    });\n\n    // Navigation events\n    window.addEventListener('popstate', () => {\n      this.captureEvent('navigation', {\n        type: 'popstate',\n        url: window.location.href,\n        timestamp: Date.now()\n      });\n    });\n\n    // Page visibility\n    document.addEventListener('visibilitychange', () => {\n      this.captureEvent('visibility', {\n        hidden: document.hidden,\n        timestamp: Date.now()\n      });\n    });\n\n    // Scroll events (throttled)\n    let scrollTimeout: NodeJS.Timeout;\n    window.addEventListener('scroll', () => {\n      clearTimeout(scrollTimeout);\n      scrollTimeout = setTimeout(() => {\n        this.captureEvent('scroll', {\n          x: window.scrollX,\n          y: window.scrollY,\n          timestamp: Date.now()\n        });\n      }, 100);\n    }, { passive: true });\n\n    // Resize events (throttled)\n    let resizeTimeout: NodeJS.Timeout;\n    window.addEventListener('resize', () => {\n      clearTimeout(resizeTimeout);\n      resizeTimeout = setTimeout(() => {\n        this.captureEvent('resize', {\n          width: window.innerWidth,\n          height: window.innerHeight,\n          timestamp: Date.now()\n        });\n      }, 100);\n    }, { passive: true });\n\n    // Before unload\n    window.addEventListener('beforeunload', () => {\n      this.captureEvent('beforeunload', {\n        timestamp: Date.now(),\n        duration: Date.now() - this.startTime\n      });\n      this.flush();\n    });\n  }\n\n  private serializeDOMEvent(event: Event): Record<string, any> {\n    const target = event.target as HTMLElement;\n    if (!target) return {};\n\n    const data: Record<string, any> = {\n      type: event.type,\n      timestamp: Date.now(),\n      target: {\n        tagName: target.tagName,\n        id: target.id,\n        className: target.className,\n        textContent: this.shouldMaskText(target) ? '[Masked]' : target.textContent?.slice(0, 100)\n      }\n    };\n\n    // Add specific event data\n    if (event.type === 'click') {\n      const mouseEvent = event as MouseEvent;\n      data.coordinates = {\n        x: mouseEvent.clientX,\n        y: mouseEvent.clientY\n      };\n    }\n\n    if (event.type === 'input' || event.type === 'change') {\n      const inputEvent = event.target as HTMLInputElement;\n      if (inputEvent && inputEvent.value !== undefined) {\n        data.value = this.shouldMaskInput(inputEvent) ? '[Masked]' : inputEvent.value;\n      }\n    }\n\n    return data;\n  }\n\n  private shouldMaskInput(element: HTMLInputElement): boolean {\n    if (!this.config.privacy?.maskInputs) return false;\n    \n    const sensitiveTypes = ['password', 'email', 'tel', 'credit-card-number'];\n    const sensitiveNames = ['password', 'email', 'phone', 'credit', 'card', 'ssn'];\n    \n    if (sensitiveTypes.includes(element.type)) return true;\n    \n    const name = element.name?.toLowerCase() || '';\n    const id = element.id?.toLowerCase() || '';\n    \n    return sensitiveNames.some(sensitive => \n      name.includes(sensitive) || id.includes(sensitive)\n    );\n  }\n\n  private shouldMaskText(element: HTMLElement): boolean {\n    if (!this.config.replay?.maskAllText) return false;\n    \n    // Check for specific selectors that should be masked\n    if (this.config.replay?.maskSelector) {\n      try {\n        return element.matches(this.config.replay.maskSelector);\n      } catch {\n        return false;\n      }\n    }\n    \n    return false;\n  }\n\n  private trackPageLoad(): void {\n    if (typeof window === 'undefined') return;\n\n    const captureLoadEvent = () => {\n      this.captureEvent('page_load', {\n        url: window.location.href,\n        title: document.title,\n        referrer: document.referrer,\n        timestamp: Date.now(),\n        loadTime: performance.now()\n      });\n    };\n\n    if (document.readyState === 'complete') {\n      captureLoadEvent();\n    } else {\n      window.addEventListener('load', captureLoadEvent);\n    }\n  }\n\n  captureEvent(type: string, data: Record<string, any>): void {\n    // Apply sampling\n    if (this.config.sessionSampleRate && Math.random() > this.config.sessionSampleRate) {\n      return;\n    }\n\n    // Start a new span for this session event if trace manager is available\n    const traceContext = this.traceManager?.getTraceContext();\n    const spanId = this.traceManager?.startSpan(`session:${type}`);\n\n    const event: SessionEvent = {\n      sessionId: this.sessionId,\n      timestamp: Date.now(),\n      type,\n      data,\n      traceId: traceContext?.traceId,\n      spanId: spanId\n    };\n\n    // Apply beforeSendSession filter\n    const filteredEvent = this.config.beforeSendSession?.(event) || event;\n    if (!filteredEvent) return;\n\n    this.events.push(filteredEvent);\n\n    // Auto-flush when buffer is full\n    if (this.events.length >= 100) {\n      this.flush();\n    }\n  }\n\n  getEvents(): SessionEvent[] {\n    return [...this.events];\n  }\n\n  clearEvents(): void {\n    this.events = [];\n  }\n\n  flush(): SessionEvent[] {\n    const events = this.getEvents();\n    this.clearEvents();\n    return events;\n  }\n\n  endSession(): void {\n    this.captureEvent('session_end', {\n      timestamp: Date.now(),\n      duration: Date.now() - this.startTime\n    });\n    \n    if (this.storage) {\n      this.storage.removeItem('revi_session_id');\n    }\n  }\n}\n","import { generateId } from './utils';\nimport type { NetworkEvent, ReviConfig } from './types';\nimport { TraceManager } from './trace-manager';\n\nexport class NetworkMonitor {\n  private config: ReviConfig;\n  private events: NetworkEvent[] = [];\n  private originalFetch: typeof fetch;\n  private originalXHROpen: typeof XMLHttpRequest.prototype.open;\n  private originalXHRSend: typeof XMLHttpRequest.prototype.send;\n  private traceManager: TraceManager;\n\n  constructor(config: ReviConfig, traceManager?: TraceManager) {\n    this.config = config;\n    this.traceManager = traceManager || new TraceManager();\n    this.originalFetch = window.fetch;\n    this.originalXHROpen = XMLHttpRequest.prototype.open;\n    this.originalXHRSend = XMLHttpRequest.prototype.send;\n    \n    this.setupInterceptors();\n  }\n\n  private setupInterceptors(): void {\n    if (typeof window === 'undefined') return;\n\n    this.interceptFetch();\n    this.interceptXHR();\n  }\n\n  private interceptFetch(): void {\n    window.fetch = async (...args: Parameters<typeof fetch>): Promise<Response> => {\n      const startTime = Date.now();\n      const url = typeof args[0] === 'string' ? args[0] : args[0].url;\n      const method = (args[1]?.method || 'GET').toUpperCase();\n      \n      // Check if this request should be monitored\n      if (!this.shouldMonitorRequest(url)) {\n        return await this.originalFetch.apply(window, args);\n      }\n      \n      // Start a new span for this network request\n      const spanId = this.traceManager.startSpan(`http:${method} ${url}`);\n      \n      // Inject trace headers into the request\n      const traceHeaders = this.traceManager.injectTraceHeaders();\n      const originalHeaders = args[1]?.headers || {};\n      const headers = { ...originalHeaders, ...traceHeaders };\n      \n      // Update request args with trace headers\n      const modifiedArgs: Parameters<typeof fetch> = [\n        args[0],\n        {\n          ...args[1],\n          headers: headers\n        }\n      ];\n      \n      let requestSize = 0;\n      let requestBody: any;\n      \n      if (args[1]?.body) {\n        requestBody = this.serializeRequestBody(args[1].body);\n        requestSize = this.calculateBodySize(args[1].body);\n      }\n\n      try {\n        const response = await this.originalFetch.apply(window, modifiedArgs);\n        const endTime = Date.now();\n        \n        let responseBody: any;\n        let responseSize = 0;\n        \n        if (this.shouldCaptureResponseBody(url)) {\n          const clonedResponse = response.clone();\n          try {\n            responseBody = await this.extractResponseBody(clonedResponse);\n            responseSize = this.calculateResponseSize(responseBody);\n          } catch {\n            // Failed to extract response body\n          }\n        }\n\n        // Extract trace context from response headers\n        const responseTrace = this.traceManager.extractTraceFromHeaders(\n          this.extractResponseHeaders(response.headers)\n        );\n        \n        // Correlate with backend trace if available\n        if (responseTrace.traceId) {\n          this.traceManager.correlateWithBackendTrace(responseTrace.traceId, responseTrace.spanId);\n        }\n        \n        // Finish the span\n        this.traceManager.finishSpan(spanId, {\n          statusCode: response.status,\n          responseTime: endTime - startTime\n        });\n        \n        const traceContext = this.traceManager.getTraceContext();\n        \n        this.captureNetworkEvent({\n          method,\n          url,\n          statusCode: response.status,\n          responseTime: endTime - startTime,\n          requestSize,\n          responseSize,\n          requestHeaders: this.extractHeaders(headers),\n          responseHeaders: this.extractResponseHeaders(response.headers),\n          requestBody,\n          responseBody,\n          timestamp: startTime,\n          traceId: traceContext.traceId,\n          spanId: spanId,\n          parentSpanId: traceContext.parentSpanId\n        });\n\n        return response;\n      } catch (error) {\n        const endTime = Date.now();\n        \n        // Finish the span with error\n        this.traceManager.finishSpan(spanId, {\n          statusCode: 0,\n          responseTime: endTime - startTime,\n          error: error instanceof Error ? error.message : String(error)\n        });\n        \n        const traceContext = this.traceManager.getTraceContext();\n        \n        this.captureNetworkEvent({\n          method,\n          url,\n          statusCode: 0, // Network error\n          responseTime: endTime - startTime,\n          requestSize,\n          responseSize: 0,\n          requestHeaders: this.extractHeaders(headers),\n          requestBody,\n          timestamp: startTime,\n          traceId: traceContext.traceId,\n          spanId: spanId,\n          parentSpanId: traceContext.parentSpanId\n        });\n\n        throw error;\n      }\n    };\n  }\n\n  private interceptXHR(): void {\n    const self = this;\n\n    XMLHttpRequest.prototype.open = function(method: string, url: string, ...args: any[]) {\n      (this as any)._reviData = {\n        method: method.toUpperCase(),\n        url,\n        startTime: Date.now(),\n        shouldMonitor: self.shouldMonitorRequest(url)\n      };\n      \n      return self.originalXHROpen.call(this, method, url, ...args);\n    };\n\n    XMLHttpRequest.prototype.send = function(body?: any) {\n      const reviData = (this as any)._reviData;\n      if (!reviData || !reviData.shouldMonitor) {\n        return self.originalXHRSend.call(this, body);\n      }\n\n      reviData.requestBody = self.serializeRequestBody(body);\n      reviData.requestSize = self.calculateBodySize(body);\n\n      this.addEventListener('loadend', () => {\n        const endTime = Date.now();\n        \n        let responseBody: any;\n        try {\n          if (this.responseType === '' || this.responseType === 'text') {\n            responseBody = this.responseText;\n          } else if (this.responseType === 'json') {\n            responseBody = this.response;\n          }\n        } catch {\n          // Failed to extract response\n        }\n\n        self.captureNetworkEvent({\n          method: reviData.method,\n          url: reviData.url,\n          statusCode: this.status,\n          responseTime: endTime - reviData.startTime,\n          requestSize: reviData.requestSize,\n          responseSize: self.calculateResponseSize(responseBody),\n          requestBody: reviData.requestBody,\n          responseBody: self.shouldCaptureResponseBody(reviData.url) ? responseBody : undefined,\n          timestamp: reviData.startTime\n        });\n      });\n\n      return self.originalXHRSend.call(this, body);\n    };\n  }\n\n  private serializeRequestBody(body: any): any {\n    if (!body) return undefined;\n    \n    if (typeof body === 'string') return body;\n    if (body instanceof FormData) {\n      const formObject: Record<string, any> = {};\n      body.forEach((value, key) => {\n        formObject[key] = value instanceof File ? `[File: ${value.name}]` : value;\n      });\n      return formObject;\n    }\n    if (body instanceof URLSearchParams) {\n      return Object.fromEntries(body);\n    }\n    \n    try {\n      return JSON.parse(JSON.stringify(body));\n    } catch {\n      return '[Unserializable]';\n    }\n  }\n\n  private async extractResponseBody(response: Response): Promise<any> {\n    const contentType = response.headers.get('content-type') || '';\n    \n    if (contentType.includes('application/json')) {\n      return await response.json();\n    } else if (contentType.includes('text/')) {\n      return await response.text();\n    }\n    \n    return '[Binary Data]';\n  }\n\n  private extractHeaders(headers?: HeadersInit): Record<string, string> {\n    if (!headers) return {};\n    \n    if (headers instanceof Headers) {\n      const headerObj: Record<string, string> = {};\n      headers.forEach((value, key) => {\n        headerObj[key] = value;\n      });\n      return headerObj;\n    }\n    \n    if (Array.isArray(headers)) {\n      const headerObj: Record<string, string> = {};\n      headers.forEach(([key, value]) => {\n        headerObj[key] = value;\n      });\n      return headerObj;\n    }\n    \n    return headers as Record<string, string>;\n  }\n\n  private extractResponseHeaders(headers: Headers): Record<string, string> {\n    const headerObj: Record<string, string> = {};\n    headers.forEach((value, key) => {\n      headerObj[key] = value;\n    });\n    return headerObj;\n  }\n\n  private calculateBodySize(body: any): number {\n    if (!body) return 0;\n    \n    if (typeof body === 'string') return body.length;\n    if (body instanceof ArrayBuffer) return body.byteLength;\n    if (body instanceof Blob) return body.size;\n    \n    try {\n      return JSON.stringify(body).length;\n    } catch {\n      return 0;\n    }\n  }\n\n  private calculateResponseSize(response: any): number {\n    if (!response) return 0;\n    \n    try {\n      return JSON.stringify(response).length;\n    } catch {\n      return 0;\n    }\n  }\n\n  private shouldCaptureResponseBody(url: string): boolean {\n    // Only capture response bodies for specific URLs to avoid memory issues\n    const allowedPatterns = [\n      /\\/api\\//,\n      /\\/graphql/,\n    ];\n    \n    return allowedPatterns.some(pattern => pattern.test(url));\n  }\n\n  private shouldMonitorRequest(url: string): boolean {\n    // Don't monitor the SDK's own API calls to prevent feedback loops\n    const apiUrl = this.config.apiUrl || 'https://api.revi.dev';\n    \n    // Remove trailing slash for consistent comparison\n    const normalizedApiUrl = apiUrl.replace(/\\/$/, '');\n    const normalizedUrl = url.replace(/\\/$/, '');\n    \n    // Debug logging to identify filtering issues\n    if (this.config.debug) {\n      console.log('[Revi Debug] Network filter check:', { \n        url, \n        normalizedUrl, \n        apiUrl, \n        normalizedApiUrl \n      });\n    }\n    \n    // Exclude any requests to the Revi API backend\n    if (normalizedUrl.startsWith(normalizedApiUrl)) {\n      if (this.config.debug) {\n        console.log('[Revi Debug] Filtering API URL:', url, '(matches configured apiUrl)');\n      }\n      return false;\n    }\n    \n    // Use configurable development hosts or default patterns\n    const developmentHosts = this.config.developmentHosts || [\n      /^https?:\\/\\/localhost:\\d+/,\n      /^https?:\\/\\/127\\.0\\.0\\.1:\\d+/,\n      /^https?:\\/\\/0\\.0\\.0\\.0:\\d+/,\n      /^https?:\\/\\/.*\\.local:\\d+/\n    ];\n    \n    const matchedPattern = developmentHosts.find(pattern => pattern.test(url));\n    if (matchedPattern) {\n      if (this.config.debug) {\n        console.log('[Revi Debug] Filtering development host URL:', url, '(matched pattern:', matchedPattern, ')');\n      }\n      return false;\n    }\n    \n    // Additional API endpoint patterns to filter\n    const apiEndpointPatterns = [\n      /\\/api\\/capture\\//,\n      /\\/api\\/errors/,\n      /\\/api\\/session/,\n      /\\/api\\/projects/,\n      /\\/api\\/database/,\n      /\\/api\\/analytics/,\n      /\\/health$/,\n    ];\n    \n    const matchedApiPattern = apiEndpointPatterns.find(pattern => pattern.test(url));\n    if (matchedApiPattern) {\n      if (this.config.debug) {\n        console.log('[Revi Debug] Filtering API endpoint:', url, '(matched pattern:', matchedApiPattern, ')');\n      }\n      return false;\n    }\n    \n    // Check configurable exclude URLs\n    if (this.config.excludeUrls) {\n      const excluded = this.config.excludeUrls.some(pattern => pattern.test(url));\n      if (excluded) {\n        if (this.config.debug) {\n          console.log('[Revi Debug] Filtering excluded URL:', url);\n        }\n        return false;\n      }\n    }\n    \n    // Check privacy configuration if available\n    if (this.config.privacy?.denyUrls) {\n      const denied = this.config.privacy.denyUrls.some(pattern => {\n        const regex = new RegExp(pattern);\n        return regex.test(url);\n      });\n      if (denied) {\n        if (this.config.debug) {\n          console.log('[Revi Debug] Filtering denied URL:', url);\n        }\n        return false;\n      }\n    }\n    \n    if (this.config.privacy?.allowUrls) {\n      const allowed = this.config.privacy.allowUrls.some(pattern => {\n        const regex = new RegExp(pattern);\n        return regex.test(url);\n      });\n      if (this.config.debug) {\n        console.log('[Revi Debug] Allow list result for:', url, '- allowed:', allowed);\n      }\n      return allowed;\n    }\n    \n    if (this.config.debug) {\n      console.log('[Revi Debug] Monitoring URL:', url, '(no filters matched)');\n    }\n    return true;\n  }\n\n  private captureNetworkEvent(data: Partial<NetworkEvent> & { method: string; url: string; timestamp: number }): void {\n    const event: NetworkEvent = {\n      sessionId: '', // Will be set by Monitor class\n      timestamp: data.timestamp,\n      method: data.method,\n      url: data.url,\n      statusCode: data.statusCode,\n      responseTime: data.responseTime,\n      requestSize: data.requestSize,\n      responseSize: data.responseSize,\n      requestHeaders: data.requestHeaders,\n      responseHeaders: data.responseHeaders,\n      requestBody: data.requestBody,\n      responseBody: data.responseBody\n    };\n\n    this.events.push(event);\n\n    // Auto-flush when buffer is full\n    if (this.events.length >= 50) {\n      this.flush();\n    }\n  }\n\n  getEvents(): NetworkEvent[] {\n    return [...this.events];\n  }\n\n  clearEvents(): void {\n    this.events = [];\n  }\n\n  flush(): NetworkEvent[] {\n    const events = this.getEvents();\n    this.clearEvents();\n    return events;\n  }\n\n  destroy(): void {\n    // Restore original implementations\n    if (this.originalFetch) {\n      window.fetch = this.originalFetch;\n    }\n    \n    XMLHttpRequest.prototype.open = this.originalXHROpen;\n    XMLHttpRequest.prototype.send = this.originalXHRSend;\n  }\n}\n","import type { ErrorEvent, SessionEvent, NetworkEvent } from './types';\n\ninterface StorageItem {\n  id: string;\n  type: 'error' | 'session' | 'network';\n  data: any;\n  timestamp: number;\n  compressed: boolean;\n}\n\nexport class IndexedDBStorage {\n  private db: IDBDatabase | null = null;\n  private dbName = 'revi-storage';\n  private version = 1;\n  private storeName = 'queue';\n  private maxQueueSize = 1000;\n  private maxAge = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds\n\n  async initialize(): Promise<void> {\n    if (typeof window === 'undefined' || !window.indexedDB) {\n      throw new Error('IndexedDB not supported');\n    }\n\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, this.version);\n\n      request.onerror = () => {\n        reject(new Error('Failed to open IndexedDB'));\n      };\n\n      request.onsuccess = () => {\n        this.db = request.result;\n        resolve();\n      };\n\n      request.onupgradeneeded = (event) => {\n        const db = (event.target as IDBOpenDBRequest).result;\n        \n        if (!db.objectStoreNames.contains(this.storeName)) {\n          const objectStore = db.createObjectStore(this.storeName, { keyPath: 'id' });\n          objectStore.createIndex('timestamp', 'timestamp', { unique: false });\n          objectStore.createIndex('type', 'type', { unique: false });\n        }\n      };\n    });\n  }\n\n  async store(type: 'error' | 'session' | 'network', data: any): Promise<void> {\n    if (!this.db) {\n      await this.initialize();\n    }\n\n    await this.cleanupExpiredItems();\n    \n    const queueSize = await this.getQueueSize();\n    if (queueSize >= this.maxQueueSize) {\n      await this.removeOldestItems(100);\n    }\n\n    const item: StorageItem = {\n      id: this.generateId(),\n      type,\n      data: await this.compress(data),\n      timestamp: Date.now(),\n      compressed: true\n    };\n\n    return new Promise((resolve, reject) => {\n      if (!this.db) {\n        reject(new Error('Database not initialized'));\n        return;\n      }\n\n      const transaction = this.db.transaction([this.storeName], 'readwrite');\n      const objectStore = transaction.objectStore(this.storeName);\n      const request = objectStore.add(item);\n\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(new Error('Failed to store item'));\n    });\n  }\n\n  async getAll(): Promise<{ errors: ErrorEvent[]; sessionEvents: SessionEvent[]; networkEvents: NetworkEvent[] }> {\n    if (!this.db) {\n      await this.initialize();\n    }\n\n    return new Promise((resolve, reject) => {\n      if (!this.db) {\n        reject(new Error('Database not initialized'));\n        return;\n      }\n\n      const transaction = this.db.transaction([this.storeName], 'readonly');\n      const objectStore = transaction.objectStore(this.storeName);\n      const request = objectStore.getAll();\n\n      request.onsuccess = async () => {\n        const items = request.result as StorageItem[];\n        const result = {\n          errors: [] as ErrorEvent[],\n          sessionEvents: [] as SessionEvent[],\n          networkEvents: [] as NetworkEvent[]\n        };\n\n        for (const item of items) {\n          const decompressedData = await this.decompress(item.data);\n          \n          switch (item.type) {\n            case 'error':\n              result.errors.push(...(Array.isArray(decompressedData) ? decompressedData : [decompressedData]));\n              break;\n            case 'session':\n              result.sessionEvents.push(...(Array.isArray(decompressedData) ? decompressedData : [decompressedData]));\n              break;\n            case 'network':\n              result.networkEvents.push(...(Array.isArray(decompressedData) ? decompressedData : [decompressedData]));\n              break;\n          }\n        }\n\n        resolve(result);\n      };\n\n      request.onerror = () => reject(new Error('Failed to retrieve items'));\n    });\n  }\n\n  async clear(): Promise<void> {\n    if (!this.db) {\n      await this.initialize();\n    }\n\n    return new Promise((resolve, reject) => {\n      if (!this.db) {\n        reject(new Error('Database not initialized'));\n        return;\n      }\n\n      const transaction = this.db.transaction([this.storeName], 'readwrite');\n      const objectStore = transaction.objectStore(this.storeName);\n      const request = objectStore.clear();\n\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(new Error('Failed to clear storage'));\n    });\n  }\n\n  async getQueueSize(): Promise<number> {\n    if (!this.db) {\n      await this.initialize();\n    }\n\n    return new Promise((resolve, reject) => {\n      if (!this.db) {\n        reject(new Error('Database not initialized'));\n        return;\n      }\n\n      const transaction = this.db.transaction([this.storeName], 'readonly');\n      const objectStore = transaction.objectStore(this.storeName);\n      const request = objectStore.count();\n\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(new Error('Failed to get queue size'));\n    });\n  }\n\n  private async cleanupExpiredItems(): Promise<void> {\n    if (!this.db) return;\n\n    const cutoffTime = Date.now() - this.maxAge;\n\n    return new Promise((resolve) => {\n      if (!this.db) {\n        resolve();\n        return;\n      }\n\n      const transaction = this.db.transaction([this.storeName], 'readwrite');\n      const objectStore = transaction.objectStore(this.storeName);\n      const index = objectStore.index('timestamp');\n      const range = IDBKeyRange.upperBound(cutoffTime);\n      const request = index.openCursor(range);\n\n      request.onsuccess = (event) => {\n        const cursor = (event.target as IDBRequest).result;\n        if (cursor) {\n          cursor.delete();\n          cursor.continue();\n        } else {\n          resolve();\n        }\n      };\n\n      request.onerror = () => resolve();\n    });\n  }\n\n  private async removeOldestItems(count: number): Promise<void> {\n    if (!this.db) return;\n\n    return new Promise((resolve) => {\n      if (!this.db) {\n        resolve();\n        return;\n      }\n\n      const transaction = this.db.transaction([this.storeName], 'readwrite');\n      const objectStore = transaction.objectStore(this.storeName);\n      const index = objectStore.index('timestamp');\n      const request = index.openCursor();\n\n      let deletedCount = 0;\n      request.onsuccess = (event) => {\n        const cursor = (event.target as IDBRequest).result;\n        if (cursor && deletedCount < count) {\n          cursor.delete();\n          deletedCount++;\n          cursor.continue();\n        } else {\n          resolve();\n        }\n      };\n\n      request.onerror = () => resolve();\n    });\n  }\n\n  private async compress(data: any): Promise<string> {\n    try {\n      const json = JSON.stringify(data);\n      // Simple base64 compression for now - can be upgraded to gzip\n      return btoa(unescape(encodeURIComponent(json)));\n    } catch (error) {\n      // Fallback to uncompressed JSON string\n      return JSON.stringify(data);\n    }\n  }\n\n  private async decompress(data: string): Promise<any> {\n    try {\n      // Try to decode base64 first\n      const decoded = decodeURIComponent(escape(atob(data)));\n      return JSON.parse(decoded);\n    } catch (error) {\n      // Fallback to direct JSON parse\n      try {\n        return JSON.parse(data);\n      } catch (parseError) {\n        return data;\n      }\n    }\n  }\n\n  private generateId(): string {\n    return `revi-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n}","import { IndexedDBStorage } from './indexed-db-storage';\nimport { getLocalStorage } from './utils';\nimport type { ErrorEvent, SessionEvent, NetworkEvent } from './types';\n\ninterface StorageInterface {\n  store(type: 'error' | 'session' | 'network', data: any): Promise<void>;\n  getAll(): Promise<{ errors: ErrorEvent[]; sessionEvents: SessionEvent[]; networkEvents: NetworkEvent[] }>;\n  clear(): Promise<void>;\n  getQueueSize?(): Promise<number>;\n}\n\nclass LocalStorageAdapter implements StorageInterface {\n  private storage: Storage;\n  private storageKey = 'revi_upload_queue';\n\n  constructor() {\n    const localStorage = getLocalStorage();\n    if (!localStorage) {\n      throw new Error('No storage available');\n    }\n    this.storage = localStorage;\n  }\n\n  async store(type: 'error' | 'session' | 'network', data: any): Promise<void> {\n    try {\n      const existing = await this.getAll();\n      \n      switch (type) {\n        case 'error':\n          existing.errors.push(...(Array.isArray(data) ? data : [data]));\n          break;\n        case 'session':\n          existing.sessionEvents.push(...(Array.isArray(data) ? data : [data]));\n          break;\n        case 'network':\n          existing.networkEvents.push(...(Array.isArray(data) ? data : [data]));\n          break;\n      }\n\n      this.storage.setItem(this.storageKey, JSON.stringify(existing));\n    } catch (error) {\n      // Storage quota exceeded or other error\n      throw new Error('Failed to store data');\n    }\n  }\n\n  async getAll(): Promise<{ errors: ErrorEvent[]; sessionEvents: SessionEvent[]; networkEvents: NetworkEvent[] }> {\n    try {\n      const storedData = this.storage.getItem(this.storageKey);\n      if (storedData) {\n        return JSON.parse(storedData);\n      }\n    } catch (error) {\n      // Failed to parse or retrieve data\n    }\n    \n    return {\n      errors: [],\n      sessionEvents: [],\n      networkEvents: []\n    };\n  }\n\n  async clear(): Promise<void> {\n    try {\n      this.storage.removeItem(this.storageKey);\n    } catch (error) {\n      // Ignore errors\n    }\n  }\n}\n\nexport class StorageManager {\n  private storage: StorageInterface | null = null;\n  private isInitialized = false;\n\n  async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n\n    try {\n      // Try IndexedDB first\n      const indexedDB = new IndexedDBStorage();\n      await indexedDB.initialize();\n      this.storage = indexedDB;\n      console.log('[Revi] Using IndexedDB for offline storage');\n    } catch (error) {\n      // Fallback to localStorage\n      try {\n        this.storage = new LocalStorageAdapter();\n        console.log('[Revi] Using localStorage for offline storage');\n      } catch (localStorageError) {\n        console.warn('[Revi] No storage available, data will not persist offline');\n        this.storage = new NoOpStorage();\n      }\n    }\n\n    this.isInitialized = true;\n  }\n\n  async storeErrors(errors: ErrorEvent[]): Promise<void> {\n    await this.ensureInitialized();\n    if (errors.length > 0) {\n      await this.storage!.store('error', errors);\n    }\n  }\n\n  async storeSessionEvents(events: SessionEvent[]): Promise<void> {\n    await this.ensureInitialized();\n    if (events.length > 0) {\n      await this.storage!.store('session', events);\n    }\n  }\n\n  async storeNetworkEvents(events: NetworkEvent[]): Promise<void> {\n    await this.ensureInitialized();\n    if (events.length > 0) {\n      await this.storage!.store('network', events);\n    }\n  }\n\n  async getAllData(): Promise<{ errors: ErrorEvent[]; sessionEvents: SessionEvent[]; networkEvents: NetworkEvent[] }> {\n    await this.ensureInitialized();\n    return await this.storage!.getAll();\n  }\n\n  async clearAll(): Promise<void> {\n    await this.ensureInitialized();\n    await this.storage!.clear();\n  }\n\n  async getQueueSize(): Promise<number> {\n    await this.ensureInitialized();\n    if (this.storage && 'getQueueSize' in this.storage && this.storage.getQueueSize) {\n      return await this.storage.getQueueSize();\n    } else {\n      // Fallback for localStorage\n      const data = await this.getAllData();\n      return data.errors.length + data.sessionEvents.length + data.networkEvents.length;\n    }\n  }\n\n  private async ensureInitialized(): Promise<void> {\n    if (!this.isInitialized) {\n      await this.initialize();\n    }\n  }\n}\n\nclass NoOpStorage implements StorageInterface {\n  async store(): Promise<void> {\n    // Do nothing\n  }\n\n  async getAll(): Promise<{ errors: ErrorEvent[]; sessionEvents: SessionEvent[]; networkEvents: NetworkEvent[] }> {\n    return {\n      errors: [],\n      sessionEvents: [],\n      networkEvents: []\n    };\n  }\n\n  async clear(): Promise<void> {\n    // Do nothing\n  }\n}","export class NetworkManager {\n  private isOnline = typeof navigator !== 'undefined' ? navigator.onLine : true;\n  private connectionType: string = 'unknown';\n  private listeners: Array<(online: boolean) => void> = [];\n\n  constructor() {\n    if (typeof window !== 'undefined') {\n      // Listen for online/offline events\n      window.addEventListener('online', () => {\n        this.isOnline = true;\n        this.notifyListeners(true);\n      });\n\n      window.addEventListener('offline', () => {\n        this.isOnline = false;\n        this.notifyListeners(false);\n      });\n\n      // Detect connection type if available\n      this.detectConnectionType();\n    }\n  }\n\n  getConnectionStatus(): { online: boolean; connectionType: string } {\n    return {\n      online: this.isOnline,\n      connectionType: this.connectionType\n    };\n  }\n\n  onConnectionChange(callback: (online: boolean) => void): () => void {\n    this.listeners.push(callback);\n    \n    // Return unsubscribe function\n    return () => {\n      const index = this.listeners.indexOf(callback);\n      if (index > -1) {\n        this.listeners.splice(index, 1);\n      }\n    };\n  }\n\n  getBatchSize(): number {\n    if (!this.isOnline) {\n      return 0; // Don't upload when offline\n    }\n\n    // Adjust batch size based on connection quality\n    switch (this.connectionType) {\n      case 'slow-2g':\n        return 5;\n      case '2g':\n        return 10;\n      case '3g':\n        return 25;\n      case '4g':\n        return 50;\n      default:\n        return 25;\n    }\n  }\n\n  getUploadDelay(): number {\n    if (!this.isOnline) {\n      return 0; // Don't upload when offline\n    }\n\n    // Adjust upload frequency based on connection\n    switch (this.connectionType) {\n      case 'slow-2g':\n        return 30000; // 30 seconds\n      case '2g':\n        return 15000; // 15 seconds\n      case '3g':\n        return 10000; // 10 seconds\n      case '4g':\n        return 5000;  // 5 seconds\n      default:\n        return 10000; // 10 seconds\n    }\n  }\n\n  shouldRetry(attempt: number): boolean {\n    if (!this.isOnline) {\n      return false; // Don't retry when offline\n    }\n\n    // Exponential backoff with max attempts\n    const maxAttempts = 5;\n    return attempt < maxAttempts;\n  }\n\n  getRetryDelay(attempt: number): number {\n    // Exponential backoff: 1s, 2s, 4s, 8s, 16s\n    return Math.min(1000 * Math.pow(2, attempt), 16000);\n  }\n\n  private detectConnectionType(): void {\n    if ('connection' in navigator) {\n      const connection = (navigator as any).connection;\n      this.connectionType = connection.effectiveType || connection.type || 'unknown';\n      \n      // Listen for connection changes\n      connection.addEventListener('change', () => {\n        this.connectionType = connection.effectiveType || connection.type || 'unknown';\n      });\n    }\n  }\n\n  private notifyListeners(online: boolean): void {\n    this.listeners.forEach(callback => {\n      try {\n        callback(online);\n      } catch (error) {\n        console.error('[Revi] Error in connection change callback:', error);\n      }\n    });\n  }\n\n  // Ping test to verify actual connectivity\n  async testConnectivity(url?: string): Promise<boolean> {\n    if (!this.isOnline) {\n      return false;\n    }\n\n    try {\n      const testUrl = url || 'https://api.revi.dev/health';\n      const response = await fetch(testUrl, {\n        method: 'HEAD',\n        mode: 'no-cors',\n        cache: 'no-cache'\n      });\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n}","// Simple compression utilities for data transmission\n\n// Basic gzip-like compression using built-in compression APIs\nexport async function compressData(data: any): Promise<{ data: string; compressed: boolean }> {\n  const jsonString = JSON.stringify(data);\n  \n  // Only compress if the data is large enough to benefit\n  if (jsonString.length < 1024) {\n    return { data: jsonString, compressed: false };\n  }\n\n  try {\n    // Use CompressionStream if available (modern browsers)\n    if (typeof CompressionStream !== 'undefined') {\n      const stream = new CompressionStream('gzip');\n      const writer = stream.writable.getWriter();\n      const reader = stream.readable.getReader();\n      \n      // Write the JSON string as UTF-8 bytes\n      const encoder = new TextEncoder();\n      const bytes = encoder.encode(jsonString);\n      \n      await writer.write(bytes);\n      await writer.close();\n      \n      // Read compressed data\n      const compressed = [];\n      let done = false;\n      \n      while (!done) {\n        const { value, done: readerDone } = await reader.read();\n        done = readerDone;\n        if (value) {\n          compressed.push(value);\n        }\n      }\n      \n      // Combine all chunks and convert to base64\n      const compressedBytes = new Uint8Array(\n        compressed.reduce((acc, chunk) => acc + chunk.length, 0)\n      );\n      \n      let offset = 0;\n      for (const chunk of compressed) {\n        compressedBytes.set(chunk, offset);\n        offset += chunk.length;\n      }\n      \n      const base64 = btoa(String.fromCharCode(...compressedBytes));\n      \n      // Only return compressed if it's actually smaller\n      if (base64.length < jsonString.length * 0.8) {\n        return { data: base64, compressed: true };\n      }\n    }\n  } catch (error) {\n    console.warn('[Revi] Compression failed, sending uncompressed data:', error);\n  }\n  \n  // Fallback to uncompressed data\n  return { data: jsonString, compressed: false };\n}\n\n// Simple string compression for older browsers\nexport function compressString(str: string): string {\n  // Simple run-length encoding for repeated patterns\n  let compressed = '';\n  let i = 0;\n  \n  while (i < str.length) {\n    let count = 1;\n    const char = str[i];\n    \n    // Count consecutive characters\n    while (i + count < str.length && str[i + count] === char && count < 99) {\n      count++;\n    }\n    \n    if (count > 3) {\n      compressed += `${char}${count}`;\n    } else {\n      compressed += char.repeat(count);\n    }\n    \n    i += count;\n  }\n  \n  return compressed.length < str.length ? compressed : str;\n}\n\n// Deduplicate arrays of objects with similar keys\nexport function deduplicateEvents<T extends Record<string, any>>(events: T[]): {\n  events: T[];\n  compressionRatio: number;\n} {\n  if (events.length === 0) return { events, compressionRatio: 1 };\n  \n  const originalSize = JSON.stringify(events).length;\n  \n  // Group events by type/structure\n  const grouped = new Map<string, T[]>();\n  \n  for (const event of events) {\n    const keys = Object.keys(event).sort().join(',');\n    if (!grouped.has(keys)) {\n      grouped.set(keys, []);\n    }\n    grouped.get(keys)!.push(event);\n  }\n  \n  // Compress each group separately\n  const compressed: T[] = [];\n  \n  for (const [keys, groupedEvents] of grouped) {\n    if (groupedEvents.length === 1) {\n      compressed.push(groupedEvents[0]);\n      continue;\n    }\n    \n    // Extract common values\n    const commonValues: Record<string, any> = {};\n    const keyArray = keys.split(',');\n    \n    for (const key of keyArray) {\n      const values = groupedEvents.map(e => e[key]);\n      const firstValue = values[0];\n      \n      if (values.every(v => \n        JSON.stringify(v) === JSON.stringify(firstValue)\n      )) {\n        commonValues[key] = firstValue;\n      }\n    }\n    \n    // Create compressed events\n    for (const event of groupedEvents) {\n      const compressedEvent: any = { ...event };\n      \n      // Remove common values (they're implicit)\n      for (const key of Object.keys(commonValues)) {\n        if (JSON.stringify(event[key]) === JSON.stringify(commonValues[key])) {\n          delete compressedEvent[key];\n        }\n      }\n      \n      // Add common values reference if significant compression\n      if (Object.keys(commonValues).length > 2) {\n        compressedEvent._common = commonValues;\n      }\n      \n      compressed.push(compressedEvent);\n    }\n  }\n  \n  const compressedSize = JSON.stringify(compressed).length;\n  const compressionRatio = compressedSize / originalSize;\n  \n  return { events: compressed, compressionRatio };\n}\n\n// Batch events intelligently based on size and type\nexport function createOptimalBatches<T>(\n  events: T[],\n  maxBatchSize: number,\n  maxBatchBytes: number = 64 * 1024 // 64KB default\n): T[][] {\n  if (events.length === 0) return [];\n  \n  const batches: T[][] = [];\n  let currentBatch: T[] = [];\n  let currentBatchSize = 0;\n  \n  for (const event of events) {\n    const eventSize = JSON.stringify(event).length;\n    \n    // Start new batch if current would exceed limits\n    if (\n      currentBatch.length >= maxBatchSize ||\n      currentBatchSize + eventSize > maxBatchBytes\n    ) {\n      if (currentBatch.length > 0) {\n        batches.push(currentBatch);\n        currentBatch = [];\n        currentBatchSize = 0;\n      }\n    }\n    \n    currentBatch.push(event);\n    currentBatchSize += eventSize;\n  }\n  \n  // Don't forget the last batch\n  if (currentBatch.length > 0) {\n    batches.push(currentBatch);\n  }\n  \n  return batches;\n}","import { StorageManager } from './storage-manager';\nimport { NetworkManager } from './network-manager';\nimport { compressData, deduplicateEvents, createOptimalBatches } from './compression-utils';\nimport type { ErrorEvent, SessionEvent, NetworkEvent, ReviConfig } from './types';\n\nexport class DataManager {\n  private config: ReviConfig;\n  private storageManager: StorageManager;\n  private networkManager: NetworkManager;\n  private uploadTimer: NodeJS.Timeout | null = null;\n  private isUploading = false;\n  private retryAttempts = new Map<string, number>();\n  private uploadQueue: {\n    errors: ErrorEvent[];\n    sessionEvents: SessionEvent[];\n    networkEvents: NetworkEvent[];\n  } = {\n    errors: [],\n    sessionEvents: [],\n    networkEvents: []\n  };\n\n  constructor(config: ReviConfig) {\n    this.config = config;\n    this.storageManager = new StorageManager();\n    this.networkManager = new NetworkManager();\n    \n    this.initialize();\n  }\n\n  private async initialize(): Promise<void> {\n    try {\n      await this.storageManager.initialize();\n      await this.loadQueueFromStorage();\n      this.startNetworkAwareUploadTimer();\n      this.setupBeforeUnloadHandler();\n      this.setupNetworkChangeHandler();\n    } catch (error) {\n      console.error('[Revi] Failed to initialize data manager:', error);\n    }\n  }\n\n  private async loadQueueFromStorage(): Promise<void> {\n    try {\n      const storedData = await this.storageManager.getAllData();\n      this.uploadQueue = storedData;\n    } catch (error) {\n      console.error('[Revi] Failed to load queue from storage:', error);\n    }\n  }\n\n  private async saveQueueToStorage(): Promise<void> {\n    try {\n      await this.storageManager.clearAll();\n      if (this.uploadQueue.errors.length > 0) {\n        await this.storageManager.storeErrors(this.uploadQueue.errors);\n      }\n      if (this.uploadQueue.sessionEvents.length > 0) {\n        await this.storageManager.storeSessionEvents(this.uploadQueue.sessionEvents);\n      }\n      if (this.uploadQueue.networkEvents.length > 0) {\n        await this.storageManager.storeNetworkEvents(this.uploadQueue.networkEvents);\n      }\n    } catch (error) {\n      console.error('[Revi] Failed to save queue to storage:', error);\n    }\n  }\n\n  private startNetworkAwareUploadTimer(): void {\n    const scheduleNextUpload = () => {\n      if (this.uploadTimer) {\n        clearTimeout(this.uploadTimer);\n      }\n\n      const delay = this.networkManager.getUploadDelay();\n      if (delay > 0) {\n        this.uploadTimer = setTimeout(() => {\n          if (!this.isUploading && this.hasQueuedData()) {\n            this.uploadData().finally(() => {\n              scheduleNextUpload();\n            });\n          } else {\n            scheduleNextUpload();\n          }\n        }, delay);\n      }\n    };\n\n    scheduleNextUpload();\n  }\n\n  private setupNetworkChangeHandler(): void {\n    this.networkManager.onConnectionChange((online) => {\n      if (online) {\n        console.log('[Revi] Network connection restored, resuming uploads');\n        if (this.hasQueuedData() && !this.isUploading) {\n          // Wait a bit before starting uploads to ensure connection is stable\n          setTimeout(() => {\n            this.uploadData();\n          }, 1000);\n        }\n      } else {\n        console.log('[Revi] Network connection lost, uploads paused');\n      }\n    });\n  }\n\n  private setupBeforeUnloadHandler(): void {\n    if (typeof window === 'undefined') return;\n\n    window.addEventListener('beforeunload', () => {\n      if (this.hasQueuedData()) {\n        this.uploadDataSync();\n      }\n    });\n  }\n\n  queueError(error: ErrorEvent): void {\n    this.uploadQueue.errors.push(error);\n    this.saveQueueToStorage().catch(err => {\n      console.error('[Revi] Failed to save error to storage:', err);\n    });\n  }\n\n  queueSessionEvents(events: SessionEvent[]): void {\n    this.uploadQueue.sessionEvents.push(...events);\n    this.saveQueueToStorage().catch(err => {\n      console.error('[Revi] Failed to save session events to storage:', err);\n    });\n  }\n\n  queueNetworkEvents(events: NetworkEvent[]): void {\n    this.uploadQueue.networkEvents.push(...events);\n    this.saveQueueToStorage().catch(err => {\n      console.error('[Revi] Failed to save network events to storage:', err);\n    });\n  }\n\n  private hasQueuedData(): boolean {\n    return this.uploadQueue.errors.length > 0 ||\n           this.uploadQueue.sessionEvents.length > 0 ||\n           this.uploadQueue.networkEvents.length > 0;\n  }\n\n  private async uploadData(): Promise<void> {\n    if (this.isUploading || !this.hasQueuedData()) return;\n\n    const { online } = this.networkManager.getConnectionStatus();\n    if (!online) {\n      console.log('[Revi] Skipping upload - device is offline');\n      return;\n    }\n\n    this.isUploading = true;\n    const apiUrl = this.config.apiUrl || 'https://api.revi.dev';\n    const batchSize = this.networkManager.getBatchSize();\n\n    try {\n      // Upload errors in optimized batches with compression\n      if (this.uploadQueue.errors.length > 0) {\n        const { events: dedupedErrors } = deduplicateEvents(this.uploadQueue.errors);\n        const errorBatches = createOptimalBatches(dedupedErrors, batchSize, 32 * 1024);\n        for (const batch of errorBatches) {\n          await this.uploadErrorsWithRetry(apiUrl, batch);\n        }\n        this.uploadQueue.errors = [];\n      }\n\n      // Upload session events in optimized batches with compression\n      if (this.uploadQueue.sessionEvents.length > 0) {\n        const { events: dedupedEvents } = deduplicateEvents(this.uploadQueue.sessionEvents);\n        const sessionBatches = createOptimalBatches(dedupedEvents, batchSize, 64 * 1024);\n        for (const batch of sessionBatches) {\n          await this.uploadSessionEventsWithRetry(apiUrl, batch);\n        }\n        this.uploadQueue.sessionEvents = [];\n      }\n\n      // Upload network events in optimized batches with compression\n      if (this.uploadQueue.networkEvents.length > 0) {\n        const { events: dedupedEvents } = deduplicateEvents(this.uploadQueue.networkEvents);\n        const networkBatches = createOptimalBatches(dedupedEvents, batchSize, 48 * 1024);\n        for (const batch of networkBatches) {\n          await this.uploadNetworkEventsWithRetry(apiUrl, batch);\n        }\n        this.uploadQueue.networkEvents = [];\n      }\n\n      await this.saveQueueToStorage();\n      \n      // Reset retry attempts on successful upload\n      this.retryAttempts.clear();\n      \n    } catch (error) {\n      if (this.config.debug) {\n        console.error('Revi: Failed to upload data', error);\n      }\n      // Keep data in queue for retry\n    } finally {\n      this.isUploading = false;\n    }\n  }\n\n  private createBatches<T>(items: T[], batchSize: number): T[][] {\n    if (batchSize <= 0) return [];\n    \n    const batches: T[][] = [];\n    for (let i = 0; i < items.length; i += batchSize) {\n      batches.push(items.slice(i, i + batchSize));\n    }\n    return batches;\n  }\n\n  private uploadDataSync(): void {\n    if (!this.hasQueuedData()) return;\n\n    const apiUrl = this.config.apiUrl || 'https://api.revi.dev';\n\n    // Use sendBeacon for synchronous upload on page unload\n    if (navigator.sendBeacon) {\n      if (this.uploadQueue.errors.length > 0) {\n        const payload = JSON.stringify({ errors: this.uploadQueue.errors });\n        navigator.sendBeacon(`${apiUrl}/api/capture/error`, payload);\n      }\n\n      if (this.uploadQueue.sessionEvents.length > 0) {\n        const payload = JSON.stringify({ \n          session_id: this.uploadQueue.sessionEvents[0]?.sessionId,\n          events: this.uploadQueue.sessionEvents.map(e => ({\n            event_type: e.type,\n            data: e.data,\n            timestamp: e.timestamp,\n            session_id: e.sessionId\n          }))\n        });\n        navigator.sendBeacon(`${apiUrl}/api/capture/session-event`, payload);\n      }\n\n      if (this.uploadQueue.networkEvents.length > 0) {\n        const payload = JSON.stringify({ events: this.uploadQueue.networkEvents });\n        navigator.sendBeacon(`${apiUrl}/api/capture/network-event`, payload);\n      }\n    }\n  }\n\n  private async uploadErrors(apiUrl: string, errors: ErrorEvent[]): Promise<void> {\n    const payload = {\n      errors: errors.map(error => ({\n        message: error.message,\n        stack_trace: error.stack,\n        url: error.url,\n        user_agent: error.userAgent,\n        session_id: error.sessionId,\n        metadata: {\n          id: error.id,\n          userId: error.userId,\n          environment: error.environment,\n          release: error.release,\n          tags: error.tags,\n          extra: error.extra,\n          breadcrumbs: error.breadcrumbs,\n          level: error.level,\n          lineno: error.lineno,\n          colno: error.colno,\n          filename: error.filename\n        }\n      }))\n    };\n\n    const { data: compressedData, compressed } = await compressData(payload);\n    \n    const headers: Record<string, string> = {\n      'X-API-Key': this.config.apiKey\n    };\n    \n    if (compressed) {\n      headers['Content-Type'] = 'application/octet-stream';\n      headers['Content-Encoding'] = 'gzip';\n      headers['X-Original-Content-Type'] = 'application/json';\n    } else {\n      headers['Content-Type'] = 'application/json';\n    }\n\n    const response = await fetch(`${apiUrl}/api/capture/error`, {\n      method: 'POST',\n      headers,\n      body: compressedData\n    });\n\n    if (!response.ok) {\n      throw new Error(`Upload failed: ${response.status}`);\n    }\n  }\n\n  private async uploadSessionEvents(apiUrl: string, events: SessionEvent[]): Promise<void> {\n    if (events.length === 0) return;\n\n    const sessionId = events[0].sessionId;\n    const payload = {\n      session_id: sessionId,\n      events: events.map(event => ({\n        event_type: event.type,\n        data: event.data,\n        timestamp: event.timestamp,\n        session_id: event.sessionId\n      }))\n    };\n\n    const { data: compressedData, compressed } = await compressData(payload);\n    \n    const headers: Record<string, string> = {\n      'X-API-Key': this.config.apiKey\n    };\n    \n    if (compressed) {\n      headers['Content-Type'] = 'application/octet-stream';\n      headers['Content-Encoding'] = 'gzip';\n      headers['X-Original-Content-Type'] = 'application/json';\n    } else {\n      headers['Content-Type'] = 'application/json';\n    }\n\n    const response = await fetch(`${apiUrl}/api/capture/session-event`, {\n      method: 'POST',\n      headers,\n      body: compressedData\n    });\n\n    if (!response.ok) {\n      throw new Error(`Upload failed: ${response.status}`);\n    }\n  }\n\n  private async uploadNetworkEvents(apiUrl: string, events: NetworkEvent[]): Promise<void> {\n    const promises = events.map(event => \n      fetch(`${apiUrl}/api/capture/network-event`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-API-Key': this.config.apiKey\n        },\n        body: JSON.stringify({\n          session_id: event.sessionId,\n          events: [{\n            method: event.method,\n            url: event.url,\n            status_code: event.statusCode,\n            response_time: event.responseTime,\n            timestamp: event.timestamp,\n            session_id: event.sessionId,\n            request_data: {\n              headers: event.requestHeaders || {},\n              body: event.requestBody || null,\n              size: event.requestSize || 0\n            },\n            response_data: {\n              headers: event.responseHeaders || {},\n              body: event.responseBody || null,\n              size: event.responseSize || 0\n            }\n          }]\n        })\n      })\n    );\n\n    const responses = await Promise.allSettled(promises);\n    const failures = responses.filter(r => r.status === 'rejected');\n    \n    if (failures.length > 0) {\n      throw new Error(`${failures.length} network event uploads failed`);\n    }\n  }\n\n  private async uploadErrorsWithRetry(apiUrl: string, errors: ErrorEvent[]): Promise<void> {\n    const key = 'errors';\n    return this.executeWithRetry(key, () => this.uploadErrors(apiUrl, errors));\n  }\n\n  private async uploadSessionEventsWithRetry(apiUrl: string, events: SessionEvent[]): Promise<void> {\n    const key = 'session_events';\n    return this.executeWithRetry(key, () => this.uploadSessionEvents(apiUrl, events));\n  }\n\n  private async uploadNetworkEventsWithRetry(apiUrl: string, events: NetworkEvent[]): Promise<void> {\n    const key = 'network_events';  \n    return this.executeWithRetry(key, () => this.uploadNetworkEvents(apiUrl, events));\n  }\n\n  private async executeWithRetry<T>(key: string, operation: () => Promise<T>): Promise<T> {\n    const currentAttempt = this.retryAttempts.get(key) || 0;\n\n    if (!this.networkManager.shouldRetry(currentAttempt)) {\n      throw new Error(`Max retry attempts exceeded for ${key}`);\n    }\n\n    try {\n      const result = await operation();\n      this.retryAttempts.delete(key); // Success, reset retry count\n      return result;\n    } catch (error) {\n      this.retryAttempts.set(key, currentAttempt + 1);\n      \n      if (this.networkManager.shouldRetry(currentAttempt + 1)) {\n        const delay = this.networkManager.getRetryDelay(currentAttempt + 1);\n        console.log(`[Revi] Upload failed for ${key}, retrying in ${delay}ms (attempt ${currentAttempt + 2})`);\n        \n        await new Promise(resolve => setTimeout(resolve, delay));\n        return this.executeWithRetry(key, operation);\n      } else {\n        console.error(`[Revi] Max retry attempts exceeded for ${key}:`, error);\n        throw error;\n      }\n    }\n  }\n\n  async clearQueue(): Promise<void> {\n    this.uploadQueue = {\n      errors: [],\n      sessionEvents: [],\n      networkEvents: []\n    };\n    \n    await this.storageManager.clearAll();\n  }\n\n  destroy(): void {\n    if (this.uploadTimer) {\n      clearTimeout(this.uploadTimer);\n      this.uploadTimer = null;\n    }\n    \n    // Final upload attempt\n    if (this.hasQueuedData()) {\n      this.uploadDataSync();\n    }\n  }\n}\n","import type { ReviConfig } from './types';\nimport { generateId } from './utils';\nimport crypto from 'crypto';\n\nexport interface JourneyEvent {\n  event_type: 'page_view' | 'click' | 'form_submit' | 'api_call' | 'error';\n  url: string;\n  referrer?: string;\n  timestamp: number;\n  duration_ms?: number;\n  metadata: Record<string, any>;\n}\n\nexport interface DeviceFingerprint {\n  screen_resolution: string;\n  color_depth: number;\n  timezone: string;\n  language: string;\n  platform: string;\n  user_agent: string;\n  canvas_fingerprint?: string;\n  webgl_fingerprint?: string;\n}\n\n/**\n * Advanced user journey tracking with device fingerprinting\n */\nexport class UserJourneyTracker {\n  private config: ReviConfig;\n  private userId?: string;\n  private deviceFingerprint: string;\n  private sessionStartTime: number;\n  private currentPageStartTime: number;\n  private journeyEvents: JourneyEvent[] = [];\n  private isTracking = false;\n\n  constructor(config: ReviConfig) {\n    this.config = config;\n    this.deviceFingerprint = this.generateDeviceFingerprint();\n    this.sessionStartTime = Date.now();\n    this.currentPageStartTime = Date.now();\n    \n    if (typeof window !== 'undefined') {\n      this.setupJourneyTracking();\n    }\n  }\n\n  /**\n   * Start tracking user journey\n   */\n  startTracking(userId?: string): void {\n    this.userId = userId;\n    this.isTracking = true;\n    \n    // Track initial page view\n    this.trackPageView();\n    \n    if (this.config.debug) {\n      console.log('Revi: User journey tracking started', { userId, deviceFingerprint: this.deviceFingerprint });\n    }\n  }\n\n  /**\n   * Stop tracking user journey\n   */\n  stopTracking(): void {\n    this.isTracking = false;\n    this.flush();\n  }\n\n  /**\n   * Set user ID for tracking\n   */\n  setUserId(userId: string): void {\n    this.userId = userId;\n  }\n\n  /**\n   * Track page view with timing\n   */\n  private trackPageView(): void {\n    if (!this.isTracking) return;\n\n    const event: JourneyEvent = {\n      event_type: 'page_view',\n      url: window.location.href,\n      referrer: document.referrer || undefined,\n      timestamp: Date.now(),\n      metadata: {\n        title: document.title,\n        viewport: {\n          width: window.innerWidth,\n          height: window.innerHeight\n        },\n        scroll_position: {\n          x: window.scrollX,\n          y: window.scrollY\n        },\n        device_fingerprint: this.deviceFingerprint,\n        user_agent: navigator.userAgent,\n        language: navigator.language,\n        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n        connection_type: this.getConnectionType()\n      }\n    };\n\n    this.addJourneyEvent(event);\n  }\n\n  /**\n   * Track user clicks with context\n   */\n  private trackClick(element: HTMLElement, event: MouseEvent): void {\n    if (!this.isTracking) return;\n\n    const journeyEvent: JourneyEvent = {\n      event_type: 'click',\n      url: window.location.href,\n      timestamp: Date.now(),\n      metadata: {\n        element: {\n          tag: element.tagName.toLowerCase(),\n          id: element.id,\n          class: element.className,\n          text: this.getElementText(element),\n          attributes: this.getRelevantAttributes(element)\n        },\n        coordinates: {\n          x: event.clientX,\n          y: event.clientY,\n          page_x: event.pageX,\n          page_y: event.pageY\n        },\n        viewport: {\n          width: window.innerWidth,\n          height: window.innerHeight\n        },\n        scroll_position: {\n          x: window.scrollX,\n          y: window.scrollY\n        }\n      }\n    };\n\n    this.addJourneyEvent(journeyEvent);\n  }\n\n  /**\n   * Track form submissions\n   */\n  private trackFormSubmit(form: HTMLFormElement): void {\n    if (!this.isTracking) return;\n\n    const formData = new FormData(form);\n    const fields: Record<string, any> = {};\n    \n    formData.forEach((value, key) => {\n      // Only track field names and types, not values for privacy\n      const input = form.querySelector(`[name=\"${key}\"]`) as HTMLInputElement;\n      fields[key] = {\n        type: input?.type || 'unknown',\n        has_value: !!value,\n        value_length: typeof value === 'string' ? value.length : 0\n      };\n    });\n\n    const journeyEvent: JourneyEvent = {\n      event_type: 'form_submit',\n      url: window.location.href,\n      timestamp: Date.now(),\n      metadata: {\n        form: {\n          id: form.id,\n          class: form.className,\n          method: form.method,\n          action: form.action,\n          field_count: formData.entries().length\n        },\n        fields: this.config.privacy?.maskInputs ? {} : fields\n      }\n    };\n\n    this.addJourneyEvent(journeyEvent);\n  }\n\n  /**\n   * Track API calls and their performance\n   */\n  trackApiCall(url: string, method: string, status: number, duration: number, size?: number): void {\n    if (!this.isTracking) return;\n\n    const journeyEvent: JourneyEvent = {\n      event_type: 'api_call',\n      url: window.location.href,\n      timestamp: Date.now(),\n      duration_ms: duration,\n      metadata: {\n        api: {\n          url,\n          method,\n          status,\n          duration,\n          size: size || 0,\n          success: status >= 200 && status < 300\n        },\n        page_context: {\n          title: document.title,\n          time_on_page: Date.now() - this.currentPageStartTime\n        }\n      }\n    };\n\n    this.addJourneyEvent(journeyEvent);\n  }\n\n  /**\n   * Track errors in user journey context\n   */\n  trackError(error: Error, context?: Record<string, any>): void {\n    if (!this.isTracking) return;\n\n    const journeyEvent: JourneyEvent = {\n      event_type: 'error',\n      url: window.location.href,\n      timestamp: Date.now(),\n      metadata: {\n        error: {\n          message: error.message,\n          name: error.name,\n          stack: error.stack?.split('\\n').slice(0, 5).join('\\n') // Limit stack trace\n        },\n        user_context: {\n          time_on_page: Date.now() - this.currentPageStartTime,\n          session_duration: Date.now() - this.sessionStartTime,\n          page_interactions: this.countPageInteractions()\n        },\n        custom_context: context || {}\n      }\n    };\n\n    this.addJourneyEvent(journeyEvent);\n  }\n\n  /**\n   * Setup event listeners for journey tracking\n   */\n  private setupJourneyTracking(): void {\n    // Track page views on navigation\n    let currentUrl = window.location.href;\n    \n    const handleNavigation = () => {\n      if (window.location.href !== currentUrl) {\n        // Track time spent on previous page\n        const timeSpent = Date.now() - this.currentPageStartTime;\n        this.updateLastPageViewDuration(timeSpent);\n        \n        // Track new page view\n        currentUrl = window.location.href;\n        this.currentPageStartTime = Date.now();\n        this.trackPageView();\n      }\n    };\n\n    // Handle navigation events\n    window.addEventListener('popstate', handleNavigation);\n    \n    // Override pushState and replaceState to catch programmatic navigation\n    const originalPushState = history.pushState;\n    const originalReplaceState = history.replaceState;\n    \n    history.pushState = function(...args) {\n      originalPushState.apply(history, args);\n      setTimeout(handleNavigation, 0);\n    };\n    \n    history.replaceState = function(...args) {\n      originalReplaceState.apply(history, args);\n      setTimeout(handleNavigation, 0);\n    };\n\n    // Track clicks\n    document.addEventListener('click', (event) => {\n      const target = event.target as HTMLElement;\n      if (target && this.shouldTrackClick(target)) {\n        this.trackClick(target, event);\n      }\n    }, { capture: true, passive: true });\n\n    // Track form submissions\n    document.addEventListener('submit', (event) => {\n      const form = event.target as HTMLFormElement;\n      if (form && form.tagName === 'FORM') {\n        this.trackFormSubmit(form);\n      }\n    }, { capture: true, passive: true });\n\n    // Track page exit\n    window.addEventListener('beforeunload', () => {\n      const timeSpent = Date.now() - this.currentPageStartTime;\n      this.updateLastPageViewDuration(timeSpent);\n      this.flush();\n    });\n\n    // Periodic flush\n    setInterval(() => {\n      if (this.journeyEvents.length > 0) {\n        this.flush();\n      }\n    }, 30000); // Flush every 30 seconds\n  }\n\n  /**\n   * Generate device fingerprint for user tracking\n   */\n  private generateDeviceFingerprint(): string {\n    if (typeof window === 'undefined') return 'server';\n\n    const components = [\n      navigator.userAgent,\n      navigator.language,\n      screen.width + 'x' + screen.height,\n      screen.colorDepth,\n      Intl.DateTimeFormat().resolvedOptions().timeZone,\n      navigator.platform,\n      navigator.cookieEnabled,\n      typeof window.localStorage !== 'undefined',\n      typeof window.sessionStorage !== 'undefined'\n    ];\n\n    // Add canvas fingerprint if available\n    try {\n      const canvas = document.createElement('canvas');\n      const ctx = canvas.getContext('2d');\n      if (ctx) {\n        ctx.textBaseline = 'top';\n        ctx.font = '14px Arial';\n        ctx.fillText('Device fingerprint', 2, 2);\n        components.push(canvas.toDataURL());\n      }\n    } catch (e) {\n      // Canvas fingerprinting failed\n    }\n\n    // Create hash of all components\n    const fingerprint = components.join('|');\n    \n    // Simple hash function (in production, use a proper crypto library)\n    let hash = 0;\n    for (let i = 0; i < fingerprint.length; i++) {\n      const char = fingerprint.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    \n    return Math.abs(hash).toString(36);\n  }\n\n  /**\n   * Add journey event to buffer\n   */\n  private addJourneyEvent(event: JourneyEvent): void {\n    this.journeyEvents.push(event);\n\n    // Auto-flush if buffer is full\n    if (this.journeyEvents.length >= 50) {\n      this.flush();\n    }\n  }\n\n  /**\n   * Flush journey events to backend\n   */\n  private flush(): void {\n    if (this.journeyEvents.length === 0) return;\n\n    const events = [...this.journeyEvents];\n    this.journeyEvents = [];\n\n    // Send to backend (implement based on your API structure)\n    this.sendJourneyEvents(events).catch(error => {\n      if (this.config.debug) {\n        console.error('Revi: Failed to send journey events', error);\n      }\n      // Re-add events to buffer for retry\n      this.journeyEvents.unshift(...events);\n    });\n  }\n\n  /**\n   * Send journey events to analytics backend\n   */\n  private async sendJourneyEvents(events: JourneyEvent[]): Promise<void> {\n    const apiUrl = this.config.apiUrl || 'https://api.revi.dev';\n    \n    // Send each event individually (could be optimized for batch sending)\n    const promises = events.map(event => \n      fetch(`${apiUrl}/api/analytics/user-event`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-API-Key': this.config.apiKey\n        },\n        body: JSON.stringify({\n          user_id: this.userId,\n          session_id: this.getSessionId(),\n          ...event\n        })\n      })\n    );\n\n    await Promise.allSettled(promises);\n  }\n\n  /**\n   * Helper methods\n   */\n  private shouldTrackClick(element: HTMLElement): boolean {\n    // Don't track clicks on sensitive elements\n    const tag = element.tagName.toLowerCase();\n    if (['input', 'textarea'].includes(tag)) {\n      const input = element as HTMLInputElement;\n      if (['password', 'hidden'].includes(input.type)) {\n        return false;\n      }\n    }\n\n    // Don't track if element has data-revi-ignore attribute\n    return !element.hasAttribute('data-revi-ignore');\n  }\n\n  private getElementText(element: HTMLElement): string {\n    const text = element.textContent || element.innerText || '';\n    return text.trim().substring(0, 100);\n  }\n\n  private getRelevantAttributes(element: HTMLElement): Record<string, string> {\n    const attrs: Record<string, string> = {};\n    const relevantAttrs = ['href', 'src', 'alt', 'title', 'data-testid', 'role'];\n    \n    relevantAttrs.forEach(attr => {\n      const value = element.getAttribute(attr);\n      if (value) {\n        attrs[attr] = value;\n      }\n    });\n    \n    return attrs;\n  }\n\n  private getConnectionType(): string {\n    if ('connection' in navigator) {\n      const connection = (navigator as any).connection;\n      return connection?.effectiveType || connection?.type || 'unknown';\n    }\n    return 'unknown';\n  }\n\n  private countPageInteractions(): number {\n    return this.journeyEvents.filter(event => \n      ['click', 'form_submit'].includes(event.event_type)\n    ).length;\n  }\n\n  private updateLastPageViewDuration(duration: number): void {\n    if (this.journeyEvents.length > 0) {\n      const lastEvent = this.journeyEvents[this.journeyEvents.length - 1];\n      if (lastEvent.event_type === 'page_view') {\n        lastEvent.duration_ms = duration;\n      }\n    }\n  }\n\n  private getSessionId(): string {\n    // This should be implemented to get session ID from session manager\n    // For now, return a placeholder\n    return 'session-' + Date.now();\n  }\n}","import type { ReviConfig } from './types';\n\nexport class SamplingManager {\n  private config: ReviConfig;\n  private activityLevel = 0;\n  private lastActivity = Date.now();\n  private errorFrequency = 0;\n  private performanceImpact = 0;\n  \n  constructor(config: ReviConfig) {\n    this.config = config;\n    this.startPerformanceMonitoring();\n  }\n\n  private startPerformanceMonitoring(): void {\n    // Monitor performance impact and adjust sampling\n    if (typeof window !== 'undefined' && 'performance' in window) {\n      setInterval(() => {\n        this.assessPerformanceImpact();\n      }, 5000);\n    }\n  }\n\n  private assessPerformanceImpact(): void {\n    if (typeof performance === 'undefined') return;\n    \n    try {\n      // Simple heuristic: if long tasks are frequent, reduce sampling\n      const now = performance.now();\n      const entries = performance.getEntriesByType('longtask');\n      const recentLongTasks = entries.filter(entry => \n        (now - entry.startTime) < 10000\n      );\n      \n      // Higher impact = more aggressive sampling reduction\n      this.performanceImpact = Math.min(recentLongTasks.length / 5, 1);\n    } catch (error) {\n      // Fallback to low impact if performance API fails\n      this.performanceImpact = 0.1;\n    }\n  }\n\n  updateActivityLevel(activity: 'high' | 'medium' | 'low' | 'idle'): void {\n    const levels = { high: 1, medium: 0.7, low: 0.4, idle: 0.1 };\n    this.activityLevel = levels[activity];\n    this.lastActivity = Date.now();\n  }\n\n  incrementErrorFrequency(): void {\n    this.errorFrequency = Math.min(this.errorFrequency + 0.1, 1);\n    \n    // Decay error frequency over time\n    setTimeout(() => {\n      this.errorFrequency = Math.max(this.errorFrequency - 0.05, 0);\n    }, 30000);\n  }\n\n  shouldSampleError(): boolean {\n    const baseSampleRate = this.config.sampling?.errorSampleRate ?? 1.0;\n    \n    // Always sample errors if error rate is high\n    if (this.errorFrequency > 0.5) {\n      return Math.random() < baseSampleRate;\n    }\n    \n    // Reduce sampling if performance impact is high\n    const adjustedRate = baseSampleRate * (1 - this.performanceImpact * 0.5);\n    \n    return Math.random() < adjustedRate;\n  }\n\n  shouldSampleSession(): boolean {\n    const baseSampleRate = this.config.sampling?.sessionSampleRate ?? this.config.sessionSampleRate ?? 1.0;\n    \n    // Increase sampling during high activity\n    const activityBonus = this.activityLevel * 0.2;\n    const adjustedRate = Math.min(baseSampleRate + activityBonus, 1.0);\n    \n    // Reduce sampling if performance impact is high\n    const finalRate = adjustedRate * (1 - this.performanceImpact * 0.3);\n    \n    return Math.random() < finalRate;\n  }\n\n  shouldSamplePerformance(): boolean {\n    const baseSampleRate = this.config.sampling?.performanceSampleRate ?? 0.1;\n    \n    // Reduce performance sampling during high load\n    const adjustedRate = baseSampleRate * (1 - this.performanceImpact * 0.7);\n    \n    return Math.random() < adjustedRate;\n  }\n\n  shouldSampleNetwork(): boolean {\n    const baseSampleRate = this.config.sampling?.networkSampleRate ?? 0.5;\n    \n    // Sample less during idle periods\n    const idleTimeDays = (Date.now() - this.lastActivity) / (1000 * 60);\n    const idlePenalty = idleTimeDays > 5 ? 0.5 : 1.0;\n    \n    const adjustedRate = baseSampleRate * idlePenalty * (1 - this.performanceImpact * 0.4);\n    \n    return Math.random() < adjustedRate;\n  }\n\n  shouldSampleReplay(): boolean {\n    const baseSampleRate = this.config.sampling?.replaySampleRate ?? 0.1;\n    \n    // Increase replay sampling when there are errors\n    const errorBonus = this.errorFrequency * 0.3;\n    let adjustedRate = Math.min(baseSampleRate + errorBonus, 1.0);\n    \n    // Heavy penalty for performance impact since replay is expensive\n    adjustedRate = adjustedRate * (1 - this.performanceImpact * 0.8);\n    \n    return Math.random() < adjustedRate;\n  }\n\n  getAdaptiveBatchSize(baseSize: number): number {\n    // Reduce batch sizes during high performance impact\n    const impactReduction = this.performanceImpact * 0.6;\n    return Math.max(Math.floor(baseSize * (1 - impactReduction)), 1);\n  }\n\n  getAdaptiveUploadDelay(baseDelay: number): number {\n    // Increase delays during high performance impact\n    const impactMultiplier = 1 + (this.performanceImpact * 2);\n    \n    // Decrease delays during high error frequency\n    const errorMultiplier = Math.max(0.3, 1 - (this.errorFrequency * 0.7));\n    \n    return Math.floor(baseDelay * impactMultiplier * errorMultiplier);\n  }\n\n  shouldSkipCapture(eventType: 'error' | 'session' | 'performance' | 'network' | 'replay'): boolean {\n    switch (eventType) {\n      case 'error':\n        return !this.shouldSampleError();\n      case 'session':\n        return !this.shouldSampleSession();\n      case 'performance':\n        return !this.shouldSamplePerformance();\n      case 'network':\n        return !this.shouldSampleNetwork();\n      case 'replay':\n        return !this.shouldSampleReplay();\n      default:\n        return false;\n    }\n  }\n\n  getPerformanceImpact(): number {\n    return this.performanceImpact;\n  }\n\n  getActivityLevel(): number {\n    return this.activityLevel;\n  }\n\n  getErrorFrequency(): number {\n    return this.errorFrequency;\n  }\n}","import type { PerformanceEntry, WebVitals, ReviConfig } from './types';\n\nexport class PerformanceMonitor {\n  private config: ReviConfig;\n  private webVitals: WebVitals = {};\n  private performanceEntries: PerformanceEntry[] = [];\n\n  constructor(config: ReviConfig) {\n    this.config = config;\n    \n    if (this.config.performance?.captureWebVitals) {\n      this.setupWebVitals();\n    }\n    \n    if (this.config.performance?.captureResourceTiming) {\n      this.setupResourceTiming();\n    }\n    \n    if (this.config.performance?.captureNavigationTiming) {\n      this.setupNavigationTiming();\n    }\n  }\n\n  private setupWebVitals(): void {\n    if (typeof window === 'undefined' || !('PerformanceObserver' in window)) return;\n\n    // Largest Contentful Paint (LCP)\n    try {\n      const lcpObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        const lastEntry = entries[entries.length - 1];\n        this.webVitals.lcp = lastEntry.startTime;\n      });\n      lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });\n    } catch (e) {\n      // LCP not supported\n    }\n\n    // First Input Delay (FID)\n    try {\n      const fidObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries() as any[];\n        entries.forEach((entry) => {\n          this.webVitals.fid = entry.processingStart - entry.startTime;\n        });\n      });\n      fidObserver.observe({ entryTypes: ['first-input'] });\n    } catch (e) {\n      // FID not supported\n    }\n\n    // Cumulative Layout Shift (CLS)\n    try {\n      let clsValue = 0;\n      const clsObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries() as any[];\n        entries.forEach((entry) => {\n          if (!entry.hadRecentInput) {\n            clsValue += entry.value;\n            this.webVitals.cls = clsValue;\n          }\n        });\n      });\n      clsObserver.observe({ entryTypes: ['layout-shift'] });\n    } catch (e) {\n      // CLS not supported\n    }\n\n    // First Contentful Paint (FCP)\n    try {\n      const fcpObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        entries.forEach((entry) => {\n          if (entry.name === 'first-contentful-paint') {\n            this.webVitals.fcp = entry.startTime;\n          }\n        });\n      });\n      fcpObserver.observe({ entryTypes: ['paint'] });\n    } catch (e) {\n      // FCP not supported\n    }\n\n    // Time to First Byte (TTFB)\n    this.calculateTTFB();\n  }\n\n  private calculateTTFB(): void {\n    if (typeof window === 'undefined' || !window.performance) return;\n\n    try {\n      const navigationTiming = performance.getEntriesByType('navigation')[0] as any;\n      if (navigationTiming) {\n        this.webVitals.ttfb = navigationTiming.responseStart - navigationTiming.requestStart;\n      }\n    } catch (e) {\n      // TTFB calculation failed\n    }\n  }\n\n  private setupResourceTiming(): void {\n    if (typeof window === 'undefined' || !window.performance) return;\n\n    try {\n      const resourceObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        entries.forEach((entry) => {\n          this.performanceEntries.push({\n            name: entry.name,\n            entryType: entry.entryType,\n            startTime: entry.startTime,\n            duration: entry.duration,\n            transferSize: (entry as any).transferSize,\n            encodedBodySize: (entry as any).encodedBodySize,\n            decodedBodySize: (entry as any).decodedBodySize\n          });\n        });\n      });\n      \n      resourceObserver.observe({ entryTypes: ['resource'] });\n    } catch (e) {\n      // Resource timing not supported\n    }\n  }\n\n  private setupNavigationTiming(): void {\n    if (typeof window === 'undefined' || !window.performance) return;\n\n    window.addEventListener('load', () => {\n      try {\n        const navigationTiming = performance.getEntriesByType('navigation')[0] as any;\n        if (navigationTiming) {\n          this.performanceEntries.push({\n            name: 'navigation',\n            entryType: 'navigation',\n            startTime: navigationTiming.startTime,\n            duration: navigationTiming.duration,\n            domContentLoadedEventEnd: navigationTiming.domContentLoadedEventEnd,\n            domContentLoadedEventStart: navigationTiming.domContentLoadedEventStart,\n            loadEventEnd: navigationTiming.loadEventEnd,\n            loadEventStart: navigationTiming.loadEventStart,\n            domComplete: navigationTiming.domComplete,\n            domInteractive: navigationTiming.domInteractive\n          });\n        }\n      } catch (e) {\n        // Navigation timing failed\n      }\n    });\n  }\n\n  getWebVitals(): WebVitals {\n    return { ...this.webVitals };\n  }\n\n  getPerformanceEntries(): PerformanceEntry[] {\n    return [...this.performanceEntries];\n  }\n\n  clearPerformanceEntries(): void {\n    this.performanceEntries = [];\n  }\n\n  // Custom performance marks\n  mark(name: string): void {\n    if (typeof window !== 'undefined' && window.performance && window.performance.mark) {\n      try {\n        performance.mark(name);\n      } catch (e) {\n        // Mark failed\n      }\n    }\n  }\n\n  measure(name: string, startMark?: string, endMark?: string): number | null {\n    if (typeof window === 'undefined' || !window.performance || !window.performance.measure) {\n      return null;\n    }\n\n    try {\n      performance.measure(name, startMark, endMark);\n      const measure = performance.getEntriesByName(name, 'measure')[0];\n      return measure ? measure.duration : null;\n    } catch (e) {\n      return null;\n    }\n  }\n}\n","import type { ReviConfig } from './types';\n\nexport interface SerializedNode {\n  type: 'document' | 'element' | 'text' | 'comment';\n  tagName?: string;\n  attributes?: Record<string, string>;\n  textContent?: string;\n  children?: SerializedNode[];\n  id?: number;\n  parentId?: number;\n}\n\nexport interface DOMSnapshot {\n  timestamp: number;\n  url: string;\n  viewport: {\n    width: number;\n    height: number;\n  };\n  scroll: {\n    x: number;\n    y: number;\n  };\n  nodes: SerializedNode[];\n  stylesheets: SerializedStylesheet[];\n  resources: SerializedResource[];\n}\n\nexport interface SerializedStylesheet {\n  href?: string;\n  cssText: string;\n  disabled: boolean;\n}\n\nexport interface SerializedResource {\n  url: string;\n  type: 'image' | 'font' | 'media';\n  data?: string; // Base64 encoded data for small resources\n  failed?: boolean;\n}\n\nexport interface DOMChange {\n  timestamp: number;\n  type: 'childList' | 'attributes' | 'characterData';\n  target: number; // Node ID\n  addedNodes?: SerializedNode[];\n  removedNodes?: number[]; // Node IDs\n  attributeName?: string;\n  attributeValue?: string;\n  oldValue?: string;\n}\n\n/**\n * Advanced DOM serializer for session replay with rrweb-like capabilities\n */\nexport class DOMSerializer {\n  private config: ReviConfig;\n  private nodeIdMap = new WeakMap<Node, number>();\n  private nodeMap = new Map<number, Node>();\n  private nextNodeId = 1;\n  private observer?: MutationObserver;\n  private isObserving = false;\n  private onDOMChange?: (change: DOMChange) => void;\n\n  constructor(config: ReviConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Take a complete snapshot of the DOM\n   */\n  takeSnapshot(): DOMSnapshot {\n    const snapshot: DOMSnapshot = {\n      timestamp: Date.now(),\n      url: window.location.href,\n      viewport: {\n        width: window.innerWidth,\n        height: window.innerHeight\n      },\n      scroll: {\n        x: window.scrollX,\n        y: window.scrollY\n      },\n      nodes: [],\n      stylesheets: [],\n      resources: []\n    };\n\n    // Serialize DOM\n    snapshot.nodes = this.serializeDocument(document);\n    \n    // Capture stylesheets\n    snapshot.stylesheets = this.serializeStylesheets();\n    \n    // Capture resources (images, fonts, etc.)\n    snapshot.resources = this.serializeResources();\n\n    return snapshot;\n  }\n\n  /**\n   * Start observing DOM changes\n   */\n  startObserving(onDOMChange: (change: DOMChange) => void): void {\n    if (this.isObserving) return;\n\n    this.onDOMChange = onDOMChange;\n    this.observer = new MutationObserver(this.handleMutations.bind(this));\n    \n    this.observer.observe(document, {\n      childList: true,\n      attributes: true,\n      characterData: true,\n      subtree: true,\n      attributeOldValue: true,\n      characterDataOldValue: true\n    });\n\n    this.isObserving = true;\n  }\n\n  /**\n   * Stop observing DOM changes\n   */\n  stopObserving(): void {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = undefined;\n    }\n    this.isObserving = false;\n    this.onDOMChange = undefined;\n  }\n\n  /**\n   * Serialize the entire document\n   */\n  private serializeDocument(doc: Document): SerializedNode[] {\n    const doctype = doc.doctype;\n    const nodes: SerializedNode[] = [];\n\n    // Add doctype if present\n    if (doctype) {\n      nodes.push({\n        type: 'document',\n        tagName: 'DOCTYPE',\n        attributes: {\n          name: doctype.name,\n          publicId: doctype.publicId,\n          systemId: doctype.systemId\n        },\n        id: this.getNodeId(doctype)\n      });\n    }\n\n    // Serialize document element (html)\n    if (doc.documentElement) {\n      const serialized = this.serializeNode(doc.documentElement);\n      if (serialized) {\n        nodes.push(serialized);\n      }\n    }\n\n    return nodes;\n  }\n\n  /**\n   * Serialize a single DOM node\n   */\n  private serializeNode(node: Node): SerializedNode | null {\n    if (this.shouldIgnoreNode(node)) {\n      return null;\n    }\n\n    const nodeId = this.getNodeId(node);\n    const serialized: SerializedNode = {\n      type: this.getNodeType(node),\n      id: nodeId\n    };\n\n    switch (node.nodeType) {\n      case Node.ELEMENT_NODE:\n        const element = node as Element;\n        serialized.tagName = element.tagName.toLowerCase();\n        serialized.attributes = this.serializeAttributes(element);\n        serialized.children = this.serializeChildren(element);\n        break;\n\n      case Node.TEXT_NODE:\n        const textNode = node as Text;\n        serialized.textContent = this.shouldMaskText(textNode) ? '[Masked]' : textNode.textContent || '';\n        break;\n\n      case Node.COMMENT_NODE:\n        const commentNode = node as Comment;\n        serialized.textContent = commentNode.textContent || '';\n        break;\n\n      default:\n        return null;\n    }\n\n    return serialized;\n  }\n\n  /**\n   * Serialize element attributes\n   */\n  private serializeAttributes(element: Element): Record<string, string> {\n    const attributes: Record<string, string> = {};\n    \n    for (let i = 0; i < element.attributes.length; i++) {\n      const attr = element.attributes[i];\n      const name = attr.name.toLowerCase();\n      \n      // Skip sensitive attributes\n      if (this.shouldIgnoreAttribute(name, attr.value)) {\n        continue;\n      }\n\n      // Mask sensitive values\n      if (this.shouldMaskAttribute(name, element)) {\n        attributes[name] = '[Masked]';\n      } else {\n        attributes[name] = attr.value;\n      }\n    }\n\n    return attributes;\n  }\n\n  /**\n   * Serialize element children\n   */\n  private serializeChildren(element: Element): SerializedNode[] {\n    const children: SerializedNode[] = [];\n    \n    for (let i = 0; i < element.childNodes.length; i++) {\n      const child = element.childNodes[i];\n      const serializedChild = this.serializeNode(child);\n      \n      if (serializedChild) {\n        children.push(serializedChild);\n      }\n    }\n\n    return children;\n  }\n\n  /**\n   * Serialize all stylesheets\n   */\n  private serializeStylesheets(): SerializedStylesheet[] {\n    const stylesheets: SerializedStylesheet[] = [];\n\n    for (let i = 0; i < document.styleSheets.length; i++) {\n      const stylesheet = document.styleSheets[i];\n      \n      try {\n        let cssText = '';\n        \n        if (stylesheet.href) {\n          // External stylesheet - we'll capture the URL\n          // In production, you might want to fetch and inline the CSS\n          cssText = `/* External stylesheet: ${stylesheet.href} */`;\n        } else {\n          // Inline stylesheet - capture the rules\n          if (stylesheet.cssRules) {\n            const rules = Array.from(stylesheet.cssRules);\n            cssText = rules.map(rule => rule.cssText).join('\\n');\n          }\n        }\n\n        stylesheets.push({\n          href: stylesheet.href || undefined,\n          cssText,\n          disabled: stylesheet.disabled\n        });\n      } catch (error) {\n        // CORS issues or other access problems\n        if (stylesheet.href) {\n          stylesheets.push({\n            href: stylesheet.href,\n            cssText: `/* Could not access stylesheet: ${stylesheet.href} */`,\n            disabled: stylesheet.disabled\n          });\n        }\n      }\n    }\n\n    return stylesheets;\n  }\n\n  /**\n   * Serialize resources (images, fonts, etc.)\n   */\n  private serializeResources(): SerializedResource[] {\n    const resources: SerializedResource[] = [];\n\n    // Capture images\n    const images = document.querySelectorAll('img');\n    images.forEach(img => {\n      if (img.src && !this.shouldIgnoreResource(img.src)) {\n        resources.push({\n          url: img.src,\n          type: 'image',\n          failed: !img.complete || img.naturalWidth === 0\n        });\n      }\n    });\n\n    // Capture background images from computed styles\n    const elementsWithBackgrounds = document.querySelectorAll('*');\n    elementsWithBackgrounds.forEach(element => {\n      const style = window.getComputedStyle(element);\n      const backgroundImage = style.backgroundImage;\n      \n      if (backgroundImage && backgroundImage !== 'none') {\n        const urlMatch = backgroundImage.match(/url\\(['\"]?([^'\")]+)['\"]?\\)/);\n        if (urlMatch && urlMatch[1] && !this.shouldIgnoreResource(urlMatch[1])) {\n          resources.push({\n            url: urlMatch[1],\n            type: 'image'\n          });\n        }\n      }\n    });\n\n    return resources;\n  }\n\n  /**\n   * Handle mutation events\n   */\n  private handleMutations(mutations: MutationRecord[]): void {\n    mutations.forEach(mutation => {\n      const targetId = this.nodeIdMap.get(mutation.target);\n      if (!targetId) return;\n\n      const change: DOMChange = {\n        timestamp: Date.now(),\n        type: mutation.type,\n        target: targetId\n      };\n\n      switch (mutation.type) {\n        case 'childList':\n          if (mutation.addedNodes.length > 0) {\n            change.addedNodes = Array.from(mutation.addedNodes)\n              .map(node => this.serializeNode(node))\n              .filter((node): node is SerializedNode => node !== null);\n          }\n          \n          if (mutation.removedNodes.length > 0) {\n            change.removedNodes = Array.from(mutation.removedNodes)\n              .map(node => this.nodeIdMap.get(node))\n              .filter((id): id is number => id !== undefined);\n          }\n          break;\n\n        case 'attributes':\n          change.attributeName = mutation.attributeName || undefined;\n          if (mutation.target.nodeType === Node.ELEMENT_NODE) {\n            const element = mutation.target as Element;\n            const value = element.getAttribute(mutation.attributeName || '');\n            change.attributeValue = this.shouldMaskAttribute(\n              mutation.attributeName || '', element\n            ) ? '[Masked]' : value || '';\n          }\n          change.oldValue = mutation.oldValue || undefined;\n          break;\n\n        case 'characterData':\n          change.attributeValue = this.shouldMaskText(mutation.target as Text) \n            ? '[Masked]' \n            : mutation.target.textContent || '';\n          change.oldValue = mutation.oldValue || undefined;\n          break;\n      }\n\n      if (this.onDOMChange) {\n        this.onDOMChange(change);\n      }\n    });\n  }\n\n  /**\n   * Utility methods\n   */\n  private getNodeId(node: Node): number {\n    if (this.nodeIdMap.has(node)) {\n      return this.nodeIdMap.get(node)!;\n    }\n    \n    const id = this.nextNodeId++;\n    this.nodeIdMap.set(node, id);\n    this.nodeMap.set(id, node);\n    \n    return id;\n  }\n\n  private getNodeType(node: Node): SerializedNode['type'] {\n    switch (node.nodeType) {\n      case Node.ELEMENT_NODE:\n        return 'element';\n      case Node.TEXT_NODE:\n        return 'text';\n      case Node.COMMENT_NODE:\n        return 'comment';\n      case Node.DOCUMENT_NODE:\n        return 'document';\n      default:\n        return 'element';\n    }\n  }\n\n  private shouldIgnoreNode(node: Node): boolean {\n    if (node.nodeType === Node.ELEMENT_NODE) {\n      const element = node as Element;\n      const tagName = element.tagName.toLowerCase();\n      \n      // Ignore script tags and other sensitive elements\n      if (['script', 'noscript', 'meta'].includes(tagName)) {\n        return true;\n      }\n      \n      // Ignore elements with data-revi-ignore attribute\n      if (element.hasAttribute('data-revi-ignore')) {\n        return true;\n      }\n      \n      // Ignore elements that match block selector\n      if (this.config.replay?.blockSelector) {\n        try {\n          if (element.matches(this.config.replay.blockSelector)) {\n            return true;\n          }\n        } catch (e) {\n          // Invalid selector\n        }\n      }\n    }\n    \n    return false;\n  }\n\n  private shouldIgnoreAttribute(name: string, value: string): boolean {\n    // Ignore sensitive attributes\n    const sensitiveAttrs = ['data-revi-ignore', 'data-password', 'data-sensitive'];\n    return sensitiveAttrs.includes(name);\n  }\n\n  private shouldMaskAttribute(name: string, element: Element): boolean {\n    if (!this.config.privacy?.maskInputs) return false;\n    \n    // Mask values of sensitive input fields\n    if (element.tagName.toLowerCase() === 'input') {\n      const input = element as HTMLInputElement;\n      const sensitiveTypes = ['password', 'email', 'tel'];\n      if (sensitiveTypes.includes(input.type)) {\n        return name === 'value';\n      }\n    }\n    \n    return false;\n  }\n\n  private shouldMaskText(textNode: Text): boolean {\n    if (!this.config.replay?.maskAllText && !this.config.privacy?.maskInputs) {\n      return false;\n    }\n    \n    const parent = textNode.parentElement;\n    if (!parent) return false;\n    \n    // Mask text in sensitive elements\n    const sensitiveElements = ['input', 'textarea'];\n    if (sensitiveElements.includes(parent.tagName.toLowerCase())) {\n      return true;\n    }\n    \n    // Check for mask selector\n    if (this.config.replay?.maskSelector) {\n      try {\n        return parent.matches(this.config.replay.maskSelector);\n      } catch (e) {\n        return false;\n      }\n    }\n    \n    return this.config.replay?.maskAllText || false;\n  }\n\n  private shouldIgnoreResource(url: string): boolean {\n    try {\n      const urlObj = new URL(url, window.location.href);\n      \n      // Ignore data URLs (they're inline)\n      if (urlObj.protocol === 'data:') return true;\n      \n      // Ignore very large images\n      if (url.includes('?')) {\n        const params = new URLSearchParams(urlObj.search);\n        const width = params.get('w') || params.get('width');\n        const height = params.get('h') || params.get('height');\n        if (width && parseInt(width) > 2000) return true;\n        if (height && parseInt(height) > 2000) return true;\n      }\n      \n      return false;\n    } catch (e) {\n      return true; // Invalid URL\n    }\n  }\n}","import { SessionEvent } from './types';\n\nexport interface ConsoleLogEntry {\n  id: string;\n  timestamp: number;\n  level: 'log' | 'info' | 'warn' | 'error' | 'debug' | 'trace';\n  args: any[];\n  stack?: string;\n  url?: string;\n  lineNumber?: number;\n  columnNumber?: number;\n}\n\nexport interface ConsoleRecorderConfig {\n  maxEntries: number;\n  captureStackTrace: boolean;\n  serializeObjects: boolean;\n  maxObjectDepth: number;\n  maxStringLength: number;\n  ignoredLevels: string[];\n}\n\nexport class ConsoleRecorder {\n  private originalMethods: Record<string, Function> = {};\n  private entries: ConsoleLogEntry[] = [];\n  private config: ConsoleRecorderConfig;\n  private isRecording = false;\n  private sessionId: string;\n\n  constructor(sessionId: string, config: Partial<ConsoleRecorderConfig> = {}) {\n    this.sessionId = sessionId;\n    this.config = {\n      maxEntries: 1000,\n      captureStackTrace: true,\n      serializeObjects: true,\n      maxObjectDepth: 3,\n      maxStringLength: 10000,\n      ignoredLevels: [],\n      ...config\n    };\n  }\n\n  start(): void {\n    if (this.isRecording) return;\n\n    const levels: Array<keyof Console> = ['log', 'info', 'warn', 'error', 'debug', 'trace'];\n    \n    levels.forEach(level => {\n      if (this.config.ignoredLevels.includes(level)) return;\n      \n      const originalMethod = console[level];\n      this.originalMethods[level] = originalMethod;\n      \n      console[level] = (...args: any[]) => {\n        // Call original method first\n        originalMethod.apply(console, args);\n        \n        // Record the log entry\n        this.recordEntry(level as ConsoleLogEntry['level'], args);\n      };\n    });\n\n    this.isRecording = true;\n  }\n\n  stop(): void {\n    if (!this.isRecording) return;\n\n    // Restore original console methods\n    Object.entries(this.originalMethods).forEach(([level, method]) => {\n      (console as any)[level] = method;\n    });\n\n    this.originalMethods = {};\n    this.isRecording = false;\n  }\n\n  private recordEntry(level: ConsoleLogEntry['level'], args: any[]): void {\n    try {\n      const entry: ConsoleLogEntry = {\n        id: this.generateId(),\n        timestamp: Date.now(),\n        level,\n        args: this.serializeArgs(args)\n      };\n\n      // Capture stack trace for errors and warnings\n      if ((level === 'error' || level === 'warn') && this.config.captureStackTrace) {\n        const error = new Error();\n        if (error.stack) {\n          entry.stack = this.cleanStackTrace(error.stack);\n        }\n      }\n\n      // Add source location if available\n      if (level === 'error' && args[0] instanceof Error) {\n        const error = args[0] as Error;\n        // Try to extract location from error stack\n        const stackLines = error.stack?.split('\\n') || [];\n        const sourceLine = stackLines.find(line => \n          line.includes('.js:') || line.includes('.ts:') || line.includes('.tsx:')\n        );\n        \n        if (sourceLine) {\n          const match = sourceLine.match(/([^/]+):(\\d+):(\\d+)/);\n          if (match) {\n            entry.url = match[1];\n            entry.lineNumber = parseInt(match[2]);\n            entry.columnNumber = parseInt(match[3]);\n          }\n        }\n      }\n\n      this.addEntry(entry);\n    } catch (error) {\n      // Fail silently to avoid infinite loops\n      this.originalMethods.warn?.call(console, 'ConsoleRecorder error:', error);\n    }\n  }\n\n  private serializeArgs(args: any[]): any[] {\n    return args.map(arg => this.serializeValue(arg, 0));\n  }\n\n  private serializeValue(value: any, depth: number): any {\n    if (depth > this.config.maxObjectDepth) {\n      return '[Object too deep]';\n    }\n\n    if (value === null || value === undefined) {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      return value.length > this.config.maxStringLength \n        ? value.substring(0, this.config.maxStringLength) + '...'\n        : value;\n    }\n\n    if (typeof value === 'number' || typeof value === 'boolean') {\n      return value;\n    }\n\n    if (typeof value === 'function') {\n      return `[Function: ${value.name || 'anonymous'}]`;\n    }\n\n    if (value instanceof Error) {\n      return {\n        name: value.name,\n        message: value.message,\n        stack: this.config.captureStackTrace ? this.cleanStackTrace(value.stack || '') : undefined\n      };\n    }\n\n    if (value instanceof Date) {\n      return {\n        __type: 'Date',\n        value: value.toISOString()\n      };\n    }\n\n    if (value instanceof RegExp) {\n      return {\n        __type: 'RegExp',\n        value: value.toString()\n      };\n    }\n\n    if (Array.isArray(value)) {\n      if (!this.config.serializeObjects) return '[Array]';\n      \n      return value.slice(0, 100).map(item => this.serializeValue(item, depth + 1));\n    }\n\n    if (typeof value === 'object') {\n      if (!this.config.serializeObjects) return '[Object]';\n      \n      try {\n        const serialized: Record<string, any> = {};\n        const keys = Object.keys(value).slice(0, 50); // Limit keys\n        \n        for (const key of keys) {\n          try {\n            serialized[key] = this.serializeValue(value[key], depth + 1);\n          } catch {\n            serialized[key] = '[Unserializable]';\n          }\n        }\n        \n        if (Object.keys(value).length > 50) {\n          serialized['...'] = `[${Object.keys(value).length - 50} more keys]`;\n        }\n        \n        return serialized;\n      } catch {\n        return '[Unserializable Object]';\n      }\n    }\n\n    return String(value);\n  }\n\n  private cleanStackTrace(stack: string): string {\n    return stack\n      .split('\\n')\n      .filter(line => \n        !line.includes('console-recorder.ts') && \n        !line.includes('ConsoleRecorder')\n      )\n      .slice(0, 10) // Limit stack depth\n      .join('\\n');\n  }\n\n  private addEntry(entry: ConsoleLogEntry): void {\n    this.entries.push(entry);\n    \n    // Maintain max entries limit\n    if (this.entries.length > this.config.maxEntries) {\n      this.entries = this.entries.slice(-this.config.maxEntries * 0.8);\n    }\n  }\n\n  private generateId(): string {\n    return `console-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  getEntries(fromTimestamp?: number, toTimestamp?: number): ConsoleLogEntry[] {\n    let filtered = this.entries;\n    \n    if (fromTimestamp) {\n      filtered = filtered.filter(entry => entry.timestamp >= fromTimestamp);\n    }\n    \n    if (toTimestamp) {\n      filtered = filtered.filter(entry => entry.timestamp <= toTimestamp);\n    }\n    \n    return [...filtered];\n  }\n\n  getEntriesByLevel(level: ConsoleLogEntry['level']): ConsoleLogEntry[] {\n    return this.entries.filter(entry => entry.level === level);\n  }\n\n  clear(): void {\n    this.entries = [];\n  }\n\n  // Convert console entries to session events format\n  toSessionEvents(): SessionEvent[] {\n    return this.entries.map(entry => ({\n      session_id: this.sessionId,\n      event_type: 'console',\n      data: {\n        level: entry.level,\n        args: entry.args,\n        stack: entry.stack,\n        url: entry.url,\n        lineNumber: entry.lineNumber,\n        columnNumber: entry.columnNumber,\n        consoleId: entry.id\n      },\n      timestamp: entry.timestamp,\n      url: entry.url || window.location.href,\n      user_agent: navigator.userAgent\n    }));\n  }\n\n  // Export for analysis\n  exportData(): {\n    sessionId: string;\n    config: ConsoleRecorderConfig;\n    entries: ConsoleLogEntry[];\n    stats: {\n      totalEntries: number;\n      levelCounts: Record<string, number>;\n      errorCount: number;\n      warningCount: number;\n      timeRange: { start: number; end: number };\n    };\n  } {\n    const levelCounts: Record<string, number> = {};\n    let minTime = Infinity;\n    let maxTime = -Infinity;\n\n    this.entries.forEach(entry => {\n      levelCounts[entry.level] = (levelCounts[entry.level] || 0) + 1;\n      minTime = Math.min(minTime, entry.timestamp);\n      maxTime = Math.max(maxTime, entry.timestamp);\n    });\n\n    return {\n      sessionId: this.sessionId,\n      config: this.config,\n      entries: [...this.entries],\n      stats: {\n        totalEntries: this.entries.length,\n        levelCounts,\n        errorCount: levelCounts.error || 0,\n        warningCount: levelCounts.warn || 0,\n        timeRange: {\n          start: minTime === Infinity ? 0 : minTime,\n          end: maxTime === -Infinity ? 0 : maxTime\n        }\n      }\n    };\n  }\n\n  // Generate insights from console logs\n  generateInsights(): {\n    errorPatterns: Array<{ pattern: string; count: number; examples: ConsoleLogEntry[] }>;\n    performanceIssues: Array<{ type: string; severity: 'low' | 'medium' | 'high'; details: string }>;\n    recommendations: string[];\n  } {\n    const errorPatterns = this.findErrorPatterns();\n    const performanceIssues = this.detectPerformanceIssues();\n    const recommendations = this.generateRecommendations();\n\n    return {\n      errorPatterns,\n      performanceIssues,\n      recommendations\n    };\n  }\n\n  private findErrorPatterns(): Array<{ pattern: string; count: number; examples: ConsoleLogEntry[] }> {\n    const errors = this.entries.filter(entry => entry.level === 'error');\n    const patterns: Record<string, ConsoleLogEntry[]> = {};\n\n    errors.forEach(error => {\n      let pattern = 'Unknown Error';\n      \n      if (error.args.length > 0) {\n        const firstArg = error.args[0];\n        if (typeof firstArg === 'string') {\n          // Extract error pattern from message\n          pattern = firstArg\n            .replace(/\\d+/g, 'N') // Replace numbers with N\n            .replace(/[\"'][^\"']*[\"']/g, 'STRING') // Replace strings with STRING\n            .replace(/\\b\\w+@\\w+\\.\\w+/g, 'EMAIL') // Replace emails\n            .replace(/https?:\\/\\/[^\\s]+/g, 'URL') // Replace URLs\n            .substring(0, 100);\n        } else if (typeof firstArg === 'object' && firstArg.name) {\n          pattern = `${firstArg.name}: ${firstArg.message}`.substring(0, 100);\n        }\n      }\n\n      if (!patterns[pattern]) {\n        patterns[pattern] = [];\n      }\n      patterns[pattern].push(error);\n    });\n\n    return Object.entries(patterns)\n      .sort(([, a], [, b]) => b.length - a.length)\n      .slice(0, 10)\n      .map(([pattern, examples]) => ({\n        pattern,\n        count: examples.length,\n        examples: examples.slice(0, 3) // Show first 3 examples\n      }));\n  }\n\n  private detectPerformanceIssues(): Array<{ type: string; severity: 'low' | 'medium' | 'high'; details: string }> {\n    const issues: Array<{ type: string; severity: 'low' | 'medium' | 'high'; details: string }> = [];\n    \n    // Check for excessive logging\n    const recentEntries = this.entries.filter(entry => \n      entry.timestamp > Date.now() - 60000 // Last minute\n    );\n    \n    if (recentEntries.length > 100) {\n      issues.push({\n        type: 'Excessive Logging',\n        severity: 'medium',\n        details: `${recentEntries.length} console entries in the last minute may impact performance`\n      });\n    }\n\n    // Check for repeated errors\n    const errorCounts: Record<string, number> = {};\n    this.entries\n      .filter(entry => entry.level === 'error')\n      .forEach(entry => {\n        const key = JSON.stringify(entry.args);\n        errorCounts[key] = (errorCounts[key] || 0) + 1;\n      });\n\n    Object.entries(errorCounts).forEach(([error, count]) => {\n      if (count > 10) {\n        issues.push({\n          type: 'Repeated Error',\n          severity: count > 50 ? 'high' : 'medium',\n          details: `Same error occurred ${count} times`\n        });\n      }\n    });\n\n    // Check for potential memory leaks (objects not being cleaned up)\n    const objectLogs = this.entries.filter(entry => \n      entry.args.some(arg => \n        typeof arg === 'object' && \n        arg !== null && \n        !Array.isArray(arg)\n      )\n    );\n    \n    if (objectLogs.length > this.entries.length * 0.5) {\n      issues.push({\n        type: 'Object Logging',\n        severity: 'low',\n        details: 'High percentage of object logging may indicate memory leaks'\n      });\n    }\n\n    return issues;\n  }\n\n  private generateRecommendations(): string[] {\n    const recommendations: string[] = [];\n    const stats = this.exportData().stats;\n\n    if (stats.errorCount > 0) {\n      recommendations.push(\n        `Found ${stats.errorCount} console errors. Review error patterns and fix underlying issues.`\n      );\n    }\n\n    if (stats.warningCount > stats.errorCount * 2) {\n      recommendations.push(\n        'High warning-to-error ratio suggests proactive error handling could prevent issues.'\n      );\n    }\n\n    if (stats.totalEntries > 500) {\n      recommendations.push(\n        'Consider reducing console logging in production to improve performance.'\n      );\n    }\n\n    if (stats.levelCounts.debug && stats.levelCounts.debug > 100) {\n      recommendations.push(\n        'Debug logs should be disabled in production environments.'\n      );\n    }\n\n    if (recommendations.length === 0) {\n      recommendations.push('Console logging patterns look healthy.');\n    }\n\n    return recommendations;\n  }\n}","import { SessionEvent } from './types';\n\nexport interface HeatmapData {\n  x: number;\n  y: number;\n  intensity: number;\n  event_type: 'click' | 'move' | 'scroll' | 'hover';\n  timestamp: number;\n}\n\nexport interface HeatmapConfig {\n  radius: number;\n  maxIntensity: number;\n  gradient: Record<string, string>;\n  blur: number;\n  minOpacity: number;\n  maxOpacity: number;\n}\n\nexport class HeatmapGenerator {\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n  private config: HeatmapConfig;\n  private data: HeatmapData[] = [];\n\n  constructor(container: HTMLElement, config: Partial<HeatmapConfig> = {}) {\n    this.config = {\n      radius: 20,\n      maxIntensity: 100,\n      gradient: {\n        0.4: 'blue',\n        0.6: 'cyan',\n        0.7: 'lime',\n        0.8: 'yellow',\n        1.0: 'red'\n      },\n      blur: 15,\n      minOpacity: 0,\n      maxOpacity: 0.6,\n      ...config\n    };\n\n    this.canvas = document.createElement('canvas');\n    this.canvas.style.position = 'absolute';\n    this.canvas.style.top = '0';\n    this.canvas.style.left = '0';\n    this.canvas.style.pointerEvents = 'none';\n    this.canvas.style.zIndex = '9999';\n    \n    container.appendChild(this.canvas);\n    \n    const ctx = this.canvas.getContext('2d');\n    if (!ctx) {\n      throw new Error('Failed to get canvas context');\n    }\n    this.ctx = ctx;\n\n    this.resizeCanvas();\n    window.addEventListener('resize', () => this.resizeCanvas());\n  }\n\n  private resizeCanvas(): void {\n    const rect = this.canvas.parentElement!.getBoundingClientRect();\n    this.canvas.width = rect.width;\n    this.canvas.height = rect.height;\n    this.canvas.style.width = rect.width + 'px';\n    this.canvas.style.height = rect.height + 'px';\n  }\n\n  addDataPoint(x: number, y: number, intensity: number, eventType: HeatmapData['event_type']): void {\n    this.data.push({\n      x,\n      y,\n      intensity,\n      event_type: eventType,\n      timestamp: Date.now()\n    });\n    \n    // Limit data points to prevent memory issues\n    if (this.data.length > 10000) {\n      this.data = this.data.slice(-8000);\n    }\n  }\n\n  generateFromEvents(events: SessionEvent[]): void {\n    this.data = [];\n    \n    events.forEach(event => {\n      if (event.event_type === 'click' && event.data?.x && event.data?.y) {\n        this.addDataPoint(\n          event.data.x,\n          event.data.y,\n          10,\n          'click'\n        );\n      } else if (event.event_type === 'mousemove' && event.data?.x && event.data?.y) {\n        this.addDataPoint(\n          event.data.x,\n          event.data.y,\n          2,\n          'move'\n        );\n      } else if (event.event_type === 'scroll' && event.data?.scrollX !== undefined && event.data?.scrollY !== undefined) {\n        // Convert scroll position to viewport coordinates\n        this.addDataPoint(\n          event.data.scrollX || 0,\n          event.data.scrollY || 0,\n          5,\n          'scroll'\n        );\n      }\n    });\n  }\n\n  render(filter?: HeatmapData['event_type'][]): void {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    \n    if (this.data.length === 0) return;\n\n    const filteredData = filter \n      ? this.data.filter(d => filter.includes(d.event_type))\n      : this.data;\n\n    // Create intensity map\n    const intensityData = this.createIntensityMap(filteredData);\n    \n    // Create gradient\n    const gradient = this.createGradient();\n    \n    // Render heatmap\n    this.renderHeatmap(intensityData, gradient);\n  }\n\n  private createIntensityMap(data: HeatmapData[]): ImageData {\n    const shadowCanvas = document.createElement('canvas');\n    shadowCanvas.width = this.canvas.width;\n    shadowCanvas.height = this.canvas.height;\n    const shadowCtx = shadowCanvas.getContext('2d')!;\n\n    // Draw intensity points\n    data.forEach(point => {\n      const radius = this.config.radius;\n      const gradient = shadowCtx.createRadialGradient(\n        point.x, point.y, 0,\n        point.x, point.y, radius\n      );\n\n      const alpha = Math.min(point.intensity / this.config.maxIntensity, 1);\n      gradient.addColorStop(0, `rgba(0, 0, 0, ${alpha})`);\n      gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\n\n      shadowCtx.fillStyle = gradient;\n      shadowCtx.fillRect(\n        point.x - radius,\n        point.y - radius,\n        radius * 2,\n        radius * 2\n      );\n    });\n\n    // Apply blur\n    shadowCtx.filter = `blur(${this.config.blur}px)`;\n    shadowCtx.drawImage(shadowCanvas, 0, 0);\n\n    return shadowCtx.getImageData(0, 0, shadowCanvas.width, shadowCanvas.height);\n  }\n\n  private createGradient(): ImageData {\n    const gradientCanvas = document.createElement('canvas');\n    gradientCanvas.width = 256;\n    gradientCanvas.height = 1;\n    const gradientCtx = gradientCanvas.getContext('2d')!;\n\n    const gradient = gradientCtx.createLinearGradient(0, 0, 256, 0);\n    Object.entries(this.config.gradient).forEach(([stop, color]) => {\n      gradient.addColorStop(parseFloat(stop), color);\n    });\n\n    gradientCtx.fillStyle = gradient;\n    gradientCtx.fillRect(0, 0, 256, 1);\n\n    return gradientCtx.getImageData(0, 0, 256, 1);\n  }\n\n  private renderHeatmap(intensityData: ImageData, gradientData: ImageData): void {\n    const output = this.ctx.createImageData(intensityData.width, intensityData.height);\n    \n    for (let i = 0; i < intensityData.data.length; i += 4) {\n      const alpha = intensityData.data[i + 3];\n      \n      if (alpha > 0) {\n        const gradientIndex = Math.floor((alpha / 255) * 255) * 4;\n        \n        output.data[i] = gradientData.data[gradientIndex];     // R\n        output.data[i + 1] = gradientData.data[gradientIndex + 1]; // G\n        output.data[i + 2] = gradientData.data[gradientIndex + 2]; // B\n        output.data[i + 3] = Math.floor(alpha * this.config.maxOpacity); // A\n      }\n    }\n\n    this.ctx.putImageData(output, 0, 0);\n  }\n\n  clear(): void {\n    this.data = [];\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n\n  destroy(): void {\n    this.clear();\n    if (this.canvas.parentElement) {\n      this.canvas.parentElement.removeChild(this.canvas);\n    }\n    window.removeEventListener('resize', () => this.resizeCanvas());\n  }\n\n  // Export heatmap data for analysis\n  exportData(): {\n    config: HeatmapConfig;\n    data: HeatmapData[];\n    stats: {\n      totalEvents: number;\n      eventTypes: Record<string, number>;\n      timeRange: { start: number; end: number };\n      bounds: { minX: number; maxX: number; minY: number; maxY: number };\n    };\n  } {\n    const eventTypes: Record<string, number> = {};\n    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;\n    let minTime = Infinity, maxTime = -Infinity;\n\n    this.data.forEach(point => {\n      eventTypes[point.event_type] = (eventTypes[point.event_type] || 0) + 1;\n      \n      minX = Math.min(minX, point.x);\n      maxX = Math.max(maxX, point.x);\n      minY = Math.min(minY, point.y);\n      maxY = Math.max(maxY, point.y);\n      \n      minTime = Math.min(minTime, point.timestamp);\n      maxTime = Math.max(maxTime, point.timestamp);\n    });\n\n    return {\n      config: this.config,\n      data: [...this.data],\n      stats: {\n        totalEvents: this.data.length,\n        eventTypes,\n        timeRange: { start: minTime, end: maxTime },\n        bounds: { minX, maxX, minY, maxY }\n      }\n    };\n  }\n\n  // Generate insights from heatmap data\n  generateInsights(): {\n    hotSpots: Array<{ x: number; y: number; intensity: number; radius: number }>;\n    clickPatterns: Array<{ pattern: string; frequency: number }>;\n    userBehavior: {\n      mostActiveArea: { x: number; y: number; width: number; height: number };\n      averageClicksPerSession: number;\n      scrollDepth: number;\n      engagementScore: number;\n    };\n  } {\n    // Find hot spots using clustering\n    const hotSpots = this.findHotSpots();\n    \n    // Analyze click patterns\n    const clickPatterns = this.analyzeClickPatterns();\n    \n    // Generate user behavior insights\n    const userBehavior = this.analyzeUserBehavior();\n\n    return {\n      hotSpots,\n      clickPatterns,\n      userBehavior\n    };\n  }\n\n  private findHotSpots(): Array<{ x: number; y: number; intensity: number; radius: number }> {\n    const clusters: Array<{ x: number; y: number; intensity: number; count: number }> = [];\n    const clusterRadius = this.config.radius * 2;\n\n    this.data.forEach(point => {\n      let foundCluster = false;\n      \n      for (const cluster of clusters) {\n        const distance = Math.sqrt(\n          Math.pow(point.x - cluster.x, 2) + Math.pow(point.y - cluster.y, 2)\n        );\n        \n        if (distance <= clusterRadius) {\n          // Add to existing cluster\n          cluster.x = (cluster.x * cluster.count + point.x) / (cluster.count + 1);\n          cluster.y = (cluster.y * cluster.count + point.y) / (cluster.count + 1);\n          cluster.intensity += point.intensity;\n          cluster.count++;\n          foundCluster = true;\n          break;\n        }\n      }\n      \n      if (!foundCluster) {\n        clusters.push({\n          x: point.x,\n          y: point.y,\n          intensity: point.intensity,\n          count: 1\n        });\n      }\n    });\n\n    return clusters\n      .filter(cluster => cluster.count >= 3) // Only significant clusters\n      .sort((a, b) => b.intensity - a.intensity)\n      .slice(0, 10) // Top 10 hot spots\n      .map(cluster => ({\n        x: Math.round(cluster.x),\n        y: Math.round(cluster.y),\n        intensity: Math.round(cluster.intensity),\n        radius: Math.min(clusterRadius, cluster.count * 5)\n      }));\n  }\n\n  private analyzeClickPatterns(): Array<{ pattern: string; frequency: number }> {\n    const clicks = this.data.filter(d => d.event_type === 'click');\n    const patterns: Record<string, number> = {};\n\n    // Analyze sequential click patterns\n    for (let i = 0; i < clicks.length - 1; i++) {\n      const current = clicks[i];\n      const next = clicks[i + 1];\n      \n      const timeDiff = next.timestamp - current.timestamp;\n      if (timeDiff < 5000) { // Within 5 seconds\n        const pattern = `(${Math.round(current.x)},${Math.round(current.y)}) -> (${Math.round(next.x)},${Math.round(next.y)})`;\n        patterns[pattern] = (patterns[pattern] || 0) + 1;\n      }\n    }\n\n    return Object.entries(patterns)\n      .sort(([, a], [, b]) => b - a)\n      .slice(0, 5)\n      .map(([pattern, frequency]) => ({ pattern, frequency }));\n  }\n\n  private analyzeUserBehavior(): {\n    mostActiveArea: { x: number; y: number; width: number; height: number };\n    averageClicksPerSession: number;\n    scrollDepth: number;\n    engagementScore: number;\n  } {\n    const clicks = this.data.filter(d => d.event_type === 'click');\n    const scrolls = this.data.filter(d => d.event_type === 'scroll');\n\n    // Find most active area (bounding box of top 50% of events)\n    const sortedByIntensity = [...this.data].sort((a, b) => b.intensity - a.intensity);\n    const topHalf = sortedByIntensity.slice(0, Math.floor(sortedByIntensity.length * 0.5));\n    \n    const minX = Math.min(...topHalf.map(d => d.x));\n    const maxX = Math.max(...topHalf.map(d => d.x));\n    const minY = Math.min(...topHalf.map(d => d.y));\n    const maxY = Math.max(...topHalf.map(d => d.y));\n\n    const scrollDepth = scrolls.length > 0 \n      ? Math.max(...scrolls.map(s => s.y)) / this.canvas.height \n      : 0;\n\n    const engagementScore = Math.min(100, \n      (clicks.length * 2) + \n      (scrollDepth * 50) + \n      (this.data.filter(d => d.event_type === 'move').length * 0.1)\n    );\n\n    return {\n      mostActiveArea: {\n        x: Math.round(minX),\n        y: Math.round(minY),\n        width: Math.round(maxX - minX),\n        height: Math.round(maxY - minY)\n      },\n      averageClicksPerSession: Math.round(clicks.length),\n      scrollDepth: Math.round(scrollDepth * 100) / 100,\n      engagementScore: Math.round(engagementScore)\n    };\n  }\n}","import type { ReviConfig } from './types';\nimport { DOMSerializer, DOMSnapshot, DOMChange } from './dom-serializer';\nimport { ConsoleRecorder, ConsoleLogEntry } from './console-recorder';\nimport { HeatmapGenerator, HeatmapData } from './heatmap-generator';\n\nexport interface ReplayEvent {\n  type: 'full_snapshot' | 'incremental_snapshot' | 'meta' | 'custom';\n  timestamp: number;\n  data: any;\n}\n\nexport interface ConsoleLog {\n  timestamp: number;\n  level: 'log' | 'info' | 'warn' | 'error' | 'debug';\n  args: any[];\n  stack?: string;\n}\n\nexport interface NetworkRequest {\n  timestamp: number;\n  id: string;\n  method: string;\n  url: string;\n  status?: number;\n  duration?: number;\n  requestHeaders?: Record<string, string>;\n  responseHeaders?: Record<string, string>;\n  requestBody?: any;\n  responseBody?: any;\n  failed?: boolean;\n}\n\n/**\n * Advanced session replay system with console logs and network requests\n */\nexport class SessionReplayManager {\n  private config: ReviConfig;\n  private domSerializer: DOMSerializer;\n  private consoleRecorder: ConsoleRecorder;\n  private heatmapGenerator: HeatmapGenerator | null = null;\n  private events: ReplayEvent[] = [];\n  private consoleLogs: ConsoleLog[] = [];\n  private networkRequests: Map<string, NetworkRequest> = new Map();\n  private isRecording = false;\n  private sessionId: string;\n  private startTime: number;\n  private originalConsole: any = {};\n  private originalFetch: any;\n  private originalXMLHttpRequest: any;\n\n  constructor(config: ReviConfig, sessionId: string) {\n    this.config = config;\n    this.sessionId = sessionId;\n    this.startTime = Date.now();\n    this.domSerializer = new DOMSerializer(config);\n    this.consoleRecorder = new ConsoleRecorder(sessionId, {\n      maxEntries: config.replay?.maxConsoleEntries || 1000,\n      captureStackTrace: config.replay?.captureStackTrace !== false,\n      serializeObjects: config.replay?.serializeObjects !== false,\n      maxObjectDepth: config.replay?.maxObjectDepth || 3,\n      maxStringLength: config.replay?.maxStringLength || 10000,\n      ignoredLevels: config.replay?.ignoredConsoleLevels || []\n    });\n    \n    if (this.config.replay?.enabled) {\n      this.setupReplay();\n      \n      // Initialize heatmap generator if enabled\n      if (this.config.replay?.heatmaps?.enabled && typeof document !== 'undefined') {\n        const container = document.body || document.documentElement;\n        if (container) {\n          this.heatmapGenerator = new HeatmapGenerator(container, {\n            radius: config.replay?.heatmaps?.radius || 20,\n            maxIntensity: config.replay?.heatmaps?.maxIntensity || 100,\n            blur: config.replay?.heatmaps?.blur || 15,\n            maxOpacity: config.replay?.heatmaps?.maxOpacity || 0.6\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Start recording session replay\n   */\n  startRecording(): void {\n    if (this.isRecording || !this.config.replay?.enabled) return;\n\n    this.isRecording = true;\n    \n    // Take initial snapshot\n    this.takeFullSnapshot();\n    \n    // Start observing DOM changes\n    this.domSerializer.startObserving(this.handleDOMChange.bind(this));\n    \n    // Start console recording\n    this.consoleRecorder.start();\n    \n    // Setup network monitoring\n    this.setupNetworkCapture();\n    \n    // Setup mouse and keyboard tracking\n    this.setupInteractionTracking();\n    \n    // Periodic full snapshots\n    setInterval(() => {\n      if (this.isRecording) {\n        this.takeFullSnapshot();\n      }\n    }, 60000); // Every minute\n    \n    if (this.config.debug) {\n      console.log('Revi: Session replay started');\n    }\n  }\n\n  /**\n   * Stop recording session replay\n   */\n  stopRecording(): void {\n    if (!this.isRecording) return;\n\n    this.isRecording = false;\n    this.domSerializer.stopObserving();\n    this.consoleRecorder.stop();\n    this.restoreOriginalNetwork();\n    \n    if (this.heatmapGenerator) {\n      this.heatmapGenerator.destroy();\n      this.heatmapGenerator = null;\n    }\n    \n    if (this.config.debug) {\n      console.log('Revi: Session replay stopped');\n    }\n  }\n\n  /**\n   * Get all replay events\n   */\n  getReplayData(): {\n    events: ReplayEvent[];\n    console_logs: ConsoleLogEntry[];\n    network_requests: NetworkRequest[];\n    heatmap_data?: HeatmapData[];\n    session_info: {\n      session_id: string;\n      start_time: number;\n      duration: number;\n      page_url: string;\n    };\n    analytics: {\n      console_insights: any;\n      heatmap_insights?: any;\n    };\n  } {\n    const consoleEntries = this.consoleRecorder.getEntries();\n    const consoleInsights = this.consoleRecorder.generateInsights();\n    \n    let heatmapData: HeatmapData[] | undefined;\n    let heatmapInsights: any;\n    \n    if (this.heatmapGenerator) {\n      const heatmapExport = this.heatmapGenerator.exportData();\n      heatmapData = heatmapExport.data;\n      heatmapInsights = this.heatmapGenerator.generateInsights();\n    }\n\n    return {\n      events: [...this.events],\n      console_logs: consoleEntries,\n      network_requests: Array.from(this.networkRequests.values()),\n      heatmap_data: heatmapData,\n      session_info: {\n        session_id: this.sessionId,\n        start_time: this.startTime,\n        duration: Date.now() - this.startTime,\n        page_url: window.location.href\n      },\n      analytics: {\n        console_insights: consoleInsights,\n        heatmap_insights: heatmapInsights\n      }\n    };\n  }\n\n  /**\n   * Clear replay data\n   */\n  clearReplayData(): void {\n    this.events = [];\n    this.consoleLogs = [];\n    this.networkRequests.clear();\n    this.consoleRecorder.clear();\n    \n    if (this.heatmapGenerator) {\n      this.heatmapGenerator.clear();\n    }\n  }\n\n  /**\n   * Setup basic replay tracking\n   */\n  private setupReplay(): void {\n    if (typeof window === 'undefined') return;\n\n    // Track page visibility changes\n    document.addEventListener('visibilitychange', () => {\n      this.addCustomEvent('visibility_change', {\n        hidden: document.hidden\n      });\n    });\n\n    // Track window focus/blur\n    window.addEventListener('focus', () => {\n      this.addCustomEvent('window_focus', {});\n    });\n\n    window.addEventListener('blur', () => {\n      this.addCustomEvent('window_blur', {});\n    });\n\n    // Track viewport changes\n    window.addEventListener('resize', () => {\n      this.addCustomEvent('viewport_change', {\n        width: window.innerWidth,\n        height: window.innerHeight\n      });\n    });\n\n    // Track scroll events (throttled)\n    let scrollTimeout: NodeJS.Timeout;\n    window.addEventListener('scroll', () => {\n      clearTimeout(scrollTimeout);\n      scrollTimeout = setTimeout(() => {\n        // Add to heatmap data\n        if (this.heatmapGenerator) {\n          this.heatmapGenerator.addDataPoint(\n            window.scrollX || 0,\n            window.scrollY || 0,\n            5,\n            'scroll'\n          );\n        }\n        \n        this.addCustomEvent('scroll', {\n          x: window.scrollX,\n          y: window.scrollY\n        });\n      }, 100);\n    }, { passive: true });\n  }\n\n  /**\n   * Take a full DOM snapshot\n   */\n  private takeFullSnapshot(): void {\n    if (!this.isRecording) return;\n\n    try {\n      const snapshot = this.domSerializer.takeSnapshot();\n      \n      this.addEvent({\n        type: 'full_snapshot',\n        timestamp: Date.now(),\n        data: snapshot\n      });\n    } catch (error) {\n      if (this.config.debug) {\n        console.error('Revi: Failed to take DOM snapshot', error);\n      }\n    }\n  }\n\n  /**\n   * Handle DOM changes\n   */\n  private handleDOMChange(change: DOMChange): void {\n    if (!this.isRecording) return;\n\n    this.addEvent({\n      type: 'incremental_snapshot',\n      timestamp: change.timestamp,\n      data: {\n        source: 'mutation',\n        ...change\n      }\n    });\n  }\n\n  /**\n   * Add heatmap methods\n   */\n  renderHeatmap(filter?: ('click' | 'move' | 'scroll')[]): void {\n    if (this.heatmapGenerator) {\n      this.heatmapGenerator.render(filter);\n    }\n  }\n\n  toggleHeatmap(visible: boolean): void {\n    if (this.heatmapGenerator) {\n      if (visible) {\n        this.heatmapGenerator.render();\n      } else {\n        this.heatmapGenerator.clear();\n      }\n    }\n  }\n\n  getHeatmapInsights(): any {\n    return this.heatmapGenerator?.generateInsights() || null;\n  }\n\n  /**\n   * Setup network request capture\n   */\n  private setupNetworkCapture(): void {\n    // Capture fetch requests\n    if (typeof window.fetch !== 'undefined') {\n      this.originalFetch = window.fetch;\n      \n      window.fetch = async (input: RequestInfo | URL, init?: RequestInit): Promise<Response> => {\n        const startTime = Date.now();\n        const requestId = this.generateRequestId();\n        const url = input instanceof Request ? input.url : input.toString();\n        const method = init?.method || (input instanceof Request ? input.method : 'GET');\n        \n        if (this.isRecording) {\n          this.networkRequests.set(requestId, {\n            timestamp: startTime,\n            id: requestId,\n            method,\n            url,\n            requestHeaders: this.getRequestHeaders(init, input),\n            requestBody: await this.serializeRequestBody(init, input)\n          });\n        }\n        \n        try {\n          const response = await this.originalFetch(input, init);\n          const duration = Date.now() - startTime;\n          \n          if (this.isRecording) {\n            const networkRequest = this.networkRequests.get(requestId);\n            if (networkRequest) {\n              networkRequest.status = response.status;\n              networkRequest.duration = duration;\n              networkRequest.responseHeaders = this.getResponseHeaders(response);\n              \n              // Optionally capture response body (be careful with large responses)\n              if (this.shouldCaptureResponseBody(response)) {\n                try {\n                  const clonedResponse = response.clone();\n                  networkRequest.responseBody = await clonedResponse.text();\n                } catch (e) {\n                  // Response body couldn't be captured\n                }\n              }\n            }\n          }\n          \n          return response;\n        } catch (error) {\n          const duration = Date.now() - startTime;\n          \n          if (this.isRecording) {\n            const networkRequest = this.networkRequests.get(requestId);\n            if (networkRequest) {\n              networkRequest.duration = duration;\n              networkRequest.failed = true;\n            }\n          }\n          \n          throw error;\n        }\n      };\n    }\n\n    // Capture XMLHttpRequest\n    if (typeof XMLHttpRequest !== 'undefined') {\n      this.originalXMLHttpRequest = XMLHttpRequest;\n      \n      const self = this;\n      \n      window.XMLHttpRequest = function() {\n        const xhr = new self.originalXMLHttpRequest();\n        const requestId = self.generateRequestId();\n        let method = 'GET';\n        let url = '';\n        let startTime = 0;\n        \n        const originalOpen = xhr.open;\n        const originalSend = xhr.send;\n        \n        xhr.open = function(m: string, u: string | URL, ...args: any[]) {\n          method = m;\n          url = u.toString();\n          return originalOpen.call(this, m, u, ...args);\n        };\n        \n        xhr.send = function(body?: any) {\n          startTime = Date.now();\n          \n          if (self.isRecording) {\n            self.networkRequests.set(requestId, {\n              timestamp: startTime,\n              id: requestId,\n              method,\n              url,\n              requestBody: body\n            });\n          }\n          \n          return originalSend.call(this, body);\n        };\n        \n        xhr.addEventListener('loadend', () => {\n          const duration = Date.now() - startTime;\n          \n          if (self.isRecording) {\n            const networkRequest = self.networkRequests.get(requestId);\n            if (networkRequest) {\n              networkRequest.status = xhr.status;\n              networkRequest.duration = duration;\n              networkRequest.failed = xhr.status === 0 || xhr.status >= 400;\n              \n              if (self.shouldCaptureXHRResponse(xhr)) {\n                networkRequest.responseBody = xhr.responseText;\n              }\n            }\n          }\n        });\n        \n        return xhr;\n      };\n    }\n  }\n\n  /**\n   * Setup mouse and keyboard interaction tracking\n   */\n  private setupInteractionTracking(): void {\n    // Mouse events\n    const mouseEvents = ['mousedown', 'mouseup', 'click', 'dblclick', 'mousemove'];\n    \n    mouseEvents.forEach(eventType => {\n      document.addEventListener(eventType, (event: MouseEvent) => {\n        if (!this.isRecording) return;\n        \n        // Throttle mousemove events\n        if (eventType === 'mousemove' && Math.random() > 0.1) return;\n        \n        // Add to heatmap data\n        if (this.heatmapGenerator) {\n          let intensity = 1;\n          if (eventType === 'click') intensity = 10;\n          else if (eventType === 'mousemove') intensity = 2;\n          else if (eventType === 'mousedown') intensity = 5;\n          \n          this.heatmapGenerator.addDataPoint(\n            event.clientX,\n            event.clientY,\n            intensity,\n            eventType === 'click' ? 'click' : 'move'\n          );\n        }\n        \n        this.addEvent({\n          type: 'incremental_snapshot',\n          timestamp: Date.now(),\n          data: {\n            source: 'mouse',\n            type: eventType,\n            x: event.clientX,\n            y: event.clientY,\n            id: this.getElementId(event.target as Element)\n          }\n        });\n      }, { capture: true, passive: true });\n    });\n\n    // Keyboard events\n    document.addEventListener('keydown', (event: KeyboardEvent) => {\n      if (!this.isRecording) return;\n      \n      // Don't capture sensitive keystrokes\n      if (this.shouldIgnoreKeystroke(event)) return;\n      \n      this.addEvent({\n        type: 'incremental_snapshot',\n        timestamp: Date.now(),\n        data: {\n          source: 'keyboard',\n          type: 'keydown',\n          key: this.sanitizeKey(event.key),\n          code: event.code,\n          id: this.getElementId(event.target as Element)\n        }\n      });\n    }, { capture: true, passive: true });\n  }\n\n  /**\n   * Utility methods\n   */\n  private addEvent(event: ReplayEvent): void {\n    this.events.push(event);\n    \n    // Limit event buffer\n    if (this.events.length > 10000) {\n      this.events = this.events.slice(-8000);\n    }\n  }\n\n  private addCustomEvent(type: string, data: any): void {\n    this.addEvent({\n      type: 'custom',\n      timestamp: Date.now(),\n      data: { type, ...data }\n    });\n  }\n\n  private serializeConsoleArgs(args: any[]): any[] {\n    return args.map(arg => {\n      try {\n        if (typeof arg === 'object' && arg !== null) {\n          return JSON.parse(JSON.stringify(arg));\n        }\n        return arg;\n      } catch (e) {\n        return '[Unserializable Object]';\n      }\n    });\n  }\n\n  private generateRequestId(): string {\n    return Date.now().toString(36) + Math.random().toString(36).substr(2);\n  }\n\n  private getRequestHeaders(init?: RequestInit, input?: RequestInfo | URL): Record<string, string> {\n    const headers: Record<string, string> = {};\n    \n    if (init?.headers) {\n      if (init.headers instanceof Headers) {\n        init.headers.forEach((value, key) => {\n          headers[key] = value;\n        });\n      } else if (Array.isArray(init.headers)) {\n        init.headers.forEach(([key, value]) => {\n          headers[key] = value;\n        });\n      } else {\n        Object.assign(headers, init.headers);\n      }\n    }\n    \n    if (input instanceof Request) {\n      input.headers.forEach((value, key) => {\n        headers[key] = value;\n      });\n    }\n    \n    return headers;\n  }\n\n  private getResponseHeaders(response: Response): Record<string, string> {\n    const headers: Record<string, string> = {};\n    response.headers.forEach((value, key) => {\n      headers[key] = value;\n    });\n    return headers;\n  }\n\n  private async serializeRequestBody(init?: RequestInit, input?: RequestInfo | URL): Promise<any> {\n    let body = init?.body;\n    \n    if (input instanceof Request && !body) {\n      try {\n        body = await input.clone().text();\n      } catch (e) {\n        return null;\n      }\n    }\n    \n    if (!body) return null;\n    \n    if (typeof body === 'string') {\n      return body.length > 10000 ? body.substring(0, 10000) + '...[truncated]' : body;\n    }\n    \n    if (body instanceof FormData) {\n      const formData: Record<string, any> = {};\n      body.forEach((value, key) => {\n        formData[key] = value instanceof File ? `[File: ${value.name}]` : value;\n      });\n      return formData;\n    }\n    \n    return '[Binary Data]';\n  }\n\n  private shouldCaptureResponseBody(response: Response): boolean {\n    const contentType = response.headers.get('content-type') || '';\n    const contentLength = parseInt(response.headers.get('content-length') || '0');\n    \n    // Only capture text-based responses under 100KB\n    return contentType.includes('application/json') ||\n           contentType.includes('text/') ||\n           (contentLength > 0 && contentLength < 100000);\n  }\n\n  private shouldCaptureXHRResponse(xhr: XMLHttpRequest): boolean {\n    const contentType = xhr.getResponseHeader('content-type') || '';\n    \n    return contentType.includes('application/json') ||\n           contentType.includes('text/') ||\n           (xhr.responseText && xhr.responseText.length < 100000);\n  }\n\n  private getElementId(element: Element | null): number | undefined {\n    // This would ideally use the same node ID system as the DOM serializer\n    return element ? Math.random() : undefined;\n  }\n\n  private shouldIgnoreKeystroke(event: KeyboardEvent): boolean {\n    const target = event.target as HTMLElement;\n    \n    if (target && target.tagName) {\n      const tagName = target.tagName.toLowerCase();\n      const type = (target as HTMLInputElement).type;\n      \n      // Ignore keystrokes in password fields\n      if (tagName === 'input' && type === 'password') return true;\n      \n      // Ignore keystrokes in elements marked as sensitive\n      if (target.hasAttribute('data-revi-ignore')) return true;\n    }\n    \n    return false;\n  }\n\n  private sanitizeKey(key: string): string {\n    // Don't capture the actual key for sensitive inputs\n    if (key.length === 1 && /[a-zA-Z0-9]/.test(key)) {\n      return '*'; // Mask alphanumeric characters\n    }\n    return key;\n  }\n\n\n  private restoreOriginalNetwork(): void {\n    if (this.originalFetch) {\n      window.fetch = this.originalFetch;\n    }\n    \n    if (this.originalXMLHttpRequest) {\n      window.XMLHttpRequest = this.originalXMLHttpRequest;\n    }\n  }\n}","import { ErrorHandler } from './error-handler';\nimport { SessionManager } from './session';\nimport { NetworkMonitor } from './network-monitor';\nimport { DataManager } from './data-manager';\nimport { UserJourneyTracker } from './user-journey';\nimport { TraceManager } from './trace-manager';\nimport { SamplingManager } from './sampling-manager';\nimport { PerformanceMonitor } from './performance-monitor';\nimport { SessionReplayManager } from './session-replay';\nimport { isBot } from './utils';\nimport type { ReviConfig, ErrorEvent, UserContext } from './types';\n\nexport class Monitor {\n  private config: ReviConfig;\n  private traceManager: TraceManager;\n  private errorHandler: ErrorHandler;\n  private sessionManager: SessionManager;\n  private networkMonitor: NetworkMonitor;\n  private performanceMonitor: PerformanceMonitor;\n  private dataManager: DataManager;\n  private userJourneyTracker: UserJourneyTracker;\n  private sessionReplayManager: SessionReplayManager;\n  private samplingManager: SamplingManager;\n  private isInitialized = false;\n\n  constructor(config: ReviConfig) {\n    this.config = {\n      apiUrl: process.env.REVI_API_URL || 'https://api.revi.dev',\n      environment: 'production',\n      debug: false,\n      sampleRate: 1.0,\n      sessionSampleRate: 1.0,\n      maxBreadcrumbs: 50,\n      privacy: {\n        maskInputs: true,\n        maskPasswords: true,\n        maskCreditCards: true\n      },\n      performance: {\n        captureWebVitals: true,\n        captureResourceTiming: false,\n        captureNavigationTiming: true\n      },\n      replay: {\n        enabled: true,\n        maskAllInputs: false,\n        maskAllText: false\n      },\n      ...config\n    };\n\n    if (!this.config.apiKey) {\n      throw new Error('Revi: API key is required');\n    }\n\n    if (isBot()) {\n      if (this.config.debug) {\n        console.log('Revi: Bot detected, skipping initialization');\n      }\n      return;\n    }\n\n    this.init();\n  }\n\n  private init(): void {\n    if (this.isInitialized) return;\n\n    try {\n      // Create shared trace manager\n      this.traceManager = new TraceManager();\n      \n      // Initialize core components with shared trace manager\n      this.errorHandler = new ErrorHandler(this.config, this.traceManager);\n      this.sessionManager = new SessionManager(this.config, this.traceManager);\n      this.networkMonitor = new NetworkMonitor(this.config, this.traceManager);\n      this.performanceMonitor = new PerformanceMonitor(this.config);\n      this.dataManager = new DataManager(this.config);\n      this.userJourneyTracker = new UserJourneyTracker(this.config);\n      this.sessionReplayManager = new SessionReplayManager(this.config, this.sessionManager.getSessionId());\n      this.samplingManager = new SamplingManager(this.config);\n\n      this.setupAdaptiveFlush();\n      \n      // Start session replay if enabled\n      if (this.config.replay?.enabled) {\n        this.sessionReplayManager.startRecording();\n      }\n      \n      this.isInitialized = true;\n\n      if (this.config.debug) {\n        console.log('Revi: Initialized successfully');\n      }\n    } catch (error) {\n      if (this.config.debug) {\n        console.error('Revi: Initialization failed', error);\n      }\n    }\n  }\n\n  private setupAdaptiveFlush(): void {\n    let errorCount = 0;\n    let lastFlushTime = Date.now();\n    \n    const adaptiveFlush = () => {\n      const now = Date.now();\n      const timeSinceLastFlush = now - lastFlushTime;\n      \n      // Base interval: 10 seconds\n      let flushInterval = 10000;\n      \n      // Reduce interval if there are many errors (max: 3 seconds)\n      if (errorCount > 0) {\n        flushInterval = Math.max(3000, 10000 - (errorCount * 1000));\n      }\n      \n      // Increase interval if no activity (max: 30 seconds)\n      if (errorCount === 0 && timeSinceLastFlush > 15000) {\n        flushInterval = Math.min(30000, flushInterval + 5000);\n      }\n      \n      if (timeSinceLastFlush >= flushInterval) {\n        this.flush();\n        lastFlushTime = now;\n        errorCount = 0; // Reset error count after flush\n      }\n      \n      // Schedule next check\n      setTimeout(adaptiveFlush, 2000);\n    };\n    \n    // Start the adaptive flush cycle\n    adaptiveFlush();\n    \n    // Track errors for adaptive frequency\n    const originalCaptureException = this.captureException.bind(this);\n    this.captureException = (error: Error, options = {}) => {\n      errorCount++;\n      return originalCaptureException(error, options);\n    };\n  }\n\n  // Public API methods\n  captureException(error: Error, options: {\n    level?: 'error' | 'warning' | 'info' | 'debug';\n    tags?: Record<string, string>;\n    extra?: Record<string, any>;\n  } = {}): string {\n    if (!this.isInitialized) return '';\n\n    // Sampling check - always capture critical errors\n    const isCriticalError = options.level === 'error' || !options.level;\n    if (!isCriticalError && this.samplingManager.shouldSkipCapture('error')) {\n      return ''; // Skip non-critical errors based on sampling\n    }\n\n    // Update activity level based on error frequency\n    this.samplingManager.incrementErrorFrequency();\n    this.samplingManager.updateActivityLevel('high');\n\n    const errorId = this.errorHandler.captureException(error, options);\n    if (errorId) {\n      // Create error event and queue for upload\n      const errorEvent: ErrorEvent = {\n        id: errorId,\n        timestamp: Date.now(),\n        message: error.message,\n        stack: error.stack,\n        url: window.location.href,\n        userId: this.config.userId,\n        sessionId: this.sessionManager.getSessionId(),\n        userAgent: navigator.userAgent,\n        environment: this.config.environment,\n        release: this.config.release,\n        tags: options.tags,\n        extra: options.extra,\n        breadcrumbs: this.errorHandler.getBreadcrumbs(),\n        level: options.level || 'error'\n      };\n\n      this.dataManager.queueError(errorEvent);\n      \n      // Track error in user journey\n      if (this.userJourneyTracker) {\n        this.userJourneyTracker.trackError(error, {\n          level: options.level,\n          tags: options.tags,\n          extra: options.extra\n        });\n      }\n    }\n\n    return errorId;\n  }\n\n  captureMessage(message: string, options: {\n    level?: 'error' | 'warning' | 'info' | 'debug';\n    tags?: Record<string, string>;\n    extra?: Record<string, any>;\n  } = {}): string {\n    if (!this.isInitialized) return '';\n\n    const errorId = this.errorHandler.captureMessage(message, options);\n    if (errorId) {\n      const errorEvent: ErrorEvent = {\n        id: errorId,\n        timestamp: Date.now(),\n        message,\n        url: window.location.href,\n        userId: this.config.userId,\n        sessionId: this.sessionManager.getSessionId(),\n        userAgent: navigator.userAgent,\n        environment: this.config.environment,\n        release: this.config.release,\n        tags: options.tags,\n        extra: options.extra,\n        breadcrumbs: this.errorHandler.getBreadcrumbs(),\n        level: options.level || 'info'\n      };\n\n      this.dataManager.queueError(errorEvent);\n    }\n\n    return errorId;\n  }\n\n  addBreadcrumb(breadcrumb: {\n    message: string;\n    category?: string;\n    level?: 'error' | 'warning' | 'info' | 'debug';\n    data?: Record<string, any>;\n  }): void {\n    if (!this.isInitialized) return;\n\n    this.errorHandler.addBreadcrumb({\n      timestamp: Date.now(),\n      message: breadcrumb.message,\n      category: breadcrumb.category || 'manual',\n      level: breadcrumb.level || 'info',\n      data: breadcrumb.data\n    });\n  }\n\n  setUserContext(user: UserContext): void {\n    if (!this.isInitialized) return;\n\n    this.config.userId = user.id;\n    this.errorHandler.setUserContext(user);\n    this.userJourneyTracker.setUserId(user.id || '');\n    this.userJourneyTracker.startTracking(user.id);\n  }\n\n  setTags(tags: Record<string, string>): void {\n    if (!this.isInitialized) return;\n    this.errorHandler.setTags(tags);\n  }\n\n  setExtra(extra: Record<string, any>): void {\n    if (!this.isInitialized) return;\n    this.errorHandler.setExtra(extra);\n  }\n\n  // Session management\n  getSessionId(): string {\n    if (!this.isInitialized) return '';\n    return this.sessionManager.getSessionId();\n  }\n\n  endSession(): void {\n    if (!this.isInitialized) return;\n    \n    this.flush();\n    this.sessionManager.endSession();\n  }\n\n  // Performance monitoring\n  mark(name: string): void {\n    if (!this.isInitialized) return;\n    this.performanceMonitor.mark(name);\n  }\n\n  measure(name: string, startMark?: string, endMark?: string): number | null {\n    if (!this.isInitialized) return null;\n    return this.performanceMonitor.measure(name, startMark, endMark);\n  }\n\n  getWebVitals() {\n    if (!this.isInitialized) return {};\n    return this.performanceMonitor.getWebVitals();\n  }\n\n  // Session Replay methods\n  startSessionReplay(): void {\n    if (!this.isInitialized || !this.sessionReplayManager) return;\n    this.sessionReplayManager.startRecording();\n  }\n\n  stopSessionReplay(): void {\n    if (!this.isInitialized || !this.sessionReplayManager) return;\n    this.sessionReplayManager.stopRecording();\n  }\n\n  getSessionReplayData() {\n    if (!this.isInitialized || !this.sessionReplayManager) return null;\n    return this.sessionReplayManager.getReplayData();\n  }\n\n  // Data management\n  flush(): void {\n    if (!this.isInitialized) return;\n\n    // Get all queued events\n    const sessionEvents = this.sessionManager.flush();\n    const networkEvents = this.networkMonitor.flush();\n\n    // Add session ID to network events\n    networkEvents.forEach(event => {\n      event.sessionId = this.sessionManager.getSessionId();\n    });\n\n    // Queue for upload\n    if (sessionEvents.length > 0) {\n      this.dataManager.queueSessionEvents(sessionEvents);\n    }\n    \n    if (networkEvents.length > 0) {\n      this.dataManager.queueNetworkEvents(networkEvents);\n    }\n  }\n\n\n  // Trace context methods\n  getCurrentTraceId(): string | undefined {\n    return this.traceManager?.getCurrentTraceId();\n  }\n\n  getCurrentSpanId(): string | undefined {\n    return this.traceManager?.getCurrentSpanId();\n  }\n\n  getTraceContext(): { traceId?: string; spanId?: string; parentSpanId?: string } {\n    return this.traceManager?.getTraceContext() || {};\n  }\n\n  startSpan(operationName: string): string | undefined {\n    return this.traceManager?.startSpan(operationName);\n  }\n\n  finishSpan(spanId?: string, data?: Record<string, any>): void {\n    this.traceManager?.finishSpan(spanId, data);\n  }\n\n  destroy(): void {\n    if (!this.isInitialized) return;\n\n    this.flush();\n    \n    if (this.networkMonitor) {\n      this.networkMonitor.destroy();\n    }\n    \n    if (this.dataManager) {\n      this.dataManager.destroy();\n    }\n\n    if (this.sessionReplayManager) {\n      this.sessionReplayManager.stopRecording();\n    }\n\n    if (this.userJourneyTracker) {\n      this.userJourneyTracker.stopTracking();\n    }\n    \n    // Cleanup trace manager\n    if (this.traceManager) {\n      this.traceManager.cleanupSpanData();\n    }\n\n    this.isInitialized = false;\n  }\n}\n"],"names":["generateId","replace","c","r","Math","random","toString","formatStackTrace","error","stack","split","map","line","trim","filter","length","join","TraceManager","constructor","this","spanCounter","spanData","Map","generateNewTrace","currentTraceId","generateTraceId","currentSpanId","undefined","startSpan","operationName","parentSpanId","generateSpanId","setSpanData","startTime","Date","now","finishSpan","spanId","data","getSpanData","endTime","getCurrentTraceId","getCurrentSpanId","getTraceContext","traceId","getParentSpanId","extractTraceFromHeaders","headers","_a","_b","_c","_d","injectTraceHeaders","correlateWithBackendTrace","backendTraceId","backendSpanId","generateRandomHex","array","Uint8Array","crypto","getRandomValues","i","floor","Array","from","byte","padStart","get","set","cleanupSpanData","cutoff","entries","delete","ErrorHandler","config","traceManager","breadcrumbs","userContext","setupGlobalHandlers","window","addEventListener","event","captureError","message","filename","lineno","colno","reason","Error","JSON","stringify","originalConsoleError","console","args","addBreadcrumb","timestamp","category","level","apply","originalConsoleWarn","warn","errorData","sampleRate","errorId","traceContext","errorEvent","id","url","location","href","userId","sessionId","userAgent","navigator","environment","release","tags","extra","beforeSend","call","captureException","options","captureMessage","breadcrumb","push","maxBreadcrumbs","splice","setUserContext","user","setTags","setExtra","getBreadcrumbs","clearBreadcrumbs","SessionManager","events","storage","sessionStorage","setItem","removeItem","getSessionStorage","getOrCreateSessionId","setupEventListeners","trackPageLoad","storageKey","existingId","getItem","newId","getSessionId","scrollTimeout","resizeTimeout","forEach","eventType","document","captureEvent","serializeDOMEvent","capture","passive","type","hidden","clearTimeout","setTimeout","x","scrollX","y","scrollY","width","innerWidth","height","innerHeight","duration","flush","target","tagName","className","textContent","shouldMaskText","slice","coordinates","clientX","clientY","inputEvent","value","shouldMaskInput","element","privacy","maskInputs","includes","name","toLowerCase","some","sensitive","replay","maskAllText","maskSelector","matches","captureLoadEvent","title","referrer","loadTime","performance","readyState","sessionSampleRate","filteredEvent","beforeSendSession","getEvents","clearEvents","endSession","NetworkMonitor","originalFetch","fetch","originalXHROpen","XMLHttpRequest","prototype","open","originalXHRSend","send","setupInterceptors","interceptFetch","interceptXHR","async","method","toUpperCase","shouldMonitorRequest","traceHeaders","modifiedArgs","requestBody","requestSize","body","serializeRequestBody","calculateBodySize","response","responseBody","responseSize","shouldCaptureResponseBody","clonedResponse","clone","extractResponseBody","calculateResponseSize","responseTrace","extractResponseHeaders","statusCode","status","responseTime","captureNetworkEvent","requestHeaders","extractHeaders","responseHeaders","String","self","_reviData","shouldMonitor","reviData","responseType","responseText","FormData","formObject","key","File","URLSearchParams","Object","fromEntries","parse","contentType","json","text","Headers","headerObj","isArray","ArrayBuffer","byteLength","Blob","size","pattern","test","normalizedApiUrl","apiUrl","startsWith","developmentHosts","find","excludeUrls","denyUrls","RegExp","allowUrls","destroy","IndexedDBStorage","db","dbName","version","storeName","maxQueueSize","maxAge","initialize","indexedDB","Promise","resolve","reject","request","onerror","onsuccess","result","onupgradeneeded","objectStoreNames","contains","objectStore","createObjectStore","keyPath","createIndex","unique","store","cleanupExpiredItems","queueSize","getQueueSize","removeOldestItems","item","compress","compressed","transaction","add","getAll","items","errors","sessionEvents","networkEvents","decompressedData","decompress","clear","count","cutoffTime","index","range","IDBKeyRange","upperBound","openCursor","cursor","continue","deletedCount","btoa","unescape","encodeURIComponent","decoded","decodeURIComponent","escape","atob","parseError","substr","LocalStorageAdapter","localStorage","getLocalStorage","existing","storedData","StorageManager","isInitialized","localStorageError","NoOpStorage","storeErrors","ensureInitialized","storeSessionEvents","storeNetworkEvents","getAllData","clearAll","NetworkManager","isOnline","onLine","connectionType","listeners","notifyListeners","detectConnectionType","getConnectionStatus","online","onConnectionChange","callback","indexOf","getBatchSize","getUploadDelay","shouldRetry","attempt","getRetryDelay","min","pow","connection","effectiveType","testConnectivity","testUrl","mode","cache","compressData","jsonString","CompressionStream","stream","writer","writable","getWriter","reader","readable","getReader","bytes","TextEncoder","encode","write","close","done","readerDone","read","compressedBytes","reduce","acc","chunk","offset","base64","fromCharCode","deduplicateEvents","compressionRatio","originalSize","grouped","keys","sort","has","groupedEvents","commonValues","keyArray","values","e","firstValue","every","v","compressedEvent","_common","createOptimalBatches","maxBatchSize","maxBatchBytes","batches","currentBatch","currentBatchSize","eventSize","DataManager","uploadTimer","isUploading","retryAttempts","uploadQueue","storageManager","networkManager","loadQueueFromStorage","startNetworkAwareUploadTimer","setupBeforeUnloadHandler","setupNetworkChangeHandler","saveQueueToStorage","scheduleNextUpload","delay","hasQueuedData","uploadData","finally","uploadDataSync","queueError","catch","err","queueSessionEvents","queueNetworkEvents","batchSize","dedupedErrors","errorBatches","batch","uploadErrorsWithRetry","dedupedEvents","sessionBatches","uploadSessionEventsWithRetry","networkBatches","uploadNetworkEventsWithRetry","createBatches","sendBeacon","payload","session_id","event_type","uploadErrors","stack_trace","user_agent","metadata","compressedData","apiKey","ok","uploadSessionEvents","uploadNetworkEvents","promises","status_code","response_time","request_data","response_data","failures","allSettled","executeWithRetry","operation","currentAttempt","clearQueue","UserJourneyTracker","journeyEvents","isTracking","deviceFingerprint","generateDeviceFingerprint","sessionStartTime","currentPageStartTime","setupJourneyTracking","startTracking","trackPageView","stopTracking","setUserId","viewport","scroll_position","device_fingerprint","language","timezone","Intl","DateTimeFormat","resolvedOptions","timeZone","connection_type","getConnectionType","addJourneyEvent","trackClick","journeyEvent","tag","class","getElementText","attributes","getRelevantAttributes","page_x","pageX","page_y","pageY","trackFormSubmit","form","formData","fields","input","querySelector","has_value","value_length","action","field_count","trackApiCall","duration_ms","api","success","page_context","time_on_page","trackError","context","user_context","session_duration","page_interactions","countPageInteractions","custom_context","currentUrl","handleNavigation","timeSpent","updateLastPageViewDuration","originalPushState","history","pushState","originalReplaceState","replaceState","shouldTrackClick","setInterval","components","screen","colorDepth","platform","cookieEnabled","canvas","createElement","ctx","getContext","textBaseline","font","fillText","toDataURL","fingerprint","hash","charCodeAt","abs","sendJourneyEvents","unshift","user_id","hasAttribute","innerText","substring","attrs","attr","getAttribute","lastEvent","SamplingManager","activityLevel","lastActivity","errorFrequency","performanceImpact","startPerformanceMonitoring","assessPerformanceImpact","recentLongTasks","getEntriesByType","entry","updateActivityLevel","activity","high","medium","low","idle","incrementErrorFrequency","max","shouldSampleError","baseSampleRate","sampling","errorSampleRate","adjustedRate","shouldSampleSession","finalRate","shouldSamplePerformance","performanceSampleRate","shouldSampleNetwork","networkSampleRate","shouldSampleReplay","replaySampleRate","getAdaptiveBatchSize","baseSize","getAdaptiveUploadDelay","baseDelay","shouldSkipCapture","getPerformanceImpact","getActivityLevel","getErrorFrequency","PerformanceMonitor","webVitals","performanceEntries","captureWebVitals","setupWebVitals","captureResourceTiming","setupResourceTiming","captureNavigationTiming","setupNavigationTiming","PerformanceObserver","list","getEntries","lcp","observe","entryTypes","fid","processingStart","clsValue","hadRecentInput","cls","fcp","calculateTTFB","navigationTiming","ttfb","responseStart","requestStart","entryType","transferSize","encodedBodySize","decodedBodySize","domContentLoadedEventEnd","domContentLoadedEventStart","loadEventEnd","loadEventStart","domComplete","domInteractive","getWebVitals","getPerformanceEntries","clearPerformanceEntries","mark","measure","startMark","endMark","getEntriesByName","DOMSerializer","nodeIdMap","WeakMap","nodeMap","nextNodeId","isObserving","takeSnapshot","snapshot","scroll","nodes","stylesheets","resources","serializeDocument","serializeStylesheets","serializeResources","startObserving","onDOMChange","observer","MutationObserver","handleMutations","bind","childList","characterData","subtree","attributeOldValue","characterDataOldValue","stopObserving","disconnect","doc","doctype","publicId","systemId","getNodeId","documentElement","serialized","serializeNode","node","shouldIgnoreNode","nodeId","getNodeType","nodeType","Node","ELEMENT_NODE","serializeAttributes","children","serializeChildren","TEXT_NODE","textNode","COMMENT_NODE","shouldIgnoreAttribute","shouldMaskAttribute","childNodes","serializedChild","styleSheets","stylesheet","cssText","cssRules","rule","disabled","querySelectorAll","img","src","shouldIgnoreResource","failed","complete","naturalWidth","backgroundImage","getComputedStyle","urlMatch","match","mutations","mutation","targetId","change","addedNodes","removedNodes","attributeName","attributeValue","oldValue","DOCUMENT_NODE","blockSelector","parent","parentElement","urlObj","URL","protocol","params","search","parseInt","ConsoleRecorder","originalMethods","isRecording","maxEntries","captureStackTrace","serializeObjects","maxObjectDepth","maxStringLength","ignoredLevels","start","originalMethod","recordEntry","stop","serializeArgs","cleanStackTrace","sourceLine","lineNumber","columnNumber","addEntry","arg","serializeValue","depth","__type","toISOString","fromTimestamp","toTimestamp","filtered","getEntriesByLevel","toSessionEvents","consoleId","exportData","levelCounts","minTime","Infinity","maxTime","stats","totalEntries","errorCount","warningCount","timeRange","end","generateInsights","errorPatterns","findErrorPatterns","performanceIssues","detectPerformanceIssues","recommendations","generateRecommendations","patterns","firstArg","a","b","examples","issues","recentEntries","severity","details","errorCounts","debug","HeatmapGenerator","container","radius","maxIntensity","gradient","blur","minOpacity","maxOpacity","style","position","top","left","pointerEvents","zIndex","appendChild","resizeCanvas","rect","getBoundingClientRect","addDataPoint","intensity","generateFromEvents","_e","_f","render","clearRect","filteredData","d","intensityData","createIntensityMap","createGradient","renderHeatmap","shadowCanvas","shadowCtx","point","createRadialGradient","addColorStop","fillStyle","fillRect","drawImage","getImageData","gradientCanvas","gradientCtx","createLinearGradient","color","parseFloat","gradientData","output","createImageData","alpha","gradientIndex","putImageData","removeChild","removeEventListener","eventTypes","minX","maxX","minY","maxY","totalEvents","bounds","hotSpots","findHotSpots","clickPatterns","analyzeClickPatterns","userBehavior","analyzeUserBehavior","clusters","clusterRadius","foundCluster","cluster","sqrt","round","clicks","current","next","frequency","scrolls","sortedByIntensity","topHalf","scrollDepth","s","engagementScore","mostActiveArea","averageClicksPerSession","SessionReplayManager","heatmapGenerator","consoleLogs","networkRequests","originalConsole","domSerializer","consoleRecorder","maxConsoleEntries","ignoredConsoleLevels","_g","enabled","setupReplay","_j","_h","heatmaps","_l","_k","_o","_m","_q","_p","_s","_r","startRecording","takeFullSnapshot","handleDOMChange","setupNetworkCapture","setupInteractionTracking","stopRecording","restoreOriginalNetwork","getReplayData","consoleEntries","consoleInsights","heatmapData","heatmapInsights","console_logs","network_requests","heatmap_data","session_info","start_time","page_url","analytics","console_insights","heatmap_insights","clearReplayData","addCustomEvent","addEvent","source","toggleHeatmap","visible","getHeatmapInsights","init","requestId","generateRequestId","Request","getRequestHeaders","networkRequest","getResponseHeaders","originalXMLHttpRequest","xhr","originalOpen","originalSend","m","u","shouldCaptureXHRResponse","getElementId","shouldIgnoreKeystroke","sanitizeKey","code","serializeConsoleArgs","assign","contentLength","getResponseHeader","Monitor","process","env","REVI_API_URL","maskPasswords","maskCreditCards","maskAllInputs","errorHandler","sessionManager","networkMonitor","performanceMonitor","dataManager","userJourneyTracker","sessionReplayManager","samplingManager","setupAdaptiveFlush","lastFlushTime","adaptiveFlush","timeSinceLastFlush","flushInterval","originalCaptureException","startSessionReplay","stopSessionReplay","getSessionReplayData"],"mappings":"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"}