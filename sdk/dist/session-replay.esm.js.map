{"version":3,"file":"session-replay.esm.js","sources":["../src/enhanced-dom-serializer.ts","../src/console-recorder.ts","../src/heatmap-generator.ts","../src/session-replay.ts"],"sourcesContent":["import type { ReviConfig } from './types';\n\nexport interface EnhancedSerializedNode {\n  id: number;\n  type: 'element' | 'text' | 'comment' | 'document' | 'doctype';\n  tagName?: string;\n  textContent?: string;\n  attributes?: Record<string, string>;\n  children?: EnhancedSerializedNode[];\n  parentId?: number;\n  \n  // Enhanced styling and layout information\n  computedStyles?: Record<string, string>;\n  inlineStyles?: Record<string, string>;\n  cssRules?: CSSRule[];\n  boundingRect?: DOMRect;\n  visibility?: {\n    visible: boolean;\n    opacity: number;\n    display: string;\n    zIndex: number;\n  };\n  \n  // Interactive state\n  interactionState?: {\n    focused: boolean;\n    hovered: boolean;\n    pressed: boolean;\n    disabled: boolean;\n    checked?: boolean;\n    selected?: boolean;\n  };\n  \n  // Content state for form elements\n  inputValue?: string;\n  selectedOptions?: string[];\n  scrollPosition?: { x: number; y: number };\n  \n  // Performance metrics\n  renderTime?: number;\n  memoryUsage?: number;\n}\n\nexport interface EnhancedDOMSnapshot {\n  timestamp: number;\n  url: string;\n  title: string;\n  viewport: {\n    width: number;\n    height: number;\n    devicePixelRatio: number;\n    scrollX: number;\n    scrollY: number;\n  };\n  nodes: EnhancedSerializedNode[];\n  stylesheets: EnhancedStylesheet[];\n  resources: EnhancedResource[];\n  \n  // Page performance metrics\n  performance?: {\n    domContentLoaded: number;\n    loadComplete: number;\n    paintTimings: Record<string, number>;\n    layoutShifts: any[];\n    memoryUsage: number;\n  };\n  \n  // Environment info\n  environment?: {\n    userAgent: string;\n    language: string;\n    timezone: string;\n    colorScheme: 'light' | 'dark';\n    reducedMotion: boolean;\n  };\n}\n\nexport interface EnhancedStylesheet {\n  href?: string;\n  cssText: string;\n  disabled: boolean;\n  media?: string;\n  title?: string;\n  type?: string;\n  origin: 'author' | 'user' | 'user-agent';\n  \n  // Processed rules for better reconstruction\n  rules: ProcessedCSSRule[];\n  \n  // Performance\n  loadTime?: number;\n  size: number;\n}\n\nexport interface ProcessedCSSRule {\n  type: number;\n  cssText: string;\n  selectorText?: string;\n  declarations?: CSSDeclaration[];\n  media?: string;\n  \n  // Computed specificity and usage\n  specificity?: number;\n  usage?: {\n    matchedElements: number[];\n    frequency: number;\n  };\n}\n\nexport interface CSSDeclaration {\n  property: string;\n  value: string;\n  priority: string;\n  important: boolean;\n}\n\nexport interface EnhancedResource {\n  url: string;\n  type: 'image' | 'font' | 'media' | 'script' | 'stylesheet' | 'fetch' | 'document';\n  method?: string;\n  status?: number;\n  size?: number;\n  mimeType?: string;\n  loadTime?: number;\n  fromCache?: boolean;\n  \n  // For images\n  dimensions?: { width: number; height: number };\n  \n  // Small resources can be inlined\n  data?: string; // Base64 encoded\n  failed?: boolean;\n  blocked?: boolean;\n}\n\nexport interface EnhancedDOMChange extends DOMChange {\n  // Additional context\n  causedBy?: {\n    type: 'user-interaction' | 'script' | 'network' | 'animation' | 'media-query';\n    details?: any;\n  };\n  \n  // Performance impact\n  renderingTime?: number;\n  layoutThrashing?: boolean;\n  \n  // Visual impact\n  visualChange?: {\n    affectedArea: DOMRect;\n    significance: 'minor' | 'moderate' | 'major';\n  };\n}\n\nexport interface DOMChange {\n  timestamp: number;\n  type: 'childList' | 'attributes' | 'characterData' | 'style' | 'class' | 'dataset';\n  target: number; // Node ID\n  addedNodes?: EnhancedSerializedNode[];\n  removedNodes?: number[]; // Node IDs\n  attributeName?: string;\n  attributeValue?: string;\n  oldValue?: string;\n  newValue?: string;\n  \n  // Style-specific changes\n  styleChanges?: {\n    property: string;\n    oldValue: string;\n    newValue: string;\n    computed?: boolean;\n  }[];\n  \n  // Class changes\n  classChanges?: {\n    added: string[];\n    removed: string[];\n  };\n}\n\n/**\n * Enhanced DOM serializer with advanced styling, layout, and interaction capture\n */\nexport class EnhancedDOMSerializer {\n  // private _config: ReviConfig;\n  private nodeIdMap = new WeakMap<Node, number>();\n  private nodeMap = new Map<number, Node>();\n  private nextNodeId = 1;\n  private observer?: MutationObserver;\n  private resizeObserver?: ResizeObserver;\n  private isObserving = false;\n  private onDOMChange?: (change: EnhancedDOMChange) => void;\n  \n  // Performance tracking\n  private performanceObserver?: PerformanceObserver;\n  private layoutShiftEntries: any[] = [];\n  \n  // Style tracking\n  // private _stylesheetMap = new Map<CSSStyleSheet, EnhancedStylesheet>();\n  private computedStyleCache = new WeakMap<Element, Record<string, string>>();\n\n  constructor(_config: ReviConfig) {\n    // this._config = config;\n    this.setupPerformanceObserver();\n    this.setupStylesheetTracking();\n  }\n\n  /**\n   * Take an enhanced snapshot of the DOM with styling and layout information\n   */\n  takeEnhancedSnapshot(): EnhancedDOMSnapshot {\n    const startTime = performance.now();\n    \n    const snapshot: EnhancedDOMSnapshot = {\n      timestamp: Date.now(),\n      url: window.location.href,\n      title: document.title,\n      viewport: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        devicePixelRatio: window.devicePixelRatio,\n        scrollX: window.scrollX,\n        scrollY: window.scrollY\n      },\n      nodes: [],\n      stylesheets: [],\n      resources: [],\n      \n      performance: this.capturePerformanceMetrics(),\n      environment: this.captureEnvironmentInfo()\n    };\n\n    // Serialize DOM with enhanced information\n    snapshot.nodes = this.serializeDocumentEnhanced(document);\n    \n    // Capture stylesheets with processed rules\n    snapshot.stylesheets = this.serializeStylesheetsEnhanced();\n    \n    // Capture resources with detailed metadata\n    snapshot.resources = this.serializeResourcesEnhanced();\n\n    const endTime = performance.now();\n    console.log(`Enhanced DOM snapshot taken in ${endTime - startTime}ms`);\n\n    return snapshot;\n  }\n\n  /**\n   * Start observing DOM changes with enhanced tracking\n   */\n  startEnhancedObserving(onDOMChange: (change: EnhancedDOMChange) => void): void {\n    if (this.isObserving) return;\n\n    this.onDOMChange = onDOMChange;\n    this.observer = new MutationObserver(this.handleEnhancedMutations.bind(this));\n    \n    this.observer.observe(document, {\n      childList: true,\n      attributes: true,\n      characterData: true,\n      subtree: true,\n      attributeOldValue: true,\n      characterDataOldValue: true,\n      attributeFilter: undefined // Capture all attributes\n    });\n\n    // Observe resize changes\n    if (typeof ResizeObserver !== 'undefined') {\n      this.resizeObserver = new ResizeObserver(this.handleResizeChanges.bind(this));\n      this.resizeObserver.observe(document.documentElement);\n    }\n\n    this.isObserving = true;\n  }\n\n  /**\n   * Stop observing DOM changes\n   */\n  stopEnhancedObserving(): void {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = undefined;\n    }\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n      this.resizeObserver = undefined;\n    }\n    if (this.performanceObserver) {\n      this.performanceObserver.disconnect();\n    }\n    this.isObserving = false;\n    this.onDOMChange = undefined;\n  }\n\n  /**\n   * Serialize document with enhanced information\n   */\n  private serializeDocumentEnhanced(doc: Document): EnhancedSerializedNode[] {\n    const nodes: EnhancedSerializedNode[] = [];\n\n    // Add doctype\n    if (doc.doctype) {\n      nodes.push(this.serializeDoctype(doc.doctype));\n    }\n\n    // Serialize document element\n    if (doc.documentElement) {\n      const serialized = this.serializeNodeEnhanced(doc.documentElement);\n      if (serialized) {\n        nodes.push(serialized);\n      }\n    }\n\n    return nodes;\n  }\n\n  /**\n   * Serialize a single node with enhanced information\n   */\n  private serializeNodeEnhanced(node: Node): EnhancedSerializedNode | null {\n    if (this.shouldIgnoreNode(node)) {\n      return null;\n    }\n\n    const nodeId = this.getNodeId(node);\n    const serialized: EnhancedSerializedNode = {\n      id: nodeId,\n      type: this.getNodeType(node),\n      renderTime: performance.now()\n    };\n\n    switch (node.nodeType) {\n      case Node.ELEMENT_NODE:\n        const element = node as Element;\n        serialized.tagName = element.tagName.toLowerCase();\n        serialized.attributes = this.serializeAttributesEnhanced(element);\n        \n        // Capture computed styles\n        serialized.computedStyles = this.captureComputedStyles(element);\n        serialized.inlineStyles = this.captureInlineStyles(element);\n        \n        // Capture layout information\n        serialized.boundingRect = element.getBoundingClientRect();\n        serialized.visibility = this.captureVisibilityInfo(element);\n        \n        // Capture interaction state\n        serialized.interactionState = this.captureInteractionState(element);\n        \n        // Capture form element values\n        if (this.isFormElement(element)) {\n          serialized.inputValue = this.captureInputValue(element);\n          serialized.selectedOptions = this.captureSelectedOptions(element);\n        }\n        \n        // Capture scroll state\n        if (element.scrollWidth > element.clientWidth || element.scrollHeight > element.clientHeight) {\n          serialized.scrollPosition = {\n            x: element.scrollLeft,\n            y: element.scrollTop\n          };\n        }\n        \n        // Serialize children\n        serialized.children = this.serializeChildrenEnhanced(element);\n        break;\n\n      case Node.TEXT_NODE:\n        const textNode = node as Text;\n        serialized.textContent = this.shouldMaskText(textNode) \n          ? '[Masked Text]' \n          : textNode.textContent || '';\n        break;\n\n      case Node.COMMENT_NODE:\n        const commentNode = node as Comment;\n        serialized.textContent = commentNode.textContent || '';\n        break;\n\n      default:\n        return null;\n    }\n\n    return serialized;\n  }\n\n  /**\n   * Capture comprehensive computed styles for an element\n   */\n  private captureComputedStyles(element: Element): Record<string, string> {\n    // Check cache first\n    if (this.computedStyleCache.has(element)) {\n      return this.computedStyleCache.get(element)!;\n    }\n\n    const computedStyle = window.getComputedStyle(element);\n    const styles: Record<string, string> = {};\n\n    // Critical properties for layout and appearance\n    const criticalProperties = [\n      // Layout\n      'display', 'position', 'top', 'right', 'bottom', 'left', 'width', 'height',\n      'margin', 'margin-top', 'margin-right', 'margin-bottom', 'margin-left',\n      'padding', 'padding-top', 'padding-right', 'padding-bottom', 'padding-left',\n      'border', 'border-width', 'border-style', 'border-color', 'border-radius',\n      'box-sizing', 'overflow', 'overflow-x', 'overflow-y', 'z-index',\n      \n      // Flexbox\n      'flex', 'flex-direction', 'flex-wrap', 'justify-content', 'align-items', 'align-self',\n      'flex-grow', 'flex-shrink', 'flex-basis', 'order',\n      \n      // Grid\n      'grid', 'grid-template', 'grid-area', 'justify-self', 'align-self',\n      \n      // Typography\n      'font', 'font-family', 'font-size', 'font-weight', 'font-style', 'line-height',\n      'text-align', 'text-decoration', 'text-transform', 'letter-spacing', 'word-spacing',\n      'color', 'text-shadow',\n      \n      // Background\n      'background', 'background-color', 'background-image', 'background-size', \n      'background-position', 'background-repeat', 'background-attachment',\n      \n      // Effects\n      'opacity', 'visibility', 'transform', 'filter', 'backdrop-filter',\n      'box-shadow', 'clip-path',\n      \n      // Animation\n      'transition', 'animation', 'will-change',\n      \n      // Misc\n      'cursor', 'pointer-events', 'user-select', 'resize'\n    ];\n\n    criticalProperties.forEach(property => {\n      const value = computedStyle.getPropertyValue(property);\n      if (value && value !== 'initial' && value !== 'inherit') {\n        styles[property] = value;\n      }\n    });\n\n    // Cache the result\n    this.computedStyleCache.set(element, styles);\n    return styles;\n  }\n\n  /**\n   * Capture inline styles from the element's style attribute\n   */\n  private captureInlineStyles(element: Element): Record<string, string> {\n    const styles: Record<string, string> = {};\n    \n    if (element instanceof HTMLElement && element.style.length > 0) {\n      for (let i = 0; i < element.style.length; i++) {\n        const property = element.style.item(i);\n        const value = element.style.getPropertyValue(property);\n        const priority = element.style.getPropertyPriority(property);\n        \n        styles[property] = priority ? `${value} !${priority}` : value;\n      }\n    }\n\n    return styles;\n  }\n\n  /**\n   * Capture visibility and display information\n   */\n  private captureVisibilityInfo(element: Element): EnhancedSerializedNode['visibility'] {\n    const computedStyle = window.getComputedStyle(element);\n    const rect = element.getBoundingClientRect();\n    \n    return {\n      visible: rect.width > 0 && rect.height > 0 && computedStyle.visibility !== 'hidden',\n      opacity: parseFloat(computedStyle.opacity),\n      display: computedStyle.display,\n      zIndex: parseInt(computedStyle.zIndex) || 0\n    };\n  }\n\n  /**\n   * Capture interaction state (focus, hover, etc.)\n   */\n  private captureInteractionState(element: Element): EnhancedSerializedNode['interactionState'] {\n    const state: EnhancedSerializedNode['interactionState'] = {\n      focused: document.activeElement === element,\n      hovered: element.matches(':hover'),\n      pressed: element.matches(':active'),\n      disabled: element instanceof HTMLElement ? element.hasAttribute('disabled') : false\n    };\n\n    // Form-specific states\n    if (element instanceof HTMLInputElement) {\n      if (element.type === 'checkbox' || element.type === 'radio') {\n        state.checked = element.checked;\n      }\n    } else if (element instanceof HTMLSelectElement) {\n      state.selected = element.selectedIndex !== -1;\n    }\n\n    return state;\n  }\n\n  /**\n   * Capture form element values\n   */\n  private captureInputValue(element: Element): string | undefined {\n    if (element instanceof HTMLInputElement) {\n      // Don't capture sensitive inputs\n      if (element.type === 'password' || element.hasAttribute('data-sensitive')) {\n        return '[Masked]';\n      }\n      return element.value;\n    } else if (element instanceof HTMLTextAreaElement) {\n      return element.value;\n    } else if (element instanceof HTMLSelectElement) {\n      return element.value;\n    }\n    \n    return undefined;\n  }\n\n  /**\n   * Capture selected options for select elements\n   */\n  private captureSelectedOptions(element: Element): string[] | undefined {\n    if (element instanceof HTMLSelectElement && element.multiple) {\n      const selected = [];\n      for (let i = 0; i < element.options.length; i++) {\n        if (element.options[i].selected) {\n          selected.push(element.options[i].value);\n        }\n      }\n      return selected;\n    }\n    \n    return undefined;\n  }\n\n  /**\n   * Enhanced stylesheet serialization with processed rules\n   */\n  private serializeStylesheetsEnhanced(): EnhancedStylesheet[] {\n    const stylesheets: EnhancedStylesheet[] = [];\n\n    for (let i = 0; i < document.styleSheets.length; i++) {\n      try {\n        const sheet = document.styleSheets[i];\n        const enhanced = this.processStylesheet(sheet);\n        if (enhanced) {\n          stylesheets.push(enhanced);\n        }\n      } catch (error) {\n        // Handle CORS issues or other stylesheet access problems\n        console.warn('Could not access stylesheet:', error);\n      }\n    }\n\n    return stylesheets;\n  }\n\n  /**\n   * Process a stylesheet and extract enhanced information\n   */\n  private processStylesheet(sheet: CSSStyleSheet): EnhancedStylesheet | null {\n    try {\n      const rules: ProcessedCSSRule[] = [];\n      \n      if (sheet.cssRules) {\n        for (let i = 0; i < sheet.cssRules.length; i++) {\n          const rule = sheet.cssRules[i];\n          const processed = this.processCSSRule(rule);\n          if (processed) {\n            rules.push(processed);\n          }\n        }\n      }\n\n      return {\n        href: sheet.href || undefined,\n        cssText: this.extractCSSText(sheet),\n        disabled: sheet.disabled,\n        media: sheet.media.mediaText,\n        title: sheet.title || undefined,\n        type: sheet.type,\n        origin: 'author', // Simplified for now\n        rules,\n        size: this.estimateStylesheetSize(sheet)\n      };\n    } catch (error) {\n      console.warn('Error processing stylesheet:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Process individual CSS rules\n   */\n  private processCSSRule(rule: CSSRule): ProcessedCSSRule | null {\n    const processed: ProcessedCSSRule = {\n      type: rule.type,\n      cssText: rule.cssText\n    };\n\n    if (rule instanceof CSSStyleRule) {\n      processed.selectorText = rule.selectorText;\n      processed.declarations = this.extractDeclarations(rule.style);\n      processed.specificity = this.calculateSpecificity(rule.selectorText);\n    } else if (rule instanceof CSSMediaRule) {\n      processed.media = rule.media.mediaText;\n    }\n\n    return processed;\n  }\n\n  /**\n   * Extract CSS declarations from a CSSStyleDeclaration\n   */\n  private extractDeclarations(style: CSSStyleDeclaration): CSSDeclaration[] {\n    const declarations: CSSDeclaration[] = [];\n    \n    for (let i = 0; i < style.length; i++) {\n      const property = style.item(i);\n      const value = style.getPropertyValue(property);\n      const priority = style.getPropertyPriority(property);\n      \n      declarations.push({\n        property,\n        value,\n        priority,\n        important: priority === 'important'\n      });\n    }\n\n    return declarations;\n  }\n\n  /**\n   * Calculate CSS selector specificity\n   */\n  private calculateSpecificity(selector: string): number {\n    // Simplified specificity calculation\n    const ids = (selector.match(/#[^\\s\\+>~\\.\\[:]+/g) || []).length;\n    const classes = (selector.match(/\\.[^\\s\\+>~\\.\\[:]+/g) || []).length;\n    const attributes = (selector.match(/\\[[^\\]]+\\]/g) || []).length;\n    const pseudoClasses = (selector.match(/:[^\\s\\+>~\\.\\[:]+/g) || []).length;\n    const elements = (selector.match(/[^\\s\\+>~\\.\\[:]+/g) || []).length;\n    \n    return ids * 100 + (classes + attributes + pseudoClasses) * 10 + elements;\n  }\n\n  /**\n   * Enhanced resource serialization\n   */\n  private serializeResourcesEnhanced(): EnhancedResource[] {\n    const resources: EnhancedResource[] = [];\n    const processedUrls = new Set<string>();\n\n    // Process images\n    document.querySelectorAll('img').forEach(img => {\n      if (!processedUrls.has(img.src)) {\n        processedUrls.add(img.src);\n        resources.push(this.createImageResource(img));\n      }\n    });\n\n    // Process fonts (from CSS)\n    // This is complex - would need to parse CSS for @font-face rules\n\n    // Process performance entries for additional resources\n    if ('performance' in window && performance.getEntriesByType) {\n      const resourceEntries = performance.getEntriesByType('resource') as PerformanceResourceTiming[];\n      \n      resourceEntries.forEach(entry => {\n        if (!processedUrls.has(entry.name)) {\n          processedUrls.add(entry.name);\n          resources.push(this.createResourceFromPerformanceEntry(entry));\n        }\n      });\n    }\n\n    return resources;\n  }\n\n  /**\n   * Create enhanced resource info from image element\n   */\n  private createImageResource(img: HTMLImageElement): EnhancedResource {\n    return {\n      url: img.src,\n      type: 'image',\n      dimensions: {\n        width: img.naturalWidth,\n        height: img.naturalHeight\n      },\n      size: undefined, // Would need to be calculated\n      failed: !img.complete || img.naturalWidth === 0\n    };\n  }\n\n  /**\n   * Create resource from performance entry\n   */\n  private createResourceFromPerformanceEntry(entry: PerformanceResourceTiming): EnhancedResource {\n    const resource: EnhancedResource = {\n      url: entry.name,\n      type: this.inferResourceType(entry.name),\n      size: entry.transferSize,\n      loadTime: entry.responseEnd - entry.requestStart,\n      fromCache: entry.transferSize === 0 && entry.decodedBodySize > 0\n    };\n\n    return resource;\n  }\n\n  /**\n   * Enhanced mutation handling\n   */\n  private handleEnhancedMutations(mutations: MutationRecord[]): void {\n    mutations.forEach(mutation => {\n      const change: EnhancedDOMChange = {\n        timestamp: Date.now(),\n        type: mutation.type as any,\n        target: this.getNodeId(mutation.target),\n        oldValue: mutation.oldValue || undefined,\n        renderingTime: performance.now()\n      };\n\n      // Enhanced processing based on mutation type\n      switch (mutation.type) {\n        case 'childList':\n          if (mutation.addedNodes.length > 0) {\n            change.addedNodes = Array.from(mutation.addedNodes)\n              .map(node => this.serializeNodeEnhanced(node))\n              .filter((node): node is EnhancedSerializedNode => node !== null);\n          }\n          if (mutation.removedNodes.length > 0) {\n            change.removedNodes = Array.from(mutation.removedNodes)\n              .map(node => this.getNodeId(node))\n              .filter(id => id !== undefined);\n          }\n          break;\n          \n        case 'attributes':\n          change.attributeName = mutation.attributeName || undefined;\n          if (mutation.target instanceof Element) {\n            change.attributeValue = mutation.target.getAttribute(mutation.attributeName!) || undefined;\n            \n            // Special handling for class and style changes\n            if (mutation.attributeName === 'class') {\n              change.classChanges = this.analyzeClassChanges(mutation.oldValue, change.attributeValue);\n            } else if (mutation.attributeName === 'style') {\n              change.styleChanges = this.analyzeStyleChanges(mutation.target as Element);\n            }\n          }\n          break;\n      }\n\n      // Analyze visual impact\n      change.visualChange = this.analyzeVisualImpact(mutation);\n      \n      this.onDOMChange?.(change);\n    });\n  }\n\n  // ... Additional helper methods for performance tracking, style analysis, etc.\n\n  private setupPerformanceObserver(): void {\n    if (typeof PerformanceObserver !== 'undefined') {\n      this.performanceObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        entries.forEach(entry => {\n          if (entry.entryType === 'layout-shift') {\n            this.layoutShiftEntries.push(entry as any);\n          }\n        });\n      });\n      \n      this.performanceObserver.observe({ \n        entryTypes: ['layout-shift', 'paint', 'measure'] \n      });\n    }\n  }\n\n  private setupStylesheetTracking(): void {\n    // Monitor for dynamically added stylesheets\n    const observer = new MutationObserver((mutations) => {\n      mutations.forEach(mutation => {\n        mutation.addedNodes.forEach(node => {\n          if (node instanceof HTMLLinkElement && node.rel === 'stylesheet') {\n            // Track new stylesheet\n            console.log('New stylesheet added:', node.href);\n          } else if (node instanceof HTMLStyleElement) {\n            // Track new style element\n            console.log('New style element added');\n          }\n        });\n      });\n    });\n\n    observer.observe(document.head, { childList: true });\n  }\n\n  private capturePerformanceMetrics() {\n    if (!('performance' in window)) return undefined;\n\n    const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;\n    const paint = performance.getEntriesByType('paint');\n    \n    return {\n      domContentLoaded: navigation?.domContentLoadedEventEnd || 0,\n      loadComplete: navigation?.loadEventEnd || 0,\n      paintTimings: paint.reduce((acc, entry) => {\n        acc[entry.name] = entry.startTime;\n        return acc;\n      }, {} as Record<string, number>),\n      layoutShifts: [...this.layoutShiftEntries],\n      memoryUsage: (performance as any).memory?.usedJSHeapSize || 0\n    };\n  }\n\n  private captureEnvironmentInfo(): {\n    userAgent: string;\n    language: string;\n    timezone: string;\n    colorScheme: 'light' | 'dark';\n    reducedMotion: boolean;\n  } {\n    return {\n      userAgent: navigator.userAgent,\n      language: navigator.language,\n      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n      colorScheme: window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' as const : 'light' as const,\n      reducedMotion: window.matchMedia('(prefers-reduced-motion: reduce)').matches\n    };\n  }\n\n  // ... More helper methods would be implemented here\n\n  private shouldIgnoreNode(_node: Node): boolean {\n    // Enhanced node filtering logic\n    return false;\n  }\n\n  private getNodeType(node: Node): EnhancedSerializedNode['type'] {\n    switch (node.nodeType) {\n      case Node.ELEMENT_NODE: return 'element';\n      case Node.TEXT_NODE: return 'text';\n      case Node.COMMENT_NODE: return 'comment';\n      case Node.DOCUMENT_NODE: return 'document';\n      case Node.DOCUMENT_TYPE_NODE: return 'doctype';\n      default: return 'element';\n    }\n  }\n\n  private getNodeId(node: Node): number {\n    if (!this.nodeIdMap.has(node)) {\n      const id = this.nextNodeId++;\n      this.nodeIdMap.set(node, id);\n      this.nodeMap.set(id, node);\n    }\n    return this.nodeIdMap.get(node)!;\n  }\n\n  private serializeDoctype(doctype: DocumentType): EnhancedSerializedNode {\n    return {\n      id: this.getNodeId(doctype),\n      type: 'doctype',\n      tagName: 'DOCTYPE',\n      attributes: {\n        name: doctype.name,\n        publicId: doctype.publicId,\n        systemId: doctype.systemId\n      }\n    };\n  }\n\n  private serializeAttributesEnhanced(element: Element): Record<string, string> {\n    const attributes: Record<string, string> = {};\n    \n    for (let i = 0; i < element.attributes.length; i++) {\n      const attr = element.attributes[i];\n      const name = attr.name.toLowerCase();\n      \n      if (this.shouldIgnoreAttribute(name, attr.value)) {\n        continue;\n      }\n\n      if (this.shouldMaskAttribute(name, element)) {\n        attributes[name] = '[Masked]';\n      } else {\n        attributes[name] = attr.value;\n      }\n    }\n\n    return attributes;\n  }\n\n  private serializeChildrenEnhanced(element: Element): EnhancedSerializedNode[] {\n    const children: EnhancedSerializedNode[] = [];\n    \n    for (let i = 0; i < element.childNodes.length; i++) {\n      const child = element.childNodes[i];\n      const serialized = this.serializeNodeEnhanced(child);\n      \n      if (serialized) {\n        children.push(serialized);\n      }\n    }\n\n    return children;\n  }\n\n  private shouldMaskText(textNode: Text): boolean {\n    const parent = textNode.parentElement;\n    if (!parent) return false;\n    \n    const tagName = parent.tagName?.toLowerCase();\n    const type = (parent as HTMLInputElement).type?.toLowerCase();\n    \n    return (tagName === 'input' && type === 'password') ||\n           parent.hasAttribute('data-sensitive') ||\n           parent.closest('[data-sensitive]') !== null;\n  }\n\n  private isFormElement(element: Element): boolean {\n    const tagName = element.tagName.toLowerCase();\n    return ['input', 'textarea', 'select'].includes(tagName);\n  }\n\n  private shouldIgnoreAttribute(name: string, value: string): boolean {\n    // Ignore script event handlers and other potentially sensitive attributes\n    return name.startsWith('on') || name === 'style' && value.length > 1000;\n  }\n\n  private shouldMaskAttribute(name: string, element: Element): boolean {\n    return (name === 'value' && (element as HTMLInputElement).type === 'password') ||\n           element.hasAttribute('data-sensitive');\n  }\n\n  private handleResizeChanges(entries: ResizeObserverEntry[]): void {\n    // Handle viewport or element resize changes\n    entries.forEach(entry => {\n      const change: EnhancedDOMChange = {\n        timestamp: Date.now(),\n        type: 'attributes',\n        target: this.getNodeId(entry.target),\n        attributeName: 'resize',\n        renderingTime: performance.now(),\n        visualChange: {\n          affectedArea: entry.contentRect,\n          significance: 'moderate'\n        }\n      };\n      \n      this.onDOMChange?.(change);\n    });\n  }\n\n  private analyzeClassChanges(oldValue: string | null, newValue: string | undefined) {\n    const oldClasses = oldValue ? oldValue.split(/\\s+/).filter(Boolean) : [];\n    const newClasses = newValue ? newValue.split(/\\s+/).filter(Boolean) : [];\n    \n    const added = newClasses.filter(cls => !oldClasses.includes(cls));\n    const removed = oldClasses.filter(cls => !newClasses.includes(cls));\n    \n    return { added, removed };\n  }\n\n  private analyzeStyleChanges(_element: Element) {\n    // This would compare previous and current computed styles\n    // For now, return empty array\n    return [];\n  }\n\n  private analyzeVisualImpact(mutation: MutationRecord): { affectedArea: DOMRect; significance: 'minor' | 'moderate' | 'major' } | undefined {\n    // Analyze the visual significance of the mutation\n    if (mutation.target instanceof Element) {\n      const rect = mutation.target.getBoundingClientRect();\n      return {\n        affectedArea: rect,\n        significance: rect.width * rect.height > 10000 ? 'major' : \n                     rect.width * rect.height > 1000 ? 'moderate' : 'minor'\n      };\n    }\n    return undefined;\n  }\n\n  private extractCSSText(sheet: CSSStyleSheet): string {\n    try {\n      if (sheet.cssRules) {\n        return Array.from(sheet.cssRules).map(rule => rule.cssText).join('\\n');\n      }\n    } catch (error) {\n      // CORS or other access issues\n    }\n    return '';\n  }\n\n  private estimateStylesheetSize(sheet: CSSStyleSheet): number {\n    return this.extractCSSText(sheet).length;\n  }\n\n  private inferResourceType(url: string): EnhancedResource['type'] {\n    const extension = url.split('.').pop()?.toLowerCase();\n    \n    switch (extension) {\n      case 'jpg':\n      case 'jpeg':\n      case 'png':\n      case 'gif':\n      case 'svg':\n      case 'webp':\n        return 'image';\n      case 'woff':\n      case 'woff2':\n      case 'ttf':\n      case 'otf':\n        return 'font';\n      case 'mp4':\n      case 'webm':\n      case 'ogg':\n        return 'media';\n      case 'js':\n        return 'script';\n      case 'css':\n        return 'stylesheet';\n      default:\n        return 'fetch';\n    }\n  }\n}","import { SessionEvent } from './types';\n\nexport interface ConsoleLogEntry {\n  id: string;\n  timestamp: number;\n  level: 'log' | 'info' | 'warn' | 'error' | 'debug' | 'trace';\n  args: any[];\n  stack?: string;\n  url?: string;\n  lineNumber?: number;\n  columnNumber?: number;\n}\n\nexport interface ConsoleRecorderConfig {\n  maxEntries: number;\n  captureStackTrace: boolean;\n  serializeObjects: boolean;\n  maxObjectDepth: number;\n  maxStringLength: number;\n  ignoredLevels: string[];\n}\n\nexport class ConsoleRecorder {\n  private originalMethods: Record<string, Function> = {};\n  private entries: ConsoleLogEntry[] = [];\n  private config: ConsoleRecorderConfig;\n  private isRecording = false;\n  private sessionId: string;\n\n  constructor(sessionId: string, config: Partial<ConsoleRecorderConfig> = {}) {\n    this.sessionId = sessionId;\n    this.config = {\n      maxEntries: 1000,\n      captureStackTrace: true,\n      serializeObjects: true,\n      maxObjectDepth: 3,\n      maxStringLength: 10000,\n      ignoredLevels: [],\n      ...config\n    };\n  }\n\n  start(): void {\n    if (this.isRecording) return;\n\n    const levels: Array<keyof Console> = ['log', 'info', 'warn', 'error', 'debug', 'trace'];\n    \n    levels.forEach(level => {\n      if (this.config.ignoredLevels.includes(level)) return;\n      \n      const originalMethod = console[level];\n      this.originalMethods[level] = originalMethod;\n      \n      (console as any)[level] = (...args: any[]) => {\n        // Call original method first\n        (originalMethod as any).apply(console, args);\n        \n        // Record the log entry\n        this.recordEntry(level as ConsoleLogEntry['level'], args);\n      };\n    });\n\n    this.isRecording = true;\n  }\n\n  stop(): void {\n    if (!this.isRecording) return;\n\n    // Restore original console methods\n    Object.entries(this.originalMethods).forEach(([level, method]) => {\n      (console as any)[level] = method;\n    });\n\n    this.originalMethods = {};\n    this.isRecording = false;\n  }\n\n  private recordEntry(level: ConsoleLogEntry['level'], args: any[]): void {\n    try {\n      const entry: ConsoleLogEntry = {\n        id: this.generateId(),\n        timestamp: Date.now(),\n        level,\n        args: this.serializeArgs(args)\n      };\n\n      // Capture stack trace for errors and warnings\n      if ((level === 'error' || level === 'warn') && this.config.captureStackTrace) {\n        const error = new Error();\n        if (error.stack) {\n          entry.stack = this.cleanStackTrace(error.stack);\n        }\n      }\n\n      // Add source location if available\n      if (level === 'error' && args[0] instanceof Error) {\n        const error = args[0] as Error;\n        // Try to extract location from error stack\n        const stackLines = error.stack?.split('\\n') || [];\n        const sourceLine = stackLines.find(line => \n          line.includes('.js:') || line.includes('.ts:') || line.includes('.tsx:')\n        );\n        \n        if (sourceLine) {\n          const match = sourceLine.match(/([^/]+):(\\d+):(\\d+)/);\n          if (match) {\n            entry.url = match[1];\n            entry.lineNumber = parseInt(match[2]);\n            entry.columnNumber = parseInt(match[3]);\n          }\n        }\n      }\n\n      this.addEntry(entry);\n    } catch (error) {\n      // Fail silently to avoid infinite loops\n      this.originalMethods.warn?.call(console, 'ConsoleRecorder error:', error);\n    }\n  }\n\n  private serializeArgs(args: any[]): any[] {\n    return args.map(arg => this.serializeValue(arg, 0));\n  }\n\n  private serializeValue(value: any, depth: number): any {\n    if (depth > this.config.maxObjectDepth) {\n      return '[Object too deep]';\n    }\n\n    if (value === null || value === undefined) {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      return value.length > this.config.maxStringLength \n        ? value.substring(0, this.config.maxStringLength) + '...'\n        : value;\n    }\n\n    if (typeof value === 'number' || typeof value === 'boolean') {\n      return value;\n    }\n\n    if (typeof value === 'function') {\n      return `[Function: ${value.name || 'anonymous'}]`;\n    }\n\n    if (value instanceof Error) {\n      return {\n        name: value.name,\n        message: value.message,\n        stack: this.config.captureStackTrace ? this.cleanStackTrace(value.stack || '') : undefined\n      };\n    }\n\n    if (value instanceof Date) {\n      return {\n        __type: 'Date',\n        value: value.toISOString()\n      };\n    }\n\n    if (value instanceof RegExp) {\n      return {\n        __type: 'RegExp',\n        value: value.toString()\n      };\n    }\n\n    if (Array.isArray(value)) {\n      if (!this.config.serializeObjects) return '[Array]';\n      \n      return value.slice(0, 100).map(item => this.serializeValue(item, depth + 1));\n    }\n\n    if (typeof value === 'object') {\n      if (!this.config.serializeObjects) return '[Object]';\n      \n      try {\n        const serialized: Record<string, any> = {};\n        const keys = Object.keys(value).slice(0, 50); // Limit keys\n        \n        for (const key of keys) {\n          try {\n            serialized[key] = this.serializeValue(value[key], depth + 1);\n          } catch {\n            serialized[key] = '[Unserializable]';\n          }\n        }\n        \n        if (Object.keys(value).length > 50) {\n          serialized['...'] = `[${Object.keys(value).length - 50} more keys]`;\n        }\n        \n        return serialized;\n      } catch {\n        return '[Unserializable Object]';\n      }\n    }\n\n    return String(value);\n  }\n\n  private cleanStackTrace(stack: string): string {\n    return stack\n      .split('\\n')\n      .filter(line => \n        !line.includes('console-recorder.ts') && \n        !line.includes('ConsoleRecorder')\n      )\n      .slice(0, 10) // Limit stack depth\n      .join('\\n');\n  }\n\n  private addEntry(entry: ConsoleLogEntry): void {\n    this.entries.push(entry);\n    \n    // Maintain max entries limit\n    if (this.entries.length > this.config.maxEntries) {\n      this.entries = this.entries.slice(-this.config.maxEntries * 0.8);\n    }\n  }\n\n  private generateId(): string {\n    return `console-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  getEntries(fromTimestamp?: number, toTimestamp?: number): ConsoleLogEntry[] {\n    let filtered = this.entries;\n    \n    if (fromTimestamp) {\n      filtered = filtered.filter(entry => entry.timestamp >= fromTimestamp);\n    }\n    \n    if (toTimestamp) {\n      filtered = filtered.filter(entry => entry.timestamp <= toTimestamp);\n    }\n    \n    return [...filtered];\n  }\n\n  getEntriesByLevel(level: ConsoleLogEntry['level']): ConsoleLogEntry[] {\n    return this.entries.filter(entry => entry.level === level);\n  }\n\n  clear(): void {\n    this.entries = [];\n  }\n\n  // Convert console entries to session events format\n  toSessionEvents(): SessionEvent[] {\n    return this.entries.map(entry => ({\n      sessionId: this.sessionId,\n      type: 'console',\n      data: {\n        level: entry.level,\n        args: entry.args,\n        stack: entry.stack,\n        url: entry.url,\n        lineNumber: entry.lineNumber,\n        columnNumber: entry.columnNumber,\n        consoleId: entry.id,\n        originalUrl: entry.url || window.location.href,\n        userAgent: navigator.userAgent\n      },\n      timestamp: entry.timestamp\n    }));\n  }\n\n  // Export for analysis\n  exportData(): {\n    sessionId: string;\n    config: ConsoleRecorderConfig;\n    entries: ConsoleLogEntry[];\n    stats: {\n      totalEntries: number;\n      levelCounts: Record<string, number>;\n      errorCount: number;\n      warningCount: number;\n      timeRange: { start: number; end: number };\n    };\n  } {\n    const levelCounts: Record<string, number> = {};\n    let minTime = Infinity;\n    let maxTime = -Infinity;\n\n    this.entries.forEach(entry => {\n      levelCounts[entry.level] = (levelCounts[entry.level] || 0) + 1;\n      minTime = Math.min(minTime, entry.timestamp);\n      maxTime = Math.max(maxTime, entry.timestamp);\n    });\n\n    return {\n      sessionId: this.sessionId,\n      config: this.config,\n      entries: [...this.entries],\n      stats: {\n        totalEntries: this.entries.length,\n        levelCounts,\n        errorCount: levelCounts.error || 0,\n        warningCount: levelCounts.warn || 0,\n        timeRange: {\n          start: minTime === Infinity ? 0 : minTime,\n          end: maxTime === -Infinity ? 0 : maxTime\n        }\n      }\n    };\n  }\n\n  // Generate insights from console logs\n  generateInsights(): {\n    errorPatterns: Array<{ pattern: string; count: number; examples: ConsoleLogEntry[] }>;\n    performanceIssues: Array<{ type: string; severity: 'low' | 'medium' | 'high'; details: string }>;\n    recommendations: string[];\n  } {\n    const errorPatterns = this.findErrorPatterns();\n    const performanceIssues = this.detectPerformanceIssues();\n    const recommendations = this.generateRecommendations();\n\n    return {\n      errorPatterns,\n      performanceIssues,\n      recommendations\n    };\n  }\n\n  private findErrorPatterns(): Array<{ pattern: string; count: number; examples: ConsoleLogEntry[] }> {\n    const errors = this.entries.filter(entry => entry.level === 'error');\n    const patterns: Record<string, ConsoleLogEntry[]> = {};\n\n    errors.forEach(error => {\n      let pattern = 'Unknown Error';\n      \n      if (error.args.length > 0) {\n        const firstArg = error.args[0];\n        if (typeof firstArg === 'string') {\n          // Extract error pattern from message\n          pattern = firstArg\n            .replace(/\\d+/g, 'N') // Replace numbers with N\n            .replace(/[\"'][^\"']*[\"']/g, 'STRING') // Replace strings with STRING\n            .replace(/\\b\\w+@\\w+\\.\\w+/g, 'EMAIL') // Replace emails\n            .replace(/https?:\\/\\/[^\\s]+/g, 'URL') // Replace URLs\n            .substring(0, 100);\n        } else if (typeof firstArg === 'object' && firstArg.name) {\n          pattern = `${firstArg.name}: ${firstArg.message}`.substring(0, 100);\n        }\n      }\n\n      if (!patterns[pattern]) {\n        patterns[pattern] = [];\n      }\n      patterns[pattern].push(error);\n    });\n\n    return Object.entries(patterns)\n      .sort(([, a], [, b]) => b.length - a.length)\n      .slice(0, 10)\n      .map(([pattern, examples]) => ({\n        pattern,\n        count: examples.length,\n        examples: examples.slice(0, 3) // Show first 3 examples\n      }));\n  }\n\n  private detectPerformanceIssues(): Array<{ type: string; severity: 'low' | 'medium' | 'high'; details: string }> {\n    const issues: Array<{ type: string; severity: 'low' | 'medium' | 'high'; details: string }> = [];\n    \n    // Check for excessive logging\n    const recentEntries = this.entries.filter(entry => \n      entry.timestamp > Date.now() - 60000 // Last minute\n    );\n    \n    if (recentEntries.length > 100) {\n      issues.push({\n        type: 'Excessive Logging',\n        severity: 'medium',\n        details: `${recentEntries.length} console entries in the last minute may impact performance`\n      });\n    }\n\n    // Check for repeated errors\n    const errorCounts: Record<string, number> = {};\n    this.entries\n      .filter(entry => entry.level === 'error')\n      .forEach(entry => {\n        const key = JSON.stringify(entry.args);\n        errorCounts[key] = (errorCounts[key] || 0) + 1;\n      });\n\n    Object.entries(errorCounts).forEach(([, count]) => {\n      if (count > 10) {\n        issues.push({\n          type: 'Repeated Error',\n          severity: count > 50 ? 'high' : 'medium',\n          details: `Same error occurred ${count} times`\n        });\n      }\n    });\n\n    // Check for potential memory leaks (objects not being cleaned up)\n    const objectLogs = this.entries.filter(entry => \n      entry.args.some(arg => \n        typeof arg === 'object' && \n        arg !== null && \n        !Array.isArray(arg)\n      )\n    );\n    \n    if (objectLogs.length > this.entries.length * 0.5) {\n      issues.push({\n        type: 'Object Logging',\n        severity: 'low',\n        details: 'High percentage of object logging may indicate memory leaks'\n      });\n    }\n\n    return issues;\n  }\n\n  private generateRecommendations(): string[] {\n    const recommendations: string[] = [];\n    const stats = this.exportData().stats;\n\n    if (stats.errorCount > 0) {\n      recommendations.push(\n        `Found ${stats.errorCount} console errors. Review error patterns and fix underlying issues.`\n      );\n    }\n\n    if (stats.warningCount > stats.errorCount * 2) {\n      recommendations.push(\n        'High warning-to-error ratio suggests proactive error handling could prevent issues.'\n      );\n    }\n\n    if (stats.totalEntries > 500) {\n      recommendations.push(\n        'Consider reducing console logging in production to improve performance.'\n      );\n    }\n\n    if (stats.levelCounts.debug && stats.levelCounts.debug > 100) {\n      recommendations.push(\n        'Debug logs should be disabled in production environments.'\n      );\n    }\n\n    if (recommendations.length === 0) {\n      recommendations.push('Console logging patterns look healthy.');\n    }\n\n    return recommendations;\n  }\n}","import { SessionEvent } from './types';\n\nexport interface HeatmapData {\n  x: number;\n  y: number;\n  intensity: number;\n  event_type: 'click' | 'move' | 'scroll' | 'hover';\n  timestamp: number;\n}\n\nexport interface HeatmapConfig {\n  radius: number;\n  maxIntensity: number;\n  gradient: Record<string, string>;\n  blur: number;\n  minOpacity: number;\n  maxOpacity: number;\n}\n\nexport class HeatmapGenerator {\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n  private config: HeatmapConfig;\n  private data: HeatmapData[] = [];\n\n  constructor(container: HTMLElement, config: Partial<HeatmapConfig> = {}) {\n    this.config = {\n      radius: 20,\n      maxIntensity: 100,\n      gradient: {\n        0.4: 'blue',\n        0.6: 'cyan',\n        0.7: 'lime',\n        0.8: 'yellow',\n        1.0: 'red'\n      },\n      blur: 15,\n      minOpacity: 0,\n      maxOpacity: 0.6,\n      ...config\n    };\n\n    this.canvas = document.createElement('canvas');\n    this.canvas.style.position = 'absolute';\n    this.canvas.style.top = '0';\n    this.canvas.style.left = '0';\n    this.canvas.style.pointerEvents = 'none';\n    this.canvas.style.zIndex = '9999';\n    \n    container.appendChild(this.canvas);\n    \n    const ctx = this.canvas.getContext('2d');\n    if (!ctx) {\n      throw new Error('Failed to get canvas context');\n    }\n    this.ctx = ctx;\n\n    this.resizeCanvas();\n    window.addEventListener('resize', () => this.resizeCanvas());\n  }\n\n  private resizeCanvas(): void {\n    const rect = this.canvas.parentElement!.getBoundingClientRect();\n    this.canvas.width = rect.width;\n    this.canvas.height = rect.height;\n    this.canvas.style.width = rect.width + 'px';\n    this.canvas.style.height = rect.height + 'px';\n  }\n\n  addDataPoint(x: number, y: number, intensity: number, eventType: HeatmapData['event_type']): void {\n    this.data.push({\n      x,\n      y,\n      intensity,\n      event_type: eventType,\n      timestamp: Date.now()\n    });\n    \n    // Limit data points to prevent memory issues\n    if (this.data.length > 10000) {\n      this.data = this.data.slice(-8000);\n    }\n  }\n\n  generateFromEvents(events: SessionEvent[]): void {\n    this.data = [];\n    \n    events.forEach(event => {\n      if (event.type === 'click' && event.data?.x && event.data?.y) {\n        this.addDataPoint(\n          event.data.x,\n          event.data.y,\n          10,\n          'click'\n        );\n      } else if (event.type === 'mousemove' && event.data?.x && event.data?.y) {\n        this.addDataPoint(\n          event.data.x,\n          event.data.y,\n          2,\n          'move'\n        );\n      } else if (event.type === 'scroll' && event.data?.scrollX !== undefined && event.data?.scrollY !== undefined) {\n        // Convert scroll position to viewport coordinates\n        this.addDataPoint(\n          event.data.scrollX || 0,\n          event.data.scrollY || 0,\n          5,\n          'scroll'\n        );\n      }\n    });\n  }\n\n  render(filter?: HeatmapData['event_type'][]): void {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    \n    if (this.data.length === 0) return;\n\n    const filteredData = filter \n      ? this.data.filter(d => filter.includes(d.event_type))\n      : this.data;\n\n    // Create intensity map\n    const intensityData = this.createIntensityMap(filteredData);\n    \n    // Create gradient\n    const gradient = this.createGradient();\n    \n    // Render heatmap\n    this.renderHeatmap(intensityData, gradient);\n  }\n\n  private createIntensityMap(data: HeatmapData[]): ImageData {\n    const shadowCanvas = document.createElement('canvas');\n    shadowCanvas.width = this.canvas.width;\n    shadowCanvas.height = this.canvas.height;\n    const shadowCtx = shadowCanvas.getContext('2d')!;\n\n    // Draw intensity points\n    data.forEach(point => {\n      const radius = this.config.radius;\n      const gradient = shadowCtx.createRadialGradient(\n        point.x, point.y, 0,\n        point.x, point.y, radius\n      );\n\n      const alpha = Math.min(point.intensity / this.config.maxIntensity, 1);\n      gradient.addColorStop(0, `rgba(0, 0, 0, ${alpha})`);\n      gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\n\n      shadowCtx.fillStyle = gradient;\n      shadowCtx.fillRect(\n        point.x - radius,\n        point.y - radius,\n        radius * 2,\n        radius * 2\n      );\n    });\n\n    // Apply blur\n    shadowCtx.filter = `blur(${this.config.blur}px)`;\n    shadowCtx.drawImage(shadowCanvas, 0, 0);\n\n    return shadowCtx.getImageData(0, 0, shadowCanvas.width, shadowCanvas.height);\n  }\n\n  private createGradient(): ImageData {\n    const gradientCanvas = document.createElement('canvas');\n    gradientCanvas.width = 256;\n    gradientCanvas.height = 1;\n    const gradientCtx = gradientCanvas.getContext('2d')!;\n\n    const gradient = gradientCtx.createLinearGradient(0, 0, 256, 0);\n    Object.entries(this.config.gradient).forEach(([stop, color]) => {\n      gradient.addColorStop(parseFloat(stop), color);\n    });\n\n    gradientCtx.fillStyle = gradient;\n    gradientCtx.fillRect(0, 0, 256, 1);\n\n    return gradientCtx.getImageData(0, 0, 256, 1);\n  }\n\n  private renderHeatmap(intensityData: ImageData, gradientData: ImageData): void {\n    const output = this.ctx.createImageData(intensityData.width, intensityData.height);\n    \n    for (let i = 0; i < intensityData.data.length; i += 4) {\n      const alpha = intensityData.data[i + 3];\n      \n      if (alpha > 0) {\n        const gradientIndex = Math.floor((alpha / 255) * 255) * 4;\n        \n        output.data[i] = gradientData.data[gradientIndex];     // R\n        output.data[i + 1] = gradientData.data[gradientIndex + 1]; // G\n        output.data[i + 2] = gradientData.data[gradientIndex + 2]; // B\n        output.data[i + 3] = Math.floor(alpha * this.config.maxOpacity); // A\n      }\n    }\n\n    this.ctx.putImageData(output, 0, 0);\n  }\n\n  clear(): void {\n    this.data = [];\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n\n  destroy(): void {\n    this.clear();\n    if (this.canvas.parentElement) {\n      this.canvas.parentElement.removeChild(this.canvas);\n    }\n    window.removeEventListener('resize', () => this.resizeCanvas());\n  }\n\n  // Export heatmap data for analysis\n  exportData(): {\n    config: HeatmapConfig;\n    data: HeatmapData[];\n    stats: {\n      totalEvents: number;\n      eventTypes: Record<string, number>;\n      timeRange: { start: number; end: number };\n      bounds: { minX: number; maxX: number; minY: number; maxY: number };\n    };\n  } {\n    const eventTypes: Record<string, number> = {};\n    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;\n    let minTime = Infinity, maxTime = -Infinity;\n\n    this.data.forEach(point => {\n      eventTypes[point.event_type] = (eventTypes[point.event_type] || 0) + 1;\n      \n      minX = Math.min(minX, point.x);\n      maxX = Math.max(maxX, point.x);\n      minY = Math.min(minY, point.y);\n      maxY = Math.max(maxY, point.y);\n      \n      minTime = Math.min(minTime, point.timestamp);\n      maxTime = Math.max(maxTime, point.timestamp);\n    });\n\n    return {\n      config: this.config,\n      data: [...this.data],\n      stats: {\n        totalEvents: this.data.length,\n        eventTypes,\n        timeRange: { start: minTime, end: maxTime },\n        bounds: { minX, maxX, minY, maxY }\n      }\n    };\n  }\n\n  // Generate insights from heatmap data\n  generateInsights(): {\n    hotSpots: Array<{ x: number; y: number; intensity: number; radius: number }>;\n    clickPatterns: Array<{ pattern: string; frequency: number }>;\n    userBehavior: {\n      mostActiveArea: { x: number; y: number; width: number; height: number };\n      averageClicksPerSession: number;\n      scrollDepth: number;\n      engagementScore: number;\n    };\n  } {\n    // Find hot spots using clustering\n    const hotSpots = this.findHotSpots();\n    \n    // Analyze click patterns\n    const clickPatterns = this.analyzeClickPatterns();\n    \n    // Generate user behavior insights\n    const userBehavior = this.analyzeUserBehavior();\n\n    return {\n      hotSpots,\n      clickPatterns,\n      userBehavior\n    };\n  }\n\n  private findHotSpots(): Array<{ x: number; y: number; intensity: number; radius: number }> {\n    const clusters: Array<{ x: number; y: number; intensity: number; count: number }> = [];\n    const clusterRadius = this.config.radius * 2;\n\n    this.data.forEach(point => {\n      let foundCluster = false;\n      \n      for (const cluster of clusters) {\n        const distance = Math.sqrt(\n          Math.pow(point.x - cluster.x, 2) + Math.pow(point.y - cluster.y, 2)\n        );\n        \n        if (distance <= clusterRadius) {\n          // Add to existing cluster\n          cluster.x = (cluster.x * cluster.count + point.x) / (cluster.count + 1);\n          cluster.y = (cluster.y * cluster.count + point.y) / (cluster.count + 1);\n          cluster.intensity += point.intensity;\n          cluster.count++;\n          foundCluster = true;\n          break;\n        }\n      }\n      \n      if (!foundCluster) {\n        clusters.push({\n          x: point.x,\n          y: point.y,\n          intensity: point.intensity,\n          count: 1\n        });\n      }\n    });\n\n    return clusters\n      .filter(cluster => cluster.count >= 3) // Only significant clusters\n      .sort((a, b) => b.intensity - a.intensity)\n      .slice(0, 10) // Top 10 hot spots\n      .map(cluster => ({\n        x: Math.round(cluster.x),\n        y: Math.round(cluster.y),\n        intensity: Math.round(cluster.intensity),\n        radius: Math.min(clusterRadius, cluster.count * 5)\n      }));\n  }\n\n  private analyzeClickPatterns(): Array<{ pattern: string; frequency: number }> {\n    const clicks = this.data.filter(d => d.event_type === 'click');\n    const patterns: Record<string, number> = {};\n\n    // Analyze sequential click patterns\n    for (let i = 0; i < clicks.length - 1; i++) {\n      const current = clicks[i];\n      const next = clicks[i + 1];\n      \n      const timeDiff = next.timestamp - current.timestamp;\n      if (timeDiff < 5000) { // Within 5 seconds\n        const pattern = `(${Math.round(current.x)},${Math.round(current.y)}) -> (${Math.round(next.x)},${Math.round(next.y)})`;\n        patterns[pattern] = (patterns[pattern] || 0) + 1;\n      }\n    }\n\n    return Object.entries(patterns)\n      .sort(([, a], [, b]) => b - a)\n      .slice(0, 5)\n      .map(([pattern, frequency]) => ({ pattern, frequency }));\n  }\n\n  private analyzeUserBehavior(): {\n    mostActiveArea: { x: number; y: number; width: number; height: number };\n    averageClicksPerSession: number;\n    scrollDepth: number;\n    engagementScore: number;\n  } {\n    const clicks = this.data.filter(d => d.event_type === 'click');\n    const scrolls = this.data.filter(d => d.event_type === 'scroll');\n\n    // Find most active area (bounding box of top 50% of events)\n    const sortedByIntensity = [...this.data].sort((a, b) => b.intensity - a.intensity);\n    const topHalf = sortedByIntensity.slice(0, Math.floor(sortedByIntensity.length * 0.5));\n    \n    const minX = Math.min(...topHalf.map(d => d.x));\n    const maxX = Math.max(...topHalf.map(d => d.x));\n    const minY = Math.min(...topHalf.map(d => d.y));\n    const maxY = Math.max(...topHalf.map(d => d.y));\n\n    const scrollDepth = scrolls.length > 0 \n      ? Math.max(...scrolls.map(s => s.y)) / this.canvas.height \n      : 0;\n\n    const engagementScore = Math.min(100, \n      (clicks.length * 2) + \n      (scrollDepth * 50) + \n      (this.data.filter(d => d.event_type === 'move').length * 0.1)\n    );\n\n    return {\n      mostActiveArea: {\n        x: Math.round(minX),\n        y: Math.round(minY),\n        width: Math.round(maxX - minX),\n        height: Math.round(maxY - minY)\n      },\n      averageClicksPerSession: Math.round(clicks.length),\n      scrollDepth: Math.round(scrollDepth * 100) / 100,\n      engagementScore: Math.round(engagementScore)\n    };\n  }\n}","import type { ReviConfig } from './types';\nimport { EnhancedDOMSerializer, EnhancedDOMSnapshot, EnhancedDOMChange } from './enhanced-dom-serializer';\nimport { ConsoleRecorder, ConsoleLogEntry } from './console-recorder';\nimport { HeatmapGenerator, HeatmapData } from './heatmap-generator';\n\nexport interface ReplayEvent {\n  type: 'full_snapshot' | 'incremental_snapshot' | 'meta' | 'custom';\n  timestamp: number;\n  data: any;\n}\n\nexport interface ConsoleLog {\n  timestamp: number;\n  level: 'log' | 'info' | 'warn' | 'error' | 'debug';\n  args: any[];\n  stack?: string;\n}\n\nexport interface NetworkRequest {\n  timestamp: number;\n  id: string;\n  method: string;\n  url: string;\n  status?: number;\n  duration?: number;\n  requestHeaders?: Record<string, string>;\n  responseHeaders?: Record<string, string>;\n  requestBody?: any;\n  responseBody?: any;\n  failed?: boolean;\n}\n\n/**\n * Advanced session replay system with console logs and network requests\n */\nexport class SessionReplayManager {\n  private config: ReviConfig;\n  private domSerializer: EnhancedDOMSerializer;\n  private consoleRecorder: ConsoleRecorder;\n  private heatmapGenerator: HeatmapGenerator | null = null;\n  private events: ReplayEvent[] = [];\n  private consoleLogs: ConsoleLog[] = [];\n  private networkRequests: Map<string, NetworkRequest> = new Map();\n  private isRecording = false;\n  private sessionId: string;\n  private startTime: number;\n  private originalConsole: any = {};\n  private originalFetch: any;\n  private originalXMLHttpRequest: any;\n\n  constructor(config: ReviConfig, sessionId: string) {\n    this.config = config;\n    this.sessionId = sessionId;\n    this.startTime = Date.now();\n    this.domSerializer = new EnhancedDOMSerializer(config);\n    this.consoleRecorder = new ConsoleRecorder(sessionId, {\n      maxEntries: config.replay?.maxConsoleEntries || 1000,\n      captureStackTrace: config.replay?.captureStackTrace !== false,\n      serializeObjects: config.replay?.serializeObjects !== false,\n      maxObjectDepth: config.replay?.maxObjectDepth || 3,\n      maxStringLength: config.replay?.maxStringLength || 10000,\n      ignoredLevels: config.replay?.ignoredConsoleLevels || []\n    });\n    \n    if (this.config.replay?.enabled) {\n      this.setupReplay();\n      \n      // Initialize heatmap generator if enabled\n      if (this.config.replay?.heatmaps?.enabled && typeof document !== 'undefined') {\n        const container = document.body || document.documentElement;\n        if (container) {\n          this.heatmapGenerator = new HeatmapGenerator(container, {\n            radius: config.replay?.heatmaps?.radius || 20,\n            maxIntensity: config.replay?.heatmaps?.maxIntensity || 100,\n            blur: config.replay?.heatmaps?.blur || 15,\n            maxOpacity: config.replay?.heatmaps?.maxOpacity || 0.6\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Start recording session replay\n   */\n  startRecording(): void {\n    if (this.isRecording || !this.config.replay?.enabled) return;\n\n    this.isRecording = true;\n    \n    // Take initial snapshot\n    this.takeFullSnapshot();\n    \n    // Start observing DOM changes\n    this.domSerializer.startEnhancedObserving(this.handleDOMChange.bind(this));\n    \n    // Start console recording\n    this.consoleRecorder.start();\n    \n    // Setup network monitoring\n    this.setupNetworkCapture();\n    \n    // Setup mouse and keyboard tracking\n    this.setupInteractionTracking();\n    \n    // Periodic full snapshots\n    setInterval(() => {\n      if (this.isRecording) {\n        this.takeFullSnapshot();\n      }\n    }, 60000); // Every minute\n    \n    if (this.config.debug) {\n      console.log('Revi: Session replay started');\n    }\n  }\n\n  /**\n   * Stop recording session replay\n   */\n  stopRecording(): void {\n    if (!this.isRecording) return;\n\n    this.isRecording = false;\n    this.domSerializer.stopEnhancedObserving();\n    this.consoleRecorder.stop();\n    this.restoreOriginalNetwork();\n    \n    if (this.heatmapGenerator) {\n      this.heatmapGenerator.destroy();\n      this.heatmapGenerator = null;\n    }\n    \n    if (this.config.debug) {\n      console.log('Revi: Session replay stopped');\n    }\n  }\n\n  /**\n   * Get all replay events\n   */\n  getReplayData(): {\n    events: ReplayEvent[];\n    console_logs: ConsoleLogEntry[];\n    network_requests: NetworkRequest[];\n    heatmap_data?: HeatmapData[];\n    session_info: {\n      session_id: string;\n      start_time: number;\n      duration: number;\n      page_url: string;\n    };\n    analytics: {\n      console_insights: any;\n      heatmap_insights?: any;\n    };\n  } {\n    const consoleEntries = this.consoleRecorder.getEntries();\n    const consoleInsights = this.consoleRecorder.generateInsights();\n    \n    let heatmapData: HeatmapData[] | undefined;\n    let heatmapInsights: any;\n    \n    if (this.heatmapGenerator) {\n      const heatmapExport = this.heatmapGenerator.exportData();\n      heatmapData = heatmapExport.data;\n      heatmapInsights = this.heatmapGenerator.generateInsights();\n    }\n\n    return {\n      events: [...this.events],\n      console_logs: consoleEntries,\n      network_requests: Array.from(this.networkRequests.values()),\n      heatmap_data: heatmapData,\n      session_info: {\n        session_id: this.sessionId,\n        start_time: this.startTime,\n        duration: Date.now() - this.startTime,\n        page_url: window.location.href\n      },\n      analytics: {\n        console_insights: consoleInsights,\n        heatmap_insights: heatmapInsights\n      }\n    };\n  }\n\n  /**\n   * Clear replay data\n   */\n  clearReplayData(): void {\n    this.events = [];\n    this.consoleLogs = [];\n    this.networkRequests.clear();\n    this.consoleRecorder.clear();\n    \n    if (this.heatmapGenerator) {\n      this.heatmapGenerator.clear();\n    }\n  }\n\n  /**\n   * Setup basic replay tracking\n   */\n  private setupReplay(): void {\n    if (typeof window === 'undefined') return;\n\n    // Track page visibility changes\n    document.addEventListener('visibilitychange', () => {\n      this.addCustomEvent('visibility_change', {\n        hidden: document.hidden\n      });\n    });\n\n    // Track window focus/blur\n    window.addEventListener('focus', () => {\n      this.addCustomEvent('window_focus', {});\n    });\n\n    window.addEventListener('blur', () => {\n      this.addCustomEvent('window_blur', {});\n    });\n\n    // Track viewport changes\n    window.addEventListener('resize', () => {\n      this.addCustomEvent('viewport_change', {\n        width: window.innerWidth,\n        height: window.innerHeight\n      });\n    });\n\n    // Track scroll events (throttled)\n    let scrollTimeout: NodeJS.Timeout;\n    window.addEventListener('scroll', () => {\n      clearTimeout(scrollTimeout);\n      scrollTimeout = setTimeout(() => {\n        // Add to heatmap data\n        if (this.heatmapGenerator) {\n          this.heatmapGenerator.addDataPoint(\n            window.scrollX || 0,\n            window.scrollY || 0,\n            5,\n            'scroll'\n          );\n        }\n        \n        this.addCustomEvent('scroll', {\n          x: window.scrollX,\n          y: window.scrollY\n        });\n      }, 100);\n    }, { passive: true });\n  }\n\n  /**\n   * Take a full DOM snapshot\n   */\n  private takeFullSnapshot(): void {\n    if (!this.isRecording) return;\n\n    try {\n      const snapshot = this.domSerializer.takeEnhancedSnapshot();\n      \n      this.addEvent({\n        type: 'full_snapshot',\n        timestamp: Date.now(),\n        data: snapshot\n      });\n    } catch (error) {\n      if (this.config.debug) {\n        console.error('Revi: Failed to take DOM snapshot', error);\n      }\n    }\n  }\n\n  /**\n   * Handle DOM changes\n   */\n  private handleDOMChange(change: EnhancedDOMChange): void {\n    if (!this.isRecording) return;\n\n    this.addEvent({\n      type: 'incremental_snapshot',\n      timestamp: change.timestamp,\n      data: {\n        source: 'mutation',\n        ...change\n      }\n    });\n  }\n\n  /**\n   * Add heatmap methods\n   */\n  renderHeatmap(filter?: ('click' | 'move' | 'scroll')[]): void {\n    if (this.heatmapGenerator) {\n      this.heatmapGenerator.render(filter);\n    }\n  }\n\n  toggleHeatmap(visible: boolean): void {\n    if (this.heatmapGenerator) {\n      if (visible) {\n        this.heatmapGenerator.render();\n      } else {\n        this.heatmapGenerator.clear();\n      }\n    }\n  }\n\n  getHeatmapInsights(): any {\n    return this.heatmapGenerator?.generateInsights() || null;\n  }\n\n  /**\n   * Setup network request capture\n   */\n  private setupNetworkCapture(): void {\n    // Capture fetch requests\n    if (typeof window.fetch !== 'undefined') {\n      this.originalFetch = window.fetch;\n      \n      window.fetch = async (input: RequestInfo | URL, init?: RequestInit): Promise<Response> => {\n        const startTime = Date.now();\n        const requestId = this.generateRequestId();\n        const url = input instanceof Request ? input.url : input.toString();\n        const method = init?.method || (input instanceof Request ? input.method : 'GET');\n        \n        if (this.isRecording) {\n          this.networkRequests.set(requestId, {\n            timestamp: startTime,\n            id: requestId,\n            method,\n            url,\n            requestHeaders: this.getRequestHeaders(init, input),\n            requestBody: await this.serializeRequestBody(init, input)\n          });\n        }\n        \n        try {\n          const response = await this.originalFetch(input, init);\n          const duration = Date.now() - startTime;\n          \n          if (this.isRecording) {\n            const networkRequest = this.networkRequests.get(requestId);\n            if (networkRequest) {\n              networkRequest.status = response.status;\n              networkRequest.duration = duration;\n              networkRequest.responseHeaders = this.getResponseHeaders(response);\n              \n              // Optionally capture response body (be careful with large responses)\n              if (this.shouldCaptureResponseBody(response)) {\n                try {\n                  const clonedResponse = response.clone();\n                  networkRequest.responseBody = await clonedResponse.text();\n                } catch (e) {\n                  // Response body couldn't be captured\n                }\n              }\n            }\n          }\n          \n          return response;\n        } catch (error) {\n          const duration = Date.now() - startTime;\n          \n          if (this.isRecording) {\n            const networkRequest = this.networkRequests.get(requestId);\n            if (networkRequest) {\n              networkRequest.duration = duration;\n              networkRequest.failed = true;\n            }\n          }\n          \n          throw error;\n        }\n      };\n    }\n\n    // Capture XMLHttpRequest\n    if (typeof XMLHttpRequest !== 'undefined') {\n      this.originalXMLHttpRequest = XMLHttpRequest;\n      \n      const self = this;\n      \n      window.XMLHttpRequest = function() {\n        const xhr = new self.originalXMLHttpRequest();\n        const requestId = self.generateRequestId();\n        let method = 'GET';\n        let url = '';\n        let startTime = 0;\n        \n        const originalOpen = xhr.open;\n        const originalSend = xhr.send;\n        \n        xhr.open = function(m: string, u: string | URL, ...args: any[]) {\n          method = m;\n          url = u.toString();\n          return originalOpen.call(this, m, u, ...args);\n        };\n        \n        xhr.send = function(body?: any) {\n          startTime = Date.now();\n          \n          if (self.isRecording) {\n            self.networkRequests.set(requestId, {\n              timestamp: startTime,\n              id: requestId,\n              method,\n              url,\n              requestBody: body\n            });\n          }\n          \n          return originalSend.call(this, body);\n        };\n        \n        xhr.addEventListener('loadend', () => {\n          const duration = Date.now() - startTime;\n          \n          if (self.isRecording) {\n            const networkRequest = self.networkRequests.get(requestId);\n            if (networkRequest) {\n              networkRequest.status = xhr.status;\n              networkRequest.duration = duration;\n              networkRequest.failed = xhr.status === 0 || xhr.status >= 400;\n              \n              if (self.shouldCaptureXHRResponse(xhr)) {\n                networkRequest.responseBody = xhr.responseText;\n              }\n            }\n          }\n        });\n        \n        return xhr;\n      };\n    }\n  }\n\n  /**\n   * Setup mouse and keyboard interaction tracking\n   */\n  private setupInteractionTracking(): void {\n    // Mouse events\n    const mouseEvents = ['mousedown', 'mouseup', 'click', 'dblclick', 'mousemove'];\n    \n    mouseEvents.forEach(eventType => {\n      document.addEventListener(eventType, (event: MouseEvent) => {\n        if (!this.isRecording) return;\n        \n        // Throttle mousemove events\n        if (eventType === 'mousemove' && Math.random() > 0.1) return;\n        \n        // Add to heatmap data\n        if (this.heatmapGenerator) {\n          let intensity = 1;\n          if (eventType === 'click') intensity = 10;\n          else if (eventType === 'mousemove') intensity = 2;\n          else if (eventType === 'mousedown') intensity = 5;\n          \n          this.heatmapGenerator.addDataPoint(\n            event.clientX,\n            event.clientY,\n            intensity,\n            eventType === 'click' ? 'click' : 'move'\n          );\n        }\n        \n        this.addEvent({\n          type: 'incremental_snapshot',\n          timestamp: Date.now(),\n          data: {\n            source: 'mouse',\n            type: eventType,\n            x: event.clientX,\n            y: event.clientY,\n            id: this.getElementId(event.target as Element)\n          }\n        });\n      }, { capture: true, passive: true });\n    });\n\n    // Keyboard events\n    document.addEventListener('keydown', (event: KeyboardEvent) => {\n      if (!this.isRecording) return;\n      \n      // Don't capture sensitive keystrokes\n      if (this.shouldIgnoreKeystroke(event)) return;\n      \n      this.addEvent({\n        type: 'incremental_snapshot',\n        timestamp: Date.now(),\n        data: {\n          source: 'keyboard',\n          type: 'keydown',\n          key: this.sanitizeKey(event.key),\n          code: event.code,\n          id: this.getElementId(event.target as Element)\n        }\n      });\n    }, { capture: true, passive: true });\n  }\n\n  /**\n   * Utility methods\n   */\n  private addEvent(event: ReplayEvent): void {\n    this.events.push(event);\n    \n    // Limit event buffer\n    if (this.events.length > 10000) {\n      this.events = this.events.slice(-8000);\n    }\n  }\n\n  private addCustomEvent(type: string, data: any): void {\n    this.addEvent({\n      type: 'custom',\n      timestamp: Date.now(),\n      data: { type, ...data }\n    });\n  }\n\n  private serializeConsoleArgs(args: any[]): any[] {\n    return args.map(arg => {\n      try {\n        if (typeof arg === 'object' && arg !== null) {\n          return JSON.parse(JSON.stringify(arg));\n        }\n        return arg;\n      } catch (e) {\n        return '[Unserializable Object]';\n      }\n    });\n  }\n\n  private generateRequestId(): string {\n    return Date.now().toString(36) + Math.random().toString(36).substr(2);\n  }\n\n  private getRequestHeaders(init?: RequestInit, input?: RequestInfo | URL): Record<string, string> {\n    const headers: Record<string, string> = {};\n    \n    if (init?.headers) {\n      if (init.headers instanceof Headers) {\n        init.headers.forEach((value, key) => {\n          headers[key] = value;\n        });\n      } else if (Array.isArray(init.headers)) {\n        init.headers.forEach(([key, value]) => {\n          headers[key] = value;\n        });\n      } else {\n        Object.assign(headers, init.headers);\n      }\n    }\n    \n    if (input instanceof Request) {\n      input.headers.forEach((value, key) => {\n        headers[key] = value;\n      });\n    }\n    \n    return headers;\n  }\n\n  private getResponseHeaders(response: Response): Record<string, string> {\n    const headers: Record<string, string> = {};\n    response.headers.forEach((value, key) => {\n      headers[key] = value;\n    });\n    return headers;\n  }\n\n  private async serializeRequestBody(init?: RequestInit, input?: RequestInfo | URL): Promise<any> {\n    let body = init?.body;\n    \n    if (input instanceof Request && !body) {\n      try {\n        body = await input.clone().text();\n      } catch (e) {\n        return null;\n      }\n    }\n    \n    if (!body) return null;\n    \n    if (typeof body === 'string') {\n      return body.length > 10000 ? body.substring(0, 10000) + '...[truncated]' : body;\n    }\n    \n    if (body instanceof FormData) {\n      const formData: Record<string, any> = {};\n      body.forEach((value, key) => {\n        formData[key] = value instanceof File ? `[File: ${value.name}]` : value;\n      });\n      return formData;\n    }\n    \n    return '[Binary Data]';\n  }\n\n  private shouldCaptureResponseBody(response: Response): boolean {\n    const contentType = response.headers.get('content-type') || '';\n    const contentLength = parseInt(response.headers.get('content-length') || '0');\n    \n    // Only capture text-based responses under 100KB\n    return contentType.includes('application/json') ||\n           contentType.includes('text/') ||\n           (contentLength > 0 && contentLength < 100000);\n  }\n\n  private shouldCaptureXHRResponse(xhr: XMLHttpRequest): boolean {\n    const contentType = xhr.getResponseHeader('content-type') || '';\n    \n    return contentType.includes('application/json') ||\n           contentType.includes('text/') ||\n           (xhr.responseText && xhr.responseText.length < 100000);\n  }\n\n  private getElementId(element: Element | null): number | undefined {\n    // This would ideally use the same node ID system as the DOM serializer\n    return element ? Math.random() : undefined;\n  }\n\n  private shouldIgnoreKeystroke(event: KeyboardEvent): boolean {\n    const target = event.target as HTMLElement;\n    \n    if (target && target.tagName) {\n      const tagName = target.tagName.toLowerCase();\n      const type = (target as HTMLInputElement).type;\n      \n      // Ignore keystrokes in password fields\n      if (tagName === 'input' && type === 'password') return true;\n      \n      // Ignore keystrokes in elements marked as sensitive\n      if (target.hasAttribute('data-revi-ignore')) return true;\n    }\n    \n    return false;\n  }\n\n  private sanitizeKey(key: string): string {\n    // Don't capture the actual key for sensitive inputs\n    if (key.length === 1 && /[a-zA-Z0-9]/.test(key)) {\n      return '*'; // Mask alphanumeric characters\n    }\n    return key;\n  }\n\n\n  private restoreOriginalNetwork(): void {\n    if (this.originalFetch) {\n      window.fetch = this.originalFetch;\n    }\n    \n    if (this.originalXMLHttpRequest) {\n      window.XMLHttpRequest = this.originalXMLHttpRequest;\n    }\n  }\n}"],"names":["EnhancedDOMSerializer","constructor","_config","this","nodeIdMap","WeakMap","nodeMap","Map","nextNodeId","isObserving","layoutShiftEntries","computedStyleCache","setupPerformanceObserver","setupStylesheetTracking","takeEnhancedSnapshot","performance","now","snapshot","timestamp","Date","url","window","location","href","title","document","viewport","width","innerWidth","height","innerHeight","devicePixelRatio","scrollX","scrollY","nodes","stylesheets","resources","capturePerformanceMetrics","environment","captureEnvironmentInfo","serializeDocumentEnhanced","serializeStylesheetsEnhanced","serializeResourcesEnhanced","startEnhancedObserving","onDOMChange","observer","MutationObserver","handleEnhancedMutations","bind","observe","childList","attributes","characterData","subtree","attributeOldValue","characterDataOldValue","attributeFilter","undefined","ResizeObserver","resizeObserver","handleResizeChanges","documentElement","stopEnhancedObserving","disconnect","performanceObserver","doc","doctype","push","serializeDoctype","serialized","serializeNodeEnhanced","node","shouldIgnoreNode","id","getNodeId","type","getNodeType","renderTime","nodeType","Node","ELEMENT_NODE","element","tagName","toLowerCase","serializeAttributesEnhanced","computedStyles","captureComputedStyles","inlineStyles","captureInlineStyles","boundingRect","getBoundingClientRect","visibility","captureVisibilityInfo","interactionState","captureInteractionState","isFormElement","inputValue","captureInputValue","selectedOptions","captureSelectedOptions","scrollWidth","clientWidth","scrollHeight","clientHeight","scrollPosition","x","scrollLeft","y","scrollTop","children","serializeChildrenEnhanced","TEXT_NODE","textNode","textContent","shouldMaskText","COMMENT_NODE","has","get","computedStyle","getComputedStyle","styles","forEach","property","value","getPropertyValue","set","HTMLElement","style","length","i","item","priority","getPropertyPriority","rect","visible","opacity","parseFloat","display","zIndex","parseInt","state","focused","activeElement","hovered","matches","pressed","disabled","hasAttribute","HTMLInputElement","checked","HTMLSelectElement","selected","selectedIndex","HTMLTextAreaElement","multiple","options","styleSheets","sheet","enhanced","processStylesheet","error","rules","cssRules","processed","processCSSRule","cssText","extractCSSText","media","mediaText","origin","size","estimateStylesheetSize","rule","CSSStyleRule","selectorText","declarations","extractDeclarations","specificity","calculateSpecificity","CSSMediaRule","important","selector","match","processedUrls","Set","querySelectorAll","img","src","add","createImageResource","getEntriesByType","entry","name","createResourceFromPerformanceEntry","dimensions","naturalWidth","naturalHeight","failed","complete","inferResourceType","transferSize","loadTime","responseEnd","requestStart","fromCache","decodedBodySize","mutations","mutation","change","target","oldValue","renderingTime","addedNodes","Array","from","map","filter","removedNodes","attributeName","Element","attributeValue","getAttribute","classChanges","analyzeClassChanges","styleChanges","analyzeStyleChanges","visualChange","analyzeVisualImpact","_a","call","PerformanceObserver","list","getEntries","entryType","entryTypes","HTMLLinkElement","rel","HTMLStyleElement","head","navigation","paint","domContentLoaded","domContentLoadedEventEnd","loadComplete","loadEventEnd","paintTimings","reduce","acc","startTime","layoutShifts","memoryUsage","memory","usedJSHeapSize","userAgent","navigator","language","timezone","Intl","DateTimeFormat","resolvedOptions","timeZone","colorScheme","matchMedia","reducedMotion","_node","DOCUMENT_NODE","DOCUMENT_TYPE_NODE","publicId","systemId","attr","shouldIgnoreAttribute","shouldMaskAttribute","childNodes","parent","parentElement","_b","closest","includes","startsWith","entries","affectedArea","contentRect","significance","newValue","oldClasses","split","Boolean","newClasses","added","cls","removed","_element","join","pop","ConsoleRecorder","sessionId","config","originalMethods","isRecording","maxEntries","captureStackTrace","serializeObjects","maxObjectDepth","maxStringLength","ignoredLevels","start","level","originalMethod","console","args","apply","recordEntry","stop","Object","method","generateId","serializeArgs","Error","stack","cleanStackTrace","sourceLine","find","line","lineNumber","columnNumber","addEntry","warn","arg","serializeValue","depth","substring","message","__type","toISOString","RegExp","isArray","slice","keys","key","String","Math","random","toString","substr","fromTimestamp","toTimestamp","filtered","getEntriesByLevel","clear","toSessionEvents","data","consoleId","originalUrl","exportData","levelCounts","minTime","Infinity","maxTime","min","max","stats","totalEntries","errorCount","warningCount","timeRange","end","generateInsights","errorPatterns","findErrorPatterns","performanceIssues","detectPerformanceIssues","recommendations","generateRecommendations","errors","patterns","pattern","firstArg","replace","sort","a","b","examples","count","issues","recentEntries","severity","details","errorCounts","JSON","stringify","some","debug","HeatmapGenerator","container","radius","maxIntensity","gradient","blur","minOpacity","maxOpacity","canvas","createElement","position","top","left","pointerEvents","appendChild","ctx","getContext","resizeCanvas","addEventListener","addDataPoint","intensity","eventType","event_type","generateFromEvents","events","event","_c","_d","_e","_f","render","clearRect","filteredData","d","intensityData","createIntensityMap","createGradient","renderHeatmap","shadowCanvas","shadowCtx","point","createRadialGradient","addColorStop","fillStyle","fillRect","drawImage","getImageData","gradientCanvas","gradientCtx","createLinearGradient","color","gradientData","output","createImageData","alpha","gradientIndex","floor","putImageData","destroy","removeChild","removeEventListener","eventTypes","minX","maxX","minY","maxY","totalEvents","bounds","hotSpots","findHotSpots","clickPatterns","analyzeClickPatterns","userBehavior","analyzeUserBehavior","clusters","clusterRadius","foundCluster","cluster","sqrt","pow","round","clicks","current","next","frequency","scrolls","sortedByIntensity","topHalf","scrollDepth","s","engagementScore","mostActiveArea","averageClicksPerSession","SessionReplayManager","heatmapGenerator","consoleLogs","networkRequests","originalConsole","domSerializer","consoleRecorder","replay","maxConsoleEntries","ignoredConsoleLevels","_g","enabled","setupReplay","_j","_h","heatmaps","body","_l","_k","_o","_m","_q","_p","_s","_r","startRecording","takeFullSnapshot","handleDOMChange","setupNetworkCapture","setupInteractionTracking","setInterval","stopRecording","restoreOriginalNetwork","getReplayData","consoleEntries","consoleInsights","heatmapData","heatmapInsights","console_logs","network_requests","values","heatmap_data","session_info","session_id","start_time","duration","page_url","analytics","console_insights","heatmap_insights","clearReplayData","scrollTimeout","addCustomEvent","hidden","clearTimeout","setTimeout","passive","addEvent","source","toggleHeatmap","getHeatmapInsights","fetch","originalFetch","async","input","init","requestId","generateRequestId","Request","requestHeaders","getRequestHeaders","requestBody","serializeRequestBody","response","networkRequest","status","responseHeaders","getResponseHeaders","shouldCaptureResponseBody","clonedResponse","clone","responseBody","text","e","XMLHttpRequest","originalXMLHttpRequest","self","xhr","originalOpen","open","originalSend","send","m","u","shouldCaptureXHRResponse","responseText","clientX","clientY","getElementId","capture","shouldIgnoreKeystroke","sanitizeKey","code","serializeConsoleArgs","parse","headers","Headers","assign","FormData","formData","File","contentType","contentLength","getResponseHeader","test"],"mappings":"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"}