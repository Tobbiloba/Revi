{"version":3,"file":"index.js","sources":["../src/utils.ts","../src/trace-manager.ts","../src/error-handler.ts","../src/session.ts","../src/network-monitor.ts","../src/indexed-db-storage.ts","../src/storage-manager.ts","../src/network-manager.ts","../src/compression-utils.ts","../src/debug-logger.ts","../src/data-manager.ts","../src/user-journey.ts","../src/sampling-manager.ts","../src/performance-monitor.ts","../src/enhanced-dom-serializer.ts","../src/console-recorder.ts","../src/heatmap-generator.ts","../src/session-replay.ts","../src/device-info-manager.ts","../src/monitor.ts","../src/retry-manager.ts","../src/circuit-breaker.ts","../src/resilient-storage.ts","../src/health-monitor.ts","../src/sync-manager.ts","../src/idempotency-manager.ts","../src/resilience-coordinator.ts"],"sourcesContent":["export function generateId(): string {\n  return 'xxxx-xxxx-4xxx-yxxx-xxxx'.replace(/[xy]/g, function(c) {\n    const r = Math.random() * 16 | 0;\n    const v = c === 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\nexport function formatStackTrace(error: Error): string {\n  if (!error.stack) return '';\n  \n  return error.stack\n    .split('\\n')\n    .map(line => line.trim())\n    .filter(line => line.length > 0)\n    .join('\\n');\n}\n\nexport function sanitizeUrl(url: string, allowUrls: string[] = [], denyUrls: string[] = []): string {\n  // Check deny list first\n  if (denyUrls.some(pattern => new RegExp(pattern).test(url))) {\n    return '[Filtered]';\n  }\n  \n  // If allow list is provided, ensure URL matches\n  if (allowUrls.length > 0 && !allowUrls.some(pattern => new RegExp(pattern).test(url))) {\n    return '[Filtered]';\n  }\n  \n  // Remove sensitive query parameters\n  try {\n    const urlObj = new URL(url);\n    const sensitiveParams = ['password', 'token', 'key', 'secret', 'auth', 'api_key'];\n    \n    sensitiveParams.forEach(param => {\n      if (urlObj.searchParams.has(param)) {\n        urlObj.searchParams.set(param, '[Filtered]');\n      }\n    });\n    \n    return urlObj.toString();\n  } catch {\n    return url;\n  }\n}\n\nexport function maskSensitiveData(data: any, maskInputs = true): any {\n  if (typeof data !== 'object' || data === null) {\n    return data;\n  }\n  \n  if (Array.isArray(data)) {\n    return data.map(item => maskSensitiveData(item, maskInputs));\n  }\n  \n  const masked: any = {};\n  const sensitiveKeys = ['password', 'token', 'key', 'secret', 'auth', 'api_key', 'credit_card', 'ssn'];\n  \n  Object.keys(data).forEach(key => {\n    const lowerKey = key.toLowerCase();\n    if (sensitiveKeys.some(sensitive => lowerKey.includes(sensitive))) {\n      masked[key] = '[Masked]';\n    } else if (typeof data[key] === 'object') {\n      masked[key] = maskSensitiveData(data[key], maskInputs);\n    } else {\n      masked[key] = data[key];\n    }\n  });\n  \n  return masked;\n}\n\nexport function debounce<T extends (...args: any[]) => any>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout;\n  \n  return function executedFunction(...args: Parameters<T>) {\n    const later = () => {\n      clearTimeout(timeout);\n      func(...args);\n    };\n    \n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n}\n\nexport function throttle<T extends (...args: any[]) => any>(\n  func: T,\n  limit: number\n): (...args: Parameters<T>) => void {\n  let inThrottle = false;\n  \n  return function executedFunction(...args: Parameters<T>) {\n    if (!inThrottle) {\n      func(...args);\n      inThrottle = true;\n      setTimeout(() => inThrottle = false, limit);\n    }\n  };\n}\n\nexport function isBot(): boolean {\n  if (typeof navigator === 'undefined') return false;\n  \n  const botPatterns = [\n    /bot/i,\n    /spider/i,\n    /crawl/i,\n    /headless/i,\n    /phantom/i,\n    /selenium/i\n  ];\n  \n  return botPatterns.some(pattern => pattern.test(navigator.userAgent));\n}\n\nexport function getSessionStorage(): Storage | null {\n  try {\n    if (typeof window !== 'undefined' && window.sessionStorage) {\n      window.sessionStorage.setItem('test', 'test');\n      window.sessionStorage.removeItem('test');\n      return window.sessionStorage;\n    }\n  } catch {\n    // Storage not available\n  }\n  return null;\n}\n\nexport function getLocalStorage(): Storage | null {\n  try {\n    if (typeof window !== 'undefined' && window.localStorage) {\n      window.localStorage.setItem('test', 'test');\n      window.localStorage.removeItem('test');\n      return window.localStorage;\n    }\n  } catch {\n    // Storage not available\n  }\n  return null;\n}\n","export class TraceManager {\n  private currentTraceId?: string;\n  private currentSpanId?: string;\n  private spanCounter = 0;\n\n  constructor() {\n    // Initialize with session-level trace ID if needed\n    this.generateNewTrace();\n  }\n\n  generateNewTrace(): string {\n    this.currentTraceId = this.generateTraceId();\n    this.currentSpanId = undefined;\n    this.spanCounter = 0;\n    return this.currentTraceId;\n  }\n\n  startSpan(operationName?: string): string {\n    const parentSpanId = this.currentSpanId;\n    this.currentSpanId = this.generateSpanId();\n    this.spanCounter++;\n    \n    // Store span context for later correlation\n    if (operationName) {\n      this.setSpanData(operationName, { \n        parentSpanId,\n        operationName,\n        startTime: Date.now()\n      });\n    }\n\n    return this.currentSpanId;\n  }\n\n  finishSpan(spanId?: string, data?: Record<string, any>): void {\n    if (spanId && this.currentSpanId === spanId) {\n      // Mark span as finished\n      if (data) {\n        this.setSpanData(spanId, { \n          ...this.getSpanData(spanId),\n          ...data,\n          endTime: Date.now()\n        });\n      }\n    }\n  }\n\n  getCurrentTraceId(): string | undefined {\n    return this.currentTraceId;\n  }\n\n  getCurrentSpanId(): string | undefined {\n    return this.currentSpanId;\n  }\n\n  getTraceContext(): { traceId?: string; spanId?: string; parentSpanId?: string } {\n    return {\n      traceId: this.currentTraceId,\n      spanId: this.currentSpanId,\n      parentSpanId: this.getParentSpanId()\n    };\n  }\n\n  // Extract trace ID from headers (for network requests)\n  extractTraceFromHeaders(headers: Record<string, string>): { traceId?: string; spanId?: string } {\n    // Support various tracing standards\n    const traceId = headers['x-trace-id'] || \n                   headers['traceparent']?.split('-')[1] ||\n                   headers['b3-traceid'] ||\n                   headers['uber-trace-id']?.split(':')[0];\n\n    const spanId = headers['x-span-id'] || \n                  headers['traceparent']?.split('-')[2] ||\n                  headers['b3-spanid'] ||\n                  headers['uber-trace-id']?.split(':')[1];\n\n    return { traceId, spanId };\n  }\n\n  // Inject trace headers for outgoing requests\n  injectTraceHeaders(): Record<string, string> {\n    if (!this.currentTraceId) {\n      return {};\n    }\n\n    const headers: Record<string, string> = {};\n    \n    // Add custom headers\n    headers['x-trace-id'] = this.currentTraceId;\n    if (this.currentSpanId) {\n      headers['x-span-id'] = this.currentSpanId;\n      headers['x-parent-span-id'] = this.getParentSpanId() || '';\n    }\n\n    // Add W3C Trace Context (traceparent header)\n    if (this.currentSpanId) {\n      headers['traceparent'] = `00-${this.currentTraceId}-${this.currentSpanId}-01`;\n    }\n\n    return headers;\n  }\n\n  // Correlate with backend trace (when available)\n  correlateWithBackendTrace(backendTraceId?: string, backendSpanId?: string): void {\n    if (backendTraceId) {\n      this.currentTraceId = backendTraceId;\n    }\n    if (backendSpanId) {\n      this.currentSpanId = backendSpanId;\n    }\n  }\n\n  private generateTraceId(): string {\n    // Generate 128-bit trace ID (32 hex characters)\n    return this.generateRandomHex(32);\n  }\n\n  private generateSpanId(): string {\n    // Generate 64-bit span ID (16 hex characters)\n    return this.generateRandomHex(16);\n  }\n\n  private generateRandomHex(length: number): string {\n    const array = new Uint8Array(length / 2);\n    if (typeof crypto !== 'undefined' && crypto.getRandomValues) {\n      crypto.getRandomValues(array);\n    } else {\n      // Fallback for environments without crypto\n      for (let i = 0; i < array.length; i++) {\n        array[i] = Math.floor(Math.random() * 256);\n      }\n    }\n    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');\n  }\n\n  private getParentSpanId(): string | undefined {\n    // This would typically track a span stack, simplified for now\n    return this.spanData.get(this.currentSpanId || '')?.parentSpanId;\n  }\n\n  private spanData = new Map<string, any>();\n\n  private setSpanData(spanId: string, data: any): void {\n    this.spanData.set(spanId, data);\n  }\n\n  private getSpanData(spanId: string): any {\n    return this.spanData.get(spanId) || {};\n  }\n\n  // Clean up old span data to prevent memory leaks\n  cleanupSpanData(): void {\n    const cutoff = Date.now() - 5 * 60 * 1000; // 5 minutes ago\n    for (const [spanId, data] of this.spanData.entries()) {\n      if (data.endTime && data.endTime < cutoff) {\n        this.spanData.delete(spanId);\n      }\n    }\n  }\n}","import { formatStackTrace, generateId } from './utils';\nimport type { ErrorEvent, Breadcrumb, ReviConfig } from './types';\nimport { TraceManager } from './trace-manager';\n\nexport class ErrorHandler {\n  private config: ReviConfig;\n  private breadcrumbs: Breadcrumb[] = [];\n  private userContext: any = {};\n  private traceManager: TraceManager;\n\n  constructor(config: ReviConfig, traceManager?: TraceManager) {\n    this.config = config;\n    this.traceManager = traceManager || new TraceManager();\n    this.setupGlobalHandlers();\n  }\n\n  private setupGlobalHandlers(): void {\n    if (typeof window === 'undefined') return;\n\n    // Global error handler\n    window.addEventListener('error', (event) => {\n      this.captureError({\n        message: event.message,\n        filename: event.filename,\n        lineno: event.lineno,\n        colno: event.colno,\n        error: event.error\n      });\n    });\n\n    // Unhandled promise rejections\n    window.addEventListener('unhandledrejection', (event) => {\n      const error = event.reason;\n      let message = 'Unhandled Promise Rejection';\n      let stack = '';\n\n      if (error instanceof Error) {\n        message = error.message;\n        stack = formatStackTrace(error);\n      } else if (typeof error === 'string') {\n        message = error;\n      } else {\n        message = JSON.stringify(error);\n      }\n\n      this.captureError({\n        message,\n        stack,\n        error\n      });\n    });\n\n    // Console error interception\n    const originalConsoleError = console.error;\n    console.error = (...args: any[]) => {\n      this.addBreadcrumb({\n        timestamp: Date.now(),\n        message: args.join(' '),\n        category: 'console',\n        level: 'error'\n      });\n      originalConsoleError.apply(console, args);\n    };\n\n    // Console warn interception\n    const originalConsoleWarn = console.warn;\n    console.warn = (...args: any[]) => {\n      this.addBreadcrumb({\n        timestamp: Date.now(),\n        message: args.join(' '),\n        category: 'console',\n        level: 'warning'\n      });\n      originalConsoleWarn.apply(console, args);\n    };\n  }\n\n  captureError(errorData: {\n    message: string;\n    stack?: string;\n    filename?: string;\n    lineno?: number;\n    colno?: number;\n    error?: Error;\n    level?: 'error' | 'warning' | 'info' | 'debug';\n    tags?: Record<string, string>;\n    extra?: Record<string, any>;\n  }): string {\n    // Apply sampling\n    if (this.config.sampleRate && Math.random() > this.config.sampleRate) {\n      return '';\n    }\n\n    const errorId = generateId();\n    \n    // Start a new span for this error\n    const spanId = this.traceManager.startSpan(`error:${errorData.message}`);\n    const traceContext = this.traceManager.getTraceContext();\n    \n    const errorEvent: ErrorEvent = {\n      id: errorId,\n      timestamp: Date.now(),\n      message: errorData.message,\n      stack: errorData.stack || (errorData.error ? formatStackTrace(errorData.error) : undefined),\n      url: errorData.filename || window.location.href,\n      lineno: errorData.lineno,\n      colno: errorData.colno,\n      filename: errorData.filename,\n      userId: this.config.userId || this.userContext.id,\n      sessionId: '', // Will be set by Monitor class\n      userAgent: navigator.userAgent,\n      environment: this.config.environment,\n      release: this.config.release,\n      tags: errorData.tags,\n      extra: errorData.extra,\n      breadcrumbs: [...this.breadcrumbs],\n      level: errorData.level || 'error',\n      traceId: traceContext.traceId,\n      spanId: spanId,\n      parentSpanId: traceContext.parentSpanId\n    };\n\n    // Apply beforeSend filter\n    const filteredError = this.config.beforeSend?.(errorEvent) || errorEvent;\n    if (!filteredError) return '';\n\n    return errorId;\n  }\n\n  captureException(error: Error, options: {\n    level?: 'error' | 'warning' | 'info' | 'debug';\n    tags?: Record<string, string>;\n    extra?: Record<string, any>;\n  } = {}): string {\n    return this.captureError({\n      message: error.message,\n      stack: formatStackTrace(error),\n      error,\n      level: options.level,\n      tags: options.tags,\n      extra: options.extra\n    });\n  }\n\n  captureMessage(message: string, options: {\n    level?: 'error' | 'warning' | 'info' | 'debug';\n    tags?: Record<string, string>;\n    extra?: Record<string, any>;\n  } = {}): string {\n    return this.captureError({\n      message,\n      level: options.level || 'info',\n      tags: options.tags,\n      extra: options.extra\n    });\n  }\n\n  addBreadcrumb(breadcrumb: Breadcrumb): void {\n    this.breadcrumbs.push(breadcrumb);\n    \n    const maxBreadcrumbs = this.config.maxBreadcrumbs || 50;\n    if (this.breadcrumbs.length > maxBreadcrumbs) {\n      this.breadcrumbs.splice(0, this.breadcrumbs.length - maxBreadcrumbs);\n    }\n  }\n\n  setUserContext(user: any): void {\n    this.userContext = { ...this.userContext, ...user };\n  }\n\n  setTags(_tags: Record<string, string>): void {\n    // Tags will be applied to future errors\n  }\n\n  setExtra(_extra: Record<string, any>): void {\n    // Extra data will be applied to future errors\n  }\n\n  getBreadcrumbs(): Breadcrumb[] {\n    return [...this.breadcrumbs];\n  }\n\n  clearBreadcrumbs(): void {\n    this.breadcrumbs = [];\n  }\n}\n","import { generateId, getSessionStorage } from './utils';\nimport type { SessionEvent, ReviConfig } from './types';\nimport { TraceManager } from './trace-manager';\n\nexport class SessionManager {\n  private sessionId: string;\n  private startTime: number;\n  private events: SessionEvent[] = [];\n  private config: ReviConfig;\n  private storage: Storage | null;\n  private traceManager?: TraceManager;\n\n  constructor(config: ReviConfig, traceManager?: TraceManager) {\n    this.config = config;\n    this.traceManager = traceManager;\n    this.storage = getSessionStorage();\n    this.sessionId = this.getOrCreateSessionId();\n    this.startTime = Date.now();\n    \n    this.setupEventListeners();\n    this.trackPageLoad();\n  }\n\n  private getOrCreateSessionId(): string {\n    const storageKey = 'revi_session_id';\n    \n    if (this.storage) {\n      const existingId = this.storage.getItem(storageKey);\n      if (existingId) return existingId;\n    }\n    \n    const newId = generateId();\n    if (this.storage) {\n      this.storage.setItem(storageKey, newId);\n    }\n    \n    return newId;\n  }\n\n  getSessionId(): string {\n    return this.sessionId;\n  }\n\n  private setupEventListeners(): void {\n    if (typeof window === 'undefined') return;\n\n    // DOM events\n    const eventTypes = ['click', 'input', 'change', 'submit', 'focus', 'blur'];\n    eventTypes.forEach(eventType => {\n      document.addEventListener(eventType, (event) => {\n        this.captureEvent(eventType, this.serializeDOMEvent(event));\n      }, { capture: true, passive: true });\n    });\n\n    // Navigation events\n    window.addEventListener('popstate', () => {\n      this.captureEvent('navigation', {\n        type: 'popstate',\n        url: window.location.href,\n        timestamp: Date.now()\n      });\n    });\n\n    // Page visibility\n    document.addEventListener('visibilitychange', () => {\n      this.captureEvent('visibility', {\n        hidden: document.hidden,\n        timestamp: Date.now()\n      });\n    });\n\n    // Scroll events (throttled)\n    let scrollTimeout: NodeJS.Timeout;\n    window.addEventListener('scroll', () => {\n      clearTimeout(scrollTimeout);\n      scrollTimeout = setTimeout(() => {\n        this.captureEvent('scroll', {\n          x: window.scrollX,\n          y: window.scrollY,\n          timestamp: Date.now()\n        });\n      }, 100);\n    }, { passive: true });\n\n    // Resize events (throttled)\n    let resizeTimeout: NodeJS.Timeout;\n    window.addEventListener('resize', () => {\n      clearTimeout(resizeTimeout);\n      resizeTimeout = setTimeout(() => {\n        this.captureEvent('resize', {\n          width: window.innerWidth,\n          height: window.innerHeight,\n          timestamp: Date.now()\n        });\n      }, 100);\n    }, { passive: true });\n\n    // Before unload\n    window.addEventListener('beforeunload', () => {\n      this.captureEvent('beforeunload', {\n        timestamp: Date.now(),\n        duration: Date.now() - this.startTime\n      });\n      this.flush();\n    });\n  }\n\n  private serializeDOMEvent(event: Event): Record<string, any> {\n    const target = event.target as HTMLElement;\n    if (!target) return {};\n\n    const data: Record<string, any> = {\n      type: event.type,\n      timestamp: Date.now(),\n      target: {\n        tagName: target.tagName,\n        id: target.id,\n        className: target.className,\n        textContent: this.shouldMaskText(target) ? '[Masked]' : target.textContent?.slice(0, 100)\n      }\n    };\n\n    // Add specific event data\n    if (event.type === 'click') {\n      const mouseEvent = event as MouseEvent;\n      data.coordinates = {\n        x: mouseEvent.clientX,\n        y: mouseEvent.clientY\n      };\n    }\n\n    if (event.type === 'input' || event.type === 'change') {\n      const inputEvent = event.target as HTMLInputElement;\n      if (inputEvent && inputEvent.value !== undefined) {\n        data.value = this.shouldMaskInput(inputEvent) ? '[Masked]' : inputEvent.value;\n      }\n    }\n\n    return data;\n  }\n\n  private shouldMaskInput(element: HTMLInputElement): boolean {\n    if (!this.config.privacy?.maskInputs) return false;\n    \n    const sensitiveTypes = ['password', 'email', 'tel', 'credit-card-number'];\n    const sensitiveNames = ['password', 'email', 'phone', 'credit', 'card', 'ssn'];\n    \n    if (sensitiveTypes.includes(element.type)) return true;\n    \n    const name = element.name?.toLowerCase() || '';\n    const id = element.id?.toLowerCase() || '';\n    \n    return sensitiveNames.some(sensitive => \n      name.includes(sensitive) || id.includes(sensitive)\n    );\n  }\n\n  private shouldMaskText(element: HTMLElement): boolean {\n    if (!this.config.replay?.maskAllText) return false;\n    \n    // Check for specific selectors that should be masked\n    if (this.config.replay?.maskSelector) {\n      try {\n        return element.matches(this.config.replay.maskSelector);\n      } catch {\n        return false;\n      }\n    }\n    \n    return false;\n  }\n\n  private trackPageLoad(): void {\n    if (typeof window === 'undefined') return;\n\n    const captureLoadEvent = () => {\n      this.captureEvent('page_load', {\n        url: window.location.href,\n        title: document.title,\n        referrer: document.referrer,\n        timestamp: Date.now(),\n        loadTime: performance.now()\n      });\n    };\n\n    if (document.readyState === 'complete') {\n      captureLoadEvent();\n    } else {\n      window.addEventListener('load', captureLoadEvent);\n    }\n  }\n\n  captureEvent(type: string, data: Record<string, any>): void {\n    // Apply sampling\n    if (this.config.sessionSampleRate && Math.random() > this.config.sessionSampleRate) {\n      return;\n    }\n\n    // Start a new span for this session event if trace manager is available\n    const traceContext = this.traceManager?.getTraceContext();\n    const spanId = this.traceManager?.startSpan(`session:${type}`);\n\n    const event: SessionEvent = {\n      sessionId: this.sessionId,\n      timestamp: Date.now(),\n      type,\n      data,\n      traceId: traceContext?.traceId,\n      spanId: spanId\n    };\n\n    // Apply beforeSendSession filter\n    const filteredEvent = this.config.beforeSendSession?.(event) || event;\n    if (!filteredEvent) return;\n\n    this.events.push(filteredEvent);\n\n    // Auto-flush when buffer is full\n    if (this.events.length >= 100) {\n      this.flush();\n    }\n  }\n\n  getEvents(): SessionEvent[] {\n    return [...this.events];\n  }\n\n  getQueuedEventCount(): number {\n    return this.events.length;\n  }\n\n  clearEvents(): void {\n    this.events = [];\n  }\n\n  flush(): SessionEvent[] {\n    const events = this.getEvents();\n    this.clearEvents();\n    return events;\n  }\n\n  endSession(): void {\n    this.captureEvent('session_end', {\n      timestamp: Date.now(),\n      duration: Date.now() - this.startTime\n    });\n    \n    if (this.storage) {\n      this.storage.removeItem('revi_session_id');\n    }\n  }\n}\n","// import { generateId } from './utils'; // Unused import\nimport type { NetworkEvent, ReviConfig } from './types';\nimport { TraceManager } from './trace-manager';\n\nexport class NetworkMonitor {\n  private config: ReviConfig;\n  private events: NetworkEvent[] = [];\n  private originalFetch: typeof fetch;\n  private originalXHROpen: typeof XMLHttpRequest.prototype.open;\n  private originalXHRSend: typeof XMLHttpRequest.prototype.send;\n  private traceManager: TraceManager;\n  private lastActivityTime: number = Date.now();\n  private activityCheckInterval: NodeJS.Timeout | null = null;\n\n  constructor(config: ReviConfig, traceManager?: TraceManager) {\n    this.config = config;\n    this.traceManager = traceManager || new TraceManager();\n    this.originalFetch = window.fetch;\n    this.originalXHROpen = XMLHttpRequest.prototype.open;\n    this.originalXHRSend = XMLHttpRequest.prototype.send;\n    \n    this.setupInterceptors();\n    this.startActivityMonitor();\n  }\n\n  private setupInterceptors(): void {\n    if (typeof window === 'undefined') return;\n\n    this.interceptFetch();\n    this.interceptXHR();\n  }\n\n  private startActivityMonitor(): void {\n    if (typeof window === 'undefined') return;\n    \n    // Check for network inactivity every 3 seconds\n    this.activityCheckInterval = setInterval(() => {\n      const now = Date.now();\n      const timeSinceActivity = now - this.lastActivityTime;\n      \n      // If no activity for 5 seconds and we have events, flush them\n      if (timeSinceActivity >= 5000 && this.events.length > 0) {\n        if (this.config.debug) {\n          console.log('[Revi Debug] Network activity idle, flushing', this.events.length, 'events');\n        }\n        this.flush();\n      }\n    }, 3000);\n  }\n\n  private recordActivity(): void {\n    this.lastActivityTime = Date.now();\n  }\n\n  private interceptFetch(): void {\n    window.fetch = async (...args: Parameters<typeof fetch>): Promise<Response> => {\n      const startTime = Date.now();\n      const url = typeof args[0] === 'string' ? args[0] : (args[0] as Request).url;\n      const method = (args[1]?.method || 'GET').toUpperCase();\n      \n      // Check if this request should be monitored\n      if (!this.shouldMonitorRequest(url)) {\n        return await this.originalFetch.apply(window, args);\n      }\n      \n      // Record network activity\n      this.recordActivity();\n      \n      // Start a new span for this network request\n      const spanId = this.traceManager.startSpan(`http:${method} ${url}`);\n      \n      // Inject trace headers into the request\n      const traceHeaders = this.traceManager.injectTraceHeaders();\n      const originalHeaders = args[1]?.headers || {};\n      const headers = { ...originalHeaders, ...traceHeaders };\n      \n      // Update request args with trace headers\n      const modifiedArgs: Parameters<typeof fetch> = [\n        args[0],\n        {\n          ...args[1],\n          headers: headers\n        }\n      ];\n      \n      let requestSize = 0;\n      let requestBody: any;\n      \n      if (args[1]?.body) {\n        requestBody = this.serializeRequestBody(args[1].body);\n        requestSize = this.calculateBodySize(args[1].body);\n      }\n\n      try {\n        const response = await this.originalFetch.apply(window, modifiedArgs);\n        const endTime = Date.now();\n        \n        let responseBody: any;\n        let responseSize = 0;\n        \n        if (this.shouldCaptureResponseBody(url)) {\n          const clonedResponse = response.clone();\n          try {\n            responseBody = await this.extractResponseBody(clonedResponse);\n            responseSize = this.calculateResponseSize(responseBody);\n          } catch {\n            // Failed to extract response body\n          }\n        }\n\n        // Extract trace context from response headers\n        const responseTrace = this.traceManager.extractTraceFromHeaders(\n          this.extractResponseHeaders(response.headers)\n        );\n        \n        // Correlate with backend trace if available\n        if (responseTrace.traceId) {\n          this.traceManager.correlateWithBackendTrace(responseTrace.traceId, responseTrace.spanId);\n        }\n        \n        // Finish the span\n        this.traceManager.finishSpan(spanId, {\n          statusCode: response.status,\n          responseTime: endTime - startTime\n        });\n        \n        const traceContext = this.traceManager.getTraceContext();\n        \n        this.captureNetworkEvent({\n          method,\n          url,\n          statusCode: response.status,\n          responseTime: endTime - startTime,\n          requestSize,\n          responseSize,\n          requestHeaders: this.extractHeaders(headers),\n          responseHeaders: this.extractResponseHeaders(response.headers),\n          requestBody,\n          responseBody,\n          timestamp: startTime,\n          traceId: traceContext.traceId,\n          spanId: spanId,\n          parentSpanId: traceContext.parentSpanId\n        });\n\n        return response;\n      } catch (error) {\n        const endTime = Date.now();\n        \n        // Finish the span with error\n        this.traceManager.finishSpan(spanId, {\n          statusCode: 0,\n          responseTime: endTime - startTime,\n          error: error instanceof Error ? error.message : String(error)\n        });\n        \n        const traceContext = this.traceManager.getTraceContext();\n        \n        this.captureNetworkEvent({\n          method,\n          url,\n          statusCode: 0, // Network error\n          responseTime: endTime - startTime,\n          requestSize,\n          responseSize: 0,\n          requestHeaders: this.extractHeaders(headers),\n          requestBody,\n          timestamp: startTime,\n          traceId: traceContext.traceId,\n          spanId: spanId,\n          parentSpanId: traceContext.parentSpanId\n        });\n\n        throw error;\n      }\n    };\n  }\n\n  private interceptXHR(): void {\n    const self = this;\n\n    XMLHttpRequest.prototype.open = function(method: string, url: string, ...args: any[]) {\n      const shouldMonitor = self.shouldMonitorRequest(url);\n      (this as any)._reviData = {\n        method: method.toUpperCase(),\n        url,\n        startTime: Date.now(),\n        shouldMonitor\n      };\n      \n      // Record network activity if we're monitoring this request\n      if (shouldMonitor) {\n        self.recordActivity();\n      }\n      \n      return self.originalXHROpen.call(this, method, url, ...(args as [boolean?, string?, string?]));\n    };\n\n    XMLHttpRequest.prototype.send = function(body?: any) {\n      const reviData = (this as any)._reviData;\n      if (!reviData || !reviData.shouldMonitor) {\n        return self.originalXHRSend.call(this, body);\n      }\n\n      reviData.requestBody = self.serializeRequestBody(body);\n      reviData.requestSize = self.calculateBodySize(body);\n\n      this.addEventListener('loadend', () => {\n        const endTime = Date.now();\n        \n        let responseBody: any;\n        try {\n          if (this.responseType === '' || this.responseType === 'text') {\n            responseBody = this.responseText;\n          } else if (this.responseType === 'json') {\n            responseBody = this.response;\n          }\n        } catch {\n          // Failed to extract response\n        }\n\n        self.captureNetworkEvent({\n          method: reviData.method,\n          url: reviData.url,\n          statusCode: this.status,\n          responseTime: endTime - reviData.startTime,\n          requestSize: reviData.requestSize,\n          responseSize: self.calculateResponseSize(responseBody),\n          requestBody: reviData.requestBody,\n          responseBody: self.shouldCaptureResponseBody(reviData.url) ? responseBody : undefined,\n          timestamp: reviData.startTime\n        });\n      });\n\n      return self.originalXHRSend.call(this, body);\n    };\n  }\n\n  private serializeRequestBody(body: any): any {\n    if (!body) return undefined;\n    \n    if (typeof body === 'string') return body;\n    if (body instanceof FormData) {\n      const formObject: Record<string, any> = {};\n      body.forEach((value, key) => {\n        formObject[key] = value instanceof File ? `[File: ${value.name}]` : value;\n      });\n      return formObject;\n    }\n    if (body instanceof URLSearchParams) {\n      return Object.fromEntries(body);\n    }\n    \n    try {\n      return JSON.parse(JSON.stringify(body));\n    } catch {\n      return '[Unserializable]';\n    }\n  }\n\n  private async extractResponseBody(response: Response): Promise<any> {\n    const contentType = response.headers.get('content-type') || '';\n    \n    if (contentType.includes('application/json')) {\n      return await response.json();\n    } else if (contentType.includes('text/')) {\n      return await response.text();\n    }\n    \n    return '[Binary Data]';\n  }\n\n  private extractHeaders(headers?: HeadersInit): Record<string, string> {\n    if (!headers) return {};\n    \n    if (headers instanceof Headers) {\n      const headerObj: Record<string, string> = {};\n      headers.forEach((value, key) => {\n        headerObj[key] = value;\n      });\n      return headerObj;\n    }\n    \n    if (Array.isArray(headers)) {\n      const headerObj: Record<string, string> = {};\n      headers.forEach(([key, value]) => {\n        headerObj[key] = value;\n      });\n      return headerObj;\n    }\n    \n    return headers as Record<string, string>;\n  }\n\n  private extractResponseHeaders(headers: Headers): Record<string, string> {\n    const headerObj: Record<string, string> = {};\n    headers.forEach((value, key) => {\n      headerObj[key] = value;\n    });\n    return headerObj;\n  }\n\n  private calculateBodySize(body: any): number {\n    if (!body) return 0;\n    \n    if (typeof body === 'string') return body.length;\n    if (body instanceof ArrayBuffer) return body.byteLength;\n    if (body instanceof Blob) return body.size;\n    \n    try {\n      return JSON.stringify(body).length;\n    } catch {\n      return 0;\n    }\n  }\n\n  private calculateResponseSize(response: any): number {\n    if (!response) return 0;\n    \n    try {\n      return JSON.stringify(response).length;\n    } catch {\n      return 0;\n    }\n  }\n\n  private shouldCaptureResponseBody(url: string): boolean {\n    // Only capture response bodies for specific URLs to avoid memory issues\n    const allowedPatterns = [\n      /\\/api\\//,\n      /\\/graphql/,\n    ];\n    \n    return allowedPatterns.some(pattern => pattern.test(url));\n  }\n\n  private shouldMonitorRequest(url: string): boolean {\n    // Debug logging to identify filtering issues\n    if (this.config.debug) {\n      console.log('[Revi Debug] Network filter check:', { url });\n    }\n    \n    // PRIORITY 1: Don't monitor the SDK's own API calls to prevent feedback loops\n    const apiUrl = this.config.apiUrl || 'https://api.revi.dev';\n    const normalizedApiUrl = apiUrl.replace(/\\/$/, '');\n    const normalizedUrl = url.replace(/\\/$/, '');\n    \n    // Filter requests to Revi's backend API (exact URL match)\n    if (normalizedUrl.startsWith(normalizedApiUrl)) {\n      if (this.config.debug) {\n        console.log('[Revi Debug] Filtering Revi API URL (exact match):', url, '(prevents feedback loop)');\n      }\n      return false;\n    }\n    \n    // Also filter localhost variants that might not match exactly\n    if (url.includes('127.0.0.1:4000') || url.includes('localhost:4000')) {\n      if (this.config.debug) {\n        console.log('[Revi Debug] Filtering localhost Revi API:', url, '(prevents feedback loop)');\n      }\n      return false;\n    }\n    \n    // PRIORITY 2: Filter all /api/analytics/ requests regardless of host (catches user journey events)\n    if (url.includes('/api/analytics/')) {\n      if (this.config.debug) {\n        console.log('[Revi Debug] Filtering analytics API:', url, '(prevents user journey feedback loop)');\n      }\n      return false;\n    }\n    \n    // PRIORITY 3: Filter other specific Revi API endpoints to prevent loops\n    const reviApiPatterns = [\n      /\\/api\\/capture\\//,\n      /\\/api\\/errors/,\n      /\\/api\\/session/,\n      /\\/api\\/projects/,\n      /\\/api\\/database/,\n      /\\/health$/,\n    ];\n    \n    // Only filter if it's a Revi API pattern AND from our backend\n    const isReviApiPattern = reviApiPatterns.some(pattern => pattern.test(url));\n    const isFromReviBackend = normalizedUrl.includes(normalizedApiUrl.replace(/^https?:\\/\\//, ''));\n    \n    if (isReviApiPattern && isFromReviBackend) {\n      if (this.config.debug) {\n        console.log('[Revi Debug] Filtering Revi API endpoint:', url, '(prevents feedback loop)');\n      }\n      return false;\n    }\n    \n    // PRIORITY 3: Check user-configured exclude URLs\n    if (this.config.excludeUrls) {\n      const excluded = this.config.excludeUrls.some(pattern => pattern.test(url));\n      if (excluded) {\n        if (this.config.debug) {\n          console.log('[Revi Debug] Filtering user-excluded URL:', url);\n        }\n        return false;\n      }\n    }\n    \n    // PRIORITY 4: Check privacy configuration\n    if (this.config.privacy?.denyUrls) {\n      const denied = this.config.privacy.denyUrls.some(pattern => {\n        const regex = new RegExp(pattern);\n        return regex.test(url);\n      });\n      if (denied) {\n        if (this.config.debug) {\n          console.log('[Revi Debug] Filtering privacy-denied URL:', url);\n        }\n        return false;\n      }\n    }\n    \n    // PRIORITY 5: If allowUrls is configured, only allow those\n    if (this.config.privacy?.allowUrls) {\n      const allowed = this.config.privacy.allowUrls.some(pattern => {\n        const regex = new RegExp(pattern);\n        return regex.test(url);\n      });\n      if (this.config.debug) {\n        console.log('[Revi Debug] Allow list result for:', url, '- allowed:', allowed);\n      }\n      return allowed;\n    }\n    \n    // DEFAULT: Allow all other requests (images, external APIs, same-origin requests, etc.)\n    if (this.config.debug) {\n      console.log('[Revi Debug] Monitoring URL:', url, '(no exclusion filters matched)');\n    }\n    return true;\n  }\n\n  private captureNetworkEvent(data: Partial<NetworkEvent> & { method: string; url: string; timestamp: number }): void {\n    const event: NetworkEvent = {\n      sessionId: '', // Will be set by Monitor class\n      timestamp: data.timestamp,\n      method: data.method,\n      url: data.url,\n      statusCode: data.statusCode,\n      responseTime: data.responseTime,\n      requestSize: data.requestSize,\n      responseSize: data.responseSize,\n      requestHeaders: data.requestHeaders,\n      responseHeaders: data.responseHeaders,\n      requestBody: data.requestBody,\n      responseBody: data.responseBody\n    };\n\n    this.events.push(event);\n\n    // Auto-flush when buffer is full - increased from 50 to 200 for better batching\n    if (this.events.length >= 200) {\n      this.flush();\n    } else {\n      // During rapid activity (< 2 seconds since last activity), delay auto-flush\n      // to allow larger batches to accumulate\n      const timeSinceActivity = Date.now() - this.lastActivityTime;\n      if (timeSinceActivity < 2000 && this.events.length >= 10) {\n        // We have at least 10 events and we're in rapid activity mode\n        // Let the activity monitor handle flushing instead of auto-flushing now\n        if (this.config.debug) {\n          console.log('[Revi Debug] Network rapid activity detected, delaying flush for larger batch');\n        }\n      }\n    }\n  }\n\n  getEvents(): NetworkEvent[] {\n    return [...this.events];\n  }\n\n  clearEvents(): void {\n    this.events = [];\n  }\n\n  flush(): NetworkEvent[] {\n    const events = this.getEvents();\n    this.clearEvents();\n    return events;\n  }\n\n  destroy(): void {\n    // Clean up activity monitor\n    if (this.activityCheckInterval) {\n      clearInterval(this.activityCheckInterval);\n      this.activityCheckInterval = null;\n    }\n    \n    // Restore original implementations\n    if (this.originalFetch) {\n      window.fetch = this.originalFetch;\n    }\n    \n    XMLHttpRequest.prototype.open = this.originalXHROpen;\n    XMLHttpRequest.prototype.send = this.originalXHRSend;\n  }\n}\n","import type { ErrorEvent, SessionEvent, NetworkEvent } from './types';\n\ninterface StorageItem {\n  id: string;\n  type: 'error' | 'session' | 'network';\n  data: any;\n  timestamp: number;\n  compressed: boolean;\n}\n\nexport class IndexedDBStorage {\n  private db: IDBDatabase | null = null;\n  private dbName = 'revi-storage';\n  private version = 1;\n  private storeName = 'queue';\n  private maxQueueSize = 1000;\n  private maxAge = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds\n\n  async initialize(): Promise<void> {\n    if (typeof window === 'undefined' || !window.indexedDB) {\n      throw new Error('IndexedDB not supported');\n    }\n\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, this.version);\n\n      request.onerror = () => {\n        reject(new Error('Failed to open IndexedDB'));\n      };\n\n      request.onsuccess = () => {\n        this.db = request.result;\n        resolve();\n      };\n\n      request.onupgradeneeded = (event) => {\n        const db = (event.target as IDBOpenDBRequest).result;\n        \n        if (!db.objectStoreNames.contains(this.storeName)) {\n          const objectStore = db.createObjectStore(this.storeName, { keyPath: 'id' });\n          objectStore.createIndex('timestamp', 'timestamp', { unique: false });\n          objectStore.createIndex('type', 'type', { unique: false });\n        }\n      };\n    });\n  }\n\n  async store(type: 'error' | 'session' | 'network', data: any): Promise<void> {\n    if (!this.db) {\n      await this.initialize();\n    }\n\n    await this.cleanupExpiredItems();\n    \n    const queueSize = await this.getQueueSize();\n    if (queueSize >= this.maxQueueSize) {\n      await this.removeOldestItems(100);\n    }\n\n    const item: StorageItem = {\n      id: this.generateId(),\n      type,\n      data: await this.compress(data),\n      timestamp: Date.now(),\n      compressed: true\n    };\n\n    return new Promise((resolve, reject) => {\n      if (!this.db) {\n        reject(new Error('Database not initialized'));\n        return;\n      }\n\n      const transaction = this.db.transaction([this.storeName], 'readwrite');\n      const objectStore = transaction.objectStore(this.storeName);\n      const request = objectStore.add(item);\n\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(new Error('Failed to store item'));\n    });\n  }\n\n  async getAll(): Promise<{ errors: ErrorEvent[]; sessionEvents: SessionEvent[]; networkEvents: NetworkEvent[] }> {\n    if (!this.db) {\n      await this.initialize();\n    }\n\n    return new Promise((resolve, reject) => {\n      if (!this.db) {\n        reject(new Error('Database not initialized'));\n        return;\n      }\n\n      const transaction = this.db.transaction([this.storeName], 'readonly');\n      const objectStore = transaction.objectStore(this.storeName);\n      const request = objectStore.getAll();\n\n      request.onsuccess = async () => {\n        const items = request.result as StorageItem[];\n        const result = {\n          errors: [] as ErrorEvent[],\n          sessionEvents: [] as SessionEvent[],\n          networkEvents: [] as NetworkEvent[]\n        };\n\n        for (const item of items) {\n          const decompressedData = await this.decompress(item.data);\n          \n          switch (item.type) {\n            case 'error':\n              result.errors.push(...(Array.isArray(decompressedData) ? decompressedData : [decompressedData]));\n              break;\n            case 'session':\n              result.sessionEvents.push(...(Array.isArray(decompressedData) ? decompressedData : [decompressedData]));\n              break;\n            case 'network':\n              result.networkEvents.push(...(Array.isArray(decompressedData) ? decompressedData : [decompressedData]));\n              break;\n          }\n        }\n\n        resolve(result);\n      };\n\n      request.onerror = () => reject(new Error('Failed to retrieve items'));\n    });\n  }\n\n  async clear(): Promise<void> {\n    if (!this.db) {\n      await this.initialize();\n    }\n\n    return new Promise((resolve, reject) => {\n      if (!this.db) {\n        reject(new Error('Database not initialized'));\n        return;\n      }\n\n      const transaction = this.db.transaction([this.storeName], 'readwrite');\n      const objectStore = transaction.objectStore(this.storeName);\n      const request = objectStore.clear();\n\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(new Error('Failed to clear storage'));\n    });\n  }\n\n  async getQueueSize(): Promise<number> {\n    if (!this.db) {\n      await this.initialize();\n    }\n\n    return new Promise((resolve, reject) => {\n      if (!this.db) {\n        reject(new Error('Database not initialized'));\n        return;\n      }\n\n      const transaction = this.db.transaction([this.storeName], 'readonly');\n      const objectStore = transaction.objectStore(this.storeName);\n      const request = objectStore.count();\n\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(new Error('Failed to get queue size'));\n    });\n  }\n\n  private async cleanupExpiredItems(): Promise<void> {\n    if (!this.db) return;\n\n    const cutoffTime = Date.now() - this.maxAge;\n\n    return new Promise((resolve) => {\n      if (!this.db) {\n        resolve();\n        return;\n      }\n\n      const transaction = this.db.transaction([this.storeName], 'readwrite');\n      const objectStore = transaction.objectStore(this.storeName);\n      const index = objectStore.index('timestamp');\n      const range = IDBKeyRange.upperBound(cutoffTime);\n      const request = index.openCursor(range);\n\n      request.onsuccess = (event) => {\n        const cursor = (event.target as IDBRequest).result;\n        if (cursor) {\n          cursor.delete();\n          cursor.continue();\n        } else {\n          resolve();\n        }\n      };\n\n      request.onerror = () => resolve();\n    });\n  }\n\n  private async removeOldestItems(count: number): Promise<void> {\n    if (!this.db) return;\n\n    return new Promise((resolve) => {\n      if (!this.db) {\n        resolve();\n        return;\n      }\n\n      const transaction = this.db.transaction([this.storeName], 'readwrite');\n      const objectStore = transaction.objectStore(this.storeName);\n      const index = objectStore.index('timestamp');\n      const request = index.openCursor();\n\n      let deletedCount = 0;\n      request.onsuccess = (event) => {\n        const cursor = (event.target as IDBRequest).result;\n        if (cursor && deletedCount < count) {\n          cursor.delete();\n          deletedCount++;\n          cursor.continue();\n        } else {\n          resolve();\n        }\n      };\n\n      request.onerror = () => resolve();\n    });\n  }\n\n  private async compress(data: any): Promise<string> {\n    try {\n      const json = JSON.stringify(data);\n      // Simple base64 compression for now - can be upgraded to gzip\n      return btoa(unescape(encodeURIComponent(json)));\n    } catch (error) {\n      // Fallback to uncompressed JSON string\n      return JSON.stringify(data);\n    }\n  }\n\n  private async decompress(data: string): Promise<any> {\n    try {\n      // Try to decode base64 first\n      const decoded = decodeURIComponent(escape(atob(data)));\n      return JSON.parse(decoded);\n    } catch (error) {\n      // Fallback to direct JSON parse\n      try {\n        return JSON.parse(data);\n      } catch (parseError) {\n        return data;\n      }\n    }\n  }\n\n  private generateId(): string {\n    return `revi-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n}","import { IndexedDBStorage } from './indexed-db-storage';\nimport { getLocalStorage } from './utils';\nimport type { ErrorEvent, SessionEvent, NetworkEvent } from './types';\n\ninterface StorageInterface {\n  store(type: 'error' | 'session' | 'network', data: any): Promise<void>;\n  getAll(): Promise<{ errors: ErrorEvent[]; sessionEvents: SessionEvent[]; networkEvents: NetworkEvent[] }>;\n  clear(): Promise<void>;\n  getQueueSize?(): Promise<number>;\n}\n\nclass LocalStorageAdapter implements StorageInterface {\n  private storage: Storage;\n  private storageKey = 'revi_upload_queue';\n\n  constructor() {\n    const localStorage = getLocalStorage();\n    if (!localStorage) {\n      throw new Error('No storage available');\n    }\n    this.storage = localStorage;\n  }\n\n  async store(type: 'error' | 'session' | 'network', data: any): Promise<void> {\n    try {\n      const existing = await this.getAll();\n      \n      switch (type) {\n        case 'error':\n          existing.errors.push(...(Array.isArray(data) ? data : [data]));\n          break;\n        case 'session':\n          existing.sessionEvents.push(...(Array.isArray(data) ? data : [data]));\n          break;\n        case 'network':\n          existing.networkEvents.push(...(Array.isArray(data) ? data : [data]));\n          break;\n      }\n\n      this.storage.setItem(this.storageKey, JSON.stringify(existing));\n    } catch (error) {\n      // Storage quota exceeded or other error\n      throw new Error('Failed to store data');\n    }\n  }\n\n  async getAll(): Promise<{ errors: ErrorEvent[]; sessionEvents: SessionEvent[]; networkEvents: NetworkEvent[] }> {\n    try {\n      const storedData = this.storage.getItem(this.storageKey);\n      if (storedData) {\n        return JSON.parse(storedData);\n      }\n    } catch (error) {\n      // Failed to parse or retrieve data\n    }\n    \n    return {\n      errors: [],\n      sessionEvents: [],\n      networkEvents: []\n    };\n  }\n\n  async clear(): Promise<void> {\n    try {\n      this.storage.removeItem(this.storageKey);\n    } catch (error) {\n      // Ignore errors\n    }\n  }\n}\n\nexport class StorageManager {\n  private storage: StorageInterface | null = null;\n  private isInitialized = false;\n\n  async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n\n    try {\n      // Try IndexedDB first\n      const indexedDB = new IndexedDBStorage();\n      await indexedDB.initialize();\n      this.storage = indexedDB;\n      console.log('[Revi] Using IndexedDB for offline storage');\n    } catch (error) {\n      // Fallback to localStorage\n      try {\n        this.storage = new LocalStorageAdapter();\n        console.log('[Revi] Using localStorage for offline storage');\n      } catch (localStorageError) {\n        console.warn('[Revi] No storage available, data will not persist offline');\n        this.storage = new NoOpStorage();\n      }\n    }\n\n    this.isInitialized = true;\n  }\n\n  async storeErrors(errors: ErrorEvent[]): Promise<void> {\n    await this.ensureInitialized();\n    if (errors.length > 0) {\n      await this.storage!.store('error', errors);\n    }\n  }\n\n  async storeSessionEvents(events: SessionEvent[]): Promise<void> {\n    await this.ensureInitialized();\n    if (events.length > 0) {\n      await this.storage!.store('session', events);\n    }\n  }\n\n  async storeNetworkEvents(events: NetworkEvent[]): Promise<void> {\n    await this.ensureInitialized();\n    if (events.length > 0) {\n      await this.storage!.store('network', events);\n    }\n  }\n\n  async getAllData(): Promise<{ errors: ErrorEvent[]; sessionEvents: SessionEvent[]; networkEvents: NetworkEvent[] }> {\n    await this.ensureInitialized();\n    return await this.storage!.getAll();\n  }\n\n  async clearAll(): Promise<void> {\n    await this.ensureInitialized();\n    await this.storage!.clear();\n  }\n\n  async getQueueSize(): Promise<number> {\n    await this.ensureInitialized();\n    if (this.storage && 'getQueueSize' in this.storage && this.storage.getQueueSize) {\n      return await this.storage.getQueueSize();\n    } else {\n      // Fallback for localStorage\n      const data = await this.getAllData();\n      return data.errors.length + data.sessionEvents.length + data.networkEvents.length;\n    }\n  }\n\n  private async ensureInitialized(): Promise<void> {\n    if (!this.isInitialized) {\n      await this.initialize();\n    }\n  }\n}\n\nclass NoOpStorage implements StorageInterface {\n  async store(): Promise<void> {\n    // Do nothing\n  }\n\n  async getAll(): Promise<{ errors: ErrorEvent[]; sessionEvents: SessionEvent[]; networkEvents: NetworkEvent[] }> {\n    return {\n      errors: [],\n      sessionEvents: [],\n      networkEvents: []\n    };\n  }\n\n  async clear(): Promise<void> {\n    // Do nothing\n  }\n}","export class NetworkManager {\n  private isOnline = typeof navigator !== 'undefined' ? navigator.onLine : true;\n  private connectionType: string = 'unknown';\n  private listeners: Array<(online: boolean) => void> = [];\n\n  constructor() {\n    if (typeof window !== 'undefined') {\n      // Listen for online/offline events\n      window.addEventListener('online', () => {\n        this.isOnline = true;\n        this.notifyListeners(true);\n      });\n\n      window.addEventListener('offline', () => {\n        this.isOnline = false;\n        this.notifyListeners(false);\n      });\n\n      // Detect connection type if available\n      this.detectConnectionType();\n    }\n  }\n\n  getConnectionStatus(): { online: boolean; connectionType: string } {\n    return {\n      online: this.isOnline,\n      connectionType: this.connectionType\n    };\n  }\n\n  onConnectionChange(callback: (online: boolean) => void): () => void {\n    this.listeners.push(callback);\n    \n    // Return unsubscribe function\n    return () => {\n      const index = this.listeners.indexOf(callback);\n      if (index > -1) {\n        this.listeners.splice(index, 1);\n      }\n    };\n  }\n\n  getBatchSize(): number {\n    if (!this.isOnline) {\n      return 0; // Don't upload when offline\n    }\n\n    // Adjust batch size based on connection quality\n    switch (this.connectionType) {\n      case 'slow-2g':\n        return 5;\n      case '2g':\n        return 10;\n      case '3g':\n        return 25;\n      case '4g':\n        return 50;\n      default:\n        return 25;\n    }\n  }\n\n  getUploadDelay(): number {\n    if (!this.isOnline) {\n      return 0; // Don't upload when offline\n    }\n\n    // Adjust upload frequency based on connection\n    switch (this.connectionType) {\n      case 'slow-2g':\n        return 30000; // 30 seconds\n      case '2g':\n        return 15000; // 15 seconds\n      case '3g':\n        return 10000; // 10 seconds\n      case '4g':\n        return 5000;  // 5 seconds\n      default:\n        return 10000; // 10 seconds\n    }\n  }\n\n  shouldRetry(attempt: number): boolean {\n    if (!this.isOnline) {\n      return false; // Don't retry when offline\n    }\n\n    // Exponential backoff with max attempts\n    const maxAttempts = 5;\n    return attempt < maxAttempts;\n  }\n\n  getRetryDelay(attempt: number): number {\n    // Exponential backoff: 1s, 2s, 4s, 8s, 16s\n    return Math.min(1000 * Math.pow(2, attempt), 16000);\n  }\n\n  private detectConnectionType(): void {\n    if ('connection' in navigator) {\n      const connection = (navigator as any).connection;\n      this.connectionType = connection.effectiveType || connection.type || 'unknown';\n      \n      // Listen for connection changes\n      connection.addEventListener('change', () => {\n        this.connectionType = connection.effectiveType || connection.type || 'unknown';\n      });\n    }\n  }\n\n  private notifyListeners(online: boolean): void {\n    this.listeners.forEach(callback => {\n      try {\n        callback(online);\n      } catch (error) {\n        console.error('[Revi] Error in connection change callback:', error);\n      }\n    });\n  }\n\n  // Ping test to verify actual connectivity\n  async testConnectivity(url?: string): Promise<boolean> {\n    if (!this.isOnline) {\n      return false;\n    }\n\n    try {\n      const testUrl = url || 'https://api.revi.dev/health';\n      await fetch(testUrl, {\n        method: 'HEAD',\n        mode: 'no-cors',\n        cache: 'no-cache'\n      });\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n}","// Simple compression utilities for data transmission\n\n// Basic gzip-like compression using built-in compression APIs\nexport async function compressData(data: any): Promise<{ data: string; compressed: boolean }> {\n  const jsonString = JSON.stringify(data);\n  \n  // TEMPORARILY DISABLED: Backend doesn't support gzip decompression\n  // Always return uncompressed data until backend supports it\n  return { data: jsonString, compressed: false };\n  \n  // Only compress if the data is large enough to benefit\n  if (jsonString.length < 1024) {\n    return { data: jsonString, compressed: false };\n  }\n\n  try {\n    // Use CompressionStream if available (modern browsers)\n    if (typeof CompressionStream !== 'undefined') {\n      const stream = new CompressionStream('gzip');\n      const writer = stream.writable.getWriter();\n      const reader = stream.readable.getReader();\n      \n      // Write the JSON string as UTF-8 bytes\n      const encoder = new TextEncoder();\n      const bytes = encoder.encode(jsonString);\n      \n      await writer.write(bytes);\n      await writer.close();\n      \n      // Read compressed data\n      const compressed = [];\n      let done = false;\n      \n      while (!done) {\n        const { value, done: readerDone } = await reader.read();\n        done = readerDone;\n        if (value) {\n          compressed.push(value);\n        }\n      }\n      \n      // Combine all chunks and convert to base64\n      const compressedBytes = new Uint8Array(\n        compressed.reduce((acc, chunk) => acc + chunk.length, 0)\n      );\n      \n      let offset = 0;\n      for (const chunk of compressed) {\n        compressedBytes.set(chunk, offset);\n        offset += chunk.length;\n      }\n      \n      const base64 = btoa(String.fromCharCode(...compressedBytes));\n      \n      // Only return compressed if it's actually smaller\n      if (base64.length < jsonString.length * 0.8) {\n        return { data: base64, compressed: true };\n      }\n    }\n  } catch (error) {\n    console.warn('[Revi] Compression failed, sending uncompressed data:', error);\n  }\n  \n  // Fallback to uncompressed data\n  return { data: jsonString, compressed: false };\n}\n\n// Simple string compression for older browsers\nexport function compressString(str: string): string {\n  // Simple run-length encoding for repeated patterns\n  let compressed = '';\n  let i = 0;\n  \n  while (i < str.length) {\n    let count = 1;\n    const char = str[i];\n    \n    // Count consecutive characters\n    while (i + count < str.length && str[i + count] === char && count < 99) {\n      count++;\n    }\n    \n    if (count > 3) {\n      compressed += `${char}${count}`;\n    } else {\n      compressed += char.repeat(count);\n    }\n    \n    i += count;\n  }\n  \n  return compressed.length < str.length ? compressed : str;\n}\n\n// Deduplicate arrays of objects with similar keys\nexport function deduplicateEvents<T extends Record<string, any>>(events: T[]): {\n  events: T[];\n  compressionRatio: number;\n} {\n  if (events.length === 0) return { events, compressionRatio: 1 };\n  \n  const originalSize = JSON.stringify(events).length;\n  \n  // Critical fields that must be preserved in each event for backend validation\n  const criticalFields = new Set([\n    'sessionId', 'session_id', 'timestamp', 'event_type', 'type', \n    'id', 'error_id', 'message', 'method', 'url', 'status_code'\n  ]);\n  \n  // Group events by type/structure\n  const grouped = new Map<string, T[]>();\n  \n  for (const event of events) {\n    const keys = Object.keys(event).sort().join(',');\n    if (!grouped.has(keys)) {\n      grouped.set(keys, []);\n    }\n    grouped.get(keys)!.push(event);\n  }\n  \n  // Compress each group separately\n  const compressed: T[] = [];\n  \n  for (const [keys, groupedEvents] of grouped) {\n    if (groupedEvents.length === 1) {\n      compressed.push(groupedEvents[0]);\n      continue;\n    }\n    \n    // Extract common values, but exclude critical fields\n    const commonValues: Record<string, any> = {};\n    const keyArray = keys.split(',');\n    \n    for (const key of keyArray) {\n      // Skip critical fields - they must remain in each event\n      if (criticalFields.has(key)) {\n        continue;\n      }\n      \n      const values = groupedEvents.map(e => e[key]);\n      const firstValue = values[0];\n      \n      if (values.every(v => \n        JSON.stringify(v) === JSON.stringify(firstValue)\n      )) {\n        commonValues[key] = firstValue;\n      }\n    }\n    \n    // Create compressed events\n    for (const event of groupedEvents) {\n      const compressedEvent: any = { ...event };\n      \n      // Remove common values (they're implicit) but preserve critical fields\n      for (const key of Object.keys(commonValues)) {\n        if (!criticalFields.has(key) && \n            JSON.stringify(event[key]) === JSON.stringify(commonValues[key])) {\n          delete compressedEvent[key];\n        }\n      }\n      \n      // Add common values reference if significant compression\n      if (Object.keys(commonValues).length > 2) {\n        compressedEvent._common = commonValues;\n      }\n      \n      compressed.push(compressedEvent);\n    }\n  }\n  \n  const compressedSize = JSON.stringify(compressed).length;\n  const compressionRatio = compressedSize / originalSize;\n  \n  return { events: compressed, compressionRatio };\n}\n\n// Batch events intelligently based on size and type\nexport function createOptimalBatches<T>(\n  events: T[],\n  maxBatchSize: number,\n  maxBatchBytes: number = 64 * 1024 // 64KB default\n): T[][] {\n  if (events.length === 0) return [];\n  \n  const batches: T[][] = [];\n  let currentBatch: T[] = [];\n  let currentBatchSize = 0;\n  \n  for (const event of events) {\n    const eventSize = JSON.stringify(event).length;\n    \n    // Start new batch if current would exceed limits\n    if (\n      currentBatch.length >= maxBatchSize ||\n      currentBatchSize + eventSize > maxBatchBytes\n    ) {\n      if (currentBatch.length > 0) {\n        batches.push(currentBatch);\n        currentBatch = [];\n        currentBatchSize = 0;\n      }\n    }\n    \n    currentBatch.push(event);\n    currentBatchSize += eventSize;\n  }\n  \n  // Don't forget the last batch\n  if (currentBatch.length > 0) {\n    batches.push(currentBatch);\n  }\n  \n  return batches;\n}","/**\n * Comprehensive debug logger for Revi SDK\n * Tracks all inputs, outputs, and transformations for debugging\n */\n\nexport interface DebugLogEntry {\n  timestamp: number;\n  level: 'info' | 'warn' | 'error' | 'debug';\n  category: 'session' | 'network' | 'error' | 'data' | 'api' | 'general';\n  operation: string;\n  data: any;\n  sessionId?: string;\n  stackTrace?: string;\n}\n\nexport class DebugLogger {\n  private logs: DebugLogEntry[] = [];\n  private isEnabled: boolean = false;\n  private saveToFile: boolean = false;\n  private maxLogs: number = 1000;\n\n  constructor(enabled: boolean = false, saveToFile: boolean = false) {\n    this.isEnabled = enabled;\n    this.saveToFile = saveToFile;\n    \n    if (this.isEnabled) {\n      console.log('[Revi Debug] Logger initialized - comprehensive debugging enabled');\n      this.log('general', 'debug-logger-init', 'Debug logger initialized', { \n        enabled, \n        saveToFile,\n        timestamp: Date.now()\n      });\n    }\n  }\n\n  log(category: DebugLogEntry['category'], operation: string, message: string, data?: any): void {\n    if (!this.isEnabled) return;\n\n    const entry: DebugLogEntry = {\n      timestamp: Date.now(),\n      level: 'info',\n      category,\n      operation,\n      data: {\n        message,\n        ...data\n      },\n      stackTrace: this.getStackTrace()\n    };\n\n    this.addLogEntry(entry);\n    this.consoleLog(entry);\n  }\n\n  logError(category: DebugLogEntry['category'], operation: string, error: Error, data?: any): void {\n    if (!this.isEnabled) return;\n\n    const entry: DebugLogEntry = {\n      timestamp: Date.now(),\n      level: 'error',\n      category,\n      operation,\n      data: {\n        error: error.message,\n        stack: error.stack,\n        ...data\n      },\n      stackTrace: error.stack\n    };\n\n    this.addLogEntry(entry);\n    this.consoleLog(entry);\n  }\n\n  logSessionEvent(operation: string, sessionId: string, eventData: any): void {\n    this.log('session', operation, `Session event: ${operation}`, {\n      sessionId,\n      eventData: this.sanitizeData(eventData),\n      hasSessionId: !!sessionId\n    });\n  }\n\n  logApiCall(operation: string, url: string, payload: any, response?: any, error?: Error): void {\n    this.log('api', operation, `API call to ${url}`, {\n      url,\n      payload: this.sanitizeData(payload),\n      response: response ? this.sanitizeData(response) : undefined,\n      error: error?.message,\n      payloadSize: JSON.stringify(payload || {}).length\n    });\n  }\n\n  logDataTransformation(operation: string, before: any, after: any, sessionId?: string): void {\n    this.log('data', operation, `Data transformation: ${operation}`, {\n      before: this.sanitizeData(before),\n      after: this.sanitizeData(after),\n      sessionId,\n      beforeType: typeof before,\n      afterType: typeof after,\n      beforeLength: Array.isArray(before) ? before.length : undefined,\n      afterLength: Array.isArray(after) ? after.length : undefined\n    });\n  }\n\n  // Special method to log the exact session event issue we're debugging\n  logSessionEventUpload(events: any[], sessionId: string, payload: any): void {\n    this.log('session', 'session-event-upload', 'Preparing session event upload', {\n      eventsCount: events.length,\n      sessionId,\n      eventsStructure: events.map(e => ({\n        eventType: e.event_type || e.type,\n        hasSessionId: !!(e.session_id || e.sessionId),\n        sessionIdValue: e.session_id || e.sessionId || 'MISSING',\n        timestamp: e.timestamp,\n        dataKeys: Object.keys(e.data || {})\n      })),\n      payload: {\n        session_id: payload.session_id,\n        eventsCount: payload.events?.length || 0,\n        firstEventHasSessionId: payload.events?.[0]?.session_id ? true : false\n      }\n    });\n  }\n\n  private addLogEntry(entry: DebugLogEntry): void {\n    this.logs.push(entry);\n    \n    // Keep only recent logs to prevent memory issues\n    if (this.logs.length > this.maxLogs) {\n      this.logs = this.logs.slice(-this.maxLogs);\n    }\n\n    // Auto-save to file if enabled\n    if (this.saveToFile && typeof window !== 'undefined') {\n      this.debouncedSave();\n    }\n  }\n\n  private consoleLog(entry: DebugLogEntry): void {\n    const prefix = `[Revi Debug:${entry.category}]`;\n    const timestamp = new Date(entry.timestamp).toISOString();\n    \n    switch (entry.level) {\n      case 'error':\n        console.error(`${prefix} ${timestamp} ${entry.operation}:`, entry.data);\n        break;\n      case 'warn':\n        console.warn(`${prefix} ${timestamp} ${entry.operation}:`, entry.data);\n        break;\n      case 'debug':\n        console.debug(`${prefix} ${timestamp} ${entry.operation}:`, entry.data);\n        break;\n      default:\n        console.log(`${prefix} ${timestamp} ${entry.operation}:`, entry.data);\n    }\n  }\n\n  private sanitizeData(data: any): any {\n    if (!data) return data;\n    \n    try {\n      // Clone and sanitize large objects\n      const cloned = JSON.parse(JSON.stringify(data));\n      \n      // Limit array sizes for logging\n      if (Array.isArray(cloned) && cloned.length > 10) {\n        return {\n          _type: 'array',\n          length: cloned.length,\n          first5: cloned.slice(0, 5),\n          last5: cloned.slice(-5)\n        };\n      }\n      \n      return cloned;\n    } catch (e) {\n      return { _error: 'Could not serialize data', _type: typeof data };\n    }\n  }\n\n  private getStackTrace(): string {\n    const stack = new Error().stack;\n    return stack ? stack.split('\\n').slice(2, 6).join('\\n') : '';\n  }\n\n  // Save logs to downloadable JSON file\n  private saveTimer: NodeJS.Timeout | null = null;\n  \n  private debouncedSave = (): void => {\n    if (this.saveTimer) clearTimeout(this.saveTimer);\n    \n    this.saveTimer = setTimeout(() => {\n      this.saveToJsonFile();\n    }, 5000); // Save after 5 seconds of inactivity\n  };\n\n  saveToJsonFile(): void {\n    if (typeof window === 'undefined') return;\n\n    try {\n      const logData = {\n        timestamp: new Date().toISOString(),\n        version: '1.0.0',\n        sessionCount: this.logs.filter(l => l.category === 'session').length,\n        apiCallCount: this.logs.filter(l => l.category === 'api').length,\n        errorCount: this.logs.filter(l => l.level === 'error').length,\n        logs: this.logs\n      };\n\n      const dataStr = JSON.stringify(logData, null, 2);\n      const dataBlob = new Blob([dataStr], { type: 'application/json' });\n      \n      const url = URL.createObjectURL(dataBlob);\n      const link = document.createElement('a');\n      link.href = url;\n      link.download = `revi-debug-logs-${Date.now()}.json`;\n      \n      // Auto-download (optional - can be controlled by config)\n      // link.click();\n      \n      console.log('[Revi Debug] Log file ready for download:', link.download);\n      \n      // Store download link globally for manual download\n      (window as any).downloadReviLogs = () => {\n        link.click();\n        URL.revokeObjectURL(url);\n      };\n      \n      URL.revokeObjectURL(url);\n      \n    } catch (error) {\n      console.error('[Revi Debug] Failed to save logs to file:', error);\n    }\n  }\n\n  // Get logs for inspection\n  getLogs(category?: DebugLogEntry['category'], operation?: string): DebugLogEntry[] {\n    let filtered = this.logs;\n    \n    if (category) {\n      filtered = filtered.filter(l => l.category === category);\n    }\n    \n    if (operation) {\n      filtered = filtered.filter(l => l.operation === operation);\n    }\n    \n    return filtered;\n  }\n\n  // Get summary of logs\n  getSummary(): any {\n    const categoryCounts = this.logs.reduce((acc, log) => {\n      acc[log.category] = (acc[log.category] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n\n    const operationCounts = this.logs.reduce((acc, log) => {\n      acc[log.operation] = (acc[log.operation] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n\n    return {\n      totalLogs: this.logs.length,\n      categories: categoryCounts,\n      operations: operationCounts,\n      errors: this.logs.filter(l => l.level === 'error').length,\n      timeRange: this.logs.length > 0 ? {\n        start: new Date(this.logs[0].timestamp).toISOString(),\n        end: new Date(this.logs[this.logs.length - 1].timestamp).toISOString()\n      } : null\n    };\n  }\n\n  // Clear logs\n  clear(): void {\n    this.logs = [];\n    console.log('[Revi Debug] Logs cleared');\n  }\n\n  // Enable/disable logging dynamically\n  setEnabled(enabled: boolean): void {\n    this.isEnabled = enabled;\n    console.log(`[Revi Debug] Logging ${enabled ? 'enabled' : 'disabled'}`);\n  }\n}\n\n// Global debug logger instance\nlet globalDebugLogger: DebugLogger | null = null;\n\nexport function getDebugLogger(): DebugLogger {\n  if (!globalDebugLogger) {\n    globalDebugLogger = new DebugLogger(false, false);\n  }\n  return globalDebugLogger;\n}\n\nexport function initDebugLogger(enabled: boolean, saveToFile: boolean = false): DebugLogger {\n  globalDebugLogger = new DebugLogger(enabled, saveToFile);\n  \n  // Make it available globally for console debugging\n  if (typeof window !== 'undefined') {\n    (window as any).ReviDebugLogger = globalDebugLogger;\n    console.log('[Revi Debug] Debug logger available globally as window.ReviDebugLogger');\n  }\n  \n  return globalDebugLogger;\n}","import { StorageManager } from './storage-manager';\nimport { NetworkManager } from './network-manager';\nimport { compressData, deduplicateEvents, createOptimalBatches } from './compression-utils';\nimport { getDebugLogger } from './debug-logger';\nimport type { ErrorEvent, SessionEvent, NetworkEvent, ReviConfig } from './types';\n\nexport class DataManager {\n  private config: ReviConfig;\n  private storageManager: StorageManager;\n  private networkManager: NetworkManager;\n  private debugLogger = getDebugLogger();\n  private uploadTimer: NodeJS.Timeout | null = null;\n  private isUploading = false;\n  private retryAttempts = new Map<string, number>();\n  private uploadQueue: {\n    errors: ErrorEvent[];\n    sessionEvents: SessionEvent[];\n    networkEvents: NetworkEvent[];\n  } = {\n    errors: [],\n    sessionEvents: [],\n    networkEvents: []\n  };\n\n  constructor(config: ReviConfig) {\n    this.config = config;\n    this.storageManager = new StorageManager();\n    this.networkManager = new NetworkManager();\n    \n    this.initialize();\n  }\n\n  private async initialize(): Promise<void> {\n    try {\n      await this.storageManager.initialize();\n      await this.loadQueueFromStorage();\n      this.startNetworkAwareUploadTimer();\n      this.setupBeforeUnloadHandler();\n      this.setupNetworkChangeHandler();\n    } catch (error) {\n      console.error('[Revi] Failed to initialize data manager:', error);\n    }\n  }\n\n  private async loadQueueFromStorage(): Promise<void> {\n    try {\n      const storedData = await this.storageManager.getAllData();\n      this.uploadQueue = storedData;\n    } catch (error) {\n      console.error('[Revi] Failed to load queue from storage:', error);\n    }\n  }\n\n  private async saveQueueToStorage(): Promise<void> {\n    try {\n      await this.storageManager.clearAll();\n      if (this.uploadQueue.errors.length > 0) {\n        await this.storageManager.storeErrors(this.uploadQueue.errors);\n      }\n      if (this.uploadQueue.sessionEvents.length > 0) {\n        await this.storageManager.storeSessionEvents(this.uploadQueue.sessionEvents);\n      }\n      if (this.uploadQueue.networkEvents.length > 0) {\n        await this.storageManager.storeNetworkEvents(this.uploadQueue.networkEvents);\n      }\n    } catch (error) {\n      console.error('[Revi] Failed to save queue to storage:', error);\n    }\n  }\n\n  private startNetworkAwareUploadTimer(): void {\n    const scheduleNextUpload = () => {\n      if (this.uploadTimer) {\n        clearTimeout(this.uploadTimer);\n      }\n\n      const delay = this.networkManager.getUploadDelay();\n      if (delay > 0) {\n        this.uploadTimer = setTimeout(() => {\n          if (!this.isUploading && this.hasQueuedData()) {\n            this.uploadData().finally(() => {\n              scheduleNextUpload();\n            });\n          } else {\n            scheduleNextUpload();\n          }\n        }, delay);\n      }\n    };\n\n    scheduleNextUpload();\n  }\n\n  private setupNetworkChangeHandler(): void {\n    this.networkManager.onConnectionChange((online) => {\n      if (online) {\n        console.log('[Revi] Network connection restored, resuming uploads');\n        if (this.hasQueuedData() && !this.isUploading) {\n          // Wait a bit before starting uploads to ensure connection is stable\n          setTimeout(() => {\n            this.uploadData();\n          }, 1000);\n        }\n      } else {\n        console.log('[Revi] Network connection lost, uploads paused');\n      }\n    });\n  }\n\n  private setupBeforeUnloadHandler(): void {\n    if (typeof window === 'undefined') return;\n\n    window.addEventListener('beforeunload', () => {\n      if (this.hasQueuedData()) {\n        this.uploadDataSync();\n      }\n    });\n  }\n\n  queueError(error: ErrorEvent): void {\n    this.uploadQueue.errors.push(error);\n    this.saveQueueToStorage().catch(err => {\n      console.error('[Revi] Failed to save error to storage:', err);\n    });\n  }\n\n  queueSessionEvents(events: SessionEvent[]): void {\n    this.uploadQueue.sessionEvents.push(...events);\n    this.saveQueueToStorage().catch(err => {\n      console.error('[Revi] Failed to save session events to storage:', err);\n    });\n  }\n\n  queueNetworkEvents(events: NetworkEvent[]): void {\n    this.uploadQueue.networkEvents.push(...events);\n    this.saveQueueToStorage().catch(err => {\n      console.error('[Revi] Failed to save network events to storage:', err);\n    });\n  }\n\n  private hasQueuedData(): boolean {\n    return this.uploadQueue.errors.length > 0 ||\n           this.uploadQueue.sessionEvents.length > 0 ||\n           this.uploadQueue.networkEvents.length > 0;\n  }\n\n  private async uploadData(): Promise<void> {\n    if (this.isUploading || !this.hasQueuedData()) return;\n\n    const { online } = this.networkManager.getConnectionStatus();\n    if (!online) {\n      console.log('[Revi] Skipping upload - device is offline');\n      return;\n    }\n\n    this.isUploading = true;\n    const apiUrl = this.config.apiUrl || 'https://api.revi.dev';\n    const batchSize = this.networkManager.getBatchSize();\n\n    try {\n      // Upload errors in optimized batches with compression\n      if (this.uploadQueue.errors.length > 0) {\n        const { events: dedupedErrors } = deduplicateEvents(this.uploadQueue.errors);\n        const errorBatches = createOptimalBatches(dedupedErrors, batchSize, 32 * 1024);\n        for (const batch of errorBatches) {\n          await this.uploadErrorsWithRetry(apiUrl, batch);\n        }\n        this.uploadQueue.errors = [];\n      }\n\n      // Upload session events in optimized batches with compression\n      if (this.uploadQueue.sessionEvents.length > 0) {\n        const { events: dedupedEvents } = deduplicateEvents(this.uploadQueue.sessionEvents);\n        const sessionBatches = createOptimalBatches(dedupedEvents, batchSize, 64 * 1024);\n        for (const batch of sessionBatches) {\n          await this.uploadSessionEventsWithRetry(apiUrl, batch);\n        }\n        this.uploadQueue.sessionEvents = [];\n      }\n\n      // Upload network events in optimized batches with compression\n      if (this.uploadQueue.networkEvents.length > 0) {\n        const { events: dedupedEvents } = deduplicateEvents(this.uploadQueue.networkEvents);\n        const networkBatches = createOptimalBatches(dedupedEvents, batchSize, 48 * 1024);\n        for (const batch of networkBatches) {\n          await this.uploadNetworkEventsWithRetry(apiUrl, batch);\n        }\n        this.uploadQueue.networkEvents = [];\n      }\n\n      await this.saveQueueToStorage();\n      \n      // Reset retry attempts on successful upload\n      this.retryAttempts.clear();\n      \n    } catch (error) {\n      if (this.config.debug) {\n        console.error('Revi: Failed to upload data', error);\n      }\n      // Keep data in queue for retry\n    } finally {\n      this.isUploading = false;\n    }\n  }\n\n\n  private uploadDataSync(): void {\n    if (!this.hasQueuedData()) return;\n\n    const apiUrl = this.config.apiUrl || 'https://api.revi.dev';\n\n    // Use sendBeacon for synchronous upload on page unload\n    if (navigator.sendBeacon) {\n      if (this.uploadQueue.errors.length > 0) {\n        const payload = JSON.stringify({ errors: this.uploadQueue.errors });\n        navigator.sendBeacon(`${apiUrl}/api/capture/error`, payload);\n      }\n\n      if (this.uploadQueue.sessionEvents.length > 0) {\n        const payload = JSON.stringify({ \n          session_id: this.uploadQueue.sessionEvents[0]?.sessionId,\n          events: this.uploadQueue.sessionEvents.map(e => ({\n            event_type: e.type,\n            data: e.data,\n            timestamp: e.timestamp,\n            session_id: e.sessionId\n          }))\n        });\n        navigator.sendBeacon(`${apiUrl}/api/capture/session-event`, payload);\n      }\n\n      if (this.uploadQueue.networkEvents.length > 0) {\n        const payload = JSON.stringify({ events: this.uploadQueue.networkEvents });\n        navigator.sendBeacon(`${apiUrl}/api/capture/network-event`, payload);\n      }\n    }\n  }\n\n  private async uploadErrors(apiUrl: string, errors: ErrorEvent[]): Promise<void> {\n    const payload = {\n      errors: errors.map(error => ({\n        message: error.message,\n        stack_trace: error.stack,\n        url: error.url,\n        user_agent: error.userAgent,\n        session_id: error.sessionId,\n        metadata: {\n          id: error.id,\n          userId: error.userId,\n          environment: error.environment,\n          release: error.release,\n          tags: error.tags,\n          extra: error.extra,\n          breadcrumbs: error.breadcrumbs,\n          level: error.level,\n          lineno: error.lineno,\n          colno: error.colno,\n          filename: error.filename\n        },\n        // Device information for backend processing\n        device_info: error.deviceInfo ? {\n          browser_name: error.deviceInfo.browser_name,\n          browser_version: error.deviceInfo.browser_version,\n          browser_major_version: error.deviceInfo.browser_major_version,\n          os_name: error.deviceInfo.os_name,\n          os_version: error.deviceInfo.os_version,\n          device_type: error.deviceInfo.device_type,\n          device_fingerprint: error.deviceInfo.device_fingerprint,\n          screen_resolution: error.deviceInfo.screen_resolution,\n          color_depth: error.deviceInfo.color_depth,\n          device_pixel_ratio: error.deviceInfo.device_pixel_ratio,\n          viewport_size: error.deviceInfo.viewport_size,\n          platform: error.deviceInfo.platform,\n          language: error.deviceInfo.language,\n          timezone: error.deviceInfo.timezone,\n          canvas_fingerprint: error.deviceInfo.canvas_fingerprint,\n          webgl_fingerprint: error.deviceInfo.webgl_fingerprint,\n          cookie_enabled: error.deviceInfo.cookie_enabled,\n          local_storage_enabled: error.deviceInfo.local_storage_enabled,\n          session_storage_enabled: error.deviceInfo.session_storage_enabled\n        } : undefined\n      }))\n    };\n\n    const { data: compressedData, compressed } = await compressData(payload);\n    \n    const headers: Record<string, string> = {\n      'X-API-Key': this.config.apiKey\n    };\n    \n    if (compressed) {\n      headers['Content-Type'] = 'application/octet-stream';\n      headers['Content-Encoding'] = 'gzip';\n      headers['X-Original-Content-Type'] = 'application/json';\n    } else {\n      headers['Content-Type'] = 'application/json';\n    }\n\n    const response = await fetch(`${apiUrl}/api/capture/error`, {\n      method: 'POST',\n      headers,\n      body: compressedData\n    });\n\n    if (!response.ok) {\n      throw new Error(`Upload failed: ${response.status}`);\n    }\n  }\n\n  private async uploadSessionEvents(apiUrl: string, events: SessionEvent[]): Promise<void> {\n    if (events.length === 0) return;\n\n    this.debugLogger.log('session', 'upload-session-events-start', 'Starting session events upload', {\n      eventsCount: events.length,\n      eventsStructure: events.map((e, i) => ({\n        index: i,\n        type: e.type,\n        hasSessionId: !!e.sessionId,\n        sessionIdValue: e.sessionId || 'MISSING',\n        timestamp: e.timestamp,\n        dataKeys: Object.keys(e.data || {})\n      }))\n    });\n\n    const sessionId = events[0].sessionId;\n    this.debugLogger.log('session', 'session-id-extraction', 'Extracted session ID from first event', {\n      sessionId,\n      sessionIdType: typeof sessionId,\n      sessionIdEmpty: !sessionId,\n      firstEventType: events[0].type\n    });\n\n    const payload = {\n      session_id: sessionId,\n      events: events.map(event => ({\n        event_type: event.type,\n        data: event.data,\n        timestamp: event.timestamp,\n        session_id: event.sessionId\n      }))\n    };\n\n    this.debugLogger.logSessionEventUpload(events, sessionId, payload);\n\n    const { data: compressedData, compressed } = await compressData(payload);\n    \n    this.debugLogger.log('session', 'payload-compression', 'Payload compression completed', {\n      originalSize: JSON.stringify(payload).length,\n      compressedSize: (compressedData as any) instanceof ArrayBuffer ? (compressedData as unknown as ArrayBuffer).byteLength : (compressedData as unknown as string).length,\n      compressed,\n      payloadSessionId: payload.session_id,\n      payloadEventsCount: payload.events.length,\n      firstEventHasSessionId: payload.events[0]?.session_id ? true : false\n    });\n    \n    const headers: Record<string, string> = {\n      'X-API-Key': this.config.apiKey\n    };\n    \n    if (compressed) {\n      headers['Content-Type'] = 'application/octet-stream';\n      headers['Content-Encoding'] = 'gzip';\n      headers['X-Original-Content-Type'] = 'application/json';\n    } else {\n      headers['Content-Type'] = 'application/json';\n    }\n\n    this.debugLogger.logApiCall(\n      'session-events-upload',\n      `${apiUrl}/api/capture/session-event`,\n      payload,\n      undefined,\n      undefined\n    );\n\n    const response = await fetch(`${apiUrl}/api/capture/session-event`, {\n      method: 'POST',\n      headers,\n      body: compressedData\n    });\n\n    this.debugLogger.log('session', 'api-response', 'API response received', {\n      status: response.status,\n      statusText: response.statusText,\n      ok: response.ok,\n      headers: Object.fromEntries(response.headers.entries())\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text().catch(() => 'Could not read error response');\n      this.debugLogger.logError('session', 'upload-failed', new Error(`Upload failed: ${response.status}`), {\n        status: response.status,\n        statusText: response.statusText,\n        errorResponse: errorText,\n        payloadPreview: {\n          session_id: payload.session_id,\n          eventsCount: payload.events.length,\n          firstEventKeys: payload.events[0] ? Object.keys(payload.events[0]) : []\n        }\n      });\n      throw new Error(`Upload failed: ${response.status}`);\n    }\n\n    this.debugLogger.log('session', 'upload-success', 'Session events uploaded successfully', {\n      eventsUploaded: events.length,\n      sessionId: payload.session_id\n    });\n  }\n\n  private async uploadNetworkEvents(apiUrl: string, events: NetworkEvent[]): Promise<void> {\n    if (events.length === 0) return;\n\n    this.debugLogger.log('network', 'upload-network-events-start', 'Starting network events upload', {\n      eventsCount: events.length,\n      eventsStructure: events.map((e, i) => ({\n        index: i,\n        method: e.method,\n        url: e.url,\n        hasSessionId: !!e.sessionId,\n        sessionIdValue: e.sessionId || 'MISSING',\n        statusCode: e.statusCode,\n        timestamp: e.timestamp\n      }))\n    });\n\n    // Use the first event's session ID (all events in batch should have same session)\n    const sessionId = events[0].sessionId;\n    this.debugLogger.log('network', 'session-id-extraction', 'Extracted session ID from first event', {\n      sessionId,\n      sessionIdType: typeof sessionId,\n      sessionIdEmpty: !sessionId,\n      firstEventMethod: events[0].method\n    });\n\n    const payload = {\n      session_id: sessionId,\n      events: events.map(event => ({\n        method: event.method,\n        url: event.url,\n        status_code: event.statusCode,\n        response_time: event.responseTime,\n        timestamp: event.timestamp,\n        session_id: event.sessionId,\n        request_data: {\n          headers: event.requestHeaders || {},\n          body: event.requestBody || null,\n          size: event.requestSize || 0\n        },\n        response_data: {\n          headers: event.responseHeaders || {},\n          body: event.responseBody || null,\n          size: event.responseSize || 0\n        }\n      }))\n    };\n\n    this.debugLogger.log('network', 'network-batch-payload', 'Network events batch payload created', {\n      sessionId: payload.session_id,\n      eventsCount: payload.events.length,\n      allHaveSessionId: payload.events.every(e => !!e.session_id),\n      sessionIds: payload.events.map(e => e.session_id)\n    });\n\n    const { data: compressedData, compressed } = await compressData(payload);\n    \n    this.debugLogger.log('network', 'payload-compression', 'Network payload compression completed', {\n      originalSize: JSON.stringify(payload).length,\n      compressedSize: (compressedData as any) instanceof ArrayBuffer ? (compressedData as unknown as ArrayBuffer).byteLength : (compressedData as unknown as string).length,\n      compressed,\n      payloadSessionId: payload.session_id,\n      payloadEventsCount: payload.events.length\n    });\n    \n    const headers: Record<string, string> = {\n      'X-API-Key': this.config.apiKey\n    };\n    \n    if (compressed) {\n      headers['Content-Type'] = 'application/octet-stream';\n      headers['Content-Encoding'] = 'gzip';\n      headers['X-Original-Content-Type'] = 'application/json';\n    } else {\n      headers['Content-Type'] = 'application/json';\n    }\n\n    this.debugLogger.logApiCall(\n      'network-events-upload',\n      `${apiUrl}/api/capture/network-event`,\n      payload,\n      undefined,\n      undefined\n    );\n\n    const response = await fetch(`${apiUrl}/api/capture/network-event`, {\n      method: 'POST',\n      headers,\n      body: compressedData\n    });\n\n    this.debugLogger.log('network', 'api-response', 'Network API response received', {\n      status: response.status,\n      statusText: response.statusText,\n      ok: response.ok,\n      headers: Object.fromEntries(response.headers.entries())\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text().catch(() => 'Could not read error response');\n      this.debugLogger.logError('network', 'upload-failed', new Error(`Network upload failed: ${response.status}`), {\n        status: response.status,\n        statusText: response.statusText,\n        errorResponse: errorText,\n        payloadPreview: {\n          session_id: payload.session_id,\n          eventsCount: payload.events.length,\n          firstEventKeys: payload.events[0] ? Object.keys(payload.events[0]) : []\n        }\n      });\n      throw new Error(`Network upload failed: ${response.status}`);\n    }\n\n    this.debugLogger.log('network', 'upload-success', 'Network events uploaded successfully', {\n      eventsUploaded: events.length,\n      sessionId: payload.session_id\n    });\n  }\n\n  private async uploadErrorsWithRetry(apiUrl: string, errors: ErrorEvent[]): Promise<void> {\n    const key = 'errors';\n    return this.executeWithRetry(key, () => this.uploadErrors(apiUrl, errors));\n  }\n\n  private async uploadSessionEventsWithRetry(apiUrl: string, events: SessionEvent[]): Promise<void> {\n    const key = 'session_events';\n    return this.executeWithRetry(key, () => this.uploadSessionEvents(apiUrl, events));\n  }\n\n  private async uploadNetworkEventsWithRetry(apiUrl: string, events: NetworkEvent[]): Promise<void> {\n    const key = 'network_events';  \n    return this.executeWithRetry(key, () => this.uploadNetworkEvents(apiUrl, events));\n  }\n\n  private async executeWithRetry<T>(key: string, operation: () => Promise<T>): Promise<T> {\n    const currentAttempt = this.retryAttempts.get(key) || 0;\n\n    if (!this.networkManager.shouldRetry(currentAttempt)) {\n      throw new Error(`Max retry attempts exceeded for ${key}`);\n    }\n\n    try {\n      const result = await operation();\n      this.retryAttempts.delete(key); // Success, reset retry count\n      return result;\n    } catch (error) {\n      this.retryAttempts.set(key, currentAttempt + 1);\n      \n      if (this.networkManager.shouldRetry(currentAttempt + 1)) {\n        const delay = this.networkManager.getRetryDelay(currentAttempt + 1);\n        console.log(`[Revi] Upload failed for ${key}, retrying in ${delay}ms (attempt ${currentAttempt + 2})`);\n        \n        await new Promise(resolve => setTimeout(resolve, delay));\n        return this.executeWithRetry(key, operation);\n      } else {\n        console.error(`[Revi] Max retry attempts exceeded for ${key}:`, error);\n        throw error;\n      }\n    }\n  }\n\n  async clearQueue(): Promise<void> {\n    this.uploadQueue = {\n      errors: [],\n      sessionEvents: [],\n      networkEvents: []\n    };\n    \n    await this.storageManager.clearAll();\n  }\n\n  destroy(): void {\n    if (this.uploadTimer) {\n      clearTimeout(this.uploadTimer);\n      this.uploadTimer = null;\n    }\n    \n    // Final upload attempt\n    if (this.hasQueuedData()) {\n      this.uploadDataSync();\n    }\n  }\n}\n","import type { ReviConfig } from './types';\nimport { generateId } from './utils';\nimport crypto from 'crypto';\n\nexport interface JourneyEvent {\n  event_type: 'page_view' | 'click' | 'form_submit' | 'api_call' | 'error';\n  url: string;\n  referrer?: string;\n  timestamp: number;\n  duration_ms?: number;\n  metadata: Record<string, any>;\n}\n\nexport interface DeviceFingerprint {\n  screen_resolution: string;\n  color_depth: number;\n  timezone: string;\n  language: string;\n  platform: string;\n  user_agent: string;\n  canvas_fingerprint?: string;\n  webgl_fingerprint?: string;\n}\n\n/**\n * Advanced user journey tracking with device fingerprinting\n */\nexport class UserJourneyTracker {\n  private config: ReviConfig;\n  private userId?: string;\n  private deviceFingerprint: string;\n  private sessionStartTime: number;\n  private currentPageStartTime: number;\n  private journeyEvents: JourneyEvent[] = [];\n  private isTracking = false;\n  private sessionIdProvider?: () => string;\n\n  constructor(config: ReviConfig, sessionIdProvider?: () => string) {\n    this.config = config;\n    this.sessionIdProvider = sessionIdProvider;\n    this.deviceFingerprint = this.generateDeviceFingerprint();\n    this.sessionStartTime = Date.now();\n    this.currentPageStartTime = Date.now();\n    \n    if (typeof window !== 'undefined') {\n      this.setupJourneyTracking();\n    }\n  }\n\n  /**\n   * Start tracking user journey\n   */\n  startTracking(userId?: string): void {\n    this.userId = userId;\n    this.isTracking = true;\n    \n    // Track initial page view\n    this.trackPageView();\n    \n    if (this.config.debug) {\n      console.log('Revi: User journey tracking started', { userId, deviceFingerprint: this.deviceFingerprint });\n    }\n  }\n\n  /**\n   * Stop tracking user journey\n   */\n  stopTracking(): void {\n    this.isTracking = false;\n    this.flush();\n  }\n\n  /**\n   * Set user ID for tracking\n   */\n  setUserId(userId: string): void {\n    this.userId = userId;\n  }\n\n  /**\n   * Track page view with timing\n   */\n  private trackPageView(): void {\n    if (!this.isTracking) return;\n\n    const event: JourneyEvent = {\n      event_type: 'page_view',\n      url: window.location.href,\n      referrer: document.referrer || undefined,\n      timestamp: Date.now(),\n      metadata: {\n        title: document.title,\n        viewport: {\n          width: window.innerWidth,\n          height: window.innerHeight\n        },\n        scroll_position: {\n          x: window.scrollX,\n          y: window.scrollY\n        },\n        device_fingerprint: this.deviceFingerprint,\n        user_agent: navigator.userAgent,\n        language: navigator.language,\n        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n        connection_type: this.getConnectionType()\n      }\n    };\n\n    this.addJourneyEvent(event);\n  }\n\n  /**\n   * Track user clicks with context\n   */\n  private trackClick(element: HTMLElement, event: MouseEvent): void {\n    if (!this.isTracking) return;\n\n    const journeyEvent: JourneyEvent = {\n      event_type: 'click',\n      url: window.location.href,\n      timestamp: Date.now(),\n      metadata: {\n        element: {\n          tag: element.tagName.toLowerCase(),\n          id: element.id,\n          class: element.className,\n          text: this.getElementText(element),\n          attributes: this.getRelevantAttributes(element)\n        },\n        coordinates: {\n          x: event.clientX,\n          y: event.clientY,\n          page_x: event.pageX,\n          page_y: event.pageY\n        },\n        viewport: {\n          width: window.innerWidth,\n          height: window.innerHeight\n        },\n        scroll_position: {\n          x: window.scrollX,\n          y: window.scrollY\n        }\n      }\n    };\n\n    this.addJourneyEvent(journeyEvent);\n  }\n\n  /**\n   * Track form submissions\n   */\n  private trackFormSubmit(form: HTMLFormElement): void {\n    if (!this.isTracking) return;\n\n    const formData = new FormData(form);\n    const fields: Record<string, any> = {};\n    \n    formData.forEach((value, key) => {\n      // Only track field names and types, not values for privacy\n      const input = form.querySelector(`[name=\"${key}\"]`) as HTMLInputElement;\n      fields[key] = {\n        type: input?.type || 'unknown',\n        has_value: !!value,\n        value_length: typeof value === 'string' ? value.length : 0\n      };\n    });\n\n    const journeyEvent: JourneyEvent = {\n      event_type: 'form_submit',\n      url: window.location.href,\n      timestamp: Date.now(),\n      metadata: {\n        form: {\n          id: form.id,\n          class: form.className,\n          method: form.method,\n          action: form.action,\n          field_count: formData.entries().length\n        },\n        fields: this.config.privacy?.maskInputs ? {} : fields\n      }\n    };\n\n    this.addJourneyEvent(journeyEvent);\n  }\n\n  /**\n   * Track API calls and their performance\n   */\n  trackApiCall(url: string, method: string, status: number, duration: number, size?: number): void {\n    if (!this.isTracking) return;\n\n    const journeyEvent: JourneyEvent = {\n      event_type: 'api_call',\n      url: window.location.href,\n      timestamp: Date.now(),\n      duration_ms: duration,\n      metadata: {\n        api: {\n          url,\n          method,\n          status,\n          duration,\n          size: size || 0,\n          success: status >= 200 && status < 300\n        },\n        page_context: {\n          title: document.title,\n          time_on_page: Date.now() - this.currentPageStartTime\n        }\n      }\n    };\n\n    this.addJourneyEvent(journeyEvent);\n  }\n\n  /**\n   * Track errors in user journey context\n   */\n  trackError(error: Error, context?: Record<string, any>): void {\n    if (!this.isTracking) return;\n\n    const journeyEvent: JourneyEvent = {\n      event_type: 'error',\n      url: window.location.href,\n      timestamp: Date.now(),\n      metadata: {\n        error: {\n          message: error.message,\n          name: error.name,\n          stack: error.stack?.split('\\n').slice(0, 5).join('\\n') // Limit stack trace\n        },\n        user_context: {\n          time_on_page: Date.now() - this.currentPageStartTime,\n          session_duration: Date.now() - this.sessionStartTime,\n          page_interactions: this.countPageInteractions()\n        },\n        custom_context: context || {}\n      }\n    };\n\n    this.addJourneyEvent(journeyEvent);\n  }\n\n  /**\n   * Setup event listeners for journey tracking\n   */\n  private setupJourneyTracking(): void {\n    // Track page views on navigation\n    let currentUrl = window.location.href;\n    \n    const handleNavigation = () => {\n      if (window.location.href !== currentUrl) {\n        // Track time spent on previous page\n        const timeSpent = Date.now() - this.currentPageStartTime;\n        this.updateLastPageViewDuration(timeSpent);\n        \n        // Track new page view\n        currentUrl = window.location.href;\n        this.currentPageStartTime = Date.now();\n        this.trackPageView();\n      }\n    };\n\n    // Handle navigation events\n    window.addEventListener('popstate', handleNavigation);\n    \n    // Override pushState and replaceState to catch programmatic navigation\n    const originalPushState = history.pushState;\n    const originalReplaceState = history.replaceState;\n    \n    history.pushState = function(...args) {\n      originalPushState.apply(history, args);\n      setTimeout(handleNavigation, 0);\n    };\n    \n    history.replaceState = function(...args) {\n      originalReplaceState.apply(history, args);\n      setTimeout(handleNavigation, 0);\n    };\n\n    // Track clicks\n    document.addEventListener('click', (event) => {\n      const target = event.target as HTMLElement;\n      if (target && this.shouldTrackClick(target)) {\n        this.trackClick(target, event);\n      }\n    }, { capture: true, passive: true });\n\n    // Track form submissions\n    document.addEventListener('submit', (event) => {\n      const form = event.target as HTMLFormElement;\n      if (form && form.tagName === 'FORM') {\n        this.trackFormSubmit(form);\n      }\n    }, { capture: true, passive: true });\n\n    // Track page exit\n    window.addEventListener('beforeunload', () => {\n      const timeSpent = Date.now() - this.currentPageStartTime;\n      this.updateLastPageViewDuration(timeSpent);\n      this.flush();\n    });\n\n    // Periodic flush\n    setInterval(() => {\n      if (this.journeyEvents.length > 0) {\n        this.flush();\n      }\n    }, 30000); // Flush every 30 seconds\n  }\n\n  /**\n   * Generate device fingerprint for user tracking\n   */\n  private generateDeviceFingerprint(): string {\n    if (typeof window === 'undefined') return 'server';\n\n    const components = [\n      navigator.userAgent,\n      navigator.language,\n      screen.width + 'x' + screen.height,\n      screen.colorDepth,\n      Intl.DateTimeFormat().resolvedOptions().timeZone,\n      navigator.platform,\n      navigator.cookieEnabled,\n      typeof window.localStorage !== 'undefined',\n      typeof window.sessionStorage !== 'undefined'\n    ];\n\n    // Add canvas fingerprint if available\n    try {\n      const canvas = document.createElement('canvas');\n      const ctx = canvas.getContext('2d');\n      if (ctx) {\n        ctx.textBaseline = 'top';\n        ctx.font = '14px Arial';\n        ctx.fillText('Device fingerprint', 2, 2);\n        components.push(canvas.toDataURL());\n      }\n    } catch (e) {\n      // Canvas fingerprinting failed\n    }\n\n    // Create hash of all components\n    const fingerprint = components.join('|');\n    \n    // Simple hash function (in production, use a proper crypto library)\n    let hash = 0;\n    for (let i = 0; i < fingerprint.length; i++) {\n      const char = fingerprint.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    \n    return Math.abs(hash).toString(36);\n  }\n\n  /**\n   * Add journey event to buffer\n   */\n  private addJourneyEvent(event: JourneyEvent): void {\n    this.journeyEvents.push(event);\n\n    // Auto-flush if buffer is full\n    if (this.journeyEvents.length >= 50) {\n      this.flush();\n    }\n  }\n\n  /**\n   * Flush journey events to backend\n   */\n  private flush(): void {\n    if (this.journeyEvents.length === 0) return;\n\n    const events = [...this.journeyEvents];\n    this.journeyEvents = [];\n\n    // Send to backend (implement based on your API structure)\n    this.sendJourneyEvents(events).catch(error => {\n      if (this.config.debug) {\n        console.error('Revi: Failed to send journey events', error);\n      }\n      // Re-add events to buffer for retry\n      this.journeyEvents.unshift(...events);\n    });\n  }\n\n  /**\n   * Send journey events to analytics backend\n   */\n  private async sendJourneyEvents(events: JourneyEvent[]): Promise<void> {\n    const apiUrl = this.config.apiUrl || 'https://api.revi.dev';\n    \n    // Send each event individually (could be optimized for batch sending)\n    const promises = events.map(event => \n      fetch(`${apiUrl}/api/analytics/user-event`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-API-Key': this.config.apiKey\n        },\n        body: JSON.stringify({\n          user_id: this.userId,\n          session_id: this.getSessionId(),\n          ...event\n        })\n      })\n    );\n\n    await Promise.allSettled(promises);\n  }\n\n  /**\n   * Helper methods\n   */\n  private shouldTrackClick(element: HTMLElement): boolean {\n    // Don't track clicks on sensitive elements\n    const tag = element.tagName.toLowerCase();\n    if (['input', 'textarea'].includes(tag)) {\n      const input = element as HTMLInputElement;\n      if (['password', 'hidden'].includes(input.type)) {\n        return false;\n      }\n    }\n\n    // Don't track if element has data-revi-ignore attribute\n    return !element.hasAttribute('data-revi-ignore');\n  }\n\n  private getElementText(element: HTMLElement): string {\n    const text = element.textContent || element.innerText || '';\n    return text.trim().substring(0, 100);\n  }\n\n  private getRelevantAttributes(element: HTMLElement): Record<string, string> {\n    const attrs: Record<string, string> = {};\n    const relevantAttrs = ['href', 'src', 'alt', 'title', 'data-testid', 'role'];\n    \n    relevantAttrs.forEach(attr => {\n      const value = element.getAttribute(attr);\n      if (value) {\n        attrs[attr] = value;\n      }\n    });\n    \n    return attrs;\n  }\n\n  private getConnectionType(): string {\n    if ('connection' in navigator) {\n      const connection = (navigator as any).connection;\n      return connection?.effectiveType || connection?.type || 'unknown';\n    }\n    return 'unknown';\n  }\n\n  private countPageInteractions(): number {\n    return this.journeyEvents.filter(event => \n      ['click', 'form_submit'].includes(event.event_type)\n    ).length;\n  }\n\n  private updateLastPageViewDuration(duration: number): void {\n    if (this.journeyEvents.length > 0) {\n      const lastEvent = this.journeyEvents[this.journeyEvents.length - 1];\n      if (lastEvent.event_type === 'page_view') {\n        lastEvent.duration_ms = duration;\n      }\n    }\n  }\n\n  private getSessionId(): string {\n    // Use the provided session ID provider from Monitor, fallback to placeholder\n    if (this.sessionIdProvider) {\n      return this.sessionIdProvider();\n    }\n    \n    // Fallback placeholder for standalone usage\n    return 'session-' + Date.now();\n  }\n}","import type { ReviConfig } from './types';\n\nexport class SamplingManager {\n  private config: ReviConfig;\n  private activityLevel = 0;\n  private lastActivity = Date.now();\n  private errorFrequency = 0;\n  private performanceImpact = 0;\n  \n  constructor(config: ReviConfig) {\n    this.config = config;\n    this.startPerformanceMonitoring();\n  }\n\n  private startPerformanceMonitoring(): void {\n    // Monitor performance impact and adjust sampling\n    if (typeof window !== 'undefined' && 'performance' in window) {\n      setInterval(() => {\n        this.assessPerformanceImpact();\n      }, 5000);\n    }\n  }\n\n  private assessPerformanceImpact(): void {\n    if (typeof performance === 'undefined') return;\n    \n    try {\n      // Simple heuristic: if long tasks are frequent, reduce sampling\n      const now = performance.now();\n      const entries = performance.getEntriesByType('longtask');\n      const recentLongTasks = entries.filter(entry => \n        (now - entry.startTime) < 10000\n      );\n      \n      // Higher impact = more aggressive sampling reduction\n      this.performanceImpact = Math.min(recentLongTasks.length / 5, 1);\n    } catch (error) {\n      // Fallback to low impact if performance API fails\n      this.performanceImpact = 0.1;\n    }\n  }\n\n  updateActivityLevel(activity: 'high' | 'medium' | 'low' | 'idle'): void {\n    const levels = { high: 1, medium: 0.7, low: 0.4, idle: 0.1 };\n    this.activityLevel = levels[activity];\n    this.lastActivity = Date.now();\n  }\n\n  incrementErrorFrequency(): void {\n    this.errorFrequency = Math.min(this.errorFrequency + 0.1, 1);\n    \n    // Decay error frequency over time\n    setTimeout(() => {\n      this.errorFrequency = Math.max(this.errorFrequency - 0.05, 0);\n    }, 30000);\n  }\n\n  shouldSampleError(): boolean {\n    const baseSampleRate = this.config.sampling?.errorSampleRate ?? 1.0;\n    \n    // Always sample errors if error rate is high\n    if (this.errorFrequency > 0.5) {\n      return Math.random() < baseSampleRate;\n    }\n    \n    // Reduce sampling if performance impact is high\n    const adjustedRate = baseSampleRate * (1 - this.performanceImpact * 0.5);\n    \n    return Math.random() < adjustedRate;\n  }\n\n  shouldSampleSession(): boolean {\n    const baseSampleRate = this.config.sampling?.sessionSampleRate ?? this.config.sessionSampleRate ?? 1.0;\n    \n    // Increase sampling during high activity\n    const activityBonus = this.activityLevel * 0.2;\n    const adjustedRate = Math.min(baseSampleRate + activityBonus, 1.0);\n    \n    // Reduce sampling if performance impact is high\n    const finalRate = adjustedRate * (1 - this.performanceImpact * 0.3);\n    \n    return Math.random() < finalRate;\n  }\n\n  shouldSamplePerformance(): boolean {\n    const baseSampleRate = this.config.sampling?.performanceSampleRate ?? 0.1;\n    \n    // Reduce performance sampling during high load\n    const adjustedRate = baseSampleRate * (1 - this.performanceImpact * 0.7);\n    \n    return Math.random() < adjustedRate;\n  }\n\n  shouldSampleNetwork(): boolean {\n    const baseSampleRate = this.config.sampling?.networkSampleRate ?? 0.5;\n    \n    // Sample less during idle periods\n    const idleTimeDays = (Date.now() - this.lastActivity) / (1000 * 60);\n    const idlePenalty = idleTimeDays > 5 ? 0.5 : 1.0;\n    \n    const adjustedRate = baseSampleRate * idlePenalty * (1 - this.performanceImpact * 0.4);\n    \n    return Math.random() < adjustedRate;\n  }\n\n  shouldSampleReplay(): boolean {\n    const baseSampleRate = this.config.sampling?.replaySampleRate ?? 0.1;\n    \n    // Increase replay sampling when there are errors\n    const errorBonus = this.errorFrequency * 0.3;\n    let adjustedRate = Math.min(baseSampleRate + errorBonus, 1.0);\n    \n    // Heavy penalty for performance impact since replay is expensive\n    adjustedRate = adjustedRate * (1 - this.performanceImpact * 0.8);\n    \n    return Math.random() < adjustedRate;\n  }\n\n  getAdaptiveBatchSize(baseSize: number): number {\n    // Reduce batch sizes during high performance impact\n    const impactReduction = this.performanceImpact * 0.6;\n    return Math.max(Math.floor(baseSize * (1 - impactReduction)), 1);\n  }\n\n  getAdaptiveUploadDelay(baseDelay: number): number {\n    // Increase delays during high performance impact\n    const impactMultiplier = 1 + (this.performanceImpact * 2);\n    \n    // Decrease delays during high error frequency\n    const errorMultiplier = Math.max(0.3, 1 - (this.errorFrequency * 0.7));\n    \n    return Math.floor(baseDelay * impactMultiplier * errorMultiplier);\n  }\n\n  shouldSkipCapture(eventType: 'error' | 'session' | 'performance' | 'network' | 'replay'): boolean {\n    switch (eventType) {\n      case 'error':\n        return !this.shouldSampleError();\n      case 'session':\n        return !this.shouldSampleSession();\n      case 'performance':\n        return !this.shouldSamplePerformance();\n      case 'network':\n        return !this.shouldSampleNetwork();\n      case 'replay':\n        return !this.shouldSampleReplay();\n      default:\n        return false;\n    }\n  }\n\n  getPerformanceImpact(): number {\n    return this.performanceImpact;\n  }\n\n  getActivityLevel(): number {\n    return this.activityLevel;\n  }\n\n  getErrorFrequency(): number {\n    return this.errorFrequency;\n  }\n}","import type { PerformanceEntry, WebVitals, ReviConfig } from './types';\n\nexport class PerformanceMonitor {\n  private config: ReviConfig;\n  private webVitals: WebVitals = {};\n  private performanceEntries: PerformanceEntry[] = [];\n\n  constructor(config: ReviConfig) {\n    this.config = config;\n    \n    if (this.config.performance?.captureWebVitals) {\n      this.setupWebVitals();\n    }\n    \n    if (this.config.performance?.captureResourceTiming) {\n      this.setupResourceTiming();\n    }\n    \n    if (this.config.performance?.captureNavigationTiming) {\n      this.setupNavigationTiming();\n    }\n  }\n\n  private setupWebVitals(): void {\n    if (typeof window === 'undefined' || !('PerformanceObserver' in window)) return;\n\n    // Largest Contentful Paint (LCP)\n    try {\n      const lcpObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        const lastEntry = entries[entries.length - 1];\n        this.webVitals.lcp = lastEntry.startTime;\n      });\n      lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });\n    } catch (e) {\n      // LCP not supported\n    }\n\n    // First Input Delay (FID)\n    try {\n      const fidObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries() as any[];\n        entries.forEach((entry) => {\n          this.webVitals.fid = entry.processingStart - entry.startTime;\n        });\n      });\n      fidObserver.observe({ entryTypes: ['first-input'] });\n    } catch (e) {\n      // FID not supported\n    }\n\n    // Cumulative Layout Shift (CLS)\n    try {\n      let clsValue = 0;\n      const clsObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries() as any[];\n        entries.forEach((entry) => {\n          if (!entry.hadRecentInput) {\n            clsValue += entry.value;\n            this.webVitals.cls = clsValue;\n          }\n        });\n      });\n      clsObserver.observe({ entryTypes: ['layout-shift'] });\n    } catch (e) {\n      // CLS not supported\n    }\n\n    // First Contentful Paint (FCP)\n    try {\n      const fcpObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        entries.forEach((entry) => {\n          if (entry.name === 'first-contentful-paint') {\n            this.webVitals.fcp = entry.startTime;\n          }\n        });\n      });\n      fcpObserver.observe({ entryTypes: ['paint'] });\n    } catch (e) {\n      // FCP not supported\n    }\n\n    // Time to First Byte (TTFB)\n    this.calculateTTFB();\n  }\n\n  private calculateTTFB(): void {\n    if (typeof window === 'undefined' || !window.performance) return;\n\n    try {\n      const navigationTiming = performance.getEntriesByType('navigation')[0] as any;\n      if (navigationTiming) {\n        this.webVitals.ttfb = navigationTiming.responseStart - navigationTiming.requestStart;\n      }\n    } catch (e) {\n      // TTFB calculation failed\n    }\n  }\n\n  private setupResourceTiming(): void {\n    if (typeof window === 'undefined' || !window.performance) return;\n\n    try {\n      const resourceObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        entries.forEach((entry) => {\n          this.performanceEntries.push({\n            name: entry.name,\n            entryType: entry.entryType,\n            startTime: entry.startTime,\n            duration: entry.duration,\n            transferSize: (entry as any).transferSize,\n            encodedBodySize: (entry as any).encodedBodySize,\n            decodedBodySize: (entry as any).decodedBodySize\n          });\n        });\n      });\n      \n      resourceObserver.observe({ entryTypes: ['resource'] });\n    } catch (e) {\n      // Resource timing not supported\n    }\n  }\n\n  private setupNavigationTiming(): void {\n    if (typeof window === 'undefined' || !window.performance) return;\n\n    window.addEventListener('load', () => {\n      try {\n        const navigationTiming = performance.getEntriesByType('navigation')[0] as any;\n        if (navigationTiming) {\n          this.performanceEntries.push({\n            name: 'navigation',\n            entryType: 'navigation',\n            startTime: navigationTiming.startTime,\n            duration: navigationTiming.duration,\n            domContentLoadedEventEnd: navigationTiming.domContentLoadedEventEnd,\n            domContentLoadedEventStart: navigationTiming.domContentLoadedEventStart,\n            loadEventEnd: navigationTiming.loadEventEnd,\n            loadEventStart: navigationTiming.loadEventStart,\n            domComplete: navigationTiming.domComplete,\n            domInteractive: navigationTiming.domInteractive\n          });\n        }\n      } catch (e) {\n        // Navigation timing failed\n      }\n    });\n  }\n\n  getWebVitals(): WebVitals {\n    return { ...this.webVitals };\n  }\n\n  getPerformanceEntries(): PerformanceEntry[] {\n    return [...this.performanceEntries];\n  }\n\n  clearPerformanceEntries(): void {\n    this.performanceEntries = [];\n  }\n\n  // Custom performance marks\n  mark(name: string): void {\n    if (typeof window !== 'undefined' && window.performance && typeof window.performance.mark === 'function') {\n      try {\n        performance.mark(name);\n      } catch (e) {\n        // Mark failed\n      }\n    }\n  }\n\n  measure(name: string, startMark?: string, endMark?: string): number | null {\n    if (typeof window === 'undefined' || !window.performance || !window.performance.measure) {\n      return null;\n    }\n\n    try {\n      performance.measure(name, startMark, endMark);\n      const measure = performance.getEntriesByName(name, 'measure')[0];\n      return measure ? measure.duration : null;\n    } catch (e) {\n      return null;\n    }\n  }\n}\n","import type { ReviConfig } from './types';\n\nexport interface EnhancedSerializedNode {\n  id: number;\n  type: 'element' | 'text' | 'comment' | 'document' | 'doctype';\n  tagName?: string;\n  textContent?: string;\n  attributes?: Record<string, string>;\n  children?: EnhancedSerializedNode[];\n  parentId?: number;\n  \n  // Enhanced styling and layout information\n  computedStyles?: Record<string, string>;\n  inlineStyles?: Record<string, string>;\n  cssRules?: CSSRule[];\n  boundingRect?: DOMRect;\n  visibility?: {\n    visible: boolean;\n    opacity: number;\n    display: string;\n    zIndex: number;\n  };\n  \n  // Interactive state\n  interactionState?: {\n    focused: boolean;\n    hovered: boolean;\n    pressed: boolean;\n    disabled: boolean;\n    checked?: boolean;\n    selected?: boolean;\n  };\n  \n  // Content state for form elements\n  inputValue?: string;\n  selectedOptions?: string[];\n  scrollPosition?: { x: number; y: number };\n  \n  // Performance metrics\n  renderTime?: number;\n  memoryUsage?: number;\n}\n\nexport interface EnhancedDOMSnapshot {\n  timestamp: number;\n  url: string;\n  title: string;\n  viewport: {\n    width: number;\n    height: number;\n    devicePixelRatio: number;\n    scrollX: number;\n    scrollY: number;\n  };\n  nodes: EnhancedSerializedNode[];\n  stylesheets: EnhancedStylesheet[];\n  resources: EnhancedResource[];\n  \n  // Page performance metrics\n  performance?: {\n    domContentLoaded: number;\n    loadComplete: number;\n    paintTimings: Record<string, number>;\n    layoutShifts: any[];\n    memoryUsage: number;\n  };\n  \n  // Environment info\n  environment?: {\n    userAgent: string;\n    language: string;\n    timezone: string;\n    colorScheme: 'light' | 'dark';\n    reducedMotion: boolean;\n  };\n}\n\nexport interface EnhancedStylesheet {\n  href?: string;\n  cssText: string;\n  disabled: boolean;\n  media?: string;\n  title?: string;\n  type?: string;\n  origin: 'author' | 'user' | 'user-agent';\n  \n  // Processed rules for better reconstruction\n  rules: ProcessedCSSRule[];\n  \n  // Performance\n  loadTime?: number;\n  size: number;\n}\n\nexport interface ProcessedCSSRule {\n  type: number;\n  cssText: string;\n  selectorText?: string;\n  declarations?: CSSDeclaration[];\n  media?: string;\n  \n  // Computed specificity and usage\n  specificity?: number;\n  usage?: {\n    matchedElements: number[];\n    frequency: number;\n  };\n}\n\nexport interface CSSDeclaration {\n  property: string;\n  value: string;\n  priority: string;\n  important: boolean;\n}\n\nexport interface EnhancedResource {\n  url: string;\n  type: 'image' | 'font' | 'media' | 'script' | 'stylesheet' | 'fetch' | 'document';\n  method?: string;\n  status?: number;\n  size?: number;\n  mimeType?: string;\n  loadTime?: number;\n  fromCache?: boolean;\n  \n  // For images\n  dimensions?: { width: number; height: number };\n  \n  // Small resources can be inlined\n  data?: string; // Base64 encoded\n  failed?: boolean;\n  blocked?: boolean;\n}\n\nexport interface EnhancedDOMChange extends DOMChange {\n  // Additional context\n  causedBy?: {\n    type: 'user-interaction' | 'script' | 'network' | 'animation' | 'media-query';\n    details?: any;\n  };\n  \n  // Performance impact\n  renderingTime?: number;\n  layoutThrashing?: boolean;\n  \n  // Visual impact\n  visualChange?: {\n    affectedArea: DOMRect;\n    significance: 'minor' | 'moderate' | 'major';\n  };\n}\n\nexport interface DOMChange {\n  timestamp: number;\n  type: 'childList' | 'attributes' | 'characterData' | 'style' | 'class' | 'dataset';\n  target: number; // Node ID\n  addedNodes?: EnhancedSerializedNode[];\n  removedNodes?: number[]; // Node IDs\n  attributeName?: string;\n  attributeValue?: string;\n  oldValue?: string;\n  newValue?: string;\n  \n  // Style-specific changes\n  styleChanges?: {\n    property: string;\n    oldValue: string;\n    newValue: string;\n    computed?: boolean;\n  }[];\n  \n  // Class changes\n  classChanges?: {\n    added: string[];\n    removed: string[];\n  };\n}\n\n/**\n * Enhanced DOM serializer with advanced styling, layout, and interaction capture\n */\nexport class EnhancedDOMSerializer {\n  // private _config: ReviConfig;\n  private nodeIdMap = new WeakMap<Node, number>();\n  private nodeMap = new Map<number, Node>();\n  private nextNodeId = 1;\n  private observer?: MutationObserver;\n  private resizeObserver?: ResizeObserver;\n  private isObserving = false;\n  private onDOMChange?: (change: EnhancedDOMChange) => void;\n  \n  // Performance tracking\n  private performanceObserver?: PerformanceObserver;\n  private layoutShiftEntries: any[] = [];\n  \n  // Style tracking\n  // private _stylesheetMap = new Map<CSSStyleSheet, EnhancedStylesheet>();\n  private computedStyleCache = new WeakMap<Element, Record<string, string>>();\n\n  constructor(_config: ReviConfig) {\n    // this._config = config;\n    this.setupPerformanceObserver();\n    this.setupStylesheetTracking();\n  }\n\n  /**\n   * Take an enhanced snapshot of the DOM with styling and layout information\n   */\n  takeEnhancedSnapshot(): EnhancedDOMSnapshot {\n    const startTime = performance.now();\n    \n    const snapshot: EnhancedDOMSnapshot = {\n      timestamp: Date.now(),\n      url: window.location.href,\n      title: document.title,\n      viewport: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        devicePixelRatio: window.devicePixelRatio,\n        scrollX: window.scrollX,\n        scrollY: window.scrollY\n      },\n      nodes: [],\n      stylesheets: [],\n      resources: [],\n      \n      performance: this.capturePerformanceMetrics(),\n      environment: this.captureEnvironmentInfo()\n    };\n\n    // Serialize DOM with enhanced information\n    snapshot.nodes = this.serializeDocumentEnhanced(document);\n    \n    // Capture stylesheets with processed rules\n    snapshot.stylesheets = this.serializeStylesheetsEnhanced();\n    \n    // Capture resources with detailed metadata\n    snapshot.resources = this.serializeResourcesEnhanced();\n\n    const endTime = performance.now();\n    console.log(`Enhanced DOM snapshot taken in ${endTime - startTime}ms`);\n\n    return snapshot;\n  }\n\n  /**\n   * Start observing DOM changes with enhanced tracking\n   */\n  startEnhancedObserving(onDOMChange: (change: EnhancedDOMChange) => void): void {\n    if (this.isObserving) return;\n\n    this.onDOMChange = onDOMChange;\n    this.observer = new MutationObserver(this.handleEnhancedMutations.bind(this));\n    \n    this.observer.observe(document, {\n      childList: true,\n      attributes: true,\n      characterData: true,\n      subtree: true,\n      attributeOldValue: true,\n      characterDataOldValue: true,\n      attributeFilter: undefined // Capture all attributes\n    });\n\n    // Observe resize changes\n    if (typeof ResizeObserver !== 'undefined') {\n      this.resizeObserver = new ResizeObserver(this.handleResizeChanges.bind(this));\n      this.resizeObserver.observe(document.documentElement);\n    }\n\n    this.isObserving = true;\n  }\n\n  /**\n   * Stop observing DOM changes\n   */\n  stopEnhancedObserving(): void {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = undefined;\n    }\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n      this.resizeObserver = undefined;\n    }\n    if (this.performanceObserver) {\n      this.performanceObserver.disconnect();\n    }\n    this.isObserving = false;\n    this.onDOMChange = undefined;\n  }\n\n  /**\n   * Serialize document with enhanced information\n   */\n  private serializeDocumentEnhanced(doc: Document): EnhancedSerializedNode[] {\n    const nodes: EnhancedSerializedNode[] = [];\n\n    // Add doctype\n    if (doc.doctype) {\n      nodes.push(this.serializeDoctype(doc.doctype));\n    }\n\n    // Serialize document element\n    if (doc.documentElement) {\n      const serialized = this.serializeNodeEnhanced(doc.documentElement);\n      if (serialized) {\n        nodes.push(serialized);\n      }\n    }\n\n    return nodes;\n  }\n\n  /**\n   * Serialize a single node with enhanced information\n   */\n  private serializeNodeEnhanced(node: Node): EnhancedSerializedNode | null {\n    if (this.shouldIgnoreNode(node)) {\n      return null;\n    }\n\n    const nodeId = this.getNodeId(node);\n    const serialized: EnhancedSerializedNode = {\n      id: nodeId,\n      type: this.getNodeType(node),\n      renderTime: performance.now()\n    };\n\n    switch (node.nodeType) {\n      case Node.ELEMENT_NODE:\n        const element = node as Element;\n        serialized.tagName = element.tagName.toLowerCase();\n        serialized.attributes = this.serializeAttributesEnhanced(element);\n        \n        // Capture computed styles\n        serialized.computedStyles = this.captureComputedStyles(element);\n        serialized.inlineStyles = this.captureInlineStyles(element);\n        \n        // Capture layout information\n        serialized.boundingRect = element.getBoundingClientRect();\n        serialized.visibility = this.captureVisibilityInfo(element);\n        \n        // Capture interaction state\n        serialized.interactionState = this.captureInteractionState(element);\n        \n        // Capture form element values\n        if (this.isFormElement(element)) {\n          serialized.inputValue = this.captureInputValue(element);\n          serialized.selectedOptions = this.captureSelectedOptions(element);\n        }\n        \n        // Capture scroll state\n        if (element.scrollWidth > element.clientWidth || element.scrollHeight > element.clientHeight) {\n          serialized.scrollPosition = {\n            x: element.scrollLeft,\n            y: element.scrollTop\n          };\n        }\n        \n        // Serialize children\n        serialized.children = this.serializeChildrenEnhanced(element);\n        break;\n\n      case Node.TEXT_NODE:\n        const textNode = node as Text;\n        serialized.textContent = this.shouldMaskText(textNode) \n          ? '[Masked Text]' \n          : textNode.textContent || '';\n        break;\n\n      case Node.COMMENT_NODE:\n        const commentNode = node as Comment;\n        serialized.textContent = commentNode.textContent || '';\n        break;\n\n      default:\n        return null;\n    }\n\n    return serialized;\n  }\n\n  /**\n   * Capture comprehensive computed styles for an element\n   */\n  private captureComputedStyles(element: Element): Record<string, string> {\n    // Check cache first\n    if (this.computedStyleCache.has(element)) {\n      return this.computedStyleCache.get(element)!;\n    }\n\n    const computedStyle = window.getComputedStyle(element);\n    const styles: Record<string, string> = {};\n\n    // Critical properties for layout and appearance\n    const criticalProperties = [\n      // Layout\n      'display', 'position', 'top', 'right', 'bottom', 'left', 'width', 'height',\n      'margin', 'margin-top', 'margin-right', 'margin-bottom', 'margin-left',\n      'padding', 'padding-top', 'padding-right', 'padding-bottom', 'padding-left',\n      'border', 'border-width', 'border-style', 'border-color', 'border-radius',\n      'box-sizing', 'overflow', 'overflow-x', 'overflow-y', 'z-index',\n      \n      // Flexbox\n      'flex', 'flex-direction', 'flex-wrap', 'justify-content', 'align-items', 'align-self',\n      'flex-grow', 'flex-shrink', 'flex-basis', 'order',\n      \n      // Grid\n      'grid', 'grid-template', 'grid-area', 'justify-self', 'align-self',\n      \n      // Typography\n      'font', 'font-family', 'font-size', 'font-weight', 'font-style', 'line-height',\n      'text-align', 'text-decoration', 'text-transform', 'letter-spacing', 'word-spacing',\n      'color', 'text-shadow',\n      \n      // Background\n      'background', 'background-color', 'background-image', 'background-size', \n      'background-position', 'background-repeat', 'background-attachment',\n      \n      // Effects\n      'opacity', 'visibility', 'transform', 'filter', 'backdrop-filter',\n      'box-shadow', 'clip-path',\n      \n      // Animation\n      'transition', 'animation', 'will-change',\n      \n      // Misc\n      'cursor', 'pointer-events', 'user-select', 'resize'\n    ];\n\n    criticalProperties.forEach(property => {\n      const value = computedStyle.getPropertyValue(property);\n      if (value && value !== 'initial' && value !== 'inherit') {\n        styles[property] = value;\n      }\n    });\n\n    // Cache the result\n    this.computedStyleCache.set(element, styles);\n    return styles;\n  }\n\n  /**\n   * Capture inline styles from the element's style attribute\n   */\n  private captureInlineStyles(element: Element): Record<string, string> {\n    const styles: Record<string, string> = {};\n    \n    if (element instanceof HTMLElement && element.style.length > 0) {\n      for (let i = 0; i < element.style.length; i++) {\n        const property = element.style.item(i);\n        const value = element.style.getPropertyValue(property);\n        const priority = element.style.getPropertyPriority(property);\n        \n        styles[property] = priority ? `${value} !${priority}` : value;\n      }\n    }\n\n    return styles;\n  }\n\n  /**\n   * Capture visibility and display information\n   */\n  private captureVisibilityInfo(element: Element): EnhancedSerializedNode['visibility'] {\n    const computedStyle = window.getComputedStyle(element);\n    const rect = element.getBoundingClientRect();\n    \n    return {\n      visible: rect.width > 0 && rect.height > 0 && computedStyle.visibility !== 'hidden',\n      opacity: parseFloat(computedStyle.opacity),\n      display: computedStyle.display,\n      zIndex: parseInt(computedStyle.zIndex) || 0\n    };\n  }\n\n  /**\n   * Capture interaction state (focus, hover, etc.)\n   */\n  private captureInteractionState(element: Element): EnhancedSerializedNode['interactionState'] {\n    const state: EnhancedSerializedNode['interactionState'] = {\n      focused: document.activeElement === element,\n      hovered: element.matches(':hover'),\n      pressed: element.matches(':active'),\n      disabled: element instanceof HTMLElement ? element.hasAttribute('disabled') : false\n    };\n\n    // Form-specific states\n    if (element instanceof HTMLInputElement) {\n      if (element.type === 'checkbox' || element.type === 'radio') {\n        state.checked = element.checked;\n      }\n    } else if (element instanceof HTMLSelectElement) {\n      state.selected = element.selectedIndex !== -1;\n    }\n\n    return state;\n  }\n\n  /**\n   * Capture form element values\n   */\n  private captureInputValue(element: Element): string | undefined {\n    if (element instanceof HTMLInputElement) {\n      // Don't capture sensitive inputs\n      if (element.type === 'password' || element.hasAttribute('data-sensitive')) {\n        return '[Masked]';\n      }\n      return element.value;\n    } else if (element instanceof HTMLTextAreaElement) {\n      return element.value;\n    } else if (element instanceof HTMLSelectElement) {\n      return element.value;\n    }\n    \n    return undefined;\n  }\n\n  /**\n   * Capture selected options for select elements\n   */\n  private captureSelectedOptions(element: Element): string[] | undefined {\n    if (element instanceof HTMLSelectElement && element.multiple) {\n      const selected = [];\n      for (let i = 0; i < element.options.length; i++) {\n        if (element.options[i].selected) {\n          selected.push(element.options[i].value);\n        }\n      }\n      return selected;\n    }\n    \n    return undefined;\n  }\n\n  /**\n   * Enhanced stylesheet serialization with processed rules\n   */\n  private serializeStylesheetsEnhanced(): EnhancedStylesheet[] {\n    const stylesheets: EnhancedStylesheet[] = [];\n\n    for (let i = 0; i < document.styleSheets.length; i++) {\n      try {\n        const sheet = document.styleSheets[i];\n        const enhanced = this.processStylesheet(sheet);\n        if (enhanced) {\n          stylesheets.push(enhanced);\n        }\n      } catch (error) {\n        // Handle CORS issues or other stylesheet access problems\n        console.warn('Could not access stylesheet:', error);\n      }\n    }\n\n    return stylesheets;\n  }\n\n  /**\n   * Process a stylesheet and extract enhanced information\n   */\n  private processStylesheet(sheet: CSSStyleSheet): EnhancedStylesheet | null {\n    try {\n      const rules: ProcessedCSSRule[] = [];\n      \n      if (sheet.cssRules) {\n        for (let i = 0; i < sheet.cssRules.length; i++) {\n          const rule = sheet.cssRules[i];\n          const processed = this.processCSSRule(rule);\n          if (processed) {\n            rules.push(processed);\n          }\n        }\n      }\n\n      return {\n        href: sheet.href || undefined,\n        cssText: this.extractCSSText(sheet),\n        disabled: sheet.disabled,\n        media: sheet.media.mediaText,\n        title: sheet.title || undefined,\n        type: sheet.type,\n        origin: 'author', // Simplified for now\n        rules,\n        size: this.estimateStylesheetSize(sheet)\n      };\n    } catch (error) {\n      console.warn('Error processing stylesheet:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Process individual CSS rules\n   */\n  private processCSSRule(rule: CSSRule): ProcessedCSSRule | null {\n    const processed: ProcessedCSSRule = {\n      type: rule.type,\n      cssText: rule.cssText\n    };\n\n    if (rule instanceof CSSStyleRule) {\n      processed.selectorText = rule.selectorText;\n      processed.declarations = this.extractDeclarations(rule.style);\n      processed.specificity = this.calculateSpecificity(rule.selectorText);\n    } else if (rule instanceof CSSMediaRule) {\n      processed.media = rule.media.mediaText;\n    }\n\n    return processed;\n  }\n\n  /**\n   * Extract CSS declarations from a CSSStyleDeclaration\n   */\n  private extractDeclarations(style: CSSStyleDeclaration): CSSDeclaration[] {\n    const declarations: CSSDeclaration[] = [];\n    \n    for (let i = 0; i < style.length; i++) {\n      const property = style.item(i);\n      const value = style.getPropertyValue(property);\n      const priority = style.getPropertyPriority(property);\n      \n      declarations.push({\n        property,\n        value,\n        priority,\n        important: priority === 'important'\n      });\n    }\n\n    return declarations;\n  }\n\n  /**\n   * Calculate CSS selector specificity\n   */\n  private calculateSpecificity(selector: string): number {\n    // Simplified specificity calculation\n    const ids = (selector.match(/#[^\\s\\+>~\\.\\[:]+/g) || []).length;\n    const classes = (selector.match(/\\.[^\\s\\+>~\\.\\[:]+/g) || []).length;\n    const attributes = (selector.match(/\\[[^\\]]+\\]/g) || []).length;\n    const pseudoClasses = (selector.match(/:[^\\s\\+>~\\.\\[:]+/g) || []).length;\n    const elements = (selector.match(/[^\\s\\+>~\\.\\[:]+/g) || []).length;\n    \n    return ids * 100 + (classes + attributes + pseudoClasses) * 10 + elements;\n  }\n\n  /**\n   * Enhanced resource serialization\n   */\n  private serializeResourcesEnhanced(): EnhancedResource[] {\n    const resources: EnhancedResource[] = [];\n    const processedUrls = new Set<string>();\n\n    // Process images\n    document.querySelectorAll('img').forEach(img => {\n      if (!processedUrls.has(img.src)) {\n        processedUrls.add(img.src);\n        resources.push(this.createImageResource(img));\n      }\n    });\n\n    // Process fonts (from CSS)\n    // This is complex - would need to parse CSS for @font-face rules\n\n    // Process performance entries for additional resources\n    if ('performance' in window && performance.getEntriesByType) {\n      const resourceEntries = performance.getEntriesByType('resource') as PerformanceResourceTiming[];\n      \n      resourceEntries.forEach(entry => {\n        if (!processedUrls.has(entry.name)) {\n          processedUrls.add(entry.name);\n          resources.push(this.createResourceFromPerformanceEntry(entry));\n        }\n      });\n    }\n\n    return resources;\n  }\n\n  /**\n   * Create enhanced resource info from image element\n   */\n  private createImageResource(img: HTMLImageElement): EnhancedResource {\n    return {\n      url: img.src,\n      type: 'image',\n      dimensions: {\n        width: img.naturalWidth,\n        height: img.naturalHeight\n      },\n      size: undefined, // Would need to be calculated\n      failed: !img.complete || img.naturalWidth === 0\n    };\n  }\n\n  /**\n   * Create resource from performance entry\n   */\n  private createResourceFromPerformanceEntry(entry: PerformanceResourceTiming): EnhancedResource {\n    const resource: EnhancedResource = {\n      url: entry.name,\n      type: this.inferResourceType(entry.name),\n      size: entry.transferSize,\n      loadTime: entry.responseEnd - entry.requestStart,\n      fromCache: entry.transferSize === 0 && entry.decodedBodySize > 0\n    };\n\n    return resource;\n  }\n\n  /**\n   * Enhanced mutation handling\n   */\n  private handleEnhancedMutations(mutations: MutationRecord[]): void {\n    mutations.forEach(mutation => {\n      const change: EnhancedDOMChange = {\n        timestamp: Date.now(),\n        type: mutation.type as any,\n        target: this.getNodeId(mutation.target),\n        oldValue: mutation.oldValue || undefined,\n        renderingTime: performance.now()\n      };\n\n      // Enhanced processing based on mutation type\n      switch (mutation.type) {\n        case 'childList':\n          if (mutation.addedNodes.length > 0) {\n            change.addedNodes = Array.from(mutation.addedNodes)\n              .map(node => this.serializeNodeEnhanced(node))\n              .filter((node): node is EnhancedSerializedNode => node !== null);\n          }\n          if (mutation.removedNodes.length > 0) {\n            change.removedNodes = Array.from(mutation.removedNodes)\n              .map(node => this.getNodeId(node))\n              .filter(id => id !== undefined);\n          }\n          break;\n          \n        case 'attributes':\n          change.attributeName = mutation.attributeName || undefined;\n          if (mutation.target instanceof Element) {\n            change.attributeValue = mutation.target.getAttribute(mutation.attributeName!) || undefined;\n            \n            // Special handling for class and style changes\n            if (mutation.attributeName === 'class') {\n              change.classChanges = this.analyzeClassChanges(mutation.oldValue, change.attributeValue);\n            } else if (mutation.attributeName === 'style') {\n              change.styleChanges = this.analyzeStyleChanges(mutation.target as Element);\n            }\n          }\n          break;\n      }\n\n      // Analyze visual impact\n      change.visualChange = this.analyzeVisualImpact(mutation);\n      \n      this.onDOMChange?.(change);\n    });\n  }\n\n  // ... Additional helper methods for performance tracking, style analysis, etc.\n\n  private setupPerformanceObserver(): void {\n    if (typeof PerformanceObserver !== 'undefined') {\n      this.performanceObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        entries.forEach(entry => {\n          if (entry.entryType === 'layout-shift') {\n            this.layoutShiftEntries.push(entry as any);\n          }\n        });\n      });\n      \n      this.performanceObserver.observe({ \n        entryTypes: ['layout-shift', 'paint', 'measure'] \n      });\n    }\n  }\n\n  private setupStylesheetTracking(): void {\n    // Monitor for dynamically added stylesheets\n    const observer = new MutationObserver((mutations) => {\n      mutations.forEach(mutation => {\n        mutation.addedNodes.forEach(node => {\n          if (node instanceof HTMLLinkElement && node.rel === 'stylesheet') {\n            // Track new stylesheet\n            console.log('New stylesheet added:', node.href);\n          } else if (node instanceof HTMLStyleElement) {\n            // Track new style element\n            console.log('New style element added');\n          }\n        });\n      });\n    });\n\n    observer.observe(document.head, { childList: true });\n  }\n\n  private capturePerformanceMetrics() {\n    if (!('performance' in window)) return undefined;\n\n    const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;\n    const paint = performance.getEntriesByType('paint');\n    \n    return {\n      domContentLoaded: navigation?.domContentLoadedEventEnd || 0,\n      loadComplete: navigation?.loadEventEnd || 0,\n      paintTimings: paint.reduce((acc, entry) => {\n        acc[entry.name] = entry.startTime;\n        return acc;\n      }, {} as Record<string, number>),\n      layoutShifts: [...this.layoutShiftEntries],\n      memoryUsage: (performance as any).memory?.usedJSHeapSize || 0\n    };\n  }\n\n  private captureEnvironmentInfo(): {\n    userAgent: string;\n    language: string;\n    timezone: string;\n    colorScheme: 'light' | 'dark';\n    reducedMotion: boolean;\n  } {\n    return {\n      userAgent: navigator.userAgent,\n      language: navigator.language,\n      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n      colorScheme: window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' as const : 'light' as const,\n      reducedMotion: window.matchMedia('(prefers-reduced-motion: reduce)').matches\n    };\n  }\n\n  // ... More helper methods would be implemented here\n\n  private shouldIgnoreNode(_node: Node): boolean {\n    // Enhanced node filtering logic\n    return false;\n  }\n\n  private getNodeType(node: Node): EnhancedSerializedNode['type'] {\n    switch (node.nodeType) {\n      case Node.ELEMENT_NODE: return 'element';\n      case Node.TEXT_NODE: return 'text';\n      case Node.COMMENT_NODE: return 'comment';\n      case Node.DOCUMENT_NODE: return 'document';\n      case Node.DOCUMENT_TYPE_NODE: return 'doctype';\n      default: return 'element';\n    }\n  }\n\n  private getNodeId(node: Node): number {\n    if (!this.nodeIdMap.has(node)) {\n      const id = this.nextNodeId++;\n      this.nodeIdMap.set(node, id);\n      this.nodeMap.set(id, node);\n    }\n    return this.nodeIdMap.get(node)!;\n  }\n\n  private serializeDoctype(doctype: DocumentType): EnhancedSerializedNode {\n    return {\n      id: this.getNodeId(doctype),\n      type: 'doctype',\n      tagName: 'DOCTYPE',\n      attributes: {\n        name: doctype.name,\n        publicId: doctype.publicId,\n        systemId: doctype.systemId\n      }\n    };\n  }\n\n  private serializeAttributesEnhanced(element: Element): Record<string, string> {\n    const attributes: Record<string, string> = {};\n    \n    for (let i = 0; i < element.attributes.length; i++) {\n      const attr = element.attributes[i];\n      const name = attr.name.toLowerCase();\n      \n      if (this.shouldIgnoreAttribute(name, attr.value)) {\n        continue;\n      }\n\n      if (this.shouldMaskAttribute(name, element)) {\n        attributes[name] = '[Masked]';\n      } else {\n        attributes[name] = attr.value;\n      }\n    }\n\n    return attributes;\n  }\n\n  private serializeChildrenEnhanced(element: Element): EnhancedSerializedNode[] {\n    const children: EnhancedSerializedNode[] = [];\n    \n    for (let i = 0; i < element.childNodes.length; i++) {\n      const child = element.childNodes[i];\n      const serialized = this.serializeNodeEnhanced(child);\n      \n      if (serialized) {\n        children.push(serialized);\n      }\n    }\n\n    return children;\n  }\n\n  private shouldMaskText(textNode: Text): boolean {\n    const parent = textNode.parentElement;\n    if (!parent) return false;\n    \n    const tagName = parent.tagName?.toLowerCase();\n    const type = (parent as HTMLInputElement).type?.toLowerCase();\n    \n    return (tagName === 'input' && type === 'password') ||\n           parent.hasAttribute('data-sensitive') ||\n           parent.closest('[data-sensitive]') !== null;\n  }\n\n  private isFormElement(element: Element): boolean {\n    const tagName = element.tagName.toLowerCase();\n    return ['input', 'textarea', 'select'].includes(tagName);\n  }\n\n  private shouldIgnoreAttribute(name: string, value: string): boolean {\n    // Ignore script event handlers and other potentially sensitive attributes\n    return name.startsWith('on') || name === 'style' && value.length > 1000;\n  }\n\n  private shouldMaskAttribute(name: string, element: Element): boolean {\n    return (name === 'value' && (element as HTMLInputElement).type === 'password') ||\n           element.hasAttribute('data-sensitive');\n  }\n\n  private handleResizeChanges(entries: ResizeObserverEntry[]): void {\n    // Handle viewport or element resize changes\n    entries.forEach(entry => {\n      const change: EnhancedDOMChange = {\n        timestamp: Date.now(),\n        type: 'attributes',\n        target: this.getNodeId(entry.target),\n        attributeName: 'resize',\n        renderingTime: performance.now(),\n        visualChange: {\n          affectedArea: entry.contentRect,\n          significance: 'moderate'\n        }\n      };\n      \n      this.onDOMChange?.(change);\n    });\n  }\n\n  private analyzeClassChanges(oldValue: string | null, newValue: string | undefined) {\n    const oldClasses = oldValue ? oldValue.split(/\\s+/).filter(Boolean) : [];\n    const newClasses = newValue ? newValue.split(/\\s+/).filter(Boolean) : [];\n    \n    const added = newClasses.filter(cls => !oldClasses.includes(cls));\n    const removed = oldClasses.filter(cls => !newClasses.includes(cls));\n    \n    return { added, removed };\n  }\n\n  private analyzeStyleChanges(_element: Element) {\n    // This would compare previous and current computed styles\n    // For now, return empty array\n    return [];\n  }\n\n  private analyzeVisualImpact(mutation: MutationRecord): { affectedArea: DOMRect; significance: 'minor' | 'moderate' | 'major' } | undefined {\n    // Analyze the visual significance of the mutation\n    if (mutation.target instanceof Element) {\n      const rect = mutation.target.getBoundingClientRect();\n      return {\n        affectedArea: rect,\n        significance: rect.width * rect.height > 10000 ? 'major' : \n                     rect.width * rect.height > 1000 ? 'moderate' : 'minor'\n      };\n    }\n    return undefined;\n  }\n\n  private extractCSSText(sheet: CSSStyleSheet): string {\n    try {\n      if (sheet.cssRules) {\n        return Array.from(sheet.cssRules).map(rule => rule.cssText).join('\\n');\n      }\n    } catch (error) {\n      // CORS or other access issues\n    }\n    return '';\n  }\n\n  private estimateStylesheetSize(sheet: CSSStyleSheet): number {\n    return this.extractCSSText(sheet).length;\n  }\n\n  private inferResourceType(url: string): EnhancedResource['type'] {\n    const extension = url.split('.').pop()?.toLowerCase();\n    \n    switch (extension) {\n      case 'jpg':\n      case 'jpeg':\n      case 'png':\n      case 'gif':\n      case 'svg':\n      case 'webp':\n        return 'image';\n      case 'woff':\n      case 'woff2':\n      case 'ttf':\n      case 'otf':\n        return 'font';\n      case 'mp4':\n      case 'webm':\n      case 'ogg':\n        return 'media';\n      case 'js':\n        return 'script';\n      case 'css':\n        return 'stylesheet';\n      default:\n        return 'fetch';\n    }\n  }\n}","import { SessionEvent } from './types';\n\nexport interface ConsoleLogEntry {\n  id: string;\n  timestamp: number;\n  level: 'log' | 'info' | 'warn' | 'error' | 'debug' | 'trace';\n  args: any[];\n  stack?: string;\n  url?: string;\n  lineNumber?: number;\n  columnNumber?: number;\n}\n\nexport interface ConsoleRecorderConfig {\n  maxEntries: number;\n  captureStackTrace: boolean;\n  serializeObjects: boolean;\n  maxObjectDepth: number;\n  maxStringLength: number;\n  ignoredLevels: string[];\n}\n\nexport class ConsoleRecorder {\n  private originalMethods: Record<string, Function> = {};\n  private entries: ConsoleLogEntry[] = [];\n  private config: ConsoleRecorderConfig;\n  private isRecording = false;\n  private sessionId: string;\n\n  constructor(sessionId: string, config: Partial<ConsoleRecorderConfig> = {}) {\n    this.sessionId = sessionId;\n    this.config = {\n      maxEntries: 1000,\n      captureStackTrace: true,\n      serializeObjects: true,\n      maxObjectDepth: 3,\n      maxStringLength: 10000,\n      ignoredLevels: [],\n      ...config\n    };\n  }\n\n  start(): void {\n    if (this.isRecording) return;\n\n    const levels: Array<keyof Console> = ['log', 'info', 'warn', 'error', 'debug', 'trace'];\n    \n    levels.forEach(level => {\n      if (this.config.ignoredLevels.includes(level)) return;\n      \n      const originalMethod = console[level];\n      this.originalMethods[level] = originalMethod;\n      \n      (console as any)[level] = (...args: any[]) => {\n        // Call original method first\n        (originalMethod as any).apply(console, args);\n        \n        // Record the log entry\n        this.recordEntry(level as ConsoleLogEntry['level'], args);\n      };\n    });\n\n    this.isRecording = true;\n  }\n\n  stop(): void {\n    if (!this.isRecording) return;\n\n    // Restore original console methods\n    Object.entries(this.originalMethods).forEach(([level, method]) => {\n      (console as any)[level] = method;\n    });\n\n    this.originalMethods = {};\n    this.isRecording = false;\n  }\n\n  private recordEntry(level: ConsoleLogEntry['level'], args: any[]): void {\n    try {\n      const entry: ConsoleLogEntry = {\n        id: this.generateId(),\n        timestamp: Date.now(),\n        level,\n        args: this.serializeArgs(args)\n      };\n\n      // Capture stack trace for errors and warnings\n      if ((level === 'error' || level === 'warn') && this.config.captureStackTrace) {\n        const error = new Error();\n        if (error.stack) {\n          entry.stack = this.cleanStackTrace(error.stack);\n        }\n      }\n\n      // Add source location if available\n      if (level === 'error' && args[0] instanceof Error) {\n        const error = args[0] as Error;\n        // Try to extract location from error stack\n        const stackLines = error.stack?.split('\\n') || [];\n        const sourceLine = stackLines.find(line => \n          line.includes('.js:') || line.includes('.ts:') || line.includes('.tsx:')\n        );\n        \n        if (sourceLine) {\n          const match = sourceLine.match(/([^/]+):(\\d+):(\\d+)/);\n          if (match) {\n            entry.url = match[1];\n            entry.lineNumber = parseInt(match[2]);\n            entry.columnNumber = parseInt(match[3]);\n          }\n        }\n      }\n\n      this.addEntry(entry);\n    } catch (error) {\n      // Fail silently to avoid infinite loops\n      this.originalMethods.warn?.call(console, 'ConsoleRecorder error:', error);\n    }\n  }\n\n  private serializeArgs(args: any[]): any[] {\n    return args.map(arg => this.serializeValue(arg, 0));\n  }\n\n  private serializeValue(value: any, depth: number): any {\n    if (depth > this.config.maxObjectDepth) {\n      return '[Object too deep]';\n    }\n\n    if (value === null || value === undefined) {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      return value.length > this.config.maxStringLength \n        ? value.substring(0, this.config.maxStringLength) + '...'\n        : value;\n    }\n\n    if (typeof value === 'number' || typeof value === 'boolean') {\n      return value;\n    }\n\n    if (typeof value === 'function') {\n      return `[Function: ${value.name || 'anonymous'}]`;\n    }\n\n    if (value instanceof Error) {\n      return {\n        name: value.name,\n        message: value.message,\n        stack: this.config.captureStackTrace ? this.cleanStackTrace(value.stack || '') : undefined\n      };\n    }\n\n    if (value instanceof Date) {\n      return {\n        __type: 'Date',\n        value: value.toISOString()\n      };\n    }\n\n    if (value instanceof RegExp) {\n      return {\n        __type: 'RegExp',\n        value: value.toString()\n      };\n    }\n\n    if (Array.isArray(value)) {\n      if (!this.config.serializeObjects) return '[Array]';\n      \n      return value.slice(0, 100).map(item => this.serializeValue(item, depth + 1));\n    }\n\n    if (typeof value === 'object') {\n      if (!this.config.serializeObjects) return '[Object]';\n      \n      try {\n        const serialized: Record<string, any> = {};\n        const keys = Object.keys(value).slice(0, 50); // Limit keys\n        \n        for (const key of keys) {\n          try {\n            serialized[key] = this.serializeValue(value[key], depth + 1);\n          } catch {\n            serialized[key] = '[Unserializable]';\n          }\n        }\n        \n        if (Object.keys(value).length > 50) {\n          serialized['...'] = `[${Object.keys(value).length - 50} more keys]`;\n        }\n        \n        return serialized;\n      } catch {\n        return '[Unserializable Object]';\n      }\n    }\n\n    return String(value);\n  }\n\n  private cleanStackTrace(stack: string): string {\n    return stack\n      .split('\\n')\n      .filter(line => \n        !line.includes('console-recorder.ts') && \n        !line.includes('ConsoleRecorder')\n      )\n      .slice(0, 10) // Limit stack depth\n      .join('\\n');\n  }\n\n  private addEntry(entry: ConsoleLogEntry): void {\n    this.entries.push(entry);\n    \n    // Maintain max entries limit\n    if (this.entries.length > this.config.maxEntries) {\n      this.entries = this.entries.slice(-this.config.maxEntries * 0.8);\n    }\n  }\n\n  private generateId(): string {\n    return `console-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  getEntries(fromTimestamp?: number, toTimestamp?: number): ConsoleLogEntry[] {\n    let filtered = this.entries;\n    \n    if (fromTimestamp) {\n      filtered = filtered.filter(entry => entry.timestamp >= fromTimestamp);\n    }\n    \n    if (toTimestamp) {\n      filtered = filtered.filter(entry => entry.timestamp <= toTimestamp);\n    }\n    \n    return [...filtered];\n  }\n\n  getEntriesByLevel(level: ConsoleLogEntry['level']): ConsoleLogEntry[] {\n    return this.entries.filter(entry => entry.level === level);\n  }\n\n  clear(): void {\n    this.entries = [];\n  }\n\n  // Convert console entries to session events format\n  toSessionEvents(): SessionEvent[] {\n    return this.entries.map(entry => ({\n      sessionId: this.sessionId,\n      type: 'console',\n      data: {\n        level: entry.level,\n        args: entry.args,\n        stack: entry.stack,\n        url: entry.url,\n        lineNumber: entry.lineNumber,\n        columnNumber: entry.columnNumber,\n        consoleId: entry.id,\n        originalUrl: entry.url || window.location.href,\n        userAgent: navigator.userAgent\n      },\n      timestamp: entry.timestamp\n    }));\n  }\n\n  // Export for analysis\n  exportData(): {\n    sessionId: string;\n    config: ConsoleRecorderConfig;\n    entries: ConsoleLogEntry[];\n    stats: {\n      totalEntries: number;\n      levelCounts: Record<string, number>;\n      errorCount: number;\n      warningCount: number;\n      timeRange: { start: number; end: number };\n    };\n  } {\n    const levelCounts: Record<string, number> = {};\n    let minTime = Infinity;\n    let maxTime = -Infinity;\n\n    this.entries.forEach(entry => {\n      levelCounts[entry.level] = (levelCounts[entry.level] || 0) + 1;\n      minTime = Math.min(minTime, entry.timestamp);\n      maxTime = Math.max(maxTime, entry.timestamp);\n    });\n\n    return {\n      sessionId: this.sessionId,\n      config: this.config,\n      entries: [...this.entries],\n      stats: {\n        totalEntries: this.entries.length,\n        levelCounts,\n        errorCount: levelCounts.error || 0,\n        warningCount: levelCounts.warn || 0,\n        timeRange: {\n          start: minTime === Infinity ? 0 : minTime,\n          end: maxTime === -Infinity ? 0 : maxTime\n        }\n      }\n    };\n  }\n\n  // Generate insights from console logs\n  generateInsights(): {\n    errorPatterns: Array<{ pattern: string; count: number; examples: ConsoleLogEntry[] }>;\n    performanceIssues: Array<{ type: string; severity: 'low' | 'medium' | 'high'; details: string }>;\n    recommendations: string[];\n  } {\n    const errorPatterns = this.findErrorPatterns();\n    const performanceIssues = this.detectPerformanceIssues();\n    const recommendations = this.generateRecommendations();\n\n    return {\n      errorPatterns,\n      performanceIssues,\n      recommendations\n    };\n  }\n\n  private findErrorPatterns(): Array<{ pattern: string; count: number; examples: ConsoleLogEntry[] }> {\n    const errors = this.entries.filter(entry => entry.level === 'error');\n    const patterns: Record<string, ConsoleLogEntry[]> = {};\n\n    errors.forEach(error => {\n      let pattern = 'Unknown Error';\n      \n      if (error.args.length > 0) {\n        const firstArg = error.args[0];\n        if (typeof firstArg === 'string') {\n          // Extract error pattern from message\n          pattern = firstArg\n            .replace(/\\d+/g, 'N') // Replace numbers with N\n            .replace(/[\"'][^\"']*[\"']/g, 'STRING') // Replace strings with STRING\n            .replace(/\\b\\w+@\\w+\\.\\w+/g, 'EMAIL') // Replace emails\n            .replace(/https?:\\/\\/[^\\s]+/g, 'URL') // Replace URLs\n            .substring(0, 100);\n        } else if (typeof firstArg === 'object' && firstArg.name) {\n          pattern = `${firstArg.name}: ${firstArg.message}`.substring(0, 100);\n        }\n      }\n\n      if (!patterns[pattern]) {\n        patterns[pattern] = [];\n      }\n      patterns[pattern].push(error);\n    });\n\n    return Object.entries(patterns)\n      .sort(([, a], [, b]) => b.length - a.length)\n      .slice(0, 10)\n      .map(([pattern, examples]) => ({\n        pattern,\n        count: examples.length,\n        examples: examples.slice(0, 3) // Show first 3 examples\n      }));\n  }\n\n  private detectPerformanceIssues(): Array<{ type: string; severity: 'low' | 'medium' | 'high'; details: string }> {\n    const issues: Array<{ type: string; severity: 'low' | 'medium' | 'high'; details: string }> = [];\n    \n    // Check for excessive logging\n    const recentEntries = this.entries.filter(entry => \n      entry.timestamp > Date.now() - 60000 // Last minute\n    );\n    \n    if (recentEntries.length > 100) {\n      issues.push({\n        type: 'Excessive Logging',\n        severity: 'medium',\n        details: `${recentEntries.length} console entries in the last minute may impact performance`\n      });\n    }\n\n    // Check for repeated errors\n    const errorCounts: Record<string, number> = {};\n    this.entries\n      .filter(entry => entry.level === 'error')\n      .forEach(entry => {\n        const key = JSON.stringify(entry.args);\n        errorCounts[key] = (errorCounts[key] || 0) + 1;\n      });\n\n    Object.entries(errorCounts).forEach(([, count]) => {\n      if (count > 10) {\n        issues.push({\n          type: 'Repeated Error',\n          severity: count > 50 ? 'high' : 'medium',\n          details: `Same error occurred ${count} times`\n        });\n      }\n    });\n\n    // Check for potential memory leaks (objects not being cleaned up)\n    const objectLogs = this.entries.filter(entry => \n      entry.args.some(arg => \n        typeof arg === 'object' && \n        arg !== null && \n        !Array.isArray(arg)\n      )\n    );\n    \n    if (objectLogs.length > this.entries.length * 0.5) {\n      issues.push({\n        type: 'Object Logging',\n        severity: 'low',\n        details: 'High percentage of object logging may indicate memory leaks'\n      });\n    }\n\n    return issues;\n  }\n\n  private generateRecommendations(): string[] {\n    const recommendations: string[] = [];\n    const stats = this.exportData().stats;\n\n    if (stats.errorCount > 0) {\n      recommendations.push(\n        `Found ${stats.errorCount} console errors. Review error patterns and fix underlying issues.`\n      );\n    }\n\n    if (stats.warningCount > stats.errorCount * 2) {\n      recommendations.push(\n        'High warning-to-error ratio suggests proactive error handling could prevent issues.'\n      );\n    }\n\n    if (stats.totalEntries > 500) {\n      recommendations.push(\n        'Consider reducing console logging in production to improve performance.'\n      );\n    }\n\n    if (stats.levelCounts.debug && stats.levelCounts.debug > 100) {\n      recommendations.push(\n        'Debug logs should be disabled in production environments.'\n      );\n    }\n\n    if (recommendations.length === 0) {\n      recommendations.push('Console logging patterns look healthy.');\n    }\n\n    return recommendations;\n  }\n}","import { SessionEvent } from './types';\n\nexport interface HeatmapData {\n  x: number;\n  y: number;\n  intensity: number;\n  event_type: 'click' | 'move' | 'scroll' | 'hover';\n  timestamp: number;\n}\n\nexport interface HeatmapConfig {\n  radius: number;\n  maxIntensity: number;\n  gradient: Record<string, string>;\n  blur: number;\n  minOpacity: number;\n  maxOpacity: number;\n}\n\nexport class HeatmapGenerator {\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n  private config: HeatmapConfig;\n  private data: HeatmapData[] = [];\n\n  constructor(container: HTMLElement, config: Partial<HeatmapConfig> = {}) {\n    this.config = {\n      radius: 20,\n      maxIntensity: 100,\n      gradient: {\n        0.4: 'blue',\n        0.6: 'cyan',\n        0.7: 'lime',\n        0.8: 'yellow',\n        1.0: 'red'\n      },\n      blur: 15,\n      minOpacity: 0,\n      maxOpacity: 0.6,\n      ...config\n    };\n\n    this.canvas = document.createElement('canvas');\n    this.canvas.style.position = 'absolute';\n    this.canvas.style.top = '0';\n    this.canvas.style.left = '0';\n    this.canvas.style.pointerEvents = 'none';\n    this.canvas.style.zIndex = '9999';\n    \n    container.appendChild(this.canvas);\n    \n    const ctx = this.canvas.getContext('2d');\n    if (!ctx) {\n      throw new Error('Failed to get canvas context');\n    }\n    this.ctx = ctx;\n\n    this.resizeCanvas();\n    window.addEventListener('resize', () => this.resizeCanvas());\n  }\n\n  private resizeCanvas(): void {\n    const rect = this.canvas.parentElement!.getBoundingClientRect();\n    this.canvas.width = rect.width;\n    this.canvas.height = rect.height;\n    this.canvas.style.width = rect.width + 'px';\n    this.canvas.style.height = rect.height + 'px';\n  }\n\n  addDataPoint(x: number, y: number, intensity: number, eventType: HeatmapData['event_type']): void {\n    this.data.push({\n      x,\n      y,\n      intensity,\n      event_type: eventType,\n      timestamp: Date.now()\n    });\n    \n    // Limit data points to prevent memory issues\n    if (this.data.length > 10000) {\n      this.data = this.data.slice(-8000);\n    }\n  }\n\n  generateFromEvents(events: SessionEvent[]): void {\n    this.data = [];\n    \n    events.forEach(event => {\n      if (event.type === 'click' && event.data?.x && event.data?.y) {\n        this.addDataPoint(\n          event.data.x,\n          event.data.y,\n          10,\n          'click'\n        );\n      } else if (event.type === 'mousemove' && event.data?.x && event.data?.y) {\n        this.addDataPoint(\n          event.data.x,\n          event.data.y,\n          2,\n          'move'\n        );\n      } else if (event.type === 'scroll' && event.data?.scrollX !== undefined && event.data?.scrollY !== undefined) {\n        // Convert scroll position to viewport coordinates\n        this.addDataPoint(\n          event.data.scrollX || 0,\n          event.data.scrollY || 0,\n          5,\n          'scroll'\n        );\n      }\n    });\n  }\n\n  render(filter?: HeatmapData['event_type'][]): void {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    \n    if (this.data.length === 0) return;\n\n    const filteredData = filter \n      ? this.data.filter(d => filter.includes(d.event_type))\n      : this.data;\n\n    // Create intensity map\n    const intensityData = this.createIntensityMap(filteredData);\n    \n    // Create gradient\n    const gradient = this.createGradient();\n    \n    // Render heatmap\n    this.renderHeatmap(intensityData, gradient);\n  }\n\n  private createIntensityMap(data: HeatmapData[]): ImageData {\n    const shadowCanvas = document.createElement('canvas');\n    shadowCanvas.width = this.canvas.width;\n    shadowCanvas.height = this.canvas.height;\n    const shadowCtx = shadowCanvas.getContext('2d')!;\n\n    // Draw intensity points\n    data.forEach(point => {\n      const radius = this.config.radius;\n      const gradient = shadowCtx.createRadialGradient(\n        point.x, point.y, 0,\n        point.x, point.y, radius\n      );\n\n      const alpha = Math.min(point.intensity / this.config.maxIntensity, 1);\n      gradient.addColorStop(0, `rgba(0, 0, 0, ${alpha})`);\n      gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\n\n      shadowCtx.fillStyle = gradient;\n      shadowCtx.fillRect(\n        point.x - radius,\n        point.y - radius,\n        radius * 2,\n        radius * 2\n      );\n    });\n\n    // Apply blur\n    shadowCtx.filter = `blur(${this.config.blur}px)`;\n    shadowCtx.drawImage(shadowCanvas, 0, 0);\n\n    return shadowCtx.getImageData(0, 0, shadowCanvas.width, shadowCanvas.height);\n  }\n\n  private createGradient(): ImageData {\n    const gradientCanvas = document.createElement('canvas');\n    gradientCanvas.width = 256;\n    gradientCanvas.height = 1;\n    const gradientCtx = gradientCanvas.getContext('2d')!;\n\n    const gradient = gradientCtx.createLinearGradient(0, 0, 256, 0);\n    Object.entries(this.config.gradient).forEach(([stop, color]) => {\n      gradient.addColorStop(parseFloat(stop), color);\n    });\n\n    gradientCtx.fillStyle = gradient;\n    gradientCtx.fillRect(0, 0, 256, 1);\n\n    return gradientCtx.getImageData(0, 0, 256, 1);\n  }\n\n  private renderHeatmap(intensityData: ImageData, gradientData: ImageData): void {\n    const output = this.ctx.createImageData(intensityData.width, intensityData.height);\n    \n    for (let i = 0; i < intensityData.data.length; i += 4) {\n      const alpha = intensityData.data[i + 3];\n      \n      if (alpha > 0) {\n        const gradientIndex = Math.floor((alpha / 255) * 255) * 4;\n        \n        output.data[i] = gradientData.data[gradientIndex];     // R\n        output.data[i + 1] = gradientData.data[gradientIndex + 1]; // G\n        output.data[i + 2] = gradientData.data[gradientIndex + 2]; // B\n        output.data[i + 3] = Math.floor(alpha * this.config.maxOpacity); // A\n      }\n    }\n\n    this.ctx.putImageData(output, 0, 0);\n  }\n\n  clear(): void {\n    this.data = [];\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n\n  destroy(): void {\n    this.clear();\n    if (this.canvas.parentElement) {\n      this.canvas.parentElement.removeChild(this.canvas);\n    }\n    window.removeEventListener('resize', () => this.resizeCanvas());\n  }\n\n  // Export heatmap data for analysis\n  exportData(): {\n    config: HeatmapConfig;\n    data: HeatmapData[];\n    stats: {\n      totalEvents: number;\n      eventTypes: Record<string, number>;\n      timeRange: { start: number; end: number };\n      bounds: { minX: number; maxX: number; minY: number; maxY: number };\n    };\n  } {\n    const eventTypes: Record<string, number> = {};\n    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;\n    let minTime = Infinity, maxTime = -Infinity;\n\n    this.data.forEach(point => {\n      eventTypes[point.event_type] = (eventTypes[point.event_type] || 0) + 1;\n      \n      minX = Math.min(minX, point.x);\n      maxX = Math.max(maxX, point.x);\n      minY = Math.min(minY, point.y);\n      maxY = Math.max(maxY, point.y);\n      \n      minTime = Math.min(minTime, point.timestamp);\n      maxTime = Math.max(maxTime, point.timestamp);\n    });\n\n    return {\n      config: this.config,\n      data: [...this.data],\n      stats: {\n        totalEvents: this.data.length,\n        eventTypes,\n        timeRange: { start: minTime, end: maxTime },\n        bounds: { minX, maxX, minY, maxY }\n      }\n    };\n  }\n\n  // Generate insights from heatmap data\n  generateInsights(): {\n    hotSpots: Array<{ x: number; y: number; intensity: number; radius: number }>;\n    clickPatterns: Array<{ pattern: string; frequency: number }>;\n    userBehavior: {\n      mostActiveArea: { x: number; y: number; width: number; height: number };\n      averageClicksPerSession: number;\n      scrollDepth: number;\n      engagementScore: number;\n    };\n  } {\n    // Find hot spots using clustering\n    const hotSpots = this.findHotSpots();\n    \n    // Analyze click patterns\n    const clickPatterns = this.analyzeClickPatterns();\n    \n    // Generate user behavior insights\n    const userBehavior = this.analyzeUserBehavior();\n\n    return {\n      hotSpots,\n      clickPatterns,\n      userBehavior\n    };\n  }\n\n  private findHotSpots(): Array<{ x: number; y: number; intensity: number; radius: number }> {\n    const clusters: Array<{ x: number; y: number; intensity: number; count: number }> = [];\n    const clusterRadius = this.config.radius * 2;\n\n    this.data.forEach(point => {\n      let foundCluster = false;\n      \n      for (const cluster of clusters) {\n        const distance = Math.sqrt(\n          Math.pow(point.x - cluster.x, 2) + Math.pow(point.y - cluster.y, 2)\n        );\n        \n        if (distance <= clusterRadius) {\n          // Add to existing cluster\n          cluster.x = (cluster.x * cluster.count + point.x) / (cluster.count + 1);\n          cluster.y = (cluster.y * cluster.count + point.y) / (cluster.count + 1);\n          cluster.intensity += point.intensity;\n          cluster.count++;\n          foundCluster = true;\n          break;\n        }\n      }\n      \n      if (!foundCluster) {\n        clusters.push({\n          x: point.x,\n          y: point.y,\n          intensity: point.intensity,\n          count: 1\n        });\n      }\n    });\n\n    return clusters\n      .filter(cluster => cluster.count >= 3) // Only significant clusters\n      .sort((a, b) => b.intensity - a.intensity)\n      .slice(0, 10) // Top 10 hot spots\n      .map(cluster => ({\n        x: Math.round(cluster.x),\n        y: Math.round(cluster.y),\n        intensity: Math.round(cluster.intensity),\n        radius: Math.min(clusterRadius, cluster.count * 5)\n      }));\n  }\n\n  private analyzeClickPatterns(): Array<{ pattern: string; frequency: number }> {\n    const clicks = this.data.filter(d => d.event_type === 'click');\n    const patterns: Record<string, number> = {};\n\n    // Analyze sequential click patterns\n    for (let i = 0; i < clicks.length - 1; i++) {\n      const current = clicks[i];\n      const next = clicks[i + 1];\n      \n      const timeDiff = next.timestamp - current.timestamp;\n      if (timeDiff < 5000) { // Within 5 seconds\n        const pattern = `(${Math.round(current.x)},${Math.round(current.y)}) -> (${Math.round(next.x)},${Math.round(next.y)})`;\n        patterns[pattern] = (patterns[pattern] || 0) + 1;\n      }\n    }\n\n    return Object.entries(patterns)\n      .sort(([, a], [, b]) => b - a)\n      .slice(0, 5)\n      .map(([pattern, frequency]) => ({ pattern, frequency }));\n  }\n\n  private analyzeUserBehavior(): {\n    mostActiveArea: { x: number; y: number; width: number; height: number };\n    averageClicksPerSession: number;\n    scrollDepth: number;\n    engagementScore: number;\n  } {\n    const clicks = this.data.filter(d => d.event_type === 'click');\n    const scrolls = this.data.filter(d => d.event_type === 'scroll');\n\n    // Find most active area (bounding box of top 50% of events)\n    const sortedByIntensity = [...this.data].sort((a, b) => b.intensity - a.intensity);\n    const topHalf = sortedByIntensity.slice(0, Math.floor(sortedByIntensity.length * 0.5));\n    \n    const minX = Math.min(...topHalf.map(d => d.x));\n    const maxX = Math.max(...topHalf.map(d => d.x));\n    const minY = Math.min(...topHalf.map(d => d.y));\n    const maxY = Math.max(...topHalf.map(d => d.y));\n\n    const scrollDepth = scrolls.length > 0 \n      ? Math.max(...scrolls.map(s => s.y)) / this.canvas.height \n      : 0;\n\n    const engagementScore = Math.min(100, \n      (clicks.length * 2) + \n      (scrollDepth * 50) + \n      (this.data.filter(d => d.event_type === 'move').length * 0.1)\n    );\n\n    return {\n      mostActiveArea: {\n        x: Math.round(minX),\n        y: Math.round(minY),\n        width: Math.round(maxX - minX),\n        height: Math.round(maxY - minY)\n      },\n      averageClicksPerSession: Math.round(clicks.length),\n      scrollDepth: Math.round(scrollDepth * 100) / 100,\n      engagementScore: Math.round(engagementScore)\n    };\n  }\n}","import type { ReviConfig } from './types';\nimport { EnhancedDOMSerializer, EnhancedDOMSnapshot, EnhancedDOMChange } from './enhanced-dom-serializer';\nimport { ConsoleRecorder, ConsoleLogEntry } from './console-recorder';\nimport { HeatmapGenerator, HeatmapData } from './heatmap-generator';\n\nexport interface ReplayEvent {\n  type: 'full_snapshot' | 'incremental_snapshot' | 'meta' | 'custom';\n  timestamp: number;\n  data: any;\n}\n\nexport interface ConsoleLog {\n  timestamp: number;\n  level: 'log' | 'info' | 'warn' | 'error' | 'debug';\n  args: any[];\n  stack?: string;\n}\n\nexport interface NetworkRequest {\n  timestamp: number;\n  id: string;\n  method: string;\n  url: string;\n  status?: number;\n  duration?: number;\n  requestHeaders?: Record<string, string>;\n  responseHeaders?: Record<string, string>;\n  requestBody?: any;\n  responseBody?: any;\n  failed?: boolean;\n}\n\n/**\n * Advanced session replay system with console logs and network requests\n */\nexport class SessionReplayManager {\n  private config: ReviConfig;\n  private domSerializer: EnhancedDOMSerializer;\n  private consoleRecorder: ConsoleRecorder;\n  private heatmapGenerator: HeatmapGenerator | null = null;\n  private events: ReplayEvent[] = [];\n  private consoleLogs: ConsoleLog[] = [];\n  private networkRequests: Map<string, NetworkRequest> = new Map();\n  private isRecording = false;\n  private sessionId: string;\n  private startTime: number;\n  private originalConsole: any = {};\n  private originalFetch: any;\n  private originalXMLHttpRequest: any;\n\n  constructor(config: ReviConfig, sessionId: string) {\n    this.config = config;\n    this.sessionId = sessionId;\n    this.startTime = Date.now();\n    this.domSerializer = new EnhancedDOMSerializer(config);\n    this.consoleRecorder = new ConsoleRecorder(sessionId, {\n      maxEntries: config.replay?.maxConsoleEntries || 1000,\n      captureStackTrace: config.replay?.captureStackTrace !== false,\n      serializeObjects: config.replay?.serializeObjects !== false,\n      maxObjectDepth: config.replay?.maxObjectDepth || 3,\n      maxStringLength: config.replay?.maxStringLength || 10000,\n      ignoredLevels: config.replay?.ignoredConsoleLevels || []\n    });\n    \n    if (this.config.replay?.enabled) {\n      this.setupReplay();\n      \n      // Initialize heatmap generator if enabled\n      if (this.config.replay?.heatmaps?.enabled && typeof document !== 'undefined') {\n        const container = document.body || document.documentElement;\n        if (container) {\n          this.heatmapGenerator = new HeatmapGenerator(container, {\n            radius: config.replay?.heatmaps?.radius || 20,\n            maxIntensity: config.replay?.heatmaps?.maxIntensity || 100,\n            blur: config.replay?.heatmaps?.blur || 15,\n            maxOpacity: config.replay?.heatmaps?.maxOpacity || 0.6\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Start recording session replay\n   */\n  startRecording(): void {\n    if (this.isRecording || !this.config.replay?.enabled) return;\n\n    this.isRecording = true;\n    \n    // Take initial snapshot\n    this.takeFullSnapshot();\n    \n    // Start observing DOM changes\n    this.domSerializer.startEnhancedObserving(this.handleDOMChange.bind(this));\n    \n    // Start console recording\n    this.consoleRecorder.start();\n    \n    // Setup network monitoring\n    this.setupNetworkCapture();\n    \n    // Setup mouse and keyboard tracking\n    this.setupInteractionTracking();\n    \n    // Periodic full snapshots\n    setInterval(() => {\n      if (this.isRecording) {\n        this.takeFullSnapshot();\n      }\n    }, 60000); // Every minute\n    \n    if (this.config.debug) {\n      console.log('Revi: Session replay started');\n    }\n  }\n\n  /**\n   * Stop recording session replay\n   */\n  stopRecording(): void {\n    if (!this.isRecording) return;\n\n    this.isRecording = false;\n    this.domSerializer.stopEnhancedObserving();\n    this.consoleRecorder.stop();\n    this.restoreOriginalNetwork();\n    \n    if (this.heatmapGenerator) {\n      this.heatmapGenerator.destroy();\n      this.heatmapGenerator = null;\n    }\n    \n    if (this.config.debug) {\n      console.log('Revi: Session replay stopped');\n    }\n  }\n\n  /**\n   * Get all replay events\n   */\n  getReplayData(): {\n    events: ReplayEvent[];\n    console_logs: ConsoleLogEntry[];\n    network_requests: NetworkRequest[];\n    heatmap_data?: HeatmapData[];\n    session_info: {\n      session_id: string;\n      start_time: number;\n      duration: number;\n      page_url: string;\n    };\n    analytics: {\n      console_insights: any;\n      heatmap_insights?: any;\n    };\n  } {\n    const consoleEntries = this.consoleRecorder.getEntries();\n    const consoleInsights = this.consoleRecorder.generateInsights();\n    \n    let heatmapData: HeatmapData[] | undefined;\n    let heatmapInsights: any;\n    \n    if (this.heatmapGenerator) {\n      const heatmapExport = this.heatmapGenerator.exportData();\n      heatmapData = heatmapExport.data;\n      heatmapInsights = this.heatmapGenerator.generateInsights();\n    }\n\n    return {\n      events: [...this.events],\n      console_logs: consoleEntries,\n      network_requests: Array.from(this.networkRequests.values()),\n      heatmap_data: heatmapData,\n      session_info: {\n        session_id: this.sessionId,\n        start_time: this.startTime,\n        duration: Date.now() - this.startTime,\n        page_url: window.location.href\n      },\n      analytics: {\n        console_insights: consoleInsights,\n        heatmap_insights: heatmapInsights\n      }\n    };\n  }\n\n  /**\n   * Clear replay data\n   */\n  clearReplayData(): void {\n    this.events = [];\n    this.consoleLogs = [];\n    this.networkRequests.clear();\n    this.consoleRecorder.clear();\n    \n    if (this.heatmapGenerator) {\n      this.heatmapGenerator.clear();\n    }\n  }\n\n  /**\n   * Setup basic replay tracking\n   */\n  private setupReplay(): void {\n    if (typeof window === 'undefined') return;\n\n    // Track page visibility changes\n    document.addEventListener('visibilitychange', () => {\n      this.addCustomEvent('visibility_change', {\n        hidden: document.hidden\n      });\n    });\n\n    // Track window focus/blur\n    window.addEventListener('focus', () => {\n      this.addCustomEvent('window_focus', {});\n    });\n\n    window.addEventListener('blur', () => {\n      this.addCustomEvent('window_blur', {});\n    });\n\n    // Track viewport changes\n    window.addEventListener('resize', () => {\n      this.addCustomEvent('viewport_change', {\n        width: window.innerWidth,\n        height: window.innerHeight\n      });\n    });\n\n    // Track scroll events (throttled)\n    let scrollTimeout: NodeJS.Timeout;\n    window.addEventListener('scroll', () => {\n      clearTimeout(scrollTimeout);\n      scrollTimeout = setTimeout(() => {\n        // Add to heatmap data\n        if (this.heatmapGenerator) {\n          this.heatmapGenerator.addDataPoint(\n            window.scrollX || 0,\n            window.scrollY || 0,\n            5,\n            'scroll'\n          );\n        }\n        \n        this.addCustomEvent('scroll', {\n          x: window.scrollX,\n          y: window.scrollY\n        });\n      }, 100);\n    }, { passive: true });\n  }\n\n  /**\n   * Take a full DOM snapshot\n   */\n  private takeFullSnapshot(): void {\n    if (!this.isRecording) return;\n\n    try {\n      const snapshot = this.domSerializer.takeEnhancedSnapshot();\n      \n      this.addEvent({\n        type: 'full_snapshot',\n        timestamp: Date.now(),\n        data: snapshot\n      });\n    } catch (error) {\n      if (this.config.debug) {\n        console.error('Revi: Failed to take DOM snapshot', error);\n      }\n    }\n  }\n\n  /**\n   * Handle DOM changes\n   */\n  private handleDOMChange(change: EnhancedDOMChange): void {\n    if (!this.isRecording) return;\n\n    this.addEvent({\n      type: 'incremental_snapshot',\n      timestamp: change.timestamp,\n      data: {\n        source: 'mutation',\n        ...change\n      }\n    });\n  }\n\n  /**\n   * Add heatmap methods\n   */\n  renderHeatmap(filter?: ('click' | 'move' | 'scroll')[]): void {\n    if (this.heatmapGenerator) {\n      this.heatmapGenerator.render(filter);\n    }\n  }\n\n  toggleHeatmap(visible: boolean): void {\n    if (this.heatmapGenerator) {\n      if (visible) {\n        this.heatmapGenerator.render();\n      } else {\n        this.heatmapGenerator.clear();\n      }\n    }\n  }\n\n  getHeatmapInsights(): any {\n    return this.heatmapGenerator?.generateInsights() || null;\n  }\n\n  /**\n   * Setup network request capture\n   */\n  private setupNetworkCapture(): void {\n    // Capture fetch requests\n    if (typeof window.fetch !== 'undefined') {\n      this.originalFetch = window.fetch;\n      \n      window.fetch = async (input: RequestInfo | URL, init?: RequestInit): Promise<Response> => {\n        const startTime = Date.now();\n        const requestId = this.generateRequestId();\n        const url = input instanceof Request ? input.url : input.toString();\n        const method = init?.method || (input instanceof Request ? input.method : 'GET');\n        \n        if (this.isRecording) {\n          this.networkRequests.set(requestId, {\n            timestamp: startTime,\n            id: requestId,\n            method,\n            url,\n            requestHeaders: this.getRequestHeaders(init, input),\n            requestBody: await this.serializeRequestBody(init, input)\n          });\n        }\n        \n        try {\n          const response = await this.originalFetch(input, init);\n          const duration = Date.now() - startTime;\n          \n          if (this.isRecording) {\n            const networkRequest = this.networkRequests.get(requestId);\n            if (networkRequest) {\n              networkRequest.status = response.status;\n              networkRequest.duration = duration;\n              networkRequest.responseHeaders = this.getResponseHeaders(response);\n              \n              // Optionally capture response body (be careful with large responses)\n              if (this.shouldCaptureResponseBody(response)) {\n                try {\n                  const clonedResponse = response.clone();\n                  networkRequest.responseBody = await clonedResponse.text();\n                } catch (e) {\n                  // Response body couldn't be captured\n                }\n              }\n            }\n          }\n          \n          return response;\n        } catch (error) {\n          const duration = Date.now() - startTime;\n          \n          if (this.isRecording) {\n            const networkRequest = this.networkRequests.get(requestId);\n            if (networkRequest) {\n              networkRequest.duration = duration;\n              networkRequest.failed = true;\n            }\n          }\n          \n          throw error;\n        }\n      };\n    }\n\n    // Capture XMLHttpRequest\n    if (typeof XMLHttpRequest !== 'undefined') {\n      this.originalXMLHttpRequest = XMLHttpRequest;\n      \n      const self = this;\n      \n      window.XMLHttpRequest = function() {\n        const xhr = new self.originalXMLHttpRequest();\n        const requestId = self.generateRequestId();\n        let method = 'GET';\n        let url = '';\n        let startTime = 0;\n        \n        const originalOpen = xhr.open;\n        const originalSend = xhr.send;\n        \n        xhr.open = function(m: string, u: string | URL, ...args: any[]) {\n          method = m;\n          url = u.toString();\n          return originalOpen.call(this, m, u, ...args);\n        };\n        \n        xhr.send = function(body?: any) {\n          startTime = Date.now();\n          \n          if (self.isRecording) {\n            self.networkRequests.set(requestId, {\n              timestamp: startTime,\n              id: requestId,\n              method,\n              url,\n              requestBody: body\n            });\n          }\n          \n          return originalSend.call(this, body);\n        };\n        \n        xhr.addEventListener('loadend', () => {\n          const duration = Date.now() - startTime;\n          \n          if (self.isRecording) {\n            const networkRequest = self.networkRequests.get(requestId);\n            if (networkRequest) {\n              networkRequest.status = xhr.status;\n              networkRequest.duration = duration;\n              networkRequest.failed = xhr.status === 0 || xhr.status >= 400;\n              \n              if (self.shouldCaptureXHRResponse(xhr)) {\n                networkRequest.responseBody = xhr.responseText;\n              }\n            }\n          }\n        });\n        \n        return xhr;\n      };\n    }\n  }\n\n  /**\n   * Setup mouse and keyboard interaction tracking\n   */\n  private setupInteractionTracking(): void {\n    // Mouse events\n    const mouseEvents = ['mousedown', 'mouseup', 'click', 'dblclick', 'mousemove'];\n    \n    mouseEvents.forEach(eventType => {\n      document.addEventListener(eventType, (event: MouseEvent) => {\n        if (!this.isRecording) return;\n        \n        // Throttle mousemove events\n        if (eventType === 'mousemove' && Math.random() > 0.1) return;\n        \n        // Add to heatmap data\n        if (this.heatmapGenerator) {\n          let intensity = 1;\n          if (eventType === 'click') intensity = 10;\n          else if (eventType === 'mousemove') intensity = 2;\n          else if (eventType === 'mousedown') intensity = 5;\n          \n          this.heatmapGenerator.addDataPoint(\n            event.clientX,\n            event.clientY,\n            intensity,\n            eventType === 'click' ? 'click' : 'move'\n          );\n        }\n        \n        this.addEvent({\n          type: 'incremental_snapshot',\n          timestamp: Date.now(),\n          data: {\n            source: 'mouse',\n            type: eventType,\n            x: event.clientX,\n            y: event.clientY,\n            id: this.getElementId(event.target as Element)\n          }\n        });\n      }, { capture: true, passive: true });\n    });\n\n    // Keyboard events\n    document.addEventListener('keydown', (event: KeyboardEvent) => {\n      if (!this.isRecording) return;\n      \n      // Don't capture sensitive keystrokes\n      if (this.shouldIgnoreKeystroke(event)) return;\n      \n      this.addEvent({\n        type: 'incremental_snapshot',\n        timestamp: Date.now(),\n        data: {\n          source: 'keyboard',\n          type: 'keydown',\n          key: this.sanitizeKey(event.key),\n          code: event.code,\n          id: this.getElementId(event.target as Element)\n        }\n      });\n    }, { capture: true, passive: true });\n  }\n\n  /**\n   * Utility methods\n   */\n  private addEvent(event: ReplayEvent): void {\n    this.events.push(event);\n    \n    // Limit event buffer\n    if (this.events.length > 10000) {\n      this.events = this.events.slice(-8000);\n    }\n  }\n\n  private addCustomEvent(type: string, data: any): void {\n    this.addEvent({\n      type: 'custom',\n      timestamp: Date.now(),\n      data: { type, ...data }\n    });\n  }\n\n  private serializeConsoleArgs(args: any[]): any[] {\n    return args.map(arg => {\n      try {\n        if (typeof arg === 'object' && arg !== null) {\n          return JSON.parse(JSON.stringify(arg));\n        }\n        return arg;\n      } catch (e) {\n        return '[Unserializable Object]';\n      }\n    });\n  }\n\n  private generateRequestId(): string {\n    return Date.now().toString(36) + Math.random().toString(36).substr(2);\n  }\n\n  private getRequestHeaders(init?: RequestInit, input?: RequestInfo | URL): Record<string, string> {\n    const headers: Record<string, string> = {};\n    \n    if (init?.headers) {\n      if (init.headers instanceof Headers) {\n        init.headers.forEach((value, key) => {\n          headers[key] = value;\n        });\n      } else if (Array.isArray(init.headers)) {\n        init.headers.forEach(([key, value]) => {\n          headers[key] = value;\n        });\n      } else {\n        Object.assign(headers, init.headers);\n      }\n    }\n    \n    if (input instanceof Request) {\n      input.headers.forEach((value, key) => {\n        headers[key] = value;\n      });\n    }\n    \n    return headers;\n  }\n\n  private getResponseHeaders(response: Response): Record<string, string> {\n    const headers: Record<string, string> = {};\n    response.headers.forEach((value, key) => {\n      headers[key] = value;\n    });\n    return headers;\n  }\n\n  private async serializeRequestBody(init?: RequestInit, input?: RequestInfo | URL): Promise<any> {\n    let body = init?.body;\n    \n    if (input instanceof Request && !body) {\n      try {\n        body = await input.clone().text();\n      } catch (e) {\n        return null;\n      }\n    }\n    \n    if (!body) return null;\n    \n    if (typeof body === 'string') {\n      return body.length > 10000 ? body.substring(0, 10000) + '...[truncated]' : body;\n    }\n    \n    if (body instanceof FormData) {\n      const formData: Record<string, any> = {};\n      body.forEach((value, key) => {\n        formData[key] = value instanceof File ? `[File: ${value.name}]` : value;\n      });\n      return formData;\n    }\n    \n    return '[Binary Data]';\n  }\n\n  private shouldCaptureResponseBody(response: Response): boolean {\n    const contentType = response.headers.get('content-type') || '';\n    const contentLength = parseInt(response.headers.get('content-length') || '0');\n    \n    // Only capture text-based responses under 100KB\n    return contentType.includes('application/json') ||\n           contentType.includes('text/') ||\n           (contentLength > 0 && contentLength < 100000);\n  }\n\n  private shouldCaptureXHRResponse(xhr: XMLHttpRequest): boolean {\n    const contentType = xhr.getResponseHeader('content-type') || '';\n    \n    return contentType.includes('application/json') ||\n           contentType.includes('text/') ||\n           (xhr.responseText && xhr.responseText.length < 100000);\n  }\n\n  private getElementId(element: Element | null): number | undefined {\n    // This would ideally use the same node ID system as the DOM serializer\n    return element ? Math.random() : undefined;\n  }\n\n  private shouldIgnoreKeystroke(event: KeyboardEvent): boolean {\n    const target = event.target as HTMLElement;\n    \n    if (target && target.tagName) {\n      const tagName = target.tagName.toLowerCase();\n      const type = (target as HTMLInputElement).type;\n      \n      // Ignore keystrokes in password fields\n      if (tagName === 'input' && type === 'password') return true;\n      \n      // Ignore keystrokes in elements marked as sensitive\n      if (target.hasAttribute('data-revi-ignore')) return true;\n    }\n    \n    return false;\n  }\n\n  private sanitizeKey(key: string): string {\n    // Don't capture the actual key for sensitive inputs\n    if (key.length === 1 && /[a-zA-Z0-9]/.test(key)) {\n      return '*'; // Mask alphanumeric characters\n    }\n    return key;\n  }\n\n\n  private restoreOriginalNetwork(): void {\n    if (this.originalFetch) {\n      window.fetch = this.originalFetch;\n    }\n    \n    if (this.originalXMLHttpRequest) {\n      window.XMLHttpRequest = this.originalXMLHttpRequest;\n    }\n  }\n}","/**\n * DeviceInfoManager - Centralized device and browser information detection\n * Parses user agent, detects device type, and generates device fingerprints\n */\n\nimport { generateId } from './utils';\n\nexport interface DeviceInfo {\n  // Browser information\n  browser_name: string;\n  browser_version: string;\n  browser_major_version: number;\n  \n  // Operating system\n  os_name: string;\n  os_version: string;\n  \n  // Device information\n  device_type: 'desktop' | 'mobile' | 'tablet' | 'unknown';\n  device_fingerprint: string;\n  \n  // Display information\n  screen_resolution: string;\n  color_depth: number;\n  device_pixel_ratio: number;\n  viewport_size: string;\n  \n  // Environment\n  platform: string;\n  language: string;\n  timezone: string;\n  \n  // Advanced fingerprinting\n  canvas_fingerprint?: string;\n  webgl_fingerprint?: string;\n  \n  // Capabilities\n  cookie_enabled: boolean;\n  local_storage_enabled: boolean;\n  session_storage_enabled: boolean;\n  \n  // Raw data\n  user_agent: string;\n}\n\nexport class DeviceInfoManager {\n  private static instance: DeviceInfoManager;\n  private cachedDeviceInfo: DeviceInfo | null = null;\n\n  constructor() {\n    if (DeviceInfoManager.instance) {\n      return DeviceInfoManager.instance;\n    }\n    DeviceInfoManager.instance = this;\n  }\n\n  /**\n   * Get comprehensive device information\n   */\n  getDeviceInfo(): DeviceInfo {\n    if (this.cachedDeviceInfo) {\n      return this.cachedDeviceInfo;\n    }\n\n    if (typeof window === 'undefined') {\n      return this.getServerSideDeviceInfo();\n    }\n\n    const userAgent = navigator.userAgent;\n    const browserInfo = this.parseBrowser(userAgent);\n    const osInfo = this.parseOperatingSystem(userAgent);\n    const deviceType = this.detectDeviceType(userAgent);\n\n    this.cachedDeviceInfo = {\n      // Browser information\n      browser_name: browserInfo.name,\n      browser_version: browserInfo.version,\n      browser_major_version: browserInfo.majorVersion,\n      \n      // Operating system\n      os_name: osInfo.name,\n      os_version: osInfo.version,\n      \n      // Device information\n      device_type: deviceType,\n      device_fingerprint: this.generateDeviceFingerprint(),\n      \n      // Display information\n      screen_resolution: `${screen.width}x${screen.height}`,\n      color_depth: screen.colorDepth,\n      device_pixel_ratio: window.devicePixelRatio || 1,\n      viewport_size: `${window.innerWidth}x${window.innerHeight}`,\n      \n      // Environment\n      platform: navigator.platform,\n      language: navigator.language,\n      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n      \n      // Advanced fingerprinting\n      canvas_fingerprint: this.generateCanvasFingerprint(),\n      webgl_fingerprint: this.generateWebGLFingerprint(),\n      \n      // Capabilities\n      cookie_enabled: navigator.cookieEnabled,\n      local_storage_enabled: this.testStorageAvailability('localStorage'),\n      session_storage_enabled: this.testStorageAvailability('sessionStorage'),\n      \n      // Raw data\n      user_agent: userAgent\n    };\n\n    return this.cachedDeviceInfo;\n  }\n\n  /**\n   * Parse browser information from user agent\n   */\n  private parseBrowser(userAgent: string): { name: string; version: string; majorVersion: number } {\n    const browsers = [\n      { name: 'Chrome', regex: /Chrome\\/([0-9.]+)/ },\n      { name: 'Firefox', regex: /Firefox\\/([0-9.]+)/ },\n      { name: 'Safari', regex: /Safari\\/[0-9.]+ Version\\/([0-9.]+)/ },\n      { name: 'Edge', regex: /Edg\\/([0-9.]+)/ },\n      { name: 'Opera', regex: /Opera\\/([0-9.]+)/ },\n      { name: 'Internet Explorer', regex: /MSIE ([0-9.]+)/ },\n      { name: 'Internet Explorer', regex: /Trident\\/.*rv:([0-9.]+)/ }\n    ];\n\n    for (const browser of browsers) {\n      const match = userAgent.match(browser.regex);\n      if (match) {\n        const version = match[1];\n        const majorVersion = parseInt(version.split('.')[0], 10);\n        return {\n          name: browser.name,\n          version,\n          majorVersion: isNaN(majorVersion) ? 0 : majorVersion\n        };\n      }\n    }\n\n    return { name: 'Unknown', version: '', majorVersion: 0 };\n  }\n\n  /**\n   * Parse operating system information from user agent\n   */\n  private parseOperatingSystem(userAgent: string): { name: string; version: string } {\n    // Debug logging\n    if (typeof console !== 'undefined' && console.log) {\n      console.log('[DeviceInfoManager] Parsing OS from UA:', userAgent);\n      console.log('[DeviceInfoManager] Platform:', typeof navigator !== 'undefined' ? navigator.platform : 'undefined');\n    }\n\n    // Use platform as a primary indicator for desktop systems\n    if (typeof navigator !== 'undefined' && navigator.platform) {\n      const platform = navigator.platform;\n      if (platform.includes('Mac') || platform === 'MacIntel') {\n        // This is definitely macOS\n        const macVersionMatch = userAgent.match(/Mac OS X ([0-9._]+)/);\n        const version = macVersionMatch ? macVersionMatch[1].replace(/_/g, '.') : '';\n        if (typeof console !== 'undefined' && console.log) {\n          console.log('[DeviceInfoManager] Platform-based detection: macOS', version);\n        }\n        return { name: 'macOS', version };\n      }\n      \n      if (platform.includes('Win') || platform.startsWith('Win')) {\n        // This is Windows\n        const winVersionMatch = userAgent.match(/Windows NT ([0-9.]+)/);\n        const version = winVersionMatch ? winVersionMatch[1] : '';\n        return { name: 'Windows', version };\n      }\n      \n      if (platform.includes('Linux') && !userAgent.includes('Android')) {\n        // This is Linux desktop\n        return { name: 'Linux', version: '' };\n      }\n    }\n\n    // Fallback to user agent parsing\n    const systems = [\n      // Windows - check first for most specific versions\n      { name: 'Windows 11', regex: /Windows NT 10\\.0.*Win64.*x64/ },\n      { name: 'Windows 10', regex: /Windows NT 10\\.0/ },\n      { name: 'Windows 8.1', regex: /Windows NT 6\\.3/ },\n      { name: 'Windows 8', regex: /Windows NT 6\\.2/ },\n      { name: 'Windows 7', regex: /Windows NT 6\\.1/ },\n      { name: 'Windows Vista', regex: /Windows NT 6\\.0/ },\n      { name: 'Windows XP', regex: /Windows NT 5\\.1/ },\n      { name: 'Windows', regex: /Windows NT ([0-9.]+)/ },\n      \n      // macOS - check before more generic patterns\n      { name: 'macOS', regex: /Mac OS X ([0-9._]+)/ },\n      { name: 'macOS', regex: /Macintosh.*Mac OS X/ },\n      \n      // iOS - specific mobile patterns (very specific to avoid false positives)\n      { name: 'iOS', regex: /iPhone.*OS ([0-9_]+)/ },\n      { name: 'iOS', regex: /iPad.*OS ([0-9_]+)/ },\n      { name: 'iOS', regex: /iPod.*OS ([0-9_]+)/ },\n      \n      // ChromeOS\n      { name: 'ChromeOS', regex: /CrOS/ },\n      \n      // Android - be very specific to avoid false positives\n      { name: 'Android', regex: /Android ([0-9.]+)(?!.*Mac)/ },\n      \n      // Linux variants\n      { name: 'Ubuntu', regex: /Ubuntu/ },\n      { name: 'Linux', regex: /Linux(?!.*Android)/ }\n    ];\n\n    for (const system of systems) {\n      const match = userAgent.match(system.regex);\n      if (match) {\n        let version = '';\n        if (match[1]) {\n          version = match[1].replace(/_/g, '.');\n        }\n        if (typeof console !== 'undefined' && console.log) {\n          console.log('[DeviceInfoManager] UA-based detection:', system.name, version);\n        }\n        return { name: system.name, version };\n      }\n    }\n\n    if (typeof console !== 'undefined' && console.log) {\n      console.log('[DeviceInfoManager] No OS match found, returning Unknown');\n    }\n    return { name: 'Unknown', version: '' };\n  }\n\n  /**\n   * Detect device type based on user agent and screen size\n   */\n  private detectDeviceType(userAgent: string): 'desktop' | 'mobile' | 'tablet' | 'unknown' {\n    // First, check for desktop OS indicators (highest priority)\n    const desktopIndicators = [\n      /Windows NT/i,\n      /Mac OS X/i,\n      /MacIntel/i,\n      /Linux.*X11/i,\n      /CrOS/i  // ChromeOS\n    ];\n\n    // If we detect desktop OS, it's very likely desktop unless explicitly mobile\n    if (desktopIndicators.some(pattern => pattern.test(userAgent))) {\n      // Only override if we have clear mobile indicators\n      const mobileBrowsers = [\n        /Mobile Safari/i,\n        /Android.*Mobile/i,\n        /iPhone/i,\n        /iPod/i,\n        /Windows Phone/i\n      ];\n      \n      if (!mobileBrowsers.some(pattern => pattern.test(userAgent))) {\n        return 'desktop';\n      }\n    }\n\n    // Check for specific mobile patterns\n    const mobilePatterns = [\n      /iPhone/i,\n      /iPod/i,\n      /Android.*Mobile/i,\n      /BlackBerry/i,\n      /Windows Phone/i,\n      /Opera Mini/i,\n      /Mobile.*Safari/i\n    ];\n\n    // Check for tablet patterns (more specific)\n    const tabletPatterns = [\n      /iPad/i,\n      /Android(?!.*Mobile)/i,\n      /Tablet/i,\n      /Kindle/i,\n      /Silk/i,\n      /PlayBook/i\n    ];\n\n    // Check screen size if available (secondary indicator)\n    if (typeof screen !== 'undefined') {\n      const screenWidth = Math.max(screen.width, screen.height);\n      // const screenHeight = Math.min(screen.width, screen.height);\n      \n      // Very small screens are likely mobile\n      if (screenWidth <= 480) {\n        return 'mobile';\n      }\n      \n      // Large screens are likely desktop\n      if (screenWidth >= 1280) {\n        return 'desktop';\n      }\n      \n      // Medium screens - check patterns\n      if (screenWidth <= 1024) {\n        if (tabletPatterns.some(pattern => pattern.test(userAgent))) {\n          return 'tablet';\n        }\n        if (mobilePatterns.some(pattern => pattern.test(userAgent))) {\n          return 'mobile';\n        }\n      }\n    }\n\n    // Check user agent patterns\n    if (mobilePatterns.some(pattern => pattern.test(userAgent))) {\n      return 'mobile';\n    }\n\n    if (tabletPatterns.some(pattern => pattern.test(userAgent))) {\n      return 'tablet';\n    }\n\n    // Default to desktop for everything else\n    return 'desktop';\n  }\n\n  /**\n   * Generate a unique device fingerprint\n   */\n  private generateDeviceFingerprint(): string {\n    if (typeof window === 'undefined') {\n      return 'server-' + generateId();\n    }\n\n    const components = [\n      navigator.userAgent,\n      navigator.language,\n      screen.width + 'x' + screen.height,\n      screen.colorDepth,\n      navigator.platform,\n      navigator.cookieEnabled.toString(),\n      typeof window.localStorage !== 'undefined',\n      typeof window.sessionStorage !== 'undefined',\n      Intl.DateTimeFormat().resolvedOptions().timeZone,\n      navigator.hardwareConcurrency || 'unknown',\n      window.devicePixelRatio || 1\n    ];\n\n    // Add canvas fingerprint if available\n    const canvasFingerprint = this.generateCanvasFingerprint();\n    if (canvasFingerprint) {\n      components.push(canvasFingerprint);\n    }\n\n    // Add WebGL fingerprint if available\n    const webglFingerprint = this.generateWebGLFingerprint();\n    if (webglFingerprint) {\n      components.push(webglFingerprint);\n    }\n\n    // Simple hash function for browser compatibility\n    const str = components.join('|');\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32bit integer\n    }\n    \n    return 'fp_' + Math.abs(hash).toString(36);\n  }\n\n  /**\n   * Generate canvas fingerprint\n   */\n  private generateCanvasFingerprint(): string | undefined {\n    try {\n      const canvas = document.createElement('canvas');\n      const ctx = canvas.getContext('2d');\n      \n      if (!ctx) return undefined;\n\n      canvas.width = 200;\n      canvas.height = 50;\n      \n      ctx.textBaseline = 'top';\n      ctx.font = '14px Arial';\n      ctx.fillStyle = '#f60';\n      ctx.fillRect(125, 1, 62, 20);\n      ctx.fillStyle = '#069';\n      ctx.fillText('Device fingerprint 🔒', 2, 15);\n      ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';\n      ctx.fillText('Device fingerprint 🔒', 4, 17);\n\n      return canvas.toDataURL();\n    } catch {\n      return undefined;\n    }\n  }\n\n  /**\n   * Generate WebGL fingerprint\n   */\n  private generateWebGLFingerprint(): string | undefined {\n    try {\n      const canvas = document.createElement('canvas');\n      const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl') as WebGLRenderingContext;\n      \n      if (!gl) return undefined;\n\n      const renderer = gl.getParameter(gl.RENDERER);\n      const vendor = gl.getParameter(gl.VENDOR);\n      const version = gl.getParameter(gl.VERSION);\n      const extensions = gl.getSupportedExtensions()?.join(',') || '';\n\n      return `${vendor}|${renderer}|${version}|${extensions}`;\n    } catch {\n      return undefined;\n    }\n  }\n\n  /**\n   * Test storage availability\n   */\n  private testStorageAvailability(type: 'localStorage' | 'sessionStorage'): boolean {\n    try {\n      const storage = window[type];\n      const testKey = '__revi_test__';\n      storage.setItem(testKey, 'test');\n      storage.removeItem(testKey);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get server-side device info (fallback)\n   */\n  private getServerSideDeviceInfo(): DeviceInfo {\n    return {\n      browser_name: 'Unknown',\n      browser_version: '',\n      browser_major_version: 0,\n      os_name: 'Unknown',\n      os_version: '',\n      device_type: 'unknown',\n      device_fingerprint: 'server-' + generateId(),\n      screen_resolution: 'unknown',\n      color_depth: 0,\n      device_pixel_ratio: 1,\n      viewport_size: 'unknown',\n      platform: 'server',\n      language: 'unknown',\n      timezone: 'unknown',\n      cookie_enabled: false,\n      local_storage_enabled: false,\n      session_storage_enabled: false,\n      user_agent: 'server'\n    };\n  }\n\n  /**\n   * Clear cached device info (for testing)\n   */\n  clearCache(): void {\n    this.cachedDeviceInfo = null;\n  }\n\n  /**\n   * Get a simplified device summary for logging\n   */\n  getDeviceSummary(): string {\n    const info = this.getDeviceInfo();\n    return `${info.browser_name} ${info.browser_version} on ${info.os_name} (${info.device_type})`;\n  }\n}\n\n// Export singleton instance\nexport const deviceInfoManager = new DeviceInfoManager();","import { ErrorHandler } from './error-handler';\nimport { SessionManager } from './session';\nimport { NetworkMonitor } from './network-monitor';\nimport { DataManager } from './data-manager';\nimport { UserJourneyTracker } from './user-journey';\nimport { TraceManager } from './trace-manager';\nimport { SamplingManager } from './sampling-manager';\nimport { PerformanceMonitor } from './performance-monitor';\nimport { SessionReplayManager } from './session-replay';\nimport { deviceInfoManager } from './device-info-manager';\nimport { isBot } from './utils';\nimport { getDebugLogger, initDebugLogger } from './debug-logger';\nimport type { ReviConfig, ErrorEvent, UserContext, DeviceInfo } from './types';\n\nexport class Monitor {\n  private config: ReviConfig;\n  private traceManager!: TraceManager;\n  private errorHandler!: ErrorHandler;\n  private sessionManager!: SessionManager;\n  private networkMonitor!: NetworkMonitor;\n  private performanceMonitor!: PerformanceMonitor;\n  private dataManager!: DataManager;\n  private userJourneyTracker!: UserJourneyTracker;\n  private sessionReplayManager!: SessionReplayManager;\n  private samplingManager!: SamplingManager;\n  private debugLogger = getDebugLogger();\n  private deviceInfo: DeviceInfo;\n  private isInitialized = false;\n\n  constructor(config: ReviConfig) {\n    this.config = {\n      apiUrl: process.env.REVI_API_URL || 'https://api.revi.dev',\n      environment: 'production',\n      debug: false,\n      sampleRate: 1.0,\n      sessionSampleRate: 1.0,\n      maxBreadcrumbs: 50,\n      privacy: {\n        maskInputs: true,\n        maskPasswords: true,\n        maskCreditCards: true\n      },\n      performance: {\n        captureWebVitals: true,\n        captureResourceTiming: false,\n        captureNavigationTiming: true\n      },\n      replay: {\n        enabled: true,\n        maskAllInputs: false,\n        maskAllText: false\n      },\n      ...config\n    };\n\n    // Initialize debug logger with enhanced debugging\n    this.debugLogger = initDebugLogger(\n      this.config.debug || false,\n      (this.config as any).saveDebugLogs || false\n    );\n\n    if (!this.config.apiKey) {\n      throw new Error('Revi: API key is required');\n    }\n\n    // Initialize device information early\n    this.deviceInfo = deviceInfoManager.getDeviceInfo();\n    \n    if (this.config.debug) {\n      console.log('Revi: Device info initialized:', deviceInfoManager.getDeviceSummary());\n    }\n\n    if (isBot()) {\n      if (this.config.debug) {\n        console.log('Revi: Bot detected, skipping initialization');\n      }\n      return;\n    }\n\n    this.init();\n  }\n\n  private init(): void {\n    if (this.isInitialized) return;\n\n    try {\n      // Create shared trace manager\n      this.traceManager = new TraceManager();\n      \n      // Initialize core components with shared trace manager\n      this.errorHandler = new ErrorHandler(this.config, this.traceManager);\n      this.sessionManager = new SessionManager(this.config, this.traceManager);\n      this.networkMonitor = new NetworkMonitor(this.config, this.traceManager);\n      this.performanceMonitor = new PerformanceMonitor(this.config);\n      this.dataManager = new DataManager(this.config);\n      this.userJourneyTracker = new UserJourneyTracker(this.config, () => this.sessionManager.getSessionId());\n      this.sessionReplayManager = new SessionReplayManager(this.config, this.sessionManager.getSessionId());\n      this.samplingManager = new SamplingManager(this.config);\n\n      this.setupAdaptiveFlush();\n      \n      // Start session replay if enabled\n      if (this.config.replay?.enabled) {\n        this.sessionReplayManager.startRecording();\n      }\n      \n      this.isInitialized = true;\n\n      // Register device information automatically\n      this.registerDevice().catch(error => {\n        if (this.config.debug) {\n          console.error('Revi: Device registration failed:', error);\n        }\n      });\n\n      if (this.config.debug) {\n        console.log('Revi: Initialized successfully');\n      }\n    } catch (error) {\n      if (this.config.debug) {\n        console.error('Revi: Initialization failed', error);\n      }\n    }\n  }\n\n  private setupAdaptiveFlush(): void {\n    let errorCount = 0;\n    let lastFlushTime = Date.now();\n    \n    const adaptiveFlush = () => {\n      const now = Date.now();\n      const timeSinceLastFlush = now - lastFlushTime;\n      \n      // Get current network and session event counts\n      const networkEventCount = this.networkMonitor?.getEvents().length || 0;\n      const sessionEventCount = this.sessionManager?.getQueuedEventCount?.() || 0;\n      const totalActivityCount = errorCount + networkEventCount + sessionEventCount;\n      \n      // Base interval: 10 seconds\n      let flushInterval = 10000;\n      \n      // Reduce interval if there's high activity (errors, network, or session events)\n      if (totalActivityCount > 0) {\n        // More aggressive flushing for high activity\n        if (totalActivityCount >= 50) {\n          flushInterval = 3000; // 3 seconds for very high activity\n        } else if (totalActivityCount >= 20) {\n          flushInterval = 5000; // 5 seconds for moderate activity  \n        } else if (totalActivityCount >= 5) {\n          flushInterval = 7000; // 7 seconds for some activity\n        }\n      }\n      \n      // Increase interval if no activity (max: 30 seconds)\n      if (totalActivityCount === 0 && timeSinceLastFlush > 15000) {\n        flushInterval = Math.min(30000, flushInterval + 5000);\n      }\n      \n      // Special case: if we have many network events, flush sooner to prevent memory buildup\n      if (networkEventCount >= 100) {\n        flushInterval = Math.min(flushInterval, 5000);\n      }\n      \n      if (timeSinceLastFlush >= flushInterval) {\n        this.flush();\n        lastFlushTime = now;\n        errorCount = 0; // Reset counts after flush\n      }\n      \n      // Schedule next check\n      setTimeout(adaptiveFlush, 2000);\n    };\n    \n    // Start the adaptive flush cycle\n    adaptiveFlush();\n    \n    // Track errors for adaptive frequency\n    const originalCaptureException = this.captureException.bind(this);\n    this.captureException = (error: Error, options = {}) => {\n      errorCount++;\n      return originalCaptureException(error, options);\n    };\n  }\n\n  // Public API methods\n  captureException(error: Error, options: {\n    level?: 'error' | 'warning' | 'info' | 'debug';\n    tags?: Record<string, string>;\n    extra?: Record<string, any>;\n  } = {}): string {\n    if (!this.isInitialized) return '';\n\n    // Sampling check - always capture critical errors\n    const isCriticalError = options.level === 'error' || !options.level;\n    if (!isCriticalError && this.samplingManager.shouldSkipCapture('error')) {\n      return ''; // Skip non-critical errors based on sampling\n    }\n\n    // Update activity level based on error frequency\n    this.samplingManager.incrementErrorFrequency();\n    this.samplingManager.updateActivityLevel('high');\n\n    const errorId = this.errorHandler.captureException(error, options);\n    if (errorId) {\n      // Create error event and queue for upload\n      const errorEvent: ErrorEvent = {\n        id: errorId,\n        timestamp: Date.now(),\n        message: error.message,\n        stack: error.stack,\n        url: window.location.href,\n        userId: this.config.userId,\n        sessionId: this.sessionManager.getSessionId(),\n        userAgent: navigator.userAgent,\n        environment: this.config.environment,\n        release: this.config.release,\n        tags: options.tags,\n        extra: options.extra,\n        breadcrumbs: this.errorHandler.getBreadcrumbs(),\n        level: options.level || 'error',\n        deviceInfo: this.deviceInfo\n      };\n\n      this.dataManager.queueError(errorEvent);\n      \n      // Track error in user journey\n      if (this.userJourneyTracker) {\n        this.userJourneyTracker.trackError(error, {\n          level: options.level,\n          tags: options.tags,\n          extra: options.extra\n        });\n      }\n    }\n\n    return errorId;\n  }\n\n  captureMessage(message: string, options: {\n    level?: 'error' | 'warning' | 'info' | 'debug';\n    tags?: Record<string, string>;\n    extra?: Record<string, any>;\n  } = {}): string {\n    if (!this.isInitialized) return '';\n\n    const errorId = this.errorHandler.captureMessage(message, options);\n    if (errorId) {\n      const errorEvent: ErrorEvent = {\n        id: errorId,\n        timestamp: Date.now(),\n        message,\n        url: window.location.href,\n        userId: this.config.userId,\n        sessionId: this.sessionManager.getSessionId(),\n        userAgent: navigator.userAgent,\n        environment: this.config.environment,\n        release: this.config.release,\n        tags: options.tags,\n        extra: options.extra,\n        breadcrumbs: this.errorHandler.getBreadcrumbs(),\n        level: options.level || 'info',\n        deviceInfo: this.deviceInfo\n      };\n\n      this.dataManager.queueError(errorEvent);\n    }\n\n    return errorId;\n  }\n\n  addBreadcrumb(breadcrumb: {\n    message: string;\n    category?: string;\n    level?: 'error' | 'warning' | 'info' | 'debug';\n    data?: Record<string, any>;\n  }): void {\n    if (!this.isInitialized) return;\n\n    this.errorHandler.addBreadcrumb({\n      timestamp: Date.now(),\n      message: breadcrumb.message,\n      category: breadcrumb.category || 'manual',\n      level: breadcrumb.level || 'info',\n      data: breadcrumb.data\n    });\n  }\n\n  setUserContext(user: UserContext): void {\n    if (!this.isInitialized) return;\n\n    this.config.userId = user.id;\n    this.errorHandler.setUserContext(user);\n    this.userJourneyTracker.setUserId(user.id || '');\n    this.userJourneyTracker.startTracking(user.id);\n  }\n\n  setTags(tags: Record<string, string>): void {\n    if (!this.isInitialized) return;\n    this.errorHandler.setTags(tags);\n  }\n\n  setExtra(extra: Record<string, any>): void {\n    if (!this.isInitialized) return;\n    this.errorHandler.setExtra(extra);\n  }\n\n  // Session management\n  getSessionId(): string {\n    if (!this.isInitialized) return '';\n    return this.sessionManager.getSessionId();\n  }\n\n  endSession(): void {\n    if (!this.isInitialized) return;\n    \n    this.flush();\n    this.sessionManager.endSession();\n  }\n\n  // Performance monitoring\n  mark(name: string): void {\n    if (!this.isInitialized) return;\n    this.performanceMonitor.mark(name);\n  }\n\n  measure(name: string, startMark?: string, endMark?: string): number | null {\n    if (!this.isInitialized) return null;\n    return this.performanceMonitor.measure(name, startMark, endMark);\n  }\n\n  getWebVitals() {\n    if (!this.isInitialized) return {};\n    return this.performanceMonitor.getWebVitals();\n  }\n\n  // Device information\n  getDeviceInfo(): DeviceInfo {\n    return this.deviceInfo;\n  }\n\n  private async registerDevice(): Promise<void> {\n    if (typeof window === 'undefined') return;\n\n    // Check if we've already registered device info for this session\n    const sessionId = this.sessionManager.getSessionId();\n    const storageKey = `revi_device_registered_${sessionId}`;\n    \n    try {\n      if (typeof sessionStorage !== 'undefined') {\n        const alreadyRegistered = sessionStorage.getItem(storageKey);\n        if (alreadyRegistered) {\n          if (this.config.debug) {\n            console.log('Revi: Device already registered for this session, skipping');\n          }\n          return;\n        }\n      }\n    } catch (e) {\n      // Ignore sessionStorage errors, continue with registration\n    }\n\n    try {\n      const devicePayload = {\n        device_info: {\n          browser_name: this.deviceInfo.browser_name,\n          browser_version: this.deviceInfo.browser_version,\n          browser_major_version: this.deviceInfo.browser_major_version,\n          os_name: this.deviceInfo.os_name,\n          os_version: this.deviceInfo.os_version,\n          device_type: this.deviceInfo.device_type,\n          device_fingerprint: this.deviceInfo.device_fingerprint,\n          screen_resolution: this.deviceInfo.screen_resolution,\n          color_depth: this.deviceInfo.color_depth,\n          device_pixel_ratio: this.deviceInfo.device_pixel_ratio,\n          viewport_size: this.deviceInfo.viewport_size,\n          platform: this.deviceInfo.platform,\n          language: this.deviceInfo.language,\n          timezone: this.deviceInfo.timezone,\n          canvas_fingerprint: this.deviceInfo.canvas_fingerprint,\n          webgl_fingerprint: this.deviceInfo.webgl_fingerprint,\n          cookie_enabled: this.deviceInfo.cookie_enabled,\n          local_storage_enabled: this.deviceInfo.local_storage_enabled,\n          session_storage_enabled: this.deviceInfo.session_storage_enabled\n        },\n        session_id: this.sessionManager.getSessionId(),\n        user_id: this.config.userId\n      };\n\n      const response = await fetch(`${this.config.apiUrl}/api/capture/device`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-API-Key': this.config.apiKey\n        },\n        body: JSON.stringify(devicePayload)\n      });\n\n      if (!response.ok) {\n        throw new Error(`Device registration failed: ${response.status}`);\n      }\n\n      // Mark as registered for this session\n      try {\n        if (typeof sessionStorage !== 'undefined') {\n          sessionStorage.setItem(storageKey, 'true');\n        }\n      } catch (e) {\n        // Ignore sessionStorage errors\n      }\n\n      if (this.config.debug) {\n        console.log('Revi: Device registered successfully');\n      }\n    } catch (error) {\n      // Don't throw, just log - device registration shouldn't break the SDK\n      if (this.config.debug) {\n        console.error('Revi: Device registration error:', error);\n      }\n    }\n  }\n\n  // Session Replay methods\n  startSessionReplay(): void {\n    if (!this.isInitialized || !this.sessionReplayManager) return;\n    this.sessionReplayManager.startRecording();\n  }\n\n  stopSessionReplay(): void {\n    if (!this.isInitialized || !this.sessionReplayManager) return;\n    this.sessionReplayManager.stopRecording();\n  }\n\n  getSessionReplayData() {\n    if (!this.isInitialized || !this.sessionReplayManager) return null;\n    return this.sessionReplayManager.getReplayData();\n  }\n\n  // Data management\n  flush(): void {\n    if (!this.isInitialized) {\n      this.debugLogger.log('general', 'flush-skipped', 'Flush called but Monitor not initialized');\n      return;\n    }\n\n    this.debugLogger.log('general', 'flush-start', 'Starting flush operation');\n\n    // Get all queued events\n    const sessionEvents = this.sessionManager.flush();\n    const networkEvents = this.networkMonitor.flush();\n\n    this.debugLogger.logDataTransformation(\n      'flush-raw-events',\n      { sessionEventsCount: sessionEvents.length, networkEventsCount: networkEvents.length },\n      { sessionEvents, networkEvents },\n      this.sessionManager.getSessionId()\n    );\n\n    // CRITICAL: Log session events before modification\n    this.debugLogger.log('session', 'session-events-before-sessionid', 'Session events before adding sessionId', {\n      count: sessionEvents.length,\n      events: sessionEvents.map((event, index) => ({\n        index,\n        type: event.type,\n        hasSessionId: !!(event.sessionId),\n        sessionIdValue: event.sessionId || 'MISSING',\n        dataKeys: Object.keys(event.data || {}),\n        timestamp: event.timestamp\n      }))\n    });\n\n    const currentSessionId = this.sessionManager.getSessionId();\n    this.debugLogger.log('session', 'current-session-id', 'Current session ID from SessionManager', {\n      sessionId: currentSessionId,\n      sessionIdType: typeof currentSessionId,\n      sessionIdLength: currentSessionId ? currentSessionId.length : 0\n    });\n\n    // Add session ID to session events\n    sessionEvents.forEach((event, index) => {\n      const beforeSessionId = event.sessionId;\n      event.sessionId = currentSessionId;\n      \n      this.debugLogger.log('session', 'sessionid-assignment', `Assigning sessionId to event ${index}`, {\n        eventIndex: index,\n        eventType: event.type,\n        beforeSessionId: beforeSessionId || 'MISSING',\n        afterSessionId: event.sessionId,\n        assignmentWorked: event.sessionId === currentSessionId\n      });\n    });\n\n    // CRITICAL: Log session events after modification\n    this.debugLogger.log('session', 'session-events-after-sessionid', 'Session events after adding sessionId', {\n      count: sessionEvents.length,\n      events: sessionEvents.map((event, index) => ({\n        index,\n        type: event.type,\n        hasSessionId: !!(event.sessionId),\n        sessionIdValue: event.sessionId,\n        sessionIdMatches: event.sessionId === currentSessionId,\n        dataKeys: Object.keys(event.data || {}),\n        timestamp: event.timestamp\n      }))\n    });\n\n    // Add session ID to network events\n    networkEvents.forEach((event, index) => {\n      const beforeSessionId = event.sessionId;\n      event.sessionId = currentSessionId;\n      \n      this.debugLogger.log('network', 'network-sessionid-assignment', `Assigning sessionId to network event ${index}`, {\n        eventIndex: index,\n        beforeSessionId: beforeSessionId || 'MISSING',\n        afterSessionId: event.sessionId\n      });\n    });\n\n    // Queue for upload with detailed logging\n    if (sessionEvents.length > 0) {\n      this.debugLogger.log('session', 'queue-session-events', 'Queueing session events for upload', {\n        count: sessionEvents.length,\n        allHaveSessionId: sessionEvents.every(e => !!e.sessionId),\n        sessionIds: sessionEvents.map(e => e.sessionId)\n      });\n      \n      this.dataManager.queueSessionEvents(sessionEvents);\n    } else {\n      this.debugLogger.log('session', 'no-session-events', 'No session events to queue');\n    }\n    \n    if (networkEvents.length > 0) {\n      this.debugLogger.log('network', 'queue-network-events', 'Queueing network events for upload', {\n        count: networkEvents.length\n      });\n      \n      this.dataManager.queueNetworkEvents(networkEvents);\n    } else {\n      this.debugLogger.log('network', 'no-network-events', 'No network events to queue');\n    }\n\n    this.debugLogger.log('general', 'flush-complete', 'Flush operation completed', {\n      sessionEventsQueued: sessionEvents.length,\n      networkEventsQueued: networkEvents.length\n    });\n  }\n\n\n  // Trace context methods\n  getCurrentTraceId(): string | undefined {\n    return this.traceManager?.getCurrentTraceId();\n  }\n\n  getCurrentSpanId(): string | undefined {\n    return this.traceManager?.getCurrentSpanId();\n  }\n\n  getTraceContext(): { traceId?: string; spanId?: string; parentSpanId?: string } {\n    return this.traceManager?.getTraceContext() || {};\n  }\n\n  startSpan(operationName: string): string | undefined {\n    return this.traceManager?.startSpan(operationName);\n  }\n\n  finishSpan(spanId?: string, data?: Record<string, any>): void {\n    this.traceManager?.finishSpan(spanId, data);\n  }\n\n  destroy(): void {\n    if (!this.isInitialized) return;\n\n    this.flush();\n    \n    if (this.networkMonitor) {\n      this.networkMonitor.destroy();\n    }\n    \n    if (this.dataManager) {\n      this.dataManager.destroy();\n    }\n\n    if (this.sessionReplayManager) {\n      this.sessionReplayManager.stopRecording();\n    }\n\n    if (this.userJourneyTracker) {\n      this.userJourneyTracker.stopTracking();\n    }\n    \n    // Cleanup trace manager\n    if (this.traceManager) {\n      this.traceManager.cleanupSpanData();\n    }\n\n    this.isInitialized = false;\n  }\n}\n","/**\n * Advanced Retry Manager with sophisticated retry strategies\n * Implements jittered exponential backoff, failure classification, and retry budgets\n */\n\nexport interface RetryConfig {\n  maxAttempts: number;\n  baseDelay: number;\n  maxDelay: number;\n  jitterRatio: number;\n  timeoutMultiplier: number;\n  retryBudget: number;\n  enableJitter: boolean;\n}\n\nexport interface RetryableError {\n  statusCode?: number;\n  type: 'network' | 'timeout' | 'server' | 'client' | 'unknown';\n  message: string;\n  retryable: boolean;\n  priority: 'critical' | 'high' | 'medium' | 'low';\n}\n\nexport interface RetryAttempt {\n  attempt: number;\n  delay: number;\n  timestamp: number;\n  error?: RetryableError;\n  duration?: number;\n}\n\nexport interface RetryStats {\n  totalAttempts: number;\n  successfulRetries: number;\n  failedRetries: number;\n  averageDelay: number;\n  budgetUsed: number;\n  lastSuccess?: number;\n  lastFailure?: number;\n}\n\nexport class RetryManager {\n  private config: RetryConfig;\n  private retryStats: Map<string, RetryStats> = new Map();\n  private retryBudgetUsed = 0;\n  private lastBudgetReset = Date.now();\n  private budgetResetInterval = 60000; // 1 minute\n  private requestDeduplication = new Map<string, Promise<any>>();\n  private rateLimitedUntil = 0;\n\n  constructor(config: Partial<RetryConfig> = {}) {\n    this.config = {\n      maxAttempts: 5,\n      baseDelay: 1000,\n      maxDelay: 30000,\n      jitterRatio: 0.1,\n      timeoutMultiplier: 1.5,\n      retryBudget: 100, // Max retry attempts per minute\n      enableJitter: true,\n      ...config\n    };\n  }\n\n  /**\n   * Execute operation with advanced retry logic\n   */\n  async executeWithRetry<T>(\n    key: string,\n    operation: () => Promise<T>,\n    options: {\n      priority?: 'critical' | 'high' | 'medium' | 'low';\n      timeout?: number;\n      payloadSize?: number;\n      deduplicationKey?: string;\n    } = {}\n  ): Promise<T> {\n    const { priority = 'medium', timeout, payloadSize, deduplicationKey } = options;\n    \n    // Check deduplication\n    if (deduplicationKey && this.requestDeduplication.has(deduplicationKey)) {\n      return this.requestDeduplication.get(deduplicationKey);\n    }\n\n    // Check retry budget\n    this.resetBudgetIfNeeded();\n    if (!this.hasBudgetAvailable(priority)) {\n      throw new Error('Retry budget exceeded. Operation rate-limited.');\n    }\n\n    const stats = this.getOrCreateStats(key);\n    const attempts: RetryAttempt[] = [];\n    let lastError: RetryableError | undefined;\n\n    // Create deduplication promise if needed\n    const executePromise = this.performRetryLoop(key, operation, priority, timeout, payloadSize, attempts, stats);\n    \n    if (deduplicationKey) {\n      this.requestDeduplication.set(deduplicationKey, executePromise);\n      \n      // Clean up deduplication entry after completion\n      executePromise.finally(() => {\n        this.requestDeduplication.delete(deduplicationKey);\n      });\n    }\n\n    return executePromise;\n  }\n\n  private async performRetryLoop<T>(\n    key: string,\n    operation: () => Promise<T>,\n    priority: 'critical' | 'high' | 'medium' | 'low',\n    timeout: number | undefined,\n    payloadSize: number | undefined,\n    attempts: RetryAttempt[],\n    stats: RetryStats\n  ): Promise<T> {\n    for (let attempt = 0; attempt < this.config.maxAttempts; attempt++) {\n      const attemptStart = Date.now();\n      \n      try {\n        // Check rate limiting\n        if (Date.now() < this.rateLimitedUntil) {\n          throw this.createRetryableError(429, 'Rate limited', 'server', false, priority);\n        }\n\n        // Execute with timeout if specified\n        const result = timeout \n          ? await this.executeWithTimeout(operation, timeout * Math.pow(this.config.timeoutMultiplier, attempt))\n          : await operation();\n\n        // Success - update stats and return\n        stats.totalAttempts++;\n        stats.successfulRetries = attempt > 0 ? stats.successfulRetries + 1 : stats.successfulRetries;\n        stats.lastSuccess = Date.now();\n        \n        const attemptRecord: RetryAttempt = {\n          attempt: attempt + 1,\n          delay: 0,\n          timestamp: attemptStart,\n          duration: Date.now() - attemptStart\n        };\n        attempts.push(attemptRecord);\n\n        return result;\n\n      } catch (error: any) {\n        const retryableError = this.classifyError(error, priority);\n        const attemptRecord: RetryAttempt = {\n          attempt: attempt + 1,\n          delay: 0,\n          timestamp: attemptStart,\n          error: retryableError,\n          duration: Date.now() - attemptStart\n        };\n        attempts.push(attemptRecord);\n\n        stats.totalAttempts++;\n        stats.lastFailure = Date.now();\n\n        // Handle rate limiting\n        if (retryableError.statusCode === 429) {\n          this.handleRateLimit(error);\n        }\n\n        // Check if we should retry\n        if (!this.shouldRetry(retryableError, attempt, priority, payloadSize)) {\n          stats.failedRetries++;\n          throw error;\n        }\n\n        // Calculate delay for next attempt\n        const delay = this.calculateDelay(attempt, priority, payloadSize);\n        attemptRecord.delay = delay;\n        \n        // Update stats\n        const totalDelay = attempts.reduce((sum, att) => sum + att.delay, 0);\n        stats.averageDelay = totalDelay / attempts.length;\n\n        // Wait before retry\n        if (delay > 0) {\n          await this.sleep(delay);\n        }\n\n        // Consume retry budget\n        this.consumeRetryBudget(priority);\n      }\n    }\n\n    // All retries exhausted\n    stats.failedRetries++;\n    throw new Error(`Max retry attempts (${this.config.maxAttempts}) exceeded for ${key}`);\n  }\n\n  private executeWithTimeout<T>(operation: () => Promise<T>, timeout: number): Promise<T> {\n    return Promise.race([\n      operation(),\n      new Promise<never>((_, reject) => \n        setTimeout(() => reject(new Error(`Operation timed out after ${timeout}ms`)), timeout)\n      )\n    ]);\n  }\n\n  private classifyError(error: any, priority: 'critical' | 'high' | 'medium' | 'low'): RetryableError {\n    // Network errors\n    if (error.name === 'TypeError' && error.message.includes('fetch')) {\n      return this.createRetryableError(0, error.message, 'network', true, priority);\n    }\n\n    // Timeout errors\n    if (error.message?.includes('timeout') || error.name === 'TimeoutError') {\n      return this.createRetryableError(0, error.message, 'timeout', true, priority);\n    }\n\n    // HTTP status code errors\n    if (error.status || error.statusCode) {\n      const status = error.status || error.statusCode;\n      \n      if (status >= 500) {\n        // Server errors - retryable\n        return this.createRetryableError(status, error.message, 'server', true, priority);\n      } else if (status === 429) {\n        // Rate limiting - retryable with backoff\n        return this.createRetryableError(status, error.message, 'server', true, priority);\n      } else if (status >= 400) {\n        // Client errors - mostly not retryable, except specific cases\n        const retryable = status === 408 || status === 409 || status === 423 || status === 424;\n        return this.createRetryableError(status, error.message, 'client', retryable, priority);\n      }\n    }\n\n    // Unknown errors - not retryable by default\n    return this.createRetryableError(0, error.message || 'Unknown error', 'unknown', false, priority);\n  }\n\n  private createRetryableError(\n    statusCode: number,\n    message: string,\n    type: RetryableError['type'],\n    retryable: boolean,\n    priority: 'critical' | 'high' | 'medium' | 'low'\n  ): RetryableError {\n    return {\n      statusCode,\n      message,\n      type,\n      retryable,\n      priority\n    };\n  }\n\n  private shouldRetry(\n    error: RetryableError,\n    attempt: number,\n    priority: 'critical' | 'high' | 'medium' | 'low',\n    payloadSize?: number\n  ): boolean {\n    // Don't retry if error is not retryable\n    if (!error.retryable) {\n      return false;\n    }\n\n    // Don't retry if we've exceeded max attempts\n    if (attempt >= this.config.maxAttempts - 1) {\n      return false;\n    }\n\n    // Don't retry if no budget available (except for critical priority)\n    if (priority !== 'critical' && !this.hasBudgetAvailable(priority)) {\n      return false;\n    }\n\n    // For large payloads, reduce retry attempts on slow connections\n    if (payloadSize && payloadSize > 100000) { // 100KB\n      const maxAttemptsForLargePayload = Math.max(2, this.config.maxAttempts - 2);\n      if (attempt >= maxAttemptsForLargePayload) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private calculateDelay(\n    attempt: number,\n    priority: 'critical' | 'high' | 'medium' | 'low',\n    payloadSize?: number\n  ): number {\n    // Base exponential backoff\n    let delay = Math.min(\n      this.config.baseDelay * Math.pow(2, attempt),\n      this.config.maxDelay\n    );\n\n    // Priority-based delay adjustment\n    const priorityMultipliers = {\n      critical: 0.5,\n      high: 0.7,\n      medium: 1.0,\n      low: 1.5\n    };\n    delay *= priorityMultipliers[priority];\n\n    // Payload size adjustment (larger payloads wait longer)\n    if (payloadSize && payloadSize > 50000) { // 50KB\n      const sizeMultiplier = Math.min(1 + (payloadSize / 100000), 2); // Max 2x delay\n      delay *= sizeMultiplier;\n    }\n\n    // Add jitter to prevent thundering herd\n    if (this.config.enableJitter) {\n      const jitter = delay * this.config.jitterRatio * (Math.random() - 0.5);\n      delay += jitter;\n    }\n\n    return Math.max(0, Math.floor(delay));\n  }\n\n  private handleRateLimit(error: any): void {\n    // Check for Retry-After header\n    const retryAfter = error.headers?.['retry-after'] || error.retryAfter;\n    \n    if (retryAfter) {\n      const retryAfterMs = parseInt(retryAfter) * 1000;\n      this.rateLimitedUntil = Date.now() + retryAfterMs;\n    } else {\n      // Default rate limit backoff\n      this.rateLimitedUntil = Date.now() + 60000; // 1 minute\n    }\n  }\n\n  private resetBudgetIfNeeded(): void {\n    const now = Date.now();\n    if (now - this.lastBudgetReset > this.budgetResetInterval) {\n      this.retryBudgetUsed = 0;\n      this.lastBudgetReset = now;\n    }\n  }\n\n  private hasBudgetAvailable(priority: 'critical' | 'high' | 'medium' | 'low'): boolean {\n    // Critical requests always have budget\n    if (priority === 'critical') {\n      return true;\n    }\n\n    // Reserve some budget for high priority requests\n    const reservedBudget = priority === 'high' ? this.config.retryBudget * 0.2 : this.config.retryBudget * 0.5;\n    \n    return this.retryBudgetUsed < (this.config.retryBudget - reservedBudget);\n  }\n\n  private consumeRetryBudget(priority: 'critical' | 'high' | 'medium' | 'low'): void {\n    // Critical requests don't consume budget\n    if (priority !== 'critical') {\n      this.retryBudgetUsed++;\n      \n      // Update stats\n      for (const stats of this.retryStats.values()) {\n        stats.budgetUsed = this.retryBudgetUsed / this.config.retryBudget;\n      }\n    }\n  }\n\n  private getOrCreateStats(key: string): RetryStats {\n    if (!this.retryStats.has(key)) {\n      this.retryStats.set(key, {\n        totalAttempts: 0,\n        successfulRetries: 0,\n        failedRetries: 0,\n        averageDelay: 0,\n        budgetUsed: 0\n      });\n    }\n    return this.retryStats.get(key)!;\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Get retry statistics for monitoring\n   */\n  getStats(key?: string): RetryStats | Map<string, RetryStats> {\n    if (key) {\n      return this.retryStats.get(key) || this.getOrCreateStats(key);\n    }\n    return new Map(this.retryStats);\n  }\n\n  /**\n   * Reset statistics (useful for testing)\n   */\n  resetStats(key?: string): void {\n    if (key) {\n      this.retryStats.delete(key);\n    } else {\n      this.retryStats.clear();\n      this.retryBudgetUsed = 0;\n      this.lastBudgetReset = Date.now();\n      this.requestDeduplication.clear();\n    }\n  }\n\n  /**\n   * Check if currently rate limited\n   */\n  isRateLimited(): boolean {\n    return Date.now() < this.rateLimitedUntil;\n  }\n\n  /**\n   * Get remaining retry budget\n   */\n  getRemainingBudget(): number {\n    this.resetBudgetIfNeeded();\n    return Math.max(0, this.config.retryBudget - this.retryBudgetUsed);\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(newConfig: Partial<RetryConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n  }\n}","/**\n * Multi-Level Circuit Breaker System\n * Prevents cascade failures and provides graceful degradation\n */\n\nexport type CircuitState = 'closed' | 'open' | 'half-open';\n\nexport interface CircuitBreakerConfig {\n  failureThreshold: number;\n  recoveryTime: number;\n  successThreshold: number;\n  timeout: number;\n  maxFailureRate: number;\n  windowSize: number;\n  minRequests: number;\n}\n\nexport interface CircuitMetrics {\n  requests: number;\n  failures: number;\n  successes: number;\n  failureRate: number;\n  averageResponseTime: number;\n  lastFailureTime?: number;\n  lastSuccessTime?: number;\n  state: CircuitState;\n  openTime?: number;\n  nextRetryTime?: number;\n}\n\nexport interface FeatureConfig {\n  name: string;\n  priority: 'critical' | 'high' | 'medium' | 'low';\n  fallbackEnabled: boolean;\n  gracefulDegradation: boolean;\n}\n\n/**\n * Individual Circuit Breaker for a single endpoint/feature\n */\nexport class CircuitBreaker {\n  private config: CircuitBreakerConfig;\n  private state: CircuitState = 'closed';\n  private metrics: CircuitMetrics;\n  private requestWindow: Array<{ timestamp: number; success: boolean; duration: number }> = [];\n  private listeners: Array<(state: CircuitState, metrics: CircuitMetrics) => void> = [];\n\n  constructor(\n    private name: string,\n    config: Partial<CircuitBreakerConfig> = {}\n  ) {\n    this.config = {\n      failureThreshold: 5,\n      recoveryTime: 60000, // 1 minute\n      successThreshold: 3,\n      timeout: 30000, // 30 seconds\n      maxFailureRate: 0.5, // 50%\n      windowSize: 60000, // 1 minute window\n      minRequests: 5,\n      ...config\n    };\n\n    this.metrics = {\n      requests: 0,\n      failures: 0,\n      successes: 0,\n      failureRate: 0,\n      averageResponseTime: 0,\n      state: this.state\n    };\n  }\n\n  /**\n   * Execute operation through circuit breaker\n   */\n  async execute<T>(operation: () => Promise<T>, fallback?: () => Promise<T>): Promise<T> {\n    // Check if circuit is open\n    if (this.state === 'open') {\n      if (Date.now() < (this.metrics.nextRetryTime || 0)) {\n        if (fallback) {\n          return await fallback();\n        }\n        throw new Error(`Circuit breaker ${this.name} is OPEN. Next retry: ${new Date(this.metrics.nextRetryTime!)}`);\n      }\n      \n      // Time to try half-open\n      this.transitionToHalfOpen();\n    }\n\n    // Execute operation\n    const startTime = Date.now();\n    \n    try {\n      const result = await Promise.race([\n        operation(),\n        new Promise<never>((_, reject) => \n          setTimeout(() => reject(new Error(`Circuit breaker timeout: ${this.config.timeout}ms`)), this.config.timeout)\n        )\n      ]);\n\n      // Success\n      const duration = Date.now() - startTime;\n      this.recordSuccess(duration);\n      return result;\n\n    } catch (error) {\n      // Failure\n      const duration = Date.now() - startTime;\n      this.recordFailure(duration);\n\n      // Try fallback if available\n      if (fallback) {\n        try {\n          return await fallback();\n        } catch (fallbackError) {\n          // Both primary and fallback failed\n          throw error; // Throw original error\n        }\n      }\n\n      throw error;\n    }\n  }\n\n  private recordSuccess(duration: number): void {\n    const now = Date.now();\n    \n    this.requestWindow.push({\n      timestamp: now,\n      success: true,\n      duration\n    });\n\n    this.cleanupOldRequests();\n    this.updateMetrics();\n\n    this.metrics.lastSuccessTime = now;\n\n    // State transitions\n    if (this.state === 'half-open') {\n      if (this.metrics.successes >= this.config.successThreshold) {\n        this.transitionToClosed();\n      }\n    }\n\n    this.notifyListeners();\n  }\n\n  private recordFailure(duration: number): void {\n    const now = Date.now();\n    \n    this.requestWindow.push({\n      timestamp: now,\n      success: false,\n      duration\n    });\n\n    this.cleanupOldRequests();\n    this.updateMetrics();\n\n    this.metrics.lastFailureTime = now;\n\n    // State transitions\n    if (this.state === 'closed' || this.state === 'half-open') {\n      if (this.shouldOpen()) {\n        this.transitionToOpen();\n      }\n    }\n\n    this.notifyListeners();\n  }\n\n  private shouldOpen(): boolean {\n    // Need minimum requests to make a decision\n    if (this.metrics.requests < this.config.minRequests) {\n      return false;\n    }\n\n    // Check failure threshold (absolute)\n    if (this.metrics.failures >= this.config.failureThreshold) {\n      return true;\n    }\n\n    // Check failure rate (percentage)\n    if (this.metrics.failureRate >= this.config.maxFailureRate) {\n      return true;\n    }\n\n    // For half-open state, any failure should open the circuit\n    if (this.state === 'half-open') {\n      return true;\n    }\n\n    return false;\n  }\n\n  private transitionToClosed(): void {\n    this.state = 'closed';\n    this.metrics.state = 'closed';\n    this.metrics.openTime = undefined;\n    this.metrics.nextRetryTime = undefined;\n    \n    // Reset failure counters but keep some history\n    this.metrics.failures = 0;\n    this.metrics.successes = 0;\n  }\n\n  private transitionToOpen(): void {\n    this.state = 'open';\n    this.metrics.state = 'open';\n    this.metrics.openTime = Date.now();\n    this.metrics.nextRetryTime = Date.now() + this.config.recoveryTime;\n  }\n\n  private transitionToHalfOpen(): void {\n    this.state = 'half-open';\n    this.metrics.state = 'half-open';\n    this.metrics.successes = 0; // Reset success counter for half-open test\n  }\n\n  private cleanupOldRequests(): void {\n    const cutoff = Date.now() - this.config.windowSize;\n    this.requestWindow = this.requestWindow.filter(req => req.timestamp > cutoff);\n  }\n\n  private updateMetrics(): void {\n    const totalRequests = this.requestWindow.length;\n    const successfulRequests = this.requestWindow.filter(req => req.success).length;\n    const failedRequests = totalRequests - successfulRequests;\n\n    this.metrics.requests = totalRequests;\n    this.metrics.successes = successfulRequests;\n    this.metrics.failures = failedRequests;\n    this.metrics.failureRate = totalRequests > 0 ? failedRequests / totalRequests : 0;\n    \n    // Calculate average response time\n    if (this.requestWindow.length > 0) {\n      const totalDuration = this.requestWindow.reduce((sum, req) => sum + req.duration, 0);\n      this.metrics.averageResponseTime = totalDuration / this.requestWindow.length;\n    }\n  }\n\n  /**\n   * Get current metrics\n   */\n  getMetrics(): CircuitMetrics {\n    this.cleanupOldRequests();\n    this.updateMetrics();\n    return { ...this.metrics };\n  }\n\n  /**\n   * Get current state\n   */\n  getState(): CircuitState {\n    return this.state;\n  }\n\n  /**\n   * Force state change (for testing)\n   */\n  forceState(state: CircuitState): void {\n    this.state = state;\n    this.metrics.state = state;\n    \n    if (state === 'open') {\n      this.metrics.openTime = Date.now();\n      this.metrics.nextRetryTime = Date.now() + this.config.recoveryTime;\n    }\n    \n    this.notifyListeners();\n  }\n\n  /**\n   * Reset circuit breaker\n   */\n  reset(): void {\n    this.state = 'closed';\n    this.requestWindow = [];\n    this.metrics = {\n      requests: 0,\n      failures: 0,\n      successes: 0,\n      failureRate: 0,\n      averageResponseTime: 0,\n      state: 'closed'\n    };\n    this.notifyListeners();\n  }\n\n  /**\n   * Listen for state changes\n   */\n  onStateChange(callback: (state: CircuitState, metrics: CircuitMetrics) => void): () => void {\n    this.listeners.push(callback);\n    return () => {\n      const index = this.listeners.indexOf(callback);\n      if (index > -1) {\n        this.listeners.splice(index, 1);\n      }\n    };\n  }\n\n  private notifyListeners(): void {\n    this.listeners.forEach(callback => {\n      try {\n        callback(this.state, { ...this.metrics });\n      } catch (error) {\n        console.error(`Circuit breaker ${this.name} listener error:`, error);\n      }\n    });\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(newConfig: Partial<CircuitBreakerConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n  }\n}\n\n/**\n * Multi-Level Circuit Breaker Manager\n */\nexport class CircuitBreakerManager {\n  private circuitBreakers = new Map<string, CircuitBreaker>();\n  private globalCircuitBreaker: CircuitBreaker;\n  private featureConfigs = new Map<string, FeatureConfig>();\n  private degradedFeatures = new Set<string>();\n  private listeners: Array<(event: string, data: any) => void> = [];\n\n  constructor() {\n    // Global circuit breaker with more lenient settings\n    this.globalCircuitBreaker = new CircuitBreaker('global', {\n      failureThreshold: 20,\n      maxFailureRate: 0.8,\n      recoveryTime: 30000, // 30 seconds\n      minRequests: 10\n    });\n\n    this.globalCircuitBreaker.onStateChange((state, metrics) => {\n      this.notifyListeners('global-state-change', { state, metrics });\n      \n      if (state === 'open') {\n        this.enableEmergencyMode();\n      } else if (state === 'closed') {\n        this.disableEmergencyMode();\n      }\n    });\n  }\n\n  /**\n   * Register a feature with circuit breaker protection\n   */\n  registerFeature(\n    name: string,\n    feature: FeatureConfig,\n    config?: Partial<CircuitBreakerConfig>\n  ): CircuitBreaker {\n    this.featureConfigs.set(name, feature);\n    \n    const circuitBreaker = new CircuitBreaker(name, {\n      // Priority-based configuration\n      failureThreshold: feature.priority === 'critical' ? 10 : feature.priority === 'high' ? 5 : 3,\n      maxFailureRate: feature.priority === 'critical' ? 0.8 : 0.5,\n      recoveryTime: feature.priority === 'critical' ? 30000 : 60000,\n      ...config\n    });\n\n    circuitBreaker.onStateChange((state, metrics) => {\n      this.handleFeatureStateChange(name, feature, state, metrics);\n    });\n\n    this.circuitBreakers.set(name, circuitBreaker);\n    return circuitBreaker;\n  }\n\n  /**\n   * Execute operation with multi-level protection\n   */\n  async executeProtected<T>(\n    featureName: string,\n    operation: () => Promise<T>,\n    fallback?: () => Promise<T>\n  ): Promise<T> {\n    // Check if feature exists\n    if (!this.circuitBreakers.has(featureName)) {\n      throw new Error(`Feature ${featureName} not registered with circuit breaker`);\n    }\n\n    const featureBreaker = this.circuitBreakers.get(featureName)!;\n    const featureConfig = this.featureConfigs.get(featureName)!;\n\n    // Check global circuit breaker first\n    if (this.globalCircuitBreaker.getState() === 'open') {\n      if (featureConfig.priority !== 'critical') {\n        if (fallback) {\n          return await fallback();\n        }\n        throw new Error('Global circuit breaker is OPEN. Only critical features allowed.');\n      }\n    }\n\n    // Check if feature is degraded\n    if (this.degradedFeatures.has(featureName)) {\n      if (featureConfig.gracefulDegradation && fallback) {\n        return await fallback();\n      }\n    }\n\n    // Execute through both global and feature-specific circuit breakers\n    return await this.globalCircuitBreaker.execute(\n      () => featureBreaker.execute(operation, fallback),\n      fallback\n    );\n  }\n\n  private handleFeatureStateChange(\n    featureName: string,\n    feature: FeatureConfig,\n    state: CircuitState,\n    metrics: CircuitMetrics\n  ): void {\n    this.notifyListeners('feature-state-change', { featureName, feature, state, metrics });\n\n    if (state === 'open') {\n      // Feature circuit opened\n      if (feature.gracefulDegradation) {\n        this.degradedFeatures.add(featureName);\n        this.notifyListeners('feature-degraded', { featureName, feature });\n      }\n\n      // Disable non-critical features if too many are failing\n      if (feature.priority !== 'critical') {\n        this.evaluateSystemHealth();\n      }\n\n    } else if (state === 'closed') {\n      // Feature circuit closed\n      if (this.degradedFeatures.has(featureName)) {\n        this.degradedFeatures.delete(featureName);\n        this.notifyListeners('feature-recovered', { featureName, feature });\n      }\n    }\n  }\n\n  private evaluateSystemHealth(): void {\n    const totalFeatures = this.circuitBreakers.size;\n    const failedFeatures = Array.from(this.circuitBreakers.values())\n      .filter(cb => cb.getState() === 'open').length;\n    \n    const failureRate = failedFeatures / totalFeatures;\n\n    // If too many features are failing, enable progressive degradation\n    if (failureRate > 0.3) { // 30% of features failing\n      this.enableProgressiveDegradation();\n    } else if (failureRate < 0.1) { // Less than 10% failing\n      this.disableProgressiveDegradation();\n    }\n  }\n\n  private enableEmergencyMode(): void {\n    this.notifyListeners('emergency-mode-enabled', { timestamp: Date.now() });\n    \n    // Degrade all non-critical features\n    this.featureConfigs.forEach((config, name) => {\n      if (config.priority !== 'critical') {\n        this.degradedFeatures.add(name);\n      }\n    });\n  }\n\n  private disableEmergencyMode(): void {\n    this.notifyListeners('emergency-mode-disabled', { timestamp: Date.now() });\n    \n    // Re-enable features based on their individual circuit breaker states\n    this.degradedFeatures.forEach(featureName => {\n      const breaker = this.circuitBreakers.get(featureName);\n      if (breaker && breaker.getState() !== 'open') {\n        this.degradedFeatures.delete(featureName);\n      }\n    });\n  }\n\n  private enableProgressiveDegradation(): void {\n    this.notifyListeners('progressive-degradation-enabled', { timestamp: Date.now() });\n    \n    // Degrade low priority features first\n    this.featureConfigs.forEach((config, name) => {\n      if (config.priority === 'low' && config.gracefulDegradation) {\n        this.degradedFeatures.add(name);\n      }\n    });\n  }\n\n  private disableProgressiveDegradation(): void {\n    this.notifyListeners('progressive-degradation-disabled', { timestamp: Date.now() });\n    \n    // Re-enable low priority features\n    this.featureConfigs.forEach((config, name) => {\n      if (config.priority === 'low') {\n        const breaker = this.circuitBreakers.get(name);\n        if (breaker && breaker.getState() !== 'open') {\n          this.degradedFeatures.delete(name);\n        }\n      }\n    });\n  }\n\n  /**\n   * Get system health overview\n   */\n  getSystemHealth(): {\n    globalState: CircuitState;\n    featuresTotal: number;\n    featuresHealthy: number;\n    featuresFailed: number;\n    featuresDegraded: number;\n    emergencyMode: boolean;\n    progressiveDegradation: boolean;\n  } {\n    const featuresTotal = this.circuitBreakers.size;\n    const featuresFailed = Array.from(this.circuitBreakers.values())\n      .filter(cb => cb.getState() === 'open').length;\n    const featuresHealthy = featuresTotal - featuresFailed;\n    const featuresDegraded = this.degradedFeatures.size;\n\n    return {\n      globalState: this.globalCircuitBreaker.getState(),\n      featuresTotal,\n      featuresHealthy,\n      featuresFailed,\n      featuresDegraded,\n      emergencyMode: this.globalCircuitBreaker.getState() === 'open',\n      progressiveDegradation: featuresDegraded > 0\n    };\n  }\n\n  /**\n   * Get metrics for all circuit breakers\n   */\n  getAllMetrics(): Map<string, CircuitMetrics> {\n    const metrics = new Map<string, CircuitMetrics>();\n    \n    metrics.set('global', this.globalCircuitBreaker.getMetrics());\n    \n    this.circuitBreakers.forEach((breaker, name) => {\n      metrics.set(name, breaker.getMetrics());\n    });\n\n    return metrics;\n  }\n\n  /**\n   * Get specific circuit breaker\n   */\n  getCircuitBreaker(featureName: string): CircuitBreaker | undefined {\n    return this.circuitBreakers.get(featureName);\n  }\n\n  /**\n   * Check if feature is degraded\n   */\n  isFeatureDegraded(featureName: string): boolean {\n    return this.degradedFeatures.has(featureName);\n  }\n\n  /**\n   * Reset all circuit breakers\n   */\n  resetAll(): void {\n    this.globalCircuitBreaker.reset();\n    this.circuitBreakers.forEach(breaker => breaker.reset());\n    this.degradedFeatures.clear();\n  }\n\n  /**\n   * Listen for circuit breaker events\n   */\n  onEvent(callback: (event: string, data: any) => void): () => void {\n    this.listeners.push(callback);\n    return () => {\n      const index = this.listeners.indexOf(callback);\n      if (index > -1) {\n        this.listeners.splice(index, 1);\n      }\n    };\n  }\n\n  private notifyListeners(event: string, data: any): void {\n    this.listeners.forEach(callback => {\n      try {\n        callback(event, data);\n      } catch (error) {\n        console.error(`Circuit breaker manager listener error:`, error);\n      }\n    });\n  }\n\n  /**\n   * Execute operation with circuit breaker protection\n   */\n  executeWithBreaker<T>(\n    featureName: string,\n    operation: () => Promise<T>,\n    options: {\n      priority?: 'critical' | 'high' | 'medium' | 'low';\n      region?: string;\n      degradeGracefully?: boolean;\n      degradedResponse?: any;\n    } = {}\n  ): Promise<T> {\n    const { priority = 'medium', degradeGracefully = false, degradedResponse } = options;\n    \n    const featureConfig: FeatureConfig = {\n      name: featureName,\n      priority,\n      fallbackEnabled: degradeGracefully,\n      gracefulDegradation: degradeGracefully\n    };\n\n    const fallback = degradeGracefully ? () => Promise.resolve(degradedResponse) : undefined;\n    \n    this.registerFeature(featureName, featureConfig);\n    const circuitBreaker = this.circuitBreakers.get(featureName);\n    \n    if (!circuitBreaker) {\n      throw new Error(`Circuit breaker for feature '${featureName}' not found`);\n    }\n    \n    return circuitBreaker.execute(operation, fallback);\n  }\n\n  /**\n   * Update global configuration\n   */\n  updateGlobalConfig(config: Partial<CircuitBreakerConfig>): void {\n    this.globalCircuitBreaker.updateConfig(config);\n  }\n\n  /**\n   * Get global statistics\n   */\n  getGlobalStats(): any {\n    return {\n      global: this.globalCircuitBreaker.getMetrics(),\n      features: Object.fromEntries(this.getAllMetrics()),\n      systemHealth: this.getSystemHealth(),\n      degradedFeatures: Array.from(this.degradedFeatures)\n    };\n  }\n\n  /**\n   * Reset all statistics\n   */\n  resetStats(): void {\n    this.resetAll();\n  }\n}","/**\n * Resilient Storage System with Prioritization and Quota Management\n * Multi-tier storage with intelligent data management\n */\n\nimport { ErrorEvent, SessionEvent, NetworkEvent } from './types';\nimport { compressData, deduplicateEvents } from './compression-utils';\n\nexport interface StorageQuota {\n  total: number;\n  used: number;\n  available: number;\n  percentage: number;\n}\n\nexport interface StorageTier {\n  name: 'hot' | 'warm' | 'cold';\n  maxSize: number;\n  compressionEnabled: boolean;\n  encryptionEnabled: boolean;\n  retentionTime: number; // milliseconds\n  priority: number; // 1 = highest\n}\n\nexport interface StoredItem<T = any> {\n  id: string;\n  data: T;\n  priority: 'critical' | 'high' | 'medium' | 'low';\n  timestamp: number;\n  size: number;\n  compressed: boolean;\n  encrypted: boolean;\n  retryCount: number;\n  tier: StorageTier['name'];\n  expiresAt?: number;\n  checksum?: string;\n}\n\nexport interface StorageStats {\n  totalItems: number;\n  totalSize: number;\n  itemsByPriority: Record<string, number>;\n  itemsByTier: Record<string, number>;\n  compressionRatio: number;\n  oldestItem?: number;\n  newestItem?: number;\n  quotaUsage: StorageQuota;\n}\n\n/**\n * Multi-tier storage with intelligent data management\n */\nexport class ResilientStorage {\n  private tiers: Map<StorageTier['name'], StorageTier> = new Map();\n  private indexedDB: IDBDatabase | null = null;\n  private localStorage: Storage | null = null;\n  private memoryStore: Map<string, StoredItem> = new Map();\n  private quotaManager: StorageQuotaManager;\n  private initialized = false;\n  private compressionWorker: Worker | null = null;\n\n  constructor() {\n    this.initializeTiers();\n    this.quotaManager = new StorageQuotaManager();\n    this.initializeCompressionWorker();\n  }\n\n  private initializeTiers(): void {\n    // Hot tier: In-memory, immediate access, critical data\n    this.tiers.set('hot', {\n      name: 'hot',\n      maxSize: 5 * 1024 * 1024, // 5MB\n      compressionEnabled: false,\n      encryptionEnabled: false,\n      retentionTime: 5 * 60 * 1000, // 5 minutes\n      priority: 1\n    });\n\n    // Warm tier: IndexedDB, fast access, important data\n    this.tiers.set('warm', {\n      name: 'warm',\n      maxSize: 50 * 1024 * 1024, // 50MB\n      compressionEnabled: true,\n      encryptionEnabled: false,\n      retentionTime: 24 * 60 * 60 * 1000, // 24 hours\n      priority: 2\n    });\n\n    // Cold tier: LocalStorage, slower access, archived data\n    this.tiers.set('cold', {\n      name: 'cold',\n      maxSize: 10 * 1024 * 1024, // 10MB (localStorage limit)\n      compressionEnabled: true,\n      encryptionEnabled: true,\n      retentionTime: 7 * 24 * 60 * 60 * 1000, // 7 days\n      priority: 3\n    });\n  }\n\n  private async initializeCompressionWorker(): Promise<void> {\n    if (typeof Worker !== 'undefined') {\n      try {\n        // Create compression worker for background processing\n        const workerCode = `\n          self.onmessage = function(e) {\n            const { action, data, id } = e.data;\n            \n            if (action === 'compress') {\n              // Simple compression simulation\n              const compressed = JSON.stringify(data);\n              self.postMessage({ id, result: compressed, compressed: true });\n            } else if (action === 'decompress') {\n              try {\n                const decompressed = JSON.parse(data);\n                self.postMessage({ id, result: decompressed, compressed: false });\n              } catch (error) {\n                self.postMessage({ id, error: error.message });\n              }\n            }\n          };\n        `;\n        \n        const blob = new Blob([workerCode], { type: 'application/javascript' });\n        this.compressionWorker = new Worker(URL.createObjectURL(blob));\n      } catch (error) {\n        console.warn('[ResilientStorage] Compression worker not available:', error);\n      }\n    }\n  }\n\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n\n    await Promise.all([\n      this.initializeIndexedDB(),\n      this.initializeLocalStorage(),\n      this.quotaManager.initialize()\n    ]);\n\n    // Start background cleanup\n    this.startBackgroundCleanup();\n    \n    this.initialized = true;\n  }\n\n  private async initializeIndexedDB(): Promise<void> {\n    if (typeof window === 'undefined' || !window.indexedDB) return;\n\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open('ReviResilientStorage', 1);\n      \n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => {\n        this.indexedDB = request.result;\n        resolve();\n      };\n      \n      request.onupgradeneeded = () => {\n        const db = request.result;\n        \n        // Create stores for each data type\n        if (!db.objectStoreNames.contains('errors')) {\n          db.createObjectStore('errors', { keyPath: 'id' });\n        }\n        if (!db.objectStoreNames.contains('sessions')) {\n          db.createObjectStore('sessions', { keyPath: 'id' });\n        }\n        if (!db.objectStoreNames.contains('network')) {\n          db.createObjectStore('network', { keyPath: 'id' });\n        }\n        if (!db.objectStoreNames.contains('metadata')) {\n          db.createObjectStore('metadata', { keyPath: 'key' });\n        }\n      };\n    });\n  }\n\n  private initializeLocalStorage(): void {\n    if (typeof window !== 'undefined' && window.localStorage) {\n      this.localStorage = window.localStorage;\n    }\n  }\n\n  /**\n   * Store data with intelligent tier selection\n   */\n  async store<T>(\n    type: 'error' | 'session' | 'network',\n    data: T,\n    options: {\n      priority?: 'critical' | 'high' | 'medium' | 'low';\n      ttl?: number;\n      forceSync?: boolean;\n    } = {}\n  ): Promise<string> {\n    if (!this.initialized) {\n      await this.initialize();\n    }\n\n    const { priority = 'medium', ttl, forceSync = false } = options;\n    \n    // Generate unique ID\n    const id = this.generateId(type);\n    \n    // Calculate data size\n    const dataSize = this.calculateSize(data);\n    \n    // Determine optimal tier\n    const tier = this.selectOptimalTier(priority, dataSize, forceSync);\n    \n    // Create storage item\n    const item: StoredItem<T> = {\n      id,\n      data,\n      priority,\n      timestamp: Date.now(),\n      size: dataSize,\n      compressed: false,\n      encrypted: false,\n      retryCount: 0,\n      tier: tier.name,\n      expiresAt: ttl ? Date.now() + ttl : undefined,\n      checksum: this.calculateChecksum(data)\n    };\n\n    // Store in selected tier\n    await this.storeInTier(item, tier);\n    \n    return id;\n  }\n\n  private selectOptimalTier(\n    priority: 'critical' | 'high' | 'medium' | 'low',\n    dataSize: number,\n    forceSync: boolean\n  ): StorageTier {\n    // Critical data or force sync -> hot tier\n    if (priority === 'critical' || forceSync) {\n      return this.tiers.get('hot')!;\n    }\n\n    // High priority or small data -> warm tier\n    if (priority === 'high' || dataSize < 10240) { // < 10KB\n      return this.tiers.get('warm')!;\n    }\n\n    // Everything else -> cold tier\n    return this.tiers.get('cold')!;\n  }\n\n  private async storeInTier<T>(item: StoredItem<T>, tier: StorageTier): Promise<void> {\n    // Check quota before storing\n    if (!await this.checkQuotaAvailable(tier, item.size)) {\n      await this.makeSpace(tier, item.size);\n    }\n\n    switch (tier.name) {\n      case 'hot':\n        await this.storeInMemory(item);\n        break;\n      case 'warm':\n        await this.storeInIndexedDB(item, tier);\n        break;\n      case 'cold':\n        await this.storeInLocalStorage(item, tier);\n        break;\n    }\n  }\n\n  private async storeInMemory<T>(item: StoredItem<T>): Promise<void> {\n    this.memoryStore.set(item.id, item);\n  }\n\n  private async storeInIndexedDB<T>(item: StoredItem<T>, tier: StorageTier): Promise<void> {\n    if (!this.indexedDB) throw new Error('IndexedDB not available');\n\n    // Compress data if enabled\n    if (tier.compressionEnabled) {\n      const compressed = await this.compressData(item.data);\n      if (compressed.compressed) {\n        item.data = compressed.data as T;\n        item.compressed = true;\n        item.size = this.calculateSize(item.data);\n      }\n    }\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.indexedDB!.transaction(['errors', 'sessions', 'network'], 'readwrite');\n      const store = transaction.objectStore(this.getStoreNameFromId(item.id));\n      \n      const request = store.put(item);\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  private async storeInLocalStorage<T>(item: StoredItem<T>, tier: StorageTier): Promise<void> {\n    if (!this.localStorage) throw new Error('LocalStorage not available');\n\n    // Compress and encrypt data if enabled\n    let processedData = item.data;\n    \n    if (tier.compressionEnabled) {\n      const compressed = await this.compressData(processedData);\n      if (compressed.compressed) {\n        processedData = compressed.data;\n        item.compressed = true;\n      }\n    }\n\n    if (tier.encryptionEnabled) {\n      processedData = await this.encryptData(processedData);\n      item.encrypted = true;\n    }\n\n    item.data = processedData as T;\n    item.size = this.calculateSize(item.data);\n\n    try {\n      this.localStorage.setItem(`revi_${item.id}`, JSON.stringify(item));\n    } catch (error) {\n      if (error instanceof Error && error.name === 'QuotaExceededError') {\n        await this.makeSpace(tier, item.size);\n        this.localStorage.setItem(`revi_${item.id}`, JSON.stringify(item));\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  /**\n   * Retrieve data with automatic tier searching\n   */\n  async retrieve<T>(id: string): Promise<StoredItem<T> | null> {\n    if (!this.initialized) {\n      await this.initialize();\n    }\n\n    // Search in priority order: hot -> warm -> cold\n    const tiers: StorageTier['name'][] = ['hot', 'warm', 'cold'];\n    \n    for (const tierName of tiers) {\n      const item = await this.retrieveFromTier<T>(id, tierName);\n      if (item) {\n        // Validate item integrity\n        if (!this.validateItemIntegrity(item)) {\n          console.warn(`[ResilientStorage] Data integrity check failed for ${id}`);\n          continue;\n        }\n        \n        // Promote frequently accessed data to higher tier\n        if (tierName !== 'hot' && this.shouldPromote(item)) {\n          await this.promoteItem(item);\n        }\n        \n        return item;\n      }\n    }\n    \n    return null;\n  }\n\n  private async retrieveFromTier<T>(id: string, tierName: StorageTier['name']): Promise<StoredItem<T> | null> {\n    switch (tierName) {\n      case 'hot':\n        return this.memoryStore.get(id) as StoredItem<T> || null;\n      case 'warm':\n        return this.retrieveFromIndexedDB<T>(id);\n      case 'cold':\n        return this.retrieveFromLocalStorage<T>(id);\n    }\n  }\n\n  private async retrieveFromIndexedDB<T>(id: string): Promise<StoredItem<T> | null> {\n    if (!this.indexedDB) return null;\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.indexedDB!.transaction(['errors', 'sessions', 'network'], 'readonly');\n      const store = transaction.objectStore(this.getStoreNameFromId(id));\n      \n      const request = store.get(id);\n      request.onsuccess = async () => {\n        const item = request.result as StoredItem<T>;\n        if (item && item.compressed) {\n          const decompressed = await this.decompressData(item.data);\n          item.data = decompressed as T;\n          item.compressed = false;\n        }\n        resolve(item || null);\n      };\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  private async retrieveFromLocalStorage<T>(id: string): Promise<StoredItem<T> | null> {\n    if (!this.localStorage) return null;\n\n    try {\n      const itemJson = this.localStorage.getItem(`revi_${id}`);\n      if (!itemJson) return null;\n\n      const item = JSON.parse(itemJson) as StoredItem<T>;\n      \n      // Decrypt if encrypted\n      if (item.encrypted) {\n        item.data = await this.decryptData(item.data);\n        item.encrypted = false;\n      }\n      \n      // Decompress if compressed\n      if (item.compressed) {\n        const decompressed = await this.decompressData(item.data);\n        item.data = decompressed as T;\n        item.compressed = false;\n      }\n      \n      return item;\n    } catch (error) {\n      console.error(`[ResilientStorage] Failed to retrieve ${id}:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Get all items by type with priority ordering\n   */\n  async getAllByType<T>(type: 'error' | 'session' | 'network'): Promise<StoredItem<T>[]> {\n    if (!this.initialized) {\n      await this.initialize();\n    }\n\n    const items: StoredItem<T>[] = [];\n    \n    // Collect from all tiers\n    for (const tierName of ['hot', 'warm', 'cold'] as const) {\n      const tierItems = await this.getAllFromTier<T>(type, tierName);\n      items.push(...tierItems);\n    }\n\n    // Sort by priority and timestamp\n    return items.sort((a, b) => {\n      const priorityOrder = { critical: 0, high: 1, medium: 2, low: 3 };\n      const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority];\n      \n      if (priorityDiff !== 0) return priorityDiff;\n      return a.timestamp - b.timestamp; // Older first\n    });\n  }\n\n  private async getAllFromTier<T>(type: string, tierName: StorageTier['name']): Promise<StoredItem<T>[]> {\n    switch (tierName) {\n      case 'hot':\n        return Array.from(this.memoryStore.values())\n          .filter(item => item.id.startsWith(type)) as StoredItem<T>[];\n      case 'warm':\n        return this.getAllFromIndexedDB<T>(type);\n      case 'cold':\n        return this.getAllFromLocalStorage<T>(type);\n    }\n  }\n\n  private async getAllFromIndexedDB<T>(type: string): Promise<StoredItem<T>[]> {\n    if (!this.indexedDB) return [];\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.indexedDB!.transaction([this.getStoreName(type)], 'readonly');\n      const store = transaction.objectStore(this.getStoreName(type));\n      \n      const request = store.getAll();\n      request.onsuccess = async () => {\n        const items = request.result as StoredItem<T>[];\n        \n        // Decompress items if needed\n        for (const item of items) {\n          if (item.compressed) {\n            const decompressed = await this.decompressData(item.data);\n            item.data = decompressed as T;\n            item.compressed = false;\n          }\n        }\n        \n        resolve(items);\n      };\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  private async getAllFromLocalStorage<T>(type: string): Promise<StoredItem<T>[]> {\n    if (!this.localStorage) return [];\n\n    const items: StoredItem<T>[] = [];\n    \n    for (let i = 0; i < this.localStorage.length; i++) {\n      const key = this.localStorage.key(i);\n      if (key && key.startsWith(`revi_${type}`)) {\n        try {\n          const itemJson = this.localStorage.getItem(key);\n          if (itemJson) {\n            const item = JSON.parse(itemJson) as StoredItem<T>;\n            \n            // Decrypt and decompress if needed\n            if (item.encrypted) {\n              item.data = await this.decryptData(item.data);\n              item.encrypted = false;\n            }\n            if (item.compressed) {\n              const decompressed = await this.decompressData(item.data);\n              item.data = decompressed as T;\n              item.compressed = false;\n            }\n            \n            items.push(item);\n          }\n        } catch (error) {\n          console.error(`[ResilientStorage] Failed to parse item ${key}:`, error);\n        }\n      }\n    }\n    \n    return items;\n  }\n\n  /**\n   * Remove item from all tiers\n   */\n  async remove(id: string): Promise<void> {\n    // Remove from all tiers\n    this.memoryStore.delete(id);\n    \n    if (this.indexedDB) {\n      const transaction = this.indexedDB.transaction(['errors', 'sessions', 'network'], 'readwrite');\n      const store = transaction.objectStore(this.getStoreNameFromId(id));\n      store.delete(id);\n    }\n    \n    if (this.localStorage) {\n      this.localStorage.removeItem(`revi_${id}`);\n    }\n  }\n\n  /**\n   * Clear all data\n   */\n  async clear(): Promise<void> {\n    this.memoryStore.clear();\n    \n    if (this.indexedDB) {\n      const transaction = this.indexedDB.transaction(['errors', 'sessions', 'network'], 'readwrite');\n      transaction.objectStore('errors').clear();\n      transaction.objectStore('sessions').clear();\n      transaction.objectStore('network').clear();\n    }\n    \n    if (this.localStorage) {\n      const keysToRemove: string[] = [];\n      for (let i = 0; i < this.localStorage.length; i++) {\n        const key = this.localStorage.key(i);\n        if (key && key.startsWith('revi_')) {\n          keysToRemove.push(key);\n        }\n      }\n      keysToRemove.forEach(key => this.localStorage!.removeItem(key));\n    }\n  }\n\n  private async checkQuotaAvailable(tier: StorageTier, requiredSize: number): Promise<boolean> {\n    const usage = await this.quotaManager.getUsage(tier.name);\n    return (usage.available >= requiredSize);\n  }\n\n  private async makeSpace(tier: StorageTier, requiredSize: number): Promise<void> {\n    // Remove expired items first\n    await this.cleanupExpiredItems(tier);\n    \n    // Check if we have enough space now\n    if (await this.checkQuotaAvailable(tier, requiredSize)) {\n      return;\n    }\n    \n    // Remove old, low-priority items\n    await this.evictLowPriorityItems(tier, requiredSize);\n  }\n\n  private async cleanupExpiredItems(tier: StorageTier): Promise<void> {\n    const now = Date.now();\n    \n    switch (tier.name) {\n      case 'hot':\n        for (const [id, item] of this.memoryStore) {\n          if ((item.expiresAt && now > item.expiresAt) || \n              (now - item.timestamp > tier.retentionTime)) {\n            this.memoryStore.delete(id);\n          }\n        }\n        break;\n        \n      case 'warm':\n        if (this.indexedDB) {\n          // Implementation for IndexedDB cleanup\n          const stores = ['errors', 'sessions', 'network'];\n          for (const storeName of stores) {\n            await this.cleanupIndexedDBStore(storeName, tier.retentionTime);\n          }\n        }\n        break;\n        \n      case 'cold':\n        if (this.localStorage) {\n          await this.cleanupLocalStorage(tier.retentionTime);\n        }\n        break;\n    }\n  }\n\n  private async evictLowPriorityItems(tier: StorageTier, requiredSize: number): Promise<void> {\n    // Get items sorted by priority (low priority first) and age (old first)\n    const priorityOrder = { low: 0, medium: 1, high: 2, critical: 3 };\n    let evictedSize = 0;\n    \n    // This is a simplified implementation - in practice, you'd implement\n    // more sophisticated eviction policies per tier\n    if (tier.name === 'hot') {\n      const sortedItems = Array.from(this.memoryStore.values()).sort((a, b) => {\n        const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority];\n        if (priorityDiff !== 0) return priorityDiff;\n        return a.timestamp - b.timestamp;\n      });\n      \n      for (const item of sortedItems) {\n        if (evictedSize >= requiredSize) break;\n        this.memoryStore.delete(item.id);\n        evictedSize += item.size;\n      }\n    }\n  }\n\n  // Helper methods\n  private generateId(type: string): string {\n    return `${type}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private calculateSize(data: any): number {\n    return JSON.stringify(data).length * 2; // Rough estimation (UTF-16)\n  }\n\n  private calculateChecksum(data: any): string {\n    // Simple checksum using JSON string hash\n    const str = JSON.stringify(data);\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    return hash.toString();\n  }\n\n  private validateItemIntegrity(item: StoredItem): boolean {\n    if (!item.checksum) return true; // No checksum to validate\n    \n    const currentChecksum = this.calculateChecksum(item.data);\n    return currentChecksum === item.checksum;\n  }\n\n  private shouldPromote(item: StoredItem): boolean {\n    // Promote critical items or frequently accessed items\n    return item.priority === 'critical' || \n           (item.priority === 'high' && Date.now() - item.timestamp < 300000); // 5 minutes\n  }\n\n  private async promoteItem<T>(item: StoredItem<T>): Promise<void> {\n    // Move item to hot tier\n    const hotTier = this.tiers.get('hot')!;\n    await this.storeInTier(item, hotTier);\n    \n    // Remove from current tier (this is simplified)\n    await this.remove(item.id);\n  }\n\n  private async compressData(data: any): Promise<{ data: any; compressed: boolean }> {\n    if (this.compressionWorker) {\n      // Use web worker for compression\n      return new Promise((resolve) => {\n        const id = Math.random().toString();\n        \n        const handleMessage = (e: MessageEvent) => {\n          if (e.data.id === id) {\n            this.compressionWorker!.removeEventListener('message', handleMessage);\n            resolve({ data: e.data.result, compressed: e.data.compressed });\n          }\n        };\n        \n        this.compressionWorker.addEventListener('message', handleMessage);\n        this.compressionWorker.postMessage({ action: 'compress', data, id });\n      });\n    }\n    \n    // Fallback to synchronous compression\n    try {\n      const result = await compressData(data);\n      return { data: result.data, compressed: result.compressed };\n    } catch (error) {\n      return { data, compressed: false };\n    }\n  }\n\n  private async decompressData(data: any): Promise<any> {\n    if (this.compressionWorker) {\n      return new Promise((resolve, reject) => {\n        const id = Math.random().toString();\n        \n        const handleMessage = (e: MessageEvent) => {\n          if (e.data.id === id) {\n            this.compressionWorker!.removeEventListener('message', handleMessage);\n            if (e.data.error) {\n              reject(new Error(e.data.error));\n            } else {\n              resolve(e.data.result);\n            }\n          }\n        };\n        \n        this.compressionWorker.addEventListener('message', handleMessage);\n        this.compressionWorker.postMessage({ action: 'decompress', data, id });\n      });\n    }\n    \n    // Fallback\n    return typeof data === 'string' ? JSON.parse(data) : data;\n  }\n\n  private async encryptData(data: any): Promise<any> {\n    // Simple encryption simulation - in production, use proper encryption\n    const str = JSON.stringify(data);\n    return btoa(str); // Base64 encoding as simulation\n  }\n\n  private async decryptData(encryptedData: any): Promise<any> {\n    // Simple decryption simulation\n    try {\n      const str = atob(encryptedData);\n      return JSON.parse(str);\n    } catch (error) {\n      throw new Error('Failed to decrypt data');\n    }\n  }\n\n  private getStoreName(type: string): string {\n    switch (type) {\n      case 'error': return 'errors';\n      case 'session': return 'sessions';\n      case 'network': return 'network';\n      default: return 'errors';\n    }\n  }\n\n  private getStoreNameFromId(id: string): string {\n    if (id.startsWith('error_')) return 'errors';\n    if (id.startsWith('session_')) return 'sessions';\n    if (id.startsWith('network_')) return 'network';\n    return 'errors';\n  }\n\n  private async cleanupIndexedDBStore(storeName: string, retentionTime: number): Promise<void> {\n    // Implementation for cleaning up expired items from IndexedDB\n    // This is a placeholder - implement based on your needs\n  }\n\n  private async cleanupLocalStorage(retentionTime: number): Promise<void> {\n    if (!this.localStorage) return;\n    \n    const now = Date.now();\n    const keysToRemove: string[] = [];\n    \n    for (let i = 0; i < this.localStorage.length; i++) {\n      const key = this.localStorage.key(i);\n      if (key && key.startsWith('revi_')) {\n        try {\n          const itemJson = this.localStorage.getItem(key);\n          if (itemJson) {\n            const item = JSON.parse(itemJson);\n            if (now - item.timestamp > retentionTime) {\n              keysToRemove.push(key);\n            }\n          }\n        } catch (error) {\n          // Invalid item, remove it\n          keysToRemove.push(key);\n        }\n      }\n    }\n    \n    keysToRemove.forEach(key => this.localStorage!.removeItem(key));\n  }\n\n  private startBackgroundCleanup(): void {\n    // Run cleanup every 5 minutes\n    setInterval(() => {\n      this.tiers.forEach(async (tier) => {\n        await this.cleanupExpiredItems(tier);\n      });\n    }, 5 * 60 * 1000);\n  }\n\n  /**\n   * Store data with resilience features\n   */\n  async storeData(key: string, data: any, options: {\n    priority: 'critical' | 'high' | 'medium' | 'low';\n    tier?: 'hot' | 'warm' | 'cold';\n    compress?: boolean;\n    encrypt?: boolean;\n  }): Promise<void> {\n    const tier = this.selectOptimalTier(options.priority, JSON.stringify(data).length);\n    const storage = this.storageProviders.get(tier);\n    if (!storage) {\n      throw new Error(`Storage tier ${tier} not available`);\n    }\n\n    let processedData = data;\n    if (options.compress) {\n      processedData = this.compressData(data);\n    }\n\n    await storage.setItem(key, JSON.stringify({\n      data: processedData,\n      metadata: {\n        priority: options.priority,\n        tier,\n        compressed: options.compress || false,\n        timestamp: Date.now()\n      }\n    }));\n  }\n\n  /**\n   * Get stored data\n   */\n  async getData(key: string): Promise<any> {\n    for (const [tierName, storage] of this.storageProviders) {\n      try {\n        const item = await storage.getItem(key);\n        if (item) {\n          const parsed = JSON.parse(item);\n          return parsed.metadata?.compressed ? this.decompressData(parsed.data) : parsed.data;\n        }\n      } catch (error) {\n        console.warn(`Failed to read from ${tierName}:`, error);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Delete stored data\n   */\n  async deleteData(key: string): Promise<void> {\n    await Promise.all(\n      Array.from(this.storageProviders.values()).map(storage =>\n        storage.removeItem(key).catch(() => {}) // Ignore errors\n      )\n    );\n  }\n\n  /**\n   * Get all data matching pattern\n   */\n  async getAllDataByPattern(pattern: string): Promise<Array<{key: string, data: any, metadata?: any}>> {\n    const results: Array<{key: string, data: any, metadata?: any}> = [];\n    const regex = new RegExp(pattern.replace('*', '.*'));\n\n    for (const [tierName, storage] of this.storageProviders) {\n      try {\n        for (let i = 0; i < storage.length; i++) {\n          const key = storage.key(i);\n          if (key && regex.test(key)) {\n            const item = await storage.getItem(key);\n            if (item) {\n              const parsed = JSON.parse(item);\n              results.push({\n                key,\n                data: parsed.metadata?.compressed ? this.decompressData(parsed.data) : parsed.data,\n                metadata: parsed.metadata\n              });\n            }\n          }\n        }\n      } catch (error) {\n        console.warn(`Failed to scan ${tierName}:`, error);\n      }\n    }\n\n    return results;\n  }\n\n  private selectOptimalTier(priority: string, dataSize: number): 'hot' | 'warm' | 'cold' {\n    if (priority === 'critical') return 'hot';\n    if (priority === 'high' && dataSize < 10000) return 'hot';\n    if (priority === 'low' || dataSize > 100000) return 'cold';\n    return 'warm';\n  }\n\n  private compressData(data: any): any {\n    // Simple compression simulation\n    return data;\n  }\n\n  private decompressData(data: any): any {\n    // Simple decompression simulation\n    return data;\n  }\n\n  /**\n   * Get storage statistics\n   */\n  async getStats(): Promise<StorageStats> {\n    // Implementation placeholder\n    const stats: StorageStats = {\n      totalItems: 0,\n      totalSize: 0,\n      itemsByPriority: { critical: 0, high: 0, medium: 0, low: 0 },\n      itemsByTier: { hot: 0, warm: 0, cold: 0 },\n      compressionRatio: 0.7,\n      quotaUsage: await this.quotaManager.getTotalUsage(),\n      tierUsage: {\n        hot: { itemCount: 0, sizeBytes: 0, quotaUsed: 0 },\n        warm: { itemCount: 0, sizeBytes: 0, quotaUsed: 0 },\n        cold: { itemCount: 0, sizeBytes: 0, quotaUsed: 0 }\n      }\n    };\n    \n    return stats;\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(config: Partial<ResilientStorageConfig>): void {\n    this.config = { ...this.config, ...config };\n  }\n\n  /**\n   * Reset statistics\n   */\n  resetStats(): void {\n    // Reset internal counters if any\n  }\n}\n\n/**\n * Storage Quota Manager\n */\nclass StorageQuotaManager {\n  private quotas: Map<string, StorageQuota> = new Map();\n\n  async initialize(): Promise<void> {\n    if ('storage' in navigator && 'estimate' in navigator.storage) {\n      const estimate = await navigator.storage.estimate();\n      const total = estimate.quota || 0;\n      const used = estimate.usage || 0;\n      \n      this.quotas.set('global', {\n        total,\n        used,\n        available: total - used,\n        percentage: total > 0 ? (used / total) * 100 : 0\n      });\n    }\n  }\n\n  async getUsage(tierName: string): Promise<StorageQuota> {\n    // Simplified implementation - in practice, calculate per-tier usage\n    return this.quotas.get('global') || {\n      total: 0,\n      used: 0,\n      available: 0,\n      percentage: 0\n    };\n  }\n\n  async getTotalUsage(): Promise<StorageQuota> {\n    return this.quotas.get('global') || {\n      total: 0,\n      used: 0,\n      available: 0,\n      percentage: 0\n    };\n  }\n}","/**\n * API Health Monitoring System\n * Continuous health assessment with adaptive behavior\n */\n\nexport interface HealthMetrics {\n  responseTime: number[];\n  successRate: number;\n  errorRate: number;\n  availability: number;\n  lastCheck: number;\n  consecutiveFailures: number;\n  consecutiveSuccesses: number;\n  averageResponseTime: number;\n  p95ResponseTime: number;\n  p99ResponseTime: number;\n  totalRequests: number;\n  totalErrors: number;\n  uptime: number;\n  downtime: number;\n}\n\nexport interface HealthCheckConfig {\n  interval: number;\n  timeout: number;\n  endpoint: string;\n  method: 'GET' | 'HEAD' | 'POST';\n  expectedStatus: number[];\n  retryCount: number;\n  failureThreshold: number;\n  recoveryThreshold: number;\n  degradationThreshold: number;\n  critical: boolean;\n}\n\nexport interface HealthStatus {\n  status: 'healthy' | 'degraded' | 'unhealthy' | 'unknown';\n  lastChecked: number;\n  responseTime?: number;\n  error?: string;\n  metrics: HealthMetrics;\n  trend: 'improving' | 'stable' | 'degrading';\n  confidence: number; // 0-1\n}\n\nexport interface RegionalHealth {\n  region: string;\n  endpoint: string;\n  status: HealthStatus;\n  priority: number;\n  lastFailover?: number;\n}\n\n/**\n * Health Monitor for individual endpoints\n */\nexport class EndpointHealthMonitor {\n  private config: HealthCheckConfig;\n  private metrics: HealthMetrics;\n  private checkInterval: NodeJS.Timeout | null = null;\n  private listeners: Array<(status: HealthStatus) => void> = [];\n  private requestHistory: Array<{ timestamp: number; success: boolean; responseTime: number }> = [];\n  private windowSize = 60000; // 1 minute window\n  private isRunning = false;\n\n  constructor(\n    private name: string,\n    config: Partial<HealthCheckConfig>\n  ) {\n    this.config = {\n      interval: 30000, // 30 seconds\n      timeout: 10000, // 10 seconds\n      endpoint: '',\n      method: 'HEAD',\n      expectedStatus: [200, 204],\n      retryCount: 3,\n      failureThreshold: 3,\n      recoveryThreshold: 3,\n      degradationThreshold: 0.1, // 10% error rate\n      critical: false,\n      ...config\n    };\n\n    this.metrics = this.initializeMetrics();\n  }\n\n  private initializeMetrics(): HealthMetrics {\n    return {\n      responseTime: [],\n      successRate: 1.0,\n      errorRate: 0.0,\n      availability: 1.0,\n      lastCheck: 0,\n      consecutiveFailures: 0,\n      consecutiveSuccesses: 0,\n      averageResponseTime: 0,\n      p95ResponseTime: 0,\n      p99ResponseTime: 0,\n      totalRequests: 0,\n      totalErrors: 0,\n      uptime: 0,\n      downtime: 0\n    };\n  }\n\n  /**\n   * Start health monitoring\n   */\n  start(): void {\n    if (this.isRunning) return;\n\n    this.isRunning = true;\n    this.scheduleCheck();\n  }\n\n  /**\n   * Stop health monitoring\n   */\n  stop(): void {\n    this.isRunning = false;\n    if (this.checkInterval) {\n      clearTimeout(this.checkInterval);\n      this.checkInterval = null;\n    }\n  }\n\n  private scheduleCheck(): void {\n    if (!this.isRunning) return;\n\n    this.checkInterval = setTimeout(async () => {\n      await this.performHealthCheck();\n      this.scheduleCheck();\n    }, this.config.interval);\n  }\n\n  private async performHealthCheck(): Promise<void> {\n    const startTime = Date.now();\n    let success = false;\n    let responseTime = 0;\n    let error: string | undefined;\n\n    try {\n      for (let attempt = 0; attempt <= this.config.retryCount; attempt++) {\n        try {\n          const checkStartTime = Date.now();\n          const response = await this.executeHealthCheck();\n          responseTime = Date.now() - checkStartTime;\n\n          if (this.config.expectedStatus.includes(response.status)) {\n            success = true;\n            break;\n          } else {\n            throw new Error(`Unexpected status code: ${response.status}`);\n          }\n        } catch (attemptError: any) {\n          if (attempt === this.config.retryCount) {\n            throw attemptError;\n          }\n          // Wait before retry with exponential backoff\n          await this.sleep(1000 * Math.pow(2, attempt));\n        }\n      }\n    } catch (checkError: any) {\n      error = checkError.message;\n      responseTime = Date.now() - startTime;\n    }\n\n    this.recordCheckResult(success, responseTime, error);\n  }\n\n  private async executeHealthCheck(): Promise<Response> {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);\n\n    try {\n      const response = await fetch(this.config.endpoint, {\n        method: this.config.method,\n        signal: controller.signal,\n        cache: 'no-cache',\n        headers: {\n          'User-Agent': 'Revi-HealthMonitor/1.0'\n        }\n      });\n\n      return response;\n    } finally {\n      clearTimeout(timeoutId);\n    }\n  }\n\n  private recordCheckResult(success: boolean, responseTime: number, error?: string): void {\n    const timestamp = Date.now();\n\n    // Add to request history\n    this.requestHistory.push({ timestamp, success, responseTime });\n    this.cleanupOldHistory();\n\n    // Update metrics\n    this.updateMetrics(success, responseTime);\n\n    // Update consecutive counters\n    if (success) {\n      this.metrics.consecutiveFailures = 0;\n      this.metrics.consecutiveSuccesses++;\n    } else {\n      this.metrics.consecutiveSuccesses = 0;\n      this.metrics.consecutiveFailures++;\n    }\n\n    this.metrics.lastCheck = timestamp;\n\n    // Notify listeners\n    const status = this.calculateHealthStatus(error);\n    this.notifyListeners(status);\n  }\n\n  private cleanupOldHistory(): void {\n    const cutoff = Date.now() - this.windowSize;\n    this.requestHistory = this.requestHistory.filter(req => req.timestamp > cutoff);\n  }\n\n  private updateMetrics(success: boolean, responseTime: number): void {\n    this.metrics.totalRequests++;\n    \n    if (!success) {\n      this.metrics.totalErrors++;\n    }\n\n    // Update response times\n    this.metrics.responseTime.push(responseTime);\n    if (this.metrics.responseTime.length > 100) {\n      this.metrics.responseTime.shift(); // Keep only last 100 measurements\n    }\n\n    // Calculate current window metrics\n    const windowRequests = this.requestHistory.length;\n    const windowSuccesses = this.requestHistory.filter(r => r.success).length;\n    const windowErrors = windowRequests - windowSuccesses;\n\n    this.metrics.successRate = windowRequests > 0 ? windowSuccesses / windowRequests : 1.0;\n    this.metrics.errorRate = windowRequests > 0 ? windowErrors / windowRequests : 0.0;\n\n    // Calculate availability (uptime vs downtime)\n    const totalTime = this.metrics.totalRequests * this.config.interval;\n    const estimatedDowntime = this.metrics.totalErrors * this.config.interval;\n    this.metrics.availability = totalTime > 0 ? 1 - (estimatedDowntime / totalTime) : 1.0;\n\n    // Calculate response time percentiles\n    if (this.metrics.responseTime.length > 0) {\n      const sorted = [...this.metrics.responseTime].sort((a, b) => a - b);\n      this.metrics.averageResponseTime = sorted.reduce((a, b) => a + b) / sorted.length;\n      this.metrics.p95ResponseTime = sorted[Math.floor(sorted.length * 0.95)];\n      this.metrics.p99ResponseTime = sorted[Math.floor(sorted.length * 0.99)];\n    }\n  }\n\n  private calculateHealthStatus(error?: string): HealthStatus {\n    let status: HealthStatus['status'] = 'unknown';\n    let trend: HealthStatus['trend'] = 'stable';\n    let confidence = 0.5;\n\n    // Determine status based on consecutive failures and error rate\n    if (this.metrics.consecutiveFailures >= this.config.failureThreshold) {\n      status = 'unhealthy';\n      confidence = Math.min(0.9, this.metrics.consecutiveFailures / (this.config.failureThreshold * 2));\n    } else if (this.metrics.errorRate > this.config.degradationThreshold) {\n      status = 'degraded';\n      confidence = Math.min(0.8, this.metrics.errorRate * 2);\n    } else if (this.metrics.consecutiveSuccesses >= this.config.recoveryThreshold) {\n      status = 'healthy';\n      confidence = Math.min(0.95, this.metrics.consecutiveSuccesses / (this.config.recoveryThreshold * 2));\n    }\n\n    // Determine trend based on recent history\n    if (this.requestHistory.length >= 10) {\n      const recentHalf = this.requestHistory.slice(-5);\n      const earlierHalf = this.requestHistory.slice(-10, -5);\n      \n      const recentSuccessRate = recentHalf.filter(r => r.success).length / recentHalf.length;\n      const earlierSuccessRate = earlierHalf.filter(r => r.success).length / earlierHalf.length;\n      \n      if (recentSuccessRate > earlierSuccessRate + 0.2) {\n        trend = 'improving';\n      } else if (recentSuccessRate < earlierSuccessRate - 0.2) {\n        trend = 'degrading';\n      }\n    }\n\n    return {\n      status,\n      lastChecked: this.metrics.lastCheck,\n      responseTime: this.metrics.averageResponseTime,\n      error,\n      metrics: { ...this.metrics },\n      trend,\n      confidence\n    };\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Get current health status\n   */\n  getHealthStatus(): HealthStatus {\n    return this.calculateHealthStatus();\n  }\n\n  /**\n   * Get current metrics\n   */\n  getMetrics(): HealthMetrics {\n    return { ...this.metrics };\n  }\n\n  /**\n   * Force a health check\n   */\n  async forceCheck(): Promise<HealthStatus> {\n    await this.performHealthCheck();\n    return this.getHealthStatus();\n  }\n\n  /**\n   * Listen for health status changes\n   */\n  onStatusChange(callback: (status: HealthStatus) => void): () => void {\n    this.listeners.push(callback);\n    return () => {\n      const index = this.listeners.indexOf(callback);\n      if (index > -1) {\n        this.listeners.splice(index, 1);\n      }\n    };\n  }\n\n  private notifyListeners(status: HealthStatus): void {\n    this.listeners.forEach(callback => {\n      try {\n        callback(status);\n      } catch (error) {\n        console.error(`Health monitor ${this.name} listener error:`, error);\n      }\n    });\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(newConfig: Partial<HealthCheckConfig>): void {\n    const oldInterval = this.config.interval;\n    this.config = { ...this.config, ...newConfig };\n    \n    // Restart if interval changed and monitor is running\n    if (this.isRunning && oldInterval !== this.config.interval) {\n      this.stop();\n      this.start();\n    }\n  }\n\n  /**\n   * Reset metrics (useful for testing)\n   */\n  reset(): void {\n    this.metrics = this.initializeMetrics();\n    this.requestHistory = [];\n  }\n}\n\n/**\n * Multi-Regional Health Monitor\n */\nexport class MultiRegionalHealthMonitor {\n  private regionalMonitors = new Map<string, EndpointHealthMonitor>();\n  private primaryRegion: string | null = null;\n  private failoverHistory: Array<{ from: string; to: string; timestamp: number; reason: string }> = [];\n  private listeners: Array<(event: string, data: any) => void> = [];\n  private adaptiveBehavior: AdaptiveBehavior;\n\n  constructor() {\n    this.adaptiveBehavior = new AdaptiveBehavior();\n  }\n\n  /**\n   * Register a regional endpoint\n   */\n  registerRegion(\n    region: string,\n    endpoint: string,\n    priority: number,\n    config?: Partial<HealthCheckConfig>\n  ): EndpointHealthMonitor {\n    const monitor = new EndpointHealthMonitor(`region-${region}`, {\n      endpoint,\n      critical: priority === 1,\n      ...config\n    });\n\n    // Set as primary if it's the highest priority\n    if (!this.primaryRegion || priority === 1) {\n      this.primaryRegion = region;\n    }\n\n    monitor.onStatusChange((status) => {\n      this.handleRegionalStatusChange(region, status);\n    });\n\n    this.regionalMonitors.set(region, monitor);\n    return monitor;\n  }\n\n  /**\n   * Start monitoring all regions\n   */\n  startAll(): void {\n    this.regionalMonitors.forEach(monitor => monitor.start());\n  }\n\n  /**\n   * Stop monitoring all regions\n   */\n  stopAll(): void {\n    this.regionalMonitors.forEach(monitor => monitor.stop());\n  }\n\n  private handleRegionalStatusChange(region: string, status: HealthStatus): void {\n    this.notifyListeners('regional-status-change', { region, status });\n\n    // Check if primary region failed and failover is needed\n    if (region === this.primaryRegion && status.status === 'unhealthy') {\n      this.performFailover(region, 'primary_unhealthy');\n    }\n\n    // Update adaptive behavior\n    this.adaptiveBehavior.recordRegionalHealth(region, status);\n  }\n\n  private performFailover(fromRegion: string, reason: string): void {\n    // Find the best available region\n    const availableRegions = Array.from(this.regionalMonitors.entries())\n      .filter(([region, monitor]) => \n        region !== fromRegion && \n        monitor.getHealthStatus().status !== 'unhealthy'\n      )\n      .sort(([, a], [, b]) => {\n        const aHealth = a.getHealthStatus();\n        const bHealth = b.getHealthStatus();\n        \n        // Prefer healthy over degraded\n        if (aHealth.status === 'healthy' && bHealth.status !== 'healthy') return -1;\n        if (bHealth.status === 'healthy' && aHealth.status !== 'healthy') return 1;\n        \n        // Prefer better response times\n        return (aHealth.responseTime || Infinity) - (bHealth.responseTime || Infinity);\n      });\n\n    if (availableRegions.length > 0) {\n      const [newPrimaryRegion] = availableRegions[0];\n      const oldPrimary = this.primaryRegion;\n      \n      this.primaryRegion = newPrimaryRegion;\n      \n      this.failoverHistory.push({\n        from: fromRegion,\n        to: newPrimaryRegion,\n        timestamp: Date.now(),\n        reason\n      });\n\n      this.notifyListeners('failover', {\n        from: fromRegion,\n        to: newPrimaryRegion,\n        reason,\n        timestamp: Date.now()\n      });\n\n      // Update adaptive behavior\n      this.adaptiveBehavior.recordFailover(fromRegion, newPrimaryRegion, reason);\n    }\n  }\n\n  /**\n   * Get current primary region\n   */\n  getPrimaryRegion(): string | null {\n    return this.primaryRegion;\n  }\n\n  /**\n   * Get health status for all regions\n   */\n  getAllRegionalHealth(): RegionalHealth[] {\n    return Array.from(this.regionalMonitors.entries()).map(([region, monitor]) => ({\n      region,\n      endpoint: monitor['config'].endpoint,\n      status: monitor.getHealthStatus(),\n      priority: region === this.primaryRegion ? 1 : 2,\n      lastFailover: this.failoverHistory\n        .filter(f => f.to === region)\n        .sort((a, b) => b.timestamp - a.timestamp)[0]?.timestamp\n    }));\n  }\n\n  /**\n   * Get failover history\n   */\n  getFailoverHistory(): typeof this.failoverHistory {\n    return [...this.failoverHistory];\n  }\n\n  /**\n   * Get adaptive behavior recommendations\n   */\n  getAdaptiveBehaviorRecommendations(): any {\n    return this.adaptiveBehavior.getRecommendations();\n  }\n\n  /**\n   * Force failover to specific region\n   */\n  forceFailover(toRegion: string, reason: string = 'manual'): void {\n    if (this.regionalMonitors.has(toRegion)) {\n      this.performFailover(this.primaryRegion || 'unknown', reason);\n    }\n  }\n\n  /**\n   * Listen for health monitor events\n   */\n  onEvent(callback: (event: string, data: any) => void): () => void {\n    this.listeners.push(callback);\n    return () => {\n      const index = this.listeners.indexOf(callback);\n      if (index > -1) {\n        this.listeners.splice(index, 1);\n      }\n    };\n  }\n\n  private notifyListeners(event: string, data: any): void {\n    this.listeners.forEach(callback => {\n      try {\n        callback(event, data);\n      } catch (error) {\n        console.error('Multi-regional health monitor listener error:', error);\n      }\n    });\n  }\n\n  /**\n   * Get global statistics\n   */\n  getGlobalStats(): any {\n    const allStats = Array.from(this.regionalMonitors.values()).map(monitor => monitor.getStats());\n    const avgLatency = allStats.reduce((sum, stats) => sum + stats.averageLatency, 0) / allStats.length;\n    const avgErrorRate = allStats.reduce((sum, stats) => sum + stats.errorRate, 0) / allStats.length;\n\n    return {\n      regions: this.config.regions.length,\n      endpoints: Object.keys(this.config.endpoints).length,\n      primaryRegion: this.primaryRegion,\n      totalChecks: allStats.reduce((sum, stats) => sum + stats.totalChecks, 0),\n      averageLatency: avgLatency || 0,\n      averageErrorRate: avgErrorRate || 0,\n      failovers: this.failoverHistory.length,\n      adaptiveBehavior: this.adaptiveBehavior.getRecommendations()\n    };\n  }\n\n  /**\n   * Reset all statistics\n   */\n  resetStats(): void {\n    this.regionalMonitors.forEach(monitor => monitor.resetStats());\n    this.failoverHistory = [];\n    this.adaptiveBehavior.reset();\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(config: Partial<HealthMonitorConfig>): void {\n    this.config = { ...this.config, ...config };\n  }\n\n  /**\n   * Destroy and cleanup\n   */\n  destroy(): void {\n    this.regionalMonitors.forEach(monitor => monitor.destroy());\n    this.regionalMonitors.clear();\n    this.listeners = [];\n  }\n}\n\n/**\n * Adaptive Behavior Engine\n */\nclass AdaptiveBehavior {\n  private regionalHealthHistory = new Map<string, HealthStatus[]>();\n  private failoverPatterns: Array<{ from: string; to: string; timestamp: number; reason: string }> = [];\n  private adaptiveSettings = {\n    uploadFrequency: 10000, // Base frequency\n    batchSize: 25, // Base batch size\n    retryAttempts: 3, // Base retry attempts\n    timeoutMultiplier: 1.0 // Base timeout multiplier\n  };\n\n  recordRegionalHealth(region: string, status: HealthStatus): void {\n    if (!this.regionalHealthHistory.has(region)) {\n      this.regionalHealthHistory.set(region, []);\n    }\n    \n    const history = this.regionalHealthHistory.get(region)!;\n    history.push(status);\n    \n    // Keep only last 100 records\n    if (history.length > 100) {\n      history.shift();\n    }\n    \n    // Update adaptive settings based on health\n    this.updateAdaptiveSettings(region, status);\n  }\n\n  recordFailover(from: string, to: string, reason: string): void {\n    this.failoverPatterns.push({ from, to, timestamp: Date.now(), reason });\n    \n    // Keep only last 50 failovers\n    if (this.failoverPatterns.length > 50) {\n      this.failoverPatterns.shift();\n    }\n  }\n\n  private updateAdaptiveSettings(region: string, status: HealthStatus): void {\n    // Adjust upload frequency based on health\n    if (status.status === 'unhealthy') {\n      this.adaptiveSettings.uploadFrequency = Math.min(this.adaptiveSettings.uploadFrequency * 2, 60000);\n    } else if (status.status === 'healthy') {\n      this.adaptiveSettings.uploadFrequency = Math.max(this.adaptiveSettings.uploadFrequency * 0.9, 5000);\n    }\n\n    // Adjust batch size based on response times\n    if (status.responseTime && status.responseTime > 5000) {\n      this.adaptiveSettings.batchSize = Math.max(this.adaptiveSettings.batchSize - 5, 5);\n    } else if (status.responseTime && status.responseTime < 1000) {\n      this.adaptiveSettings.batchSize = Math.min(this.adaptiveSettings.batchSize + 5, 100);\n    }\n\n    // Adjust retry attempts based on error rates\n    if (status.metrics.errorRate > 0.3) {\n      this.adaptiveSettings.retryAttempts = Math.min(this.adaptiveSettings.retryAttempts + 1, 10);\n    } else if (status.metrics.errorRate < 0.05) {\n      this.adaptiveSettings.retryAttempts = Math.max(this.adaptiveSettings.retryAttempts - 1, 1);\n    }\n  }\n\n  getRecommendations(): typeof this.adaptiveSettings & { \n    confidence: number;\n    reasoning: string[];\n  } {\n    const reasoning: string[] = [];\n    let confidence = 0.7;\n\n    // Add reasoning based on current settings\n    if (this.adaptiveSettings.uploadFrequency > 30000) {\n      reasoning.push('Reduced upload frequency due to poor API health');\n    }\n    if (this.adaptiveSettings.batchSize < 15) {\n      reasoning.push('Reduced batch size due to slow response times');\n    }\n    if (this.adaptiveSettings.retryAttempts > 5) {\n      reasoning.push('Increased retry attempts due to high error rates');\n    }\n\n    // Calculate confidence based on data available\n    const totalHealthRecords = Array.from(this.regionalHealthHistory.values())\n      .reduce((sum, history) => sum + history.length, 0);\n    \n    if (totalHealthRecords > 50) {\n      confidence = Math.min(0.95, confidence + 0.2);\n    }\n\n    return {\n      ...this.adaptiveSettings,\n      confidence,\n      reasoning\n    };\n  }\n\n  reset(): void {\n    this.regionalHealthHistory.clear();\n    this.failoverPatterns = [];\n    this.adaptiveSettings = {\n      uploadFrequency: 10000,\n      batchSize: 25,\n      retryAttempts: 3,\n      timeoutMultiplier: 1.0\n    };\n  }\n}","/**\n * Intelligent Sync-on-Reconnect System\n * Handles efficient data synchronization when network connectivity is restored\n */\n\nimport { ResilientStorage, StoredItem } from './resilient-storage';\nimport { RetryManager } from './retry-manager';\nimport { EndpointHealthMonitor } from './health-monitor';\nimport { ErrorEvent, SessionEvent, NetworkEvent } from './types';\n\nexport interface SyncProgress {\n  phase: 'preparing' | 'syncing' | 'completed' | 'failed';\n  totalItems: number;\n  syncedItems: number;\n  failedItems: number;\n  currentBatch: number;\n  totalBatches: number;\n  estimatedTimeRemaining: number;\n  bytesTransferred: number;\n  totalBytes: number;\n  errors: string[];\n}\n\nexport interface SyncConfig {\n  batchSize: number;\n  maxConcurrentBatches: number;\n  priorityWeights: Record<string, number>;\n  bandwidthThrottling: boolean;\n  progressiveSync: boolean;\n  conflictResolution: 'client-wins' | 'server-wins' | 'timestamp-wins';\n  maxSyncTime: number;\n  resumeIncomplete: boolean;\n}\n\nexport interface SyncContext {\n  sessionId: string;\n  userId?: string;\n  deviceId: string;\n  lastSyncTimestamp: number;\n  offlineDuration: number;\n  networkQuality: 'excellent' | 'good' | 'poor' | 'unknown';\n  batteryLevel?: number;\n  isBackground?: boolean;\n}\n\nexport interface ConflictItem {\n  localItem: StoredItem;\n  serverItem?: any;\n  conflictType: 'timestamp' | 'version' | 'data';\n  resolution: 'pending' | 'resolved';\n  resolvedWith: 'local' | 'server' | 'merged';\n}\n\n/**\n * Intelligent Sync Manager\n */\nexport class IntelligentSyncManager {\n  private storage: ResilientStorage;\n  private retryManager: RetryManager;\n  private healthMonitor: EndpointHealthMonitor | null = null;\n  private currentSync: Promise<SyncProgress> | null = null;\n  private syncContext: SyncContext | null = null;\n  private config: SyncConfig;\n  private listeners: Array<(progress: SyncProgress) => void> = [];\n  private abortController: AbortController | null = null;\n  private syncHistory: Array<{ timestamp: number; duration: number; itemsSynced: number; success: boolean }> = [];\n\n  constructor(\n    storage: ResilientStorage,\n    config: Partial<SyncConfig> = {}\n  ) {\n    this.storage = storage;\n    this.retryManager = new RetryManager({\n      maxAttempts: 5,\n      baseDelay: 2000,\n      maxDelay: 30000,\n      enableJitter: true\n    });\n\n    this.config = {\n      batchSize: 20,\n      maxConcurrentBatches: 3,\n      priorityWeights: {\n        critical: 1.0,\n        high: 0.8,\n        medium: 0.5,\n        low: 0.2\n      },\n      bandwidthThrottling: true,\n      progressiveSync: true,\n      conflictResolution: 'timestamp-wins',\n      maxSyncTime: 300000, // 5 minutes\n      resumeIncomplete: true,\n      ...config\n    };\n  }\n\n  /**\n   * Initialize sync manager with health monitoring\n   */\n  initialize(apiEndpoint: string, healthMonitor?: EndpointHealthMonitor): void {\n    if (healthMonitor) {\n      this.healthMonitor = healthMonitor;\n    } else {\n      this.healthMonitor = new EndpointHealthMonitor('sync-health', {\n        endpoint: `${apiEndpoint}/health`,\n        interval: 30000,\n        timeout: 10000\n      });\n      this.healthMonitor.start();\n    }\n\n    // Listen for network reconnection\n    this.setupNetworkListeners();\n  }\n\n  private setupNetworkListeners(): void {\n    if (typeof window === 'undefined') return;\n\n    window.addEventListener('online', () => {\n      this.handleNetworkReconnection();\n    });\n\n    // Listen for visibility changes (tab becomes active)\n    document.addEventListener('visibilitychange', () => {\n      if (!document.hidden && navigator.onLine) {\n        this.handleNetworkReconnection();\n      }\n    });\n  }\n\n  private async handleNetworkReconnection(): Promise<void> {\n    // Wait a bit for connection to stabilize\n    await this.sleep(2000);\n    \n    // Check if we actually have connectivity\n    if (this.healthMonitor) {\n      const health = await this.healthMonitor.forceCheck();\n      if (health.status === 'unhealthy') {\n        console.log('[SyncManager] API still unhealthy after reconnection, waiting...');\n        return;\n      }\n    }\n\n    // Start sync if not already running\n    if (!this.currentSync) {\n      this.startIntelligentSync();\n    }\n  }\n\n  /**\n   * Start intelligent synchronization\n   */\n  async startIntelligentSync(context?: Partial<SyncContext>): Promise<SyncProgress> {\n    // Return existing sync if in progress\n    if (this.currentSync) {\n      return this.currentSync;\n    }\n\n    // Create sync context\n    this.syncContext = {\n      sessionId: this.generateSessionId(),\n      deviceId: this.getDeviceId(),\n      lastSyncTimestamp: this.getLastSyncTimestamp(),\n      offlineDuration: Date.now() - this.getLastSyncTimestamp(),\n      networkQuality: await this.assessNetworkQuality(),\n      batteryLevel: this.getBatteryLevel(),\n      isBackground: document.hidden,\n      ...context\n    };\n\n    // Create abort controller for cancellation\n    this.abortController = new AbortController();\n\n    // Start sync process\n    this.currentSync = this.performIntelligentSync(this.syncContext);\n    \n    try {\n      const result = await this.currentSync;\n      this.recordSyncHistory(result);\n      return result;\n    } finally {\n      this.currentSync = null;\n      this.syncContext = null;\n      this.abortController = null;\n    }\n  }\n\n  private async performIntelligentSync(context: SyncContext): Promise<SyncProgress> {\n    const progress: SyncProgress = {\n      phase: 'preparing',\n      totalItems: 0,\n      syncedItems: 0,\n      failedItems: 0,\n      currentBatch: 0,\n      totalBatches: 0,\n      estimatedTimeRemaining: 0,\n      bytesTransferred: 0,\n      totalBytes: 0,\n      errors: []\n    };\n\n    this.notifyProgress(progress);\n\n    try {\n      // Phase 1: Prepare sync data\n      const syncPlan = await this.prepareSyncPlan(context);\n      progress.totalItems = syncPlan.totalItems;\n      progress.totalBatches = syncPlan.batches.length;\n      progress.totalBytes = syncPlan.totalBytes;\n\n      // Phase 2: Execute sync with intelligent batching\n      progress.phase = 'syncing';\n      this.notifyProgress(progress);\n\n      const startTime = Date.now();\n      await this.executeSyncBatches(syncPlan, progress);\n\n      // Phase 3: Handle conflicts and finalize\n      if (syncPlan.conflicts.length > 0) {\n        await this.resolveConflicts(syncPlan.conflicts);\n      }\n\n      progress.phase = 'completed';\n      progress.estimatedTimeRemaining = 0;\n      this.notifyProgress(progress);\n\n      // Update last sync timestamp\n      this.updateLastSyncTimestamp();\n\n      return progress;\n\n    } catch (error: any) {\n      progress.phase = 'failed';\n      progress.errors.push(error.message);\n      this.notifyProgress(progress);\n      throw error;\n    }\n  }\n\n  private async prepareSyncPlan(context: SyncContext): Promise<{\n    batches: Array<{ items: StoredItem[]; priority: number; estimatedBytes: number }>;\n    totalItems: number;\n    totalBytes: number;\n    conflicts: ConflictItem[];\n  }> {\n    // Get all items that need syncing\n    const [errors, sessions, networkEvents] = await Promise.all([\n      this.storage.getAllByType<ErrorEvent>('error'),\n      this.storage.getAllByType<SessionEvent>('session'),\n      this.storage.getAllByType<NetworkEvent>('network')\n    ]);\n\n    const allItems = [...errors, ...sessions, ...networkEvents];\n    \n    // Filter items that need syncing (newer than last sync)\n    const itemsToSync = allItems.filter(item => \n      item.timestamp > context.lastSyncTimestamp\n    );\n\n    // Sort by priority and timestamp\n    itemsToSync.sort((a, b) => {\n      const priorityWeight = this.config.priorityWeights[a.priority] - this.config.priorityWeights[b.priority];\n      if (priorityWeight !== 0) return -priorityWeight; // Higher priority first\n      return a.timestamp - b.timestamp; // Older first within same priority\n    });\n\n    // Adapt batch size based on network quality and context\n    const adaptedBatchSize = this.calculateAdaptiveBatchSize(context);\n\n    // Create intelligent batches\n    const batches = this.createIntelligentBatches(itemsToSync, adaptedBatchSize);\n\n    // Check for potential conflicts (simplified implementation)\n    const conflicts = await this.detectConflicts(itemsToSync);\n\n    const totalBytes = itemsToSync.reduce((sum, item) => sum + item.size, 0);\n\n    return {\n      batches,\n      totalItems: itemsToSync.length,\n      totalBytes,\n      conflicts\n    };\n  }\n\n  private calculateAdaptiveBatchSize(context: SyncContext): number {\n    let adaptedSize = this.config.batchSize;\n\n    // Adjust based on network quality\n    switch (context.networkQuality) {\n      case 'poor':\n        adaptedSize = Math.max(5, adaptedSize * 0.3);\n        break;\n      case 'good':\n        adaptedSize = Math.floor(adaptedSize * 0.8);\n        break;\n      case 'excellent':\n        adaptedSize = Math.floor(adaptedSize * 1.5);\n        break;\n    }\n\n    // Adjust based on battery level\n    if (context.batteryLevel && context.batteryLevel < 0.2) {\n      adaptedSize = Math.max(3, adaptedSize * 0.5);\n    }\n\n    // Adjust based on background status\n    if (context.isBackground) {\n      adaptedSize = Math.max(5, adaptedSize * 0.6);\n    }\n\n    // Adjust based on offline duration\n    if (context.offlineDuration > 3600000) { // More than 1 hour\n      adaptedSize = Math.max(10, adaptedSize * 0.7); // Smaller batches for large backlogs\n    }\n\n    return Math.floor(adaptedSize);\n  }\n\n  private createIntelligentBatches(\n    items: StoredItem[],\n    batchSize: number\n  ): Array<{ items: StoredItem[]; priority: number; estimatedBytes: number }> {\n    const batches: Array<{ items: StoredItem[]; priority: number; estimatedBytes: number }> = [];\n    \n    // Group by priority first\n    const priorityGroups = new Map<string, StoredItem[]>();\n    items.forEach(item => {\n      if (!priorityGroups.has(item.priority)) {\n        priorityGroups.set(item.priority, []);\n      }\n      priorityGroups.get(item.priority)!.push(item);\n    });\n\n    // Create batches within each priority group\n    const priorities = ['critical', 'high', 'medium', 'low'];\n    priorities.forEach(priority => {\n      const groupItems = priorityGroups.get(priority) || [];\n      \n      for (let i = 0; i < groupItems.length; i += batchSize) {\n        const batchItems = groupItems.slice(i, i + batchSize);\n        const estimatedBytes = batchItems.reduce((sum, item) => sum + item.size, 0);\n        \n        batches.push({\n          items: batchItems,\n          priority: this.config.priorityWeights[priority],\n          estimatedBytes\n        });\n      }\n    });\n\n    return batches;\n  }\n\n  private async executeSyncBatches(\n    syncPlan: ReturnType<IntelligentSyncManager['prepareSyncPlan']> extends Promise<infer T> ? T : never,\n    progress: SyncProgress\n  ): Promise<void> {\n    const concurrentBatches: Promise<void>[] = [];\n    let activeBatches = 0;\n\n    for (let i = 0; i < syncPlan.batches.length; i++) {\n      const batch = syncPlan.batches[i];\n      \n      // Wait if we've hit the concurrency limit\n      while (activeBatches >= this.config.maxConcurrentBatches) {\n        await Promise.race(concurrentBatches);\n        activeBatches = concurrentBatches.filter(p => this.isPromisePending(p)).length;\n      }\n\n      // Check if sync was aborted\n      if (this.abortController?.signal.aborted) {\n        throw new Error('Sync aborted');\n      }\n\n      // Execute batch\n      const batchPromise = this.syncBatch(batch, i + 1, progress);\n      concurrentBatches.push(batchPromise);\n      activeBatches++;\n\n      // Update progress\n      progress.currentBatch = i + 1;\n      this.updateEstimatedTime(progress, syncPlan);\n      this.notifyProgress(progress);\n\n      // Add progressive delay for bandwidth throttling\n      if (this.config.bandwidthThrottling && this.syncContext?.networkQuality === 'poor') {\n        await this.sleep(1000 * (i % 3)); // 0, 1, 2 second delays\n      }\n    }\n\n    // Wait for all batches to complete\n    await Promise.allSettled(concurrentBatches);\n  }\n\n  private async syncBatch(\n    batch: { items: StoredItem[]; priority: number; estimatedBytes: number },\n    batchNumber: number,\n    progress: SyncProgress\n  ): Promise<void> {\n    try {\n      // Group items by type for efficient API calls\n      const errorItems = batch.items.filter(item => item.id.startsWith('error_'));\n      const sessionItems = batch.items.filter(item => item.id.startsWith('session_'));\n      const networkItems = batch.items.filter(item => item.id.startsWith('network_'));\n\n      // Sync each type with appropriate retry strategies\n      await Promise.all([\n        errorItems.length > 0 ? this.syncErrorItems(errorItems) : Promise.resolve(),\n        sessionItems.length > 0 ? this.syncSessionItems(sessionItems) : Promise.resolve(),\n        networkItems.length > 0 ? this.syncNetworkItems(networkItems) : Promise.resolve()\n      ]);\n\n      // Update progress\n      progress.syncedItems += batch.items.length;\n      progress.bytesTransferred += batch.estimatedBytes;\n\n      // Remove synced items from storage\n      await Promise.all(\n        batch.items.map(item => this.storage.remove(item.id))\n      );\n\n    } catch (error: any) {\n      progress.failedItems += batch.items.length;\n      progress.errors.push(`Batch ${batchNumber} failed: ${error.message}`);\n      \n      // Don't remove failed items - they'll be retried later\n      console.error(`[SyncManager] Batch ${batchNumber} sync failed:`, error);\n    }\n  }\n\n  private async syncErrorItems(items: StoredItem<ErrorEvent>[]): Promise<void> {\n    const payload = {\n      errors: items.map(item => ({\n        ...item.data,\n        client_timestamp: item.timestamp,\n        retry_count: item.retryCount,\n        offline_duration: this.syncContext?.offlineDuration || 0\n      }))\n    };\n\n    return this.retryManager.executeWithRetry(\n      'sync-errors',\n      async () => {\n        const response = await fetch('/api/capture/error', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'X-Sync-Session': this.syncContext?.sessionId || ''\n          },\n          body: JSON.stringify(payload),\n          signal: this.abortController?.signal\n        });\n\n        if (!response.ok) {\n          throw new Error(`Error sync failed: ${response.status}`);\n        }\n\n        return response.json();\n      },\n      {\n        priority: 'high',\n        payloadSize: JSON.stringify(payload).length,\n        deduplicationKey: `errors-${items.map(i => i.id).join('-')}`\n      }\n    );\n  }\n\n  private async syncSessionItems(items: StoredItem<SessionEvent>[]): Promise<void> {\n    // Group by session ID for more efficient syncing\n    const sessionGroups = new Map<string, StoredItem<SessionEvent>[]>();\n    items.forEach(item => {\n      const sessionId = item.data.sessionId;\n      if (!sessionGroups.has(sessionId)) {\n        sessionGroups.set(sessionId, []);\n      }\n      sessionGroups.get(sessionId)!.push(item);\n    });\n\n    // Sync each session group\n    for (const [sessionId, sessionItems] of sessionGroups) {\n      const payload = {\n        session_id: sessionId,\n        events: sessionItems.map(item => ({\n          ...item.data,\n          client_timestamp: item.timestamp,\n          retry_count: item.retryCount\n        }))\n      };\n\n      await this.retryManager.executeWithRetry(\n        `sync-session-${sessionId}`,\n        async () => {\n          const response = await fetch('/api/capture/session-event', {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n              'X-Sync-Session': this.syncContext?.sessionId || ''\n            },\n            body: JSON.stringify(payload),\n            signal: this.abortController?.signal\n          });\n\n          if (!response.ok) {\n            throw new Error(`Session sync failed: ${response.status}`);\n          }\n\n          return response.json();\n        },\n        {\n          priority: 'medium',\n          payloadSize: JSON.stringify(payload).length,\n          deduplicationKey: `session-${sessionId}`\n        }\n      );\n    }\n  }\n\n  private async syncNetworkItems(items: StoredItem<NetworkEvent>[]): Promise<void> {\n    const payload = {\n      events: items.map(item => ({\n        ...item.data,\n        client_timestamp: item.timestamp,\n        retry_count: item.retryCount\n      }))\n    };\n\n    return this.retryManager.executeWithRetry(\n      'sync-network',\n      async () => {\n        const response = await fetch('/api/capture/network-event', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'X-Sync-Session': this.syncContext?.sessionId || ''\n          },\n          body: JSON.stringify(payload),\n          signal: this.abortController?.signal\n        });\n\n        if (!response.ok) {\n          throw new Error(`Network sync failed: ${response.status}`);\n        }\n\n        return response.json();\n      },\n      {\n        priority: 'low',\n        payloadSize: JSON.stringify(payload).length,\n        deduplicationKey: `network-${items.length}`\n      }\n    );\n  }\n\n  private async detectConflicts(items: StoredItem[]): Promise<ConflictItem[]> {\n    // Simplified conflict detection - in practice, this would check against server state\n    const conflicts: ConflictItem[] = [];\n    \n    // For demo purposes, assume some items might conflict\n    items.forEach(item => {\n      if (item.retryCount > 3) { // Items that have failed multiple times might conflict\n        conflicts.push({\n          localItem: item,\n          conflictType: 'timestamp',\n          resolution: 'pending',\n          resolvedWith: 'local'\n        });\n      }\n    });\n\n    return conflicts;\n  }\n\n  private async resolveConflicts(conflicts: ConflictItem[]): Promise<void> {\n    for (const conflict of conflicts) {\n      switch (this.config.conflictResolution) {\n        case 'client-wins':\n          conflict.resolvedWith = 'local';\n          break;\n        case 'server-wins':\n          conflict.resolvedWith = 'server';\n          break;\n        case 'timestamp-wins':\n          // Use timestamp to determine winner\n          conflict.resolvedWith = 'local'; // Simplified\n          break;\n      }\n      conflict.resolution = 'resolved';\n    }\n  }\n\n  private updateEstimatedTime(progress: SyncProgress, syncPlan: any): void {\n    if (progress.syncedItems > 0) {\n      const elapsedTime = Date.now() - (this.syncContext?.lastSyncTimestamp || Date.now());\n      const timePerItem = elapsedTime / progress.syncedItems;\n      const remainingItems = progress.totalItems - progress.syncedItems;\n      progress.estimatedTimeRemaining = Math.floor(remainingItems * timePerItem);\n    }\n  }\n\n  /**\n   * Cancel current sync operation\n   */\n  cancelSync(): void {\n    if (this.abortController) {\n      this.abortController.abort();\n    }\n  }\n\n  /**\n   * Get sync progress if sync is running\n   */\n  getCurrentProgress(): SyncProgress | null {\n    return this.currentSync ? null : null; // Would need to track progress state\n  }\n\n  /**\n   * Check if sync is currently running\n   */\n  isSyncRunning(): boolean {\n    return this.currentSync !== null;\n  }\n\n  /**\n   * Listen for sync progress updates\n   */\n  onProgress(callback: (progress: SyncProgress) => void): () => void {\n    this.listeners.push(callback);\n    return () => {\n      const index = this.listeners.indexOf(callback);\n      if (index > -1) {\n        this.listeners.splice(index, 1);\n      }\n    };\n  }\n\n  private notifyProgress(progress: SyncProgress): void {\n    this.listeners.forEach(callback => {\n      try {\n        callback({ ...progress });\n      } catch (error) {\n        console.error('Sync progress listener error:', error);\n      }\n    });\n  }\n\n  // Helper methods\n  private generateSessionId(): string {\n    return `sync_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private getDeviceId(): string {\n    // Simple device ID generation - in practice, use more sophisticated approach\n    let deviceId = localStorage.getItem('revi_device_id');\n    if (!deviceId) {\n      deviceId = `device_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      localStorage.setItem('revi_device_id', deviceId);\n    }\n    return deviceId;\n  }\n\n  private getLastSyncTimestamp(): number {\n    const stored = localStorage.getItem('revi_last_sync');\n    return stored ? parseInt(stored) : 0;\n  }\n\n  private updateLastSyncTimestamp(): void {\n    localStorage.setItem('revi_last_sync', Date.now().toString());\n  }\n\n  private async assessNetworkQuality(): Promise<'excellent' | 'good' | 'poor' | 'unknown'> {\n    if (!this.healthMonitor) return 'unknown';\n    \n    const health = this.healthMonitor.getHealthStatus();\n    \n    if (health.responseTime && health.responseTime < 1000 && health.metrics.successRate > 0.95) {\n      return 'excellent';\n    } else if (health.responseTime && health.responseTime < 3000 && health.metrics.successRate > 0.8) {\n      return 'good';\n    } else if (health.metrics.successRate < 0.5) {\n      return 'poor';\n    }\n    \n    return 'unknown';\n  }\n\n  private getBatteryLevel(): number | undefined {\n    if ('getBattery' in navigator) {\n      // Note: getBattery() is deprecated, this is for demonstration\n      return undefined;\n    }\n    return undefined;\n  }\n\n  private recordSyncHistory(progress: SyncProgress): void {\n    this.syncHistory.push({\n      timestamp: Date.now(),\n      duration: Date.now() - (this.syncContext?.lastSyncTimestamp || Date.now()),\n      itemsSynced: progress.syncedItems,\n      success: progress.phase === 'completed'\n    });\n\n    // Keep only last 20 sync records\n    if (this.syncHistory.length > 20) {\n      this.syncHistory.shift();\n    }\n  }\n\n  private isPromisePending(promise: Promise<any>): boolean {\n    // Simplified check - in practice, you'd track promise states\n    return true;\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Get sync history\n   */\n  getSyncHistory(): typeof this.syncHistory {\n    return [...this.syncHistory];\n  }\n\n  /**\n   * Update sync configuration\n   */\n  updateConfig(newConfig: Partial<SyncConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n  }\n\n  /**\n   * Get current sync configuration\n   */\n  getConfig(): SyncConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Get statistics\n   */\n  getStats(): any {\n    return {\n      activeSyncs: this.activeSyncs.size,\n      syncHistory: this.syncHistory.length,\n      lastSync: this.syncHistory.length > 0 ? this.syncHistory[this.syncHistory.length - 1] : null,\n      totalSyncs: this.syncHistory.length,\n      successfulSyncs: this.syncHistory.filter(s => s.success).length\n    };\n  }\n\n  /**\n   * Reset statistics\n   */\n  resetStats(): void {\n    this.syncHistory = [];\n    this.activeSyncs.clear();\n  }\n\n  /**\n   * Destroy and cleanup\n   */\n  destroy(): void {\n    this.activeSyncs.clear();\n    this.syncHistory = [];\n  }\n}","/**\n * Idempotency and Request Deduplication Manager\n * Ensures safe retries and prevents duplicate operations across the resilience system\n */\n\nexport interface IdempotencyConfig {\n  keyTTL: number; // How long to remember idempotency keys (ms)\n  maxConcurrentRequests: number; // Max concurrent requests for same key\n  enableResponseCaching: boolean; // Cache successful responses\n  responseCacheTTL: number; // How long to cache responses (ms)\n  enableRequestFingerprinting: boolean; // Generate fingerprints for complex requests\n  maxStoredKeys: number; // Maximum number of keys to store in memory\n}\n\nexport interface RequestFingerprint {\n  method: string;\n  url: string;\n  headers: Record<string, string>;\n  bodyHash?: string;\n  timestamp: number;\n}\n\nexport interface IdempotentRequest {\n  key: string;\n  fingerprint: RequestFingerprint;\n  status: 'pending' | 'completed' | 'failed';\n  promise?: Promise<any>;\n  response?: any;\n  error?: Error;\n  attempts: number;\n  createdAt: number;\n  lastAttemptAt: number;\n  completedAt?: number;\n}\n\nexport interface DeduplicationStats {\n  totalRequests: number;\n  deduplicatedRequests: number;\n  cacheHits: number;\n  activePendingRequests: number;\n  memoryUsage: number;\n  keyCleanups: number;\n}\n\nexport class IdempotencyManager {\n  private config: IdempotencyConfig;\n  private requestMap = new Map<string, IdempotentRequest>();\n  private responseCache = new Map<string, { response: any; cachedAt: number }>();\n  private pendingRequests = new Map<string, Promise<any>>();\n  private keyCleanupInterval: NodeJS.Timeout | null = null;\n  private stats: DeduplicationStats = {\n    totalRequests: 0,\n    deduplicatedRequests: 0,\n    cacheHits: 0,\n    activePendingRequests: 0,\n    memoryUsage: 0,\n    keyCleanups: 0\n  };\n\n  constructor(config: Partial<IdempotencyConfig> = {}) {\n    this.config = {\n      keyTTL: 300000, // 5 minutes\n      maxConcurrentRequests: 10,\n      enableResponseCaching: true,\n      responseCacheTTL: 60000, // 1 minute\n      enableRequestFingerprinting: true,\n      maxStoredKeys: 1000,\n      ...config\n    };\n\n    this.startKeyCleanup();\n  }\n\n  /**\n   * Execute request with idempotency protection\n   */\n  async executeIdempotent<T>(\n    key: string,\n    operation: () => Promise<T>,\n    options: {\n      method?: string;\n      url?: string;\n      headers?: Record<string, string>;\n      body?: any;\n      bypassCache?: boolean;\n      priority?: 'critical' | 'high' | 'medium' | 'low';\n    } = {}\n  ): Promise<T> {\n    this.stats.totalRequests++;\n\n    // Generate request fingerprint if enabled\n    const fingerprint = this.config.enableRequestFingerprinting\n      ? await this.generateRequestFingerprint(options)\n      : null;\n\n    // Check for existing cached response\n    if (!options.bypassCache && this.config.enableResponseCaching) {\n      const cachedResponse = this.getCachedResponse(key);\n      if (cachedResponse) {\n        this.stats.cacheHits++;\n        return cachedResponse as T;\n      }\n    }\n\n    // Check for existing pending request\n    const existingRequest = this.requestMap.get(key);\n    if (existingRequest && existingRequest.status === 'pending') {\n      this.stats.deduplicatedRequests++;\n      \n      // Wait for existing request to complete\n      if (existingRequest.promise) {\n        try {\n          return await existingRequest.promise;\n        } catch (error) {\n          // If existing request failed, allow this one to proceed\n          if (existingRequest.attempts < 3) {\n            // Update existing request for retry\n            existingRequest.attempts++;\n            existingRequest.lastAttemptAt = Date.now();\n          } else {\n            // Too many attempts, create new request\n            this.requestMap.delete(key);\n          }\n        }\n      }\n    }\n\n    // Create new idempotent request\n    const idempotentRequest: IdempotentRequest = {\n      key,\n      fingerprint: fingerprint || {\n        method: options.method || 'unknown',\n        url: options.url || 'unknown',\n        headers: options.headers || {},\n        timestamp: Date.now()\n      },\n      status: 'pending',\n      attempts: 1,\n      createdAt: Date.now(),\n      lastAttemptAt: Date.now()\n    };\n\n    // Check concurrent request limits\n    const pendingCount = Array.from(this.requestMap.values())\n      .filter(req => req.status === 'pending').length;\n    \n    if (pendingCount >= this.config.maxConcurrentRequests) {\n      throw new Error(`Too many concurrent idempotent requests (${pendingCount}/${this.config.maxConcurrentRequests})`);\n    }\n\n    // Execute the operation with proper cleanup\n    const executePromise = this.performIdempotentOperation(key, operation, idempotentRequest);\n    idempotentRequest.promise = executePromise;\n    \n    this.requestMap.set(key, idempotentRequest);\n    this.pendingRequests.set(key, executePromise);\n    this.updateStats();\n\n    try {\n      const result = await executePromise;\n      return result;\n    } finally {\n      this.pendingRequests.delete(key);\n      this.updateStats();\n    }\n  }\n\n  private async performIdempotentOperation<T>(\n    key: string,\n    operation: () => Promise<T>,\n    request: IdempotentRequest\n  ): Promise<T> {\n    try {\n      const result = await operation();\n      \n      // Mark request as completed\n      request.status = 'completed';\n      request.response = result;\n      request.completedAt = Date.now();\n\n      // Cache successful response if enabled\n      if (this.config.enableResponseCaching) {\n        this.cacheResponse(key, result);\n      }\n\n      return result;\n\n    } catch (error: any) {\n      // Mark request as failed\n      request.status = 'failed';\n      request.error = error;\n      request.completedAt = Date.now();\n\n      // Don't cache failed responses\n      throw error;\n    }\n  }\n\n  /**\n   * Generate request fingerprint for complex deduplication\n   */\n  private async generateRequestFingerprint(options: {\n    method?: string;\n    url?: string;\n    headers?: Record<string, string>;\n    body?: any;\n  }): Promise<RequestFingerprint> {\n    const fingerprint: RequestFingerprint = {\n      method: options.method || 'GET',\n      url: options.url || '',\n      headers: this.normalizeHeaders(options.headers || {}),\n      timestamp: Date.now()\n    };\n\n    // Generate body hash for POST/PUT requests\n    if (options.body && (options.method === 'POST' || options.method === 'PUT')) {\n      fingerprint.bodyHash = await this.hashRequestBody(options.body);\n    }\n\n    return fingerprint;\n  }\n\n  private normalizeHeaders(headers: Record<string, string>): Record<string, string> {\n    const normalized: Record<string, string> = {};\n    \n    // Only include headers that affect request semantics\n    const importantHeaders = ['content-type', 'accept', 'authorization'];\n    \n    for (const [key, value] of Object.entries(headers)) {\n      const normalizedKey = key.toLowerCase();\n      if (importantHeaders.includes(normalizedKey)) {\n        normalized[normalizedKey] = value;\n      }\n    }\n\n    return normalized;\n  }\n\n  private async hashRequestBody(body: any): Promise<string> {\n    try {\n      const bodyString = typeof body === 'string' ? body : JSON.stringify(body);\n      \n      // Simple hash function for browser compatibility\n      let hash = 0;\n      for (let i = 0; i < bodyString.length; i++) {\n        const char = bodyString.charCodeAt(i);\n        hash = ((hash << 5) - hash) + char;\n        hash = hash & hash; // Convert to 32-bit integer\n      }\n      \n      return Math.abs(hash).toString(16);\n    } catch (error) {\n      return 'hash-error';\n    }\n  }\n\n  /**\n   * Get cached response if available and not expired\n   */\n  private getCachedResponse<T>(key: string): T | null {\n    if (!this.config.enableResponseCaching) {\n      return null;\n    }\n\n    const cached = this.responseCache.get(key);\n    if (!cached) {\n      return null;\n    }\n\n    const age = Date.now() - cached.cachedAt;\n    if (age > this.config.responseCacheTTL) {\n      this.responseCache.delete(key);\n      return null;\n    }\n\n    return cached.response;\n  }\n\n  /**\n   * Cache successful response\n   */\n  private cacheResponse(key: string, response: any): void {\n    if (!this.config.enableResponseCaching) {\n      return;\n    }\n\n    this.responseCache.set(key, {\n      response,\n      cachedAt: Date.now()\n    });\n\n    // Prevent unbounded cache growth\n    if (this.responseCache.size > this.config.maxStoredKeys) {\n      const oldestKey = this.responseCache.keys().next().value;\n      if (oldestKey) {\n        this.responseCache.delete(oldestKey);\n      }\n    }\n  }\n\n  /**\n   * Generate idempotency key from request data\n   */\n  generateIdempotencyKey(\n    method: string,\n    url: string,\n    body?: any,\n    userContext?: string\n  ): string {\n    const components = [\n      method.toUpperCase(),\n      url,\n      userContext || 'anonymous'\n    ];\n\n    if (body) {\n      try {\n        const bodyString = typeof body === 'string' ? body : JSON.stringify(body);\n        components.push(bodyString);\n      } catch (error) {\n        components.push('body-serialize-error');\n      }\n    }\n\n    return components.join('|');\n  }\n\n  /**\n   * Check if request is currently pending\n   */\n  isPending(key: string): boolean {\n    const request = this.requestMap.get(key);\n    return request?.status === 'pending' || false;\n  }\n\n  /**\n   * Get request information\n   */\n  getRequestInfo(key: string): IdempotentRequest | null {\n    return this.requestMap.get(key) || null;\n  }\n\n  /**\n   * Cancel pending request\n   */\n  cancelRequest(key: string): boolean {\n    const request = this.requestMap.get(key);\n    if (request && request.status === 'pending') {\n      request.status = 'failed';\n      request.error = new Error('Request cancelled');\n      request.completedAt = Date.now();\n      \n      this.pendingRequests.delete(key);\n      this.updateStats();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Clear expired entries and manage memory\n   */\n  private startKeyCleanup(): void {\n    this.keyCleanupInterval = setInterval(() => {\n      this.cleanupExpiredEntries();\n    }, 30000); // Clean up every 30 seconds\n  }\n\n  private cleanupExpiredEntries(): void {\n    const now = Date.now();\n    let cleanedCount = 0;\n\n    // Clean up expired requests\n    for (const [key, request] of this.requestMap.entries()) {\n      const age = now - request.createdAt;\n      if (age > this.config.keyTTL || request.status !== 'pending') {\n        this.requestMap.delete(key);\n        cleanedCount++;\n      }\n    }\n\n    // Clean up expired cached responses\n    for (const [key, cached] of this.responseCache.entries()) {\n      const age = now - cached.cachedAt;\n      if (age > this.config.responseCacheTTL) {\n        this.responseCache.delete(key);\n        cleanedCount++;\n      }\n    }\n\n    // Enforce memory limits\n    if (this.requestMap.size > this.config.maxStoredKeys) {\n      const excess = this.requestMap.size - this.config.maxStoredKeys;\n      const oldestKeys = Array.from(this.requestMap.entries())\n        .sort((a, b) => a[1].createdAt - b[1].createdAt)\n        .slice(0, excess)\n        .map(([key]) => key);\n\n      for (const key of oldestKeys) {\n        this.requestMap.delete(key);\n        cleanedCount++;\n      }\n    }\n\n    this.stats.keyCleanups += cleanedCount;\n    this.updateStats();\n  }\n\n  private updateStats(): void {\n    this.stats.activePendingRequests = this.pendingRequests.size;\n    this.stats.memoryUsage = this.requestMap.size + this.responseCache.size;\n  }\n\n  /**\n   * Get deduplication statistics\n   */\n  getStats(): DeduplicationStats {\n    this.updateStats();\n    return { ...this.stats };\n  }\n\n  /**\n   * Reset statistics (useful for testing)\n   */\n  resetStats(): void {\n    this.stats = {\n      totalRequests: 0,\n      deduplicatedRequests: 0,\n      cacheHits: 0,\n      activePendingRequests: 0,\n      memoryUsage: 0,\n      keyCleanups: 0\n    };\n  }\n\n  /**\n   * Clear all stored data\n   */\n  clear(): void {\n    this.requestMap.clear();\n    this.responseCache.clear();\n    this.pendingRequests.clear();\n    this.resetStats();\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(newConfig: Partial<IdempotencyConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n  }\n\n  /**\n   * Cleanup resources\n   */\n  destroy(): void {\n    if (this.keyCleanupInterval) {\n      clearInterval(this.keyCleanupInterval);\n      this.keyCleanupInterval = null;\n    }\n    this.clear();\n  }\n}\n\n/**\n * Utility functions for common idempotency patterns\n */\nexport class IdempotencyUtils {\n  /**\n   * Generate idempotency key for error reporting\n   */\n  static errorReportingKey(\n    projectId: string,\n    errorHash: string,\n    sessionId: string,\n    timestamp?: number\n  ): string {\n    const timeWindow = timestamp ? Math.floor(timestamp / 60000) * 60000 : 0; // 1-minute windows\n    return `error:${projectId}:${errorHash}:${sessionId}:${timeWindow}`;\n  }\n\n  /**\n   * Generate idempotency key for session events\n   */\n  static sessionEventKey(\n    projectId: string,\n    sessionId: string,\n    eventType: string,\n    sequence: number\n  ): string {\n    return `session:${projectId}:${sessionId}:${eventType}:${sequence}`;\n  }\n\n  /**\n   * Generate idempotency key for network events\n   */\n  static networkEventKey(\n    projectId: string,\n    sessionId: string,\n    method: string,\n    url: string,\n    timestamp: number\n  ): string {\n    return `network:${projectId}:${sessionId}:${method}:${url}:${timestamp}`;\n  }\n\n  /**\n   * Generate idempotency key for batch operations\n   */\n  static batchOperationKey(\n    operation: string,\n    batchId: string,\n    checksum: string\n  ): string {\n    return `batch:${operation}:${batchId}:${checksum}`;\n  }\n}","/**\n * Resilience Coordinator - Central orchestrator for all resilience components\n * Coordinates retry management, circuit breakers, storage, health monitoring, and idempotency\n */\n\nimport { RetryManager, RetryConfig } from './retry-manager';\nimport { CircuitBreakerManager, CircuitBreakerConfig } from './circuit-breaker';\nimport { ResilientStorage, ResilientStorageConfig } from './resilient-storage';\nimport { MultiRegionalHealthMonitor, HealthMonitorConfig } from './health-monitor';\nimport { IntelligentSyncManager, SyncConfig } from './sync-manager';\nimport { IdempotencyManager, IdempotencyConfig } from './idempotency-manager';\n\nexport interface ResilienceConfig {\n  retry: Partial<RetryConfig>;\n  circuitBreaker: Partial<CircuitBreakerConfig>;\n  storage: Partial<ResilientStorageConfig>;\n  healthMonitor: Partial<HealthMonitorConfig>;\n  sync: Partial<SyncConfig>;\n  idempotency: Partial<IdempotencyConfig>;\n  enableAdaptiveBehavior: boolean;\n  performanceThresholds: {\n    slowRequestMs: number;\n    verySlowRequestMs: number;\n    highErrorRate: number;\n    criticalErrorRate: number;\n  };\n}\n\nexport interface ResilienceStats {\n  retry: any;\n  circuitBreaker: any;\n  storage: any;\n  healthMonitor: any;\n  sync: any;\n  idempotency: any;\n  adaptiveBehavior: {\n    currentMode: 'normal' | 'degraded' | 'emergency';\n    adaptationCount: number;\n    lastAdaptation: number;\n  };\n}\n\nexport interface RequestOptions {\n  priority: 'critical' | 'high' | 'medium' | 'low';\n  timeout?: number;\n  payloadSize?: number;\n  idempotencyKey?: string;\n  bypassCache?: boolean;\n  feature: string;\n  region?: string;\n}\n\nexport class ResilienceCoordinator {\n  private config: ResilienceConfig;\n  private retryManager: RetryManager;\n  private circuitBreakerManager: CircuitBreakerManager;\n  private storage: ResilientStorage;\n  private healthMonitor: MultiRegionalHealthMonitor;\n  private syncManager: IntelligentSyncManager;\n  private idempotencyManager: IdempotencyManager;\n  \n  private adaptiveBehavior = {\n    currentMode: 'normal' as 'normal' | 'degraded' | 'emergency',\n    adaptationCount: 0,\n    lastAdaptation: 0\n  };\n\n  private performanceHistory: Array<{\n    timestamp: number;\n    duration: number;\n    success: boolean;\n    feature: string;\n  }> = [];\n\n  constructor(config: Partial<ResilienceConfig> = {}) {\n    this.config = {\n      retry: {},\n      circuitBreaker: {},\n      storage: {},\n      healthMonitor: {},\n      sync: {},\n      idempotency: {},\n      enableAdaptiveBehavior: true,\n      performanceThresholds: {\n        slowRequestMs: 2000,\n        verySlowRequestMs: 5000,\n        highErrorRate: 0.1, // 10%\n        criticalErrorRate: 0.25 // 25%\n      },\n      ...config\n    };\n\n    // Initialize all resilience components\n    this.retryManager = new RetryManager(this.config.retry);\n    this.circuitBreakerManager = new CircuitBreakerManager(this.config.circuitBreaker);\n    this.storage = new ResilientStorage(this.config.storage);\n    this.healthMonitor = new MultiRegionalHealthMonitor(this.config.healthMonitor);\n    this.syncManager = new IntelligentSyncManager(this.config.sync);\n    this.idempotencyManager = new IdempotencyManager(this.config.idempotency);\n\n    // Set up adaptive behavior monitoring\n    if (this.config.enableAdaptiveBehavior) {\n      this.startAdaptiveBehaviorMonitoring();\n    }\n  }\n\n  /**\n   * Execute request with full resilience protection\n   */\n  async executeResilientRequest<T>(\n    operation: () => Promise<T>,\n    options: RequestOptions\n  ): Promise<T> {\n    const startTime = Date.now();\n    const { feature, priority, idempotencyKey, region } = options;\n\n    try {\n      // Check circuit breaker first\n      await this.circuitBreakerManager.executeWithBreaker(\n        feature,\n        async () => {\n          // Execute with idempotency protection if key provided\n          if (idempotencyKey) {\n            return await this.idempotencyManager.executeIdempotent(\n              idempotencyKey,\n              () => this.executeWithRetryAndHealth(operation, options),\n              {\n                method: 'POST',\n                url: feature,\n                priority,\n                bypassCache: options.bypassCache\n              }\n            );\n          } else {\n            return await this.executeWithRetryAndHealth(operation, options);\n          }\n        },\n        { priority, region }\n      );\n\n      // Record successful performance\n      this.recordPerformance(startTime, true, feature);\n\n      return await operation();\n\n    } catch (error: any) {\n      // Record failed performance\n      this.recordPerformance(startTime, false, feature);\n\n      // Check if we should store for later sync\n      if (this.shouldStoreForLaterSync(error, priority)) {\n        await this.storeForLaterSync(operation, options, error);\n      }\n\n      throw error;\n    }\n  }\n\n  private async executeWithRetryAndHealth<T>(\n    operation: () => Promise<T>,\n    options: RequestOptions\n  ): Promise<T> {\n    const { feature, priority, timeout, payloadSize, region } = options;\n\n    // Get health recommendation\n    const healthRecommendation = this.healthMonitor.getAdaptiveRecommendation(\n      feature,\n      region\n    );\n\n    // Adapt request based on health status\n    const adaptedOptions = this.adaptRequestToHealth(options, healthRecommendation);\n\n    // Execute with retry protection\n    return await this.retryManager.executeWithRetry(\n      `${feature}:${region || 'default'}`,\n      operation,\n      {\n        priority,\n        timeout: adaptedOptions.timeout,\n        payloadSize,\n        deduplicationKey: adaptedOptions.deduplicationKey\n      }\n    );\n  }\n\n  private adaptRequestToHealth(\n    options: RequestOptions,\n    healthRecommendation: any\n  ): RequestOptions {\n    const adapted = { ...options };\n\n    if (healthRecommendation) {\n      // Adjust timeout based on health\n      if (healthRecommendation.adjustedTimeout) {\n        adapted.timeout = healthRecommendation.adjustedTimeout;\n      }\n\n      // Add deduplication for unhealthy services\n      if (healthRecommendation.useDeduplication && !adapted.idempotencyKey) {\n        adapted.idempotencyKey = `auto-dedup:${options.feature}:${Date.now()}`;\n      }\n    }\n\n    return adapted;\n  }\n\n  private shouldStoreForLaterSync(error: any, priority: string): boolean {\n    // Don't store critical requests (they should fail fast)\n    if (priority === 'critical') {\n      return false;\n    }\n\n    // Store network errors for later retry\n    if (error.name === 'TypeError' && error.message.includes('fetch')) {\n      return true;\n    }\n\n    // Store timeout errors\n    if (error.message?.includes('timeout')) {\n      return true;\n    }\n\n    // Store server errors (5xx)\n    if (error.status >= 500) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private async storeForLaterSync<T>(\n    operation: () => Promise<T>,\n    options: RequestOptions,\n    error: Error\n  ): Promise<void> {\n    const requestData = {\n      operation: operation.toString(), // Note: This is a simplified approach\n      options,\n      error: {\n        message: error.message,\n        name: error.name,\n        stack: error.stack\n      },\n      timestamp: Date.now()\n    };\n\n    await this.storage.storeData(\n      `failed-request:${options.feature}:${Date.now()}`,\n      requestData,\n      {\n        priority: options.priority,\n        compress: true,\n        encrypt: false,\n        tier: options.priority === 'high' ? 'hot' : 'warm'\n      }\n    );\n  }\n\n  /**\n   * Sync failed requests when connectivity is restored\n   */\n  async syncFailedRequests(): Promise<void> {\n    // Get all failed requests from storage\n    const failedRequests = await this.storage.getAllDataByPattern('failed-request:*');\n\n    if (failedRequests.length === 0) {\n      return;\n    }\n\n    // Use intelligent sync manager for optimal batching\n    await this.syncManager.performIntelligentSync(\n      'failed-requests',\n      failedRequests.map(req => ({\n        id: req.key,\n        data: req.data,\n        priority: req.metadata?.priority || 'medium',\n        size: JSON.stringify(req.data).length,\n        timestamp: req.metadata?.timestamp || Date.now(),\n        dependencies: []\n      })),\n      {\n        maxBatchSize: 50,\n        timeoutMs: 30000,\n        priority: 'high'\n      }\n    );\n\n    // Clean up successfully synced requests\n    for (const request of failedRequests) {\n      await this.storage.deleteData(request.key);\n    }\n  }\n\n  /**\n   * Start adaptive behavior monitoring\n   */\n  private startAdaptiveBehaviorMonitoring(): void {\n    setInterval(() => {\n      this.evaluateAndAdaptBehavior();\n    }, 30000); // Check every 30 seconds\n  }\n\n  private evaluateAndAdaptBehavior(): void {\n    if (!this.config.enableAdaptiveBehavior) {\n      return;\n    }\n\n    const recentPerformance = this.getRecentPerformance(300000); // Last 5 minutes\n    if (recentPerformance.length === 0) {\n      return;\n    }\n\n    const errorRate = recentPerformance.filter(p => !p.success).length / recentPerformance.length;\n    const averageDuration = recentPerformance.reduce((sum, p) => sum + p.duration, 0) / recentPerformance.length;\n\n    const currentMode = this.adaptiveBehavior.currentMode;\n    let newMode: 'normal' | 'degraded' | 'emergency' = 'normal';\n\n    // Determine new mode based on performance\n    if (errorRate >= this.config.performanceThresholds.criticalErrorRate) {\n      newMode = 'emergency';\n    } else if (\n      errorRate >= this.config.performanceThresholds.highErrorRate ||\n      averageDuration >= this.config.performanceThresholds.verySlowRequestMs\n    ) {\n      newMode = 'degraded';\n    } else if (averageDuration >= this.config.performanceThresholds.slowRequestMs) {\n      newMode = 'degraded';\n    }\n\n    // Apply mode change if needed\n    if (newMode !== currentMode) {\n      this.applyAdaptiveBehaviorMode(newMode);\n      this.adaptiveBehavior.currentMode = newMode;\n      this.adaptiveBehavior.adaptationCount++;\n      this.adaptiveBehavior.lastAdaptation = Date.now();\n    }\n  }\n\n  private applyAdaptiveBehaviorMode(mode: 'normal' | 'degraded' | 'emergency'): void {\n    switch (mode) {\n      case 'emergency':\n        // Emergency mode: Aggressive protection\n        this.retryManager.updateConfig({\n          maxAttempts: 2,\n          baseDelay: 5000,\n          retryBudget: 20\n        });\n        this.circuitBreakerManager.updateGlobalConfig({\n          failureThreshold: 3,\n          recoveryTimeout: 30000,\n          emergencyMode: true\n        });\n        break;\n\n      case 'degraded':\n        // Degraded mode: Reduced retries, increased delays\n        this.retryManager.updateConfig({\n          maxAttempts: 3,\n          baseDelay: 2000,\n          retryBudget: 50\n        });\n        this.circuitBreakerManager.updateGlobalConfig({\n          failureThreshold: 5,\n          recoveryTimeout: 15000,\n          emergencyMode: false\n        });\n        break;\n\n      case 'normal':\n        // Normal mode: Standard settings\n        this.retryManager.updateConfig({\n          maxAttempts: 5,\n          baseDelay: 1000,\n          retryBudget: 100\n        });\n        this.circuitBreakerManager.updateGlobalConfig({\n          failureThreshold: 10,\n          recoveryTimeout: 10000,\n          emergencyMode: false\n        });\n        break;\n    }\n  }\n\n  private recordPerformance(startTime: number, success: boolean, feature: string): void {\n    const duration = Date.now() - startTime;\n    \n    this.performanceHistory.push({\n      timestamp: Date.now(),\n      duration,\n      success,\n      feature\n    });\n\n    // Keep only recent performance data (last hour)\n    const oneHourAgo = Date.now() - 3600000;\n    this.performanceHistory = this.performanceHistory.filter(\n      p => p.timestamp > oneHourAgo\n    );\n  }\n\n  private getRecentPerformance(timeWindowMs: number) {\n    const cutoff = Date.now() - timeWindowMs;\n    return this.performanceHistory.filter(p => p.timestamp > cutoff);\n  }\n\n  /**\n   * Get comprehensive resilience statistics\n   */\n  getStats(): ResilienceStats {\n    return {\n      retry: this.retryManager.getStats(),\n      circuitBreaker: this.circuitBreakerManager.getGlobalStats(),\n      storage: this.storage.getStats(),\n      healthMonitor: this.healthMonitor.getGlobalStats(),\n      sync: this.syncManager.getStats(),\n      idempotency: this.idempotencyManager.getStats(),\n      adaptiveBehavior: { ...this.adaptiveBehavior }\n    };\n  }\n\n  /**\n   * Reset all statistics (useful for testing)\n   */\n  resetAllStats(): void {\n    this.retryManager.resetStats();\n    this.circuitBreakerManager.resetStats();\n    this.storage.resetStats();\n    this.healthMonitor.resetStats();\n    this.syncManager.resetStats();\n    this.idempotencyManager.resetStats();\n    this.performanceHistory = [];\n    this.adaptiveBehavior = {\n      currentMode: 'normal',\n      adaptationCount: 0,\n      lastAdaptation: 0\n    };\n  }\n\n  /**\n   * Update configuration for all components\n   */\n  updateConfig(newConfig: Partial<ResilienceConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n\n    if (newConfig.retry) {\n      this.retryManager.updateConfig(newConfig.retry);\n    }\n    if (newConfig.circuitBreaker) {\n      this.circuitBreakerManager.updateGlobalConfig(newConfig.circuitBreaker);\n    }\n    if (newConfig.storage) {\n      this.storage.updateConfig(newConfig.storage);\n    }\n    if (newConfig.healthMonitor) {\n      this.healthMonitor.updateConfig(newConfig.healthMonitor);\n    }\n    if (newConfig.sync) {\n      this.syncManager.updateConfig(newConfig.sync);\n    }\n    if (newConfig.idempotency) {\n      this.idempotencyManager.updateConfig(newConfig.idempotency);\n    }\n  }\n\n  /**\n   * Cleanup all resources\n   */\n  destroy(): void {\n    this.idempotencyManager.destroy();\n    this.healthMonitor.destroy();\n    this.syncManager.destroy();\n    // Other components don't have destroy methods currently\n  }\n}"],"names":["generateId","replace","c","r","Math","random","toString","formatStackTrace","error","stack","split","map","line","trim","filter","length","join","TraceManager","constructor","this","spanCounter","spanData","Map","generateNewTrace","currentTraceId","generateTraceId","currentSpanId","undefined","startSpan","operationName","parentSpanId","generateSpanId","setSpanData","startTime","Date","now","finishSpan","spanId","data","getSpanData","endTime","getCurrentTraceId","getCurrentSpanId","getTraceContext","traceId","getParentSpanId","extractTraceFromHeaders","headers","_a","_b","_c","_d","injectTraceHeaders","correlateWithBackendTrace","backendTraceId","backendSpanId","generateRandomHex","array","Uint8Array","crypto","getRandomValues","i","floor","Array","from","byte","padStart","get","set","cleanupSpanData","cutoff","entries","delete","ErrorHandler","config","traceManager","breadcrumbs","userContext","setupGlobalHandlers","window","addEventListener","event","captureError","message","filename","lineno","colno","reason","Error","JSON","stringify","originalConsoleError","console","args","addBreadcrumb","timestamp","category","level","apply","originalConsoleWarn","warn","errorData","sampleRate","errorId","traceContext","errorEvent","id","url","location","href","userId","sessionId","userAgent","navigator","environment","release","tags","extra","beforeSend","call","captureException","options","captureMessage","breadcrumb","push","maxBreadcrumbs","splice","setUserContext","user","setTags","_tags","setExtra","_extra","getBreadcrumbs","clearBreadcrumbs","SessionManager","events","storage","sessionStorage","setItem","removeItem","getSessionStorage","getOrCreateSessionId","setupEventListeners","trackPageLoad","storageKey","existingId","getItem","newId","getSessionId","scrollTimeout","resizeTimeout","forEach","eventType","document","captureEvent","serializeDOMEvent","capture","passive","type","hidden","clearTimeout","setTimeout","x","scrollX","y","scrollY","width","innerWidth","height","innerHeight","duration","flush","target","tagName","className","textContent","shouldMaskText","slice","coordinates","clientX","clientY","inputEvent","value","shouldMaskInput","element","privacy","maskInputs","includes","name","toLowerCase","some","sensitive","replay","maskAllText","maskSelector","matches","captureLoadEvent","title","referrer","loadTime","performance","readyState","sessionSampleRate","filteredEvent","beforeSendSession","getEvents","getQueuedEventCount","clearEvents","endSession","NetworkMonitor","lastActivityTime","activityCheckInterval","originalFetch","fetch","originalXHROpen","XMLHttpRequest","prototype","open","originalXHRSend","send","setupInterceptors","startActivityMonitor","interceptFetch","interceptXHR","setInterval","recordActivity","async","method","toUpperCase","shouldMonitorRequest","traceHeaders","modifiedArgs","requestBody","requestSize","body","serializeRequestBody","calculateBodySize","response","responseBody","responseSize","shouldCaptureResponseBody","clonedResponse","clone","extractResponseBody","calculateResponseSize","responseTrace","extractResponseHeaders","statusCode","status","responseTime","captureNetworkEvent","requestHeaders","extractHeaders","responseHeaders","String","self","shouldMonitor","_reviData","reviData","responseType","responseText","FormData","formObject","key","File","URLSearchParams","Object","fromEntries","parse","contentType","json","text","Headers","headerObj","isArray","ArrayBuffer","byteLength","Blob","size","pattern","test","normalizedApiUrl","apiUrl","normalizedUrl","startsWith","isReviApiPattern","isFromReviBackend","excludeUrls","denyUrls","RegExp","allowUrls","destroy","clearInterval","IndexedDBStorage","db","dbName","version","storeName","maxQueueSize","maxAge","initialize","indexedDB","Promise","resolve","reject","request","onerror","onsuccess","result","onupgradeneeded","objectStoreNames","contains","objectStore","createObjectStore","keyPath","createIndex","unique","store","cleanupExpiredItems","queueSize","getQueueSize","removeOldestItems","item","compress","compressed","transaction","add","getAll","items","errors","sessionEvents","networkEvents","decompressedData","decompress","clear","count","cutoffTime","index","range","IDBKeyRange","upperBound","openCursor","cursor","continue","deletedCount","btoa","unescape","encodeURIComponent","decoded","decodeURIComponent","escape","atob","parseError","substr","LocalStorageAdapter","localStorage","getLocalStorage","existing","storedData","StorageManager","isInitialized","localStorageError","NoOpStorage","storeErrors","ensureInitialized","storeSessionEvents","storeNetworkEvents","getAllData","clearAll","NetworkManager","isOnline","onLine","connectionType","listeners","notifyListeners","detectConnectionType","getConnectionStatus","online","onConnectionChange","callback","indexOf","getBatchSize","getUploadDelay","shouldRetry","attempt","getRetryDelay","min","pow","connection","effectiveType","testConnectivity","testUrl","mode","cache","compressData","deduplicateEvents","compressionRatio","originalSize","criticalFields","Set","grouped","keys","sort","has","groupedEvents","commonValues","keyArray","values","e","firstValue","every","v","compressedEvent","_common","createOptimalBatches","maxBatchSize","maxBatchBytes","batches","currentBatch","currentBatchSize","eventSize","DebugLogger","enabled","saveToFile","logs","isEnabled","maxLogs","saveTimer","debouncedSave","saveToJsonFile","log","operation","entry","stackTrace","getStackTrace","addLogEntry","consoleLog","logError","logSessionEvent","eventData","sanitizeData","hasSessionId","logApiCall","payload","payloadSize","logDataTransformation","before","after","beforeType","afterType","beforeLength","afterLength","logSessionEventUpload","eventsCount","eventsStructure","event_type","session_id","sessionIdValue","dataKeys","firstEventHasSessionId","toISOString","cloned","_type","first5","last5","_error","logData","sessionCount","l","apiCallCount","errorCount","dataStr","dataBlob","URL","createObjectURL","link","createElement","download","downloadReviLogs","click","revokeObjectURL","getLogs","filtered","getSummary","categoryCounts","reduce","acc","operationCounts","totalLogs","categories","operations","timeRange","start","end","setEnabled","globalDebugLogger","getDebugLogger","DataManager","debugLogger","uploadTimer","isUploading","retryAttempts","uploadQueue","storageManager","networkManager","loadQueueFromStorage","startNetworkAwareUploadTimer","setupBeforeUnloadHandler","setupNetworkChangeHandler","saveQueueToStorage","scheduleNextUpload","delay","hasQueuedData","uploadData","finally","uploadDataSync","queueError","catch","err","queueSessionEvents","queueNetworkEvents","batchSize","dedupedErrors","errorBatches","batch","uploadErrorsWithRetry","dedupedEvents","sessionBatches","uploadSessionEventsWithRetry","networkBatches","uploadNetworkEventsWithRetry","sendBeacon","uploadErrors","stack_trace","user_agent","metadata","device_info","deviceInfo","browser_name","browser_version","browser_major_version","os_name","os_version","device_type","device_fingerprint","screen_resolution","color_depth","device_pixel_ratio","viewport_size","platform","language","timezone","canvas_fingerprint","webgl_fingerprint","cookie_enabled","local_storage_enabled","session_storage_enabled","compressedData","apiKey","ok","uploadSessionEvents","sessionIdType","sessionIdEmpty","firstEventType","compressedSize","payloadSessionId","payloadEventsCount","statusText","errorText","errorResponse","payloadPreview","firstEventKeys","eventsUploaded","uploadNetworkEvents","firstEventMethod","status_code","response_time","request_data","response_data","allHaveSessionId","sessionIds","executeWithRetry","currentAttempt","clearQueue","UserJourneyTracker","sessionIdProvider","journeyEvents","isTracking","deviceFingerprint","generateDeviceFingerprint","sessionStartTime","currentPageStartTime","setupJourneyTracking","startTracking","trackPageView","stopTracking","setUserId","viewport","scroll_position","Intl","DateTimeFormat","resolvedOptions","timeZone","connection_type","getConnectionType","addJourneyEvent","trackClick","journeyEvent","tag","class","getElementText","attributes","getRelevantAttributes","page_x","pageX","page_y","pageY","trackFormSubmit","form","formData","fields","input","querySelector","has_value","value_length","action","field_count","trackApiCall","duration_ms","api","success","page_context","time_on_page","trackError","context","user_context","session_duration","page_interactions","countPageInteractions","custom_context","currentUrl","handleNavigation","timeSpent","updateLastPageViewDuration","originalPushState","history","pushState","originalReplaceState","replaceState","shouldTrackClick","components","screen","colorDepth","cookieEnabled","canvas","ctx","getContext","textBaseline","font","fillText","toDataURL","fingerprint","hash","charCodeAt","abs","sendJourneyEvents","unshift","promises","user_id","allSettled","hasAttribute","innerText","substring","attrs","attr","getAttribute","lastEvent","SamplingManager","activityLevel","lastActivity","errorFrequency","performanceImpact","startPerformanceMonitoring","assessPerformanceImpact","recentLongTasks","getEntriesByType","updateActivityLevel","activity","high","medium","low","idle","incrementErrorFrequency","max","shouldSampleError","baseSampleRate","sampling","errorSampleRate","adjustedRate","shouldSampleSession","finalRate","shouldSamplePerformance","performanceSampleRate","shouldSampleNetwork","networkSampleRate","shouldSampleReplay","replaySampleRate","getAdaptiveBatchSize","baseSize","getAdaptiveUploadDelay","baseDelay","shouldSkipCapture","getPerformanceImpact","getActivityLevel","getErrorFrequency","PerformanceMonitor","webVitals","performanceEntries","captureWebVitals","setupWebVitals","captureResourceTiming","setupResourceTiming","captureNavigationTiming","setupNavigationTiming","PerformanceObserver","list","getEntries","lcp","observe","entryTypes","fid","processingStart","clsValue","hadRecentInput","cls","fcp","calculateTTFB","navigationTiming","ttfb","responseStart","requestStart","entryType","transferSize","encodedBodySize","decodedBodySize","domContentLoadedEventEnd","domContentLoadedEventStart","loadEventEnd","loadEventStart","domComplete","domInteractive","getWebVitals","getPerformanceEntries","clearPerformanceEntries","mark","measure","startMark","endMark","getEntriesByName","EnhancedDOMSerializer","_config","nodeIdMap","WeakMap","nodeMap","nextNodeId","isObserving","layoutShiftEntries","computedStyleCache","setupPerformanceObserver","setupStylesheetTracking","takeEnhancedSnapshot","snapshot","devicePixelRatio","nodes","stylesheets","resources","capturePerformanceMetrics","captureEnvironmentInfo","serializeDocumentEnhanced","serializeStylesheetsEnhanced","serializeResourcesEnhanced","startEnhancedObserving","onDOMChange","observer","MutationObserver","handleEnhancedMutations","bind","childList","characterData","subtree","attributeOldValue","characterDataOldValue","attributeFilter","ResizeObserver","resizeObserver","handleResizeChanges","documentElement","stopEnhancedObserving","disconnect","performanceObserver","doc","doctype","serializeDoctype","serialized","serializeNodeEnhanced","node","shouldIgnoreNode","getNodeId","getNodeType","renderTime","nodeType","Node","ELEMENT_NODE","serializeAttributesEnhanced","computedStyles","captureComputedStyles","inlineStyles","captureInlineStyles","boundingRect","getBoundingClientRect","visibility","captureVisibilityInfo","interactionState","captureInteractionState","isFormElement","inputValue","captureInputValue","selectedOptions","captureSelectedOptions","scrollWidth","clientWidth","scrollHeight","clientHeight","scrollPosition","scrollLeft","scrollTop","children","serializeChildrenEnhanced","TEXT_NODE","textNode","COMMENT_NODE","computedStyle","getComputedStyle","styles","property","getPropertyValue","HTMLElement","style","priority","getPropertyPriority","rect","visible","opacity","parseFloat","display","zIndex","parseInt","state","focused","activeElement","hovered","pressed","disabled","HTMLInputElement","checked","HTMLSelectElement","selected","selectedIndex","HTMLTextAreaElement","multiple","styleSheets","sheet","enhanced","processStylesheet","rules","cssRules","processed","processCSSRule","cssText","extractCSSText","media","mediaText","origin","estimateStylesheetSize","rule","CSSStyleRule","selectorText","declarations","extractDeclarations","specificity","calculateSpecificity","CSSMediaRule","important","selector","match","processedUrls","querySelectorAll","img","src","createImageResource","createResourceFromPerformanceEntry","dimensions","naturalWidth","naturalHeight","failed","complete","inferResourceType","responseEnd","fromCache","mutations","mutation","change","oldValue","renderingTime","addedNodes","removedNodes","attributeName","Element","attributeValue","classChanges","analyzeClassChanges","styleChanges","analyzeStyleChanges","visualChange","analyzeVisualImpact","HTMLLinkElement","rel","HTMLStyleElement","head","navigation","paint","domContentLoaded","loadComplete","paintTimings","layoutShifts","memoryUsage","memory","usedJSHeapSize","colorScheme","matchMedia","reducedMotion","_node","DOCUMENT_NODE","DOCUMENT_TYPE_NODE","publicId","systemId","shouldIgnoreAttribute","shouldMaskAttribute","childNodes","parent","parentElement","closest","affectedArea","contentRect","significance","newValue","oldClasses","Boolean","newClasses","added","removed","_element","pop","ConsoleRecorder","originalMethods","isRecording","maxEntries","captureStackTrace","serializeObjects","maxObjectDepth","maxStringLength","ignoredLevels","originalMethod","recordEntry","stop","serializeArgs","cleanStackTrace","sourceLine","find","lineNumber","columnNumber","addEntry","arg","serializeValue","depth","__type","fromTimestamp","toTimestamp","getEntriesByLevel","toSessionEvents","consoleId","originalUrl","exportData","levelCounts","minTime","Infinity","maxTime","stats","totalEntries","warningCount","generateInsights","errorPatterns","findErrorPatterns","performanceIssues","detectPerformanceIssues","recommendations","generateRecommendations","patterns","firstArg","a","b","examples","issues","recentEntries","severity","details","errorCounts","debug","HeatmapGenerator","container","radius","maxIntensity","gradient","blur","minOpacity","maxOpacity","position","top","left","pointerEvents","appendChild","resizeCanvas","addDataPoint","intensity","generateFromEvents","_e","_f","render","clearRect","filteredData","d","intensityData","createIntensityMap","createGradient","renderHeatmap","shadowCanvas","shadowCtx","point","createRadialGradient","addColorStop","fillStyle","fillRect","drawImage","getImageData","gradientCanvas","gradientCtx","createLinearGradient","color","gradientData","output","createImageData","alpha","gradientIndex","putImageData","removeChild","removeEventListener","eventTypes","minX","maxX","minY","maxY","totalEvents","bounds","hotSpots","findHotSpots","clickPatterns","analyzeClickPatterns","userBehavior","analyzeUserBehavior","clusters","clusterRadius","foundCluster","cluster","sqrt","round","clicks","current","next","frequency","scrolls","sortedByIntensity","topHalf","scrollDepth","s","engagementScore","mostActiveArea","averageClicksPerSession","SessionReplayManager","heatmapGenerator","consoleLogs","networkRequests","originalConsole","domSerializer","consoleRecorder","maxConsoleEntries","ignoredConsoleLevels","_g","setupReplay","_j","_h","heatmaps","_l","_k","_o","_m","_q","_p","_s","_r","startRecording","takeFullSnapshot","handleDOMChange","setupNetworkCapture","setupInteractionTracking","stopRecording","restoreOriginalNetwork","getReplayData","consoleEntries","consoleInsights","heatmapData","heatmapInsights","console_logs","network_requests","heatmap_data","session_info","start_time","page_url","analytics","console_insights","heatmap_insights","clearReplayData","addCustomEvent","addEvent","source","toggleHeatmap","getHeatmapInsights","init","requestId","generateRequestId","Request","getRequestHeaders","networkRequest","getResponseHeaders","originalXMLHttpRequest","xhr","originalOpen","originalSend","m","u","shouldCaptureXHRResponse","getElementId","shouldIgnoreKeystroke","sanitizeKey","code","serializeConsoleArgs","assign","contentLength","getResponseHeader","DeviceInfoManager","cachedDeviceInfo","instance","getDeviceInfo","getServerSideDeviceInfo","browserInfo","parseBrowser","osInfo","parseOperatingSystem","deviceType","detectDeviceType","majorVersion","generateCanvasFingerprint","generateWebGLFingerprint","testStorageAvailability","browsers","regex","browser","isNaN","macVersionMatch","winVersionMatch","systems","system","mobilePatterns","tabletPatterns","screenWidth","hardwareConcurrency","canvasFingerprint","webglFingerprint","str","gl","renderer","getParameter","RENDERER","vendor","VENDOR","VERSION","getSupportedExtensions","testKey","clearCache","getDeviceSummary","info","deviceInfoManager","Monitor","process","env","REVI_API_URL","maskPasswords","maskCreditCards","maskAllInputs","ReviDebugLogger","initDebugLogger","saveDebugLogs","errorHandler","sessionManager","networkMonitor","performanceMonitor","dataManager","userJourneyTracker","sessionReplayManager","samplingManager","setupAdaptiveFlush","registerDevice","lastFlushTime","adaptiveFlush","timeSinceLastFlush","networkEventCount","sessionEventCount","totalActivityCount","flushInterval","originalCaptureException","devicePayload","startSessionReplay","stopSessionReplay","getSessionReplayData","sessionEventsCount","networkEventsCount","currentSessionId","sessionIdLength","beforeSessionId","eventIndex","afterSessionId","assignmentWorked","sessionIdMatches","sessionEventsQueued","networkEventsQueued","RetryManager","retryStats","retryBudgetUsed","lastBudgetReset","budgetResetInterval","requestDeduplication","rateLimitedUntil","maxAttempts","maxDelay","jitterRatio","timeoutMultiplier","retryBudget","enableJitter","timeout","deduplicationKey","resetBudgetIfNeeded","hasBudgetAvailable","getOrCreateStats","executePromise","performRetryLoop","attempts","attemptStart","createRetryableError","executeWithTimeout","totalAttempts","successfulRetries","lastSuccess","attemptRecord","retryableError","classifyError","lastFailure","handleRateLimit","failedRetries","calculateDelay","totalDelay","sum","att","averageDelay","sleep","consumeRetryBudget","race","_","retryable","critical","retryAfter","retryAfterMs","budgetUsed","ms","getStats","resetStats","isRateLimited","getRemainingBudget","updateConfig","newConfig","CircuitBreaker","requestWindow","failureThreshold","recoveryTime","successThreshold","maxFailureRate","windowSize","minRequests","metrics","requests","failures","successes","failureRate","averageResponseTime","execute","fallback","nextRetryTime","transitionToHalfOpen","recordSuccess","recordFailure","fallbackError","cleanupOldRequests","updateMetrics","lastSuccessTime","transitionToClosed","lastFailureTime","shouldOpen","transitionToOpen","openTime","req","totalRequests","successfulRequests","failedRequests","totalDuration","getMetrics","getState","forceState","reset","onStateChange","CircuitBreakerManager","circuitBreakers","featureConfigs","degradedFeatures","globalCircuitBreaker","enableEmergencyMode","disableEmergencyMode","registerFeature","feature","circuitBreaker","handleFeatureStateChange","executeProtected","featureName","featureBreaker","featureConfig","gracefulDegradation","evaluateSystemHealth","totalFeatures","cb","enableProgressiveDegradation","disableProgressiveDegradation","breaker","getSystemHealth","featuresTotal","featuresFailed","featuresHealthy","featuresDegraded","globalState","emergencyMode","progressiveDegradation","getAllMetrics","getCircuitBreaker","isFeatureDegraded","resetAll","onEvent","executeWithBreaker","degradeGracefully","degradedResponse","fallbackEnabled","updateGlobalConfig","getGlobalStats","global","features","systemHealth","ResilientStorage","tiers","memoryStore","initialized","compressionWorker","initializeTiers","quotaManager","StorageQuotaManager","initializeCompressionWorker","maxSize","compressionEnabled","encryptionEnabled","retentionTime","Worker","blob","all","initializeIndexedDB","initializeLocalStorage","startBackgroundCleanup","ttl","forceSync","dataSize","calculateSize","tier","selectOptimalTier","encrypted","retryCount","expiresAt","checksum","calculateChecksum","storeInTier","checkQuotaAvailable","makeSpace","storeInMemory","storeInIndexedDB","storeInLocalStorage","getStoreNameFromId","put","processedData","encryptData","retrieve","tierName","retrieveFromTier","validateItemIntegrity","shouldPromote","promoteItem","retrieveFromIndexedDB","retrieveFromLocalStorage","decompressed","decompressData","itemJson","decryptData","getAllByType","tierItems","getAllFromTier","priorityOrder","priorityDiff","getAllFromIndexedDB","getAllFromLocalStorage","getStoreName","remove","keysToRemove","requiredSize","getUsage","available","evictLowPriorityItems","stores","cleanupIndexedDBStore","cleanupLocalStorage","evictedSize","sortedItems","hotTier","handleMessage","postMessage","encryptedData","storeData","storageProviders","getData","parsed","deleteData","getAllDataByPattern","results","totalItems","totalSize","itemsByPriority","itemsByTier","hot","warm","cold","quotaUsage","getTotalUsage","tierUsage","itemCount","sizeBytes","quotaUsed","quotas","estimate","total","quota","used","usage","percentage","EndpointHealthMonitor","checkInterval","requestHistory","isRunning","interval","endpoint","expectedStatus","recoveryThreshold","degradationThreshold","initializeMetrics","successRate","errorRate","availability","lastCheck","consecutiveFailures","consecutiveSuccesses","p95ResponseTime","p99ResponseTime","totalErrors","uptime","downtime","scheduleCheck","performHealthCheck","checkStartTime","executeHealthCheck","attemptError","checkError","recordCheckResult","controller","AbortController","timeoutId","abort","signal","cleanupOldHistory","calculateHealthStatus","shift","windowRequests","windowSuccesses","windowErrors","totalTime","sorted","trend","confidence","recentHalf","earlierHalf","recentSuccessRate","earlierSuccessRate","lastChecked","getHealthStatus","forceCheck","onStatusChange","oldInterval","MultiRegionalHealthMonitor","regionalMonitors","primaryRegion","failoverHistory","adaptiveBehavior","AdaptiveBehavior","registerRegion","region","monitor","handleRegionalStatusChange","startAll","stopAll","performFailover","recordRegionalHealth","fromRegion","availableRegions","aHealth","bHealth","newPrimaryRegion","to","recordFailover","getPrimaryRegion","getAllRegionalHealth","lastFailover","f","getFailoverHistory","getAdaptiveBehaviorRecommendations","getRecommendations","forceFailover","toRegion","allStats","avgLatency","averageLatency","avgErrorRate","regions","endpoints","totalChecks","averageErrorRate","failovers","regionalHealthHistory","failoverPatterns","adaptiveSettings","uploadFrequency","updateAdaptiveSettings","reasoning","IntelligentSyncManager","healthMonitor","currentSync","syncContext","abortController","syncHistory","retryManager","maxConcurrentBatches","priorityWeights","bandwidthThrottling","progressiveSync","conflictResolution","maxSyncTime","resumeIncomplete","apiEndpoint","setupNetworkListeners","handleNetworkReconnection","startIntelligentSync","generateSessionId","deviceId","getDeviceId","lastSyncTimestamp","getLastSyncTimestamp","offlineDuration","networkQuality","assessNetworkQuality","batteryLevel","getBatteryLevel","isBackground","performIntelligentSync","recordSyncHistory","progress","phase","syncedItems","failedItems","totalBatches","estimatedTimeRemaining","bytesTransferred","totalBytes","notifyProgress","syncPlan","prepareSyncPlan","executeSyncBatches","conflicts","resolveConflicts","updateLastSyncTimestamp","sessions","itemsToSync","priorityWeight","adaptedBatchSize","calculateAdaptiveBatchSize","createIntelligentBatches","detectConflicts","adaptedSize","priorityGroups","groupItems","batchItems","estimatedBytes","concurrentBatches","activeBatches","p","isPromisePending","aborted","batchPromise","syncBatch","updateEstimatedTime","batchNumber","errorItems","sessionItems","networkItems","syncErrorItems","syncSessionItems","syncNetworkItems","client_timestamp","retry_count","offline_duration","sessionGroups","localItem","conflictType","resolution","resolvedWith","conflict","elapsedTime","cancelSync","getCurrentProgress","isSyncRunning","onProgress","stored","health","itemsSynced","promise","getSyncHistory","getConfig","activeSyncs","lastSync","totalSyncs","successfulSyncs","IdempotencyManager","requestMap","responseCache","pendingRequests","keyCleanupInterval","deduplicatedRequests","cacheHits","activePendingRequests","keyCleanups","keyTTL","maxConcurrentRequests","enableResponseCaching","responseCacheTTL","enableRequestFingerprinting","maxStoredKeys","startKeyCleanup","executeIdempotent","generateRequestFingerprint","bypassCache","cachedResponse","getCachedResponse","existingRequest","lastAttemptAt","idempotentRequest","createdAt","pendingCount","performIdempotentOperation","updateStats","completedAt","cacheResponse","normalizeHeaders","bodyHash","hashRequestBody","normalized","importantHeaders","normalizedKey","bodyString","cached","cachedAt","oldestKey","generateIdempotencyKey","isPending","getRequestInfo","cancelRequest","cleanupExpiredEntries","cleanedCount","excess","oldestKeys","currentMode","adaptationCount","lastAdaptation","performanceHistory","retry","sync","idempotency","enableAdaptiveBehavior","performanceThresholds","slowRequestMs","verySlowRequestMs","highErrorRate","criticalErrorRate","circuitBreakerManager","syncManager","idempotencyManager","startAdaptiveBehaviorMonitoring","executeResilientRequest","idempotencyKey","executeWithRetryAndHealth","recordPerformance","shouldStoreForLaterSync","storeForLaterSync","healthRecommendation","getAdaptiveRecommendation","adaptedOptions","adaptRequestToHealth","adapted","adjustedTimeout","useDeduplication","requestData","encrypt","syncFailedRequests","dependencies","timeoutMs","evaluateAndAdaptBehavior","recentPerformance","getRecentPerformance","averageDuration","newMode","applyAdaptiveBehaviorMode","recoveryTimeout","oneHourAgo","timeWindowMs","resetAllStats"],"mappings":"SAAgBA,IACd,MAAO,2BAA2BC,QAAQ,QAAS,SAASC,GAC1D,MAAMC,EAAoB,GAAhBC,KAAKC,SAAgB,EAE/B,OADgB,MAANH,EAAYC,EAAS,EAAJA,EAAU,GAC5BG,SAAS,GACpB,EACF,CAEM,SAAUC,EAAiBC,GAC/B,OAAKA,EAAMC,MAEJD,EAAMC,MACVC,MAAM,MACNC,IAAIC,GAAQA,EAAKC,QACjBC,OAAOF,GAAQA,EAAKG,OAAS,GAC7BC,KAAK,MANiB,EAO3B,qDChBaC,EAKX,WAAAC,GAFQC,KAAAC,YAAc,EAyIdD,KAAAE,SAAW,IAAIC,IArIrBH,KAAKI,kBACP,CAEA,gBAAAA,GAIE,OAHAJ,KAAKK,eAAiBL,KAAKM,kBAC3BN,KAAKO,mBAAgBC,EACrBR,KAAKC,YAAc,EACZD,KAAKK,cACd,CAEA,SAAAI,CAAUC,GACR,MAAMC,EAAeX,KAAKO,cAa1B,OAZAP,KAAKO,cAAgBP,KAAKY,iBAC1BZ,KAAKC,cAGDS,GACFV,KAAKa,YAAYH,EAAe,CAC9BC,eACAD,gBACAI,UAAWC,KAAKC,QAIbhB,KAAKO,aACd,CAEA,UAAAU,CAAWC,EAAiBC,GACtBD,GAAUlB,KAAKO,gBAAkBW,GAE/BC,GACFnB,KAAKa,YAAYK,EAAQ,IACpBlB,KAAKoB,YAAYF,MACjBC,EACHE,QAASN,KAAKC,OAItB,CAEA,iBAAAM,GACE,OAAOtB,KAAKK,cACd,CAEA,gBAAAkB,GACE,OAAOvB,KAAKO,aACd,CAEA,eAAAiB,GACE,MAAO,CACLC,QAASzB,KAAKK,eACda,OAAQlB,KAAKO,cACbI,aAAcX,KAAK0B,kBAEvB,CAGA,uBAAAC,CAAwBC,eAYtB,MAAO,CAAEH,QAVOG,EAAQ,gBACa,QAAtBC,EAAAD,EAAqB,mBAAC,IAAAC,OAAA,EAAAA,EAAEtC,MAAM,KAAK,KACnCqC,EAAQ,gBACgB,QAAxBE,EAAAF,EAAQ,wBAAgB,IAAAE,OAAA,EAAAA,EAAEvC,MAAM,KAAK,IAOlC2B,OALHU,EAAQ,eACa,QAAtBG,EAAAH,EAAqB,mBAAC,IAAAG,OAAA,EAAAA,EAAExC,MAAM,KAAK,KACnCqC,EAAQ,eACgB,QAAxBI,EAAAJ,EAAQ,wBAAgB,IAAAI,OAAA,EAAAA,EAAEzC,MAAM,KAAK,IAGrD,CAGA,kBAAA0C,GACE,IAAKjC,KAAKK,eACR,MAAO,CAAA,EAGT,MAAMuB,EAAkC,CAAA,EAcxC,OAXAA,EAAQ,cAAgB5B,KAAKK,eACzBL,KAAKO,gBACPqB,EAAQ,aAAe5B,KAAKO,cAC5BqB,EAAQ,oBAAsB5B,KAAK0B,mBAAqB,IAItD1B,KAAKO,gBACPqB,EAAqB,YAAI,MAAM5B,KAAKK,kBAAkBL,KAAKO,oBAGtDqB,CACT,CAGA,yBAAAM,CAA0BC,EAAyBC,GAC7CD,IACFnC,KAAKK,eAAiB8B,GAEpBC,IACFpC,KAAKO,cAAgB6B,EAEzB,CAEQ,eAAA9B,GAEN,OAAON,KAAKqC,kBAAkB,GAChC,CAEQ,cAAAzB,GAEN,OAAOZ,KAAKqC,kBAAkB,GAChC,CAEQ,iBAAAA,CAAkBzC,GACxB,MAAM0C,EAAQ,IAAIC,WAAW3C,EAAS,GACtC,GAAsB,oBAAX4C,QAA0BA,OAAOC,gBAC1CD,OAAOC,gBAAgBH,QAGvB,IAAK,IAAII,EAAI,EAAOJ,EAAM1C,OAAV8C,EAAkBA,IAChCJ,EAAMI,GAAKzD,KAAK0D,MAAsB,IAAhB1D,KAAKC,UAG/B,OAAO0D,MAAMC,KAAKP,EAAOQ,GAAQA,EAAK3D,SAAS,IAAI4D,SAAS,EAAG,MAAMlD,KAAK,GAC5E,CAEQ,eAAA6B,SAEN,OAAkD,QAA3CG,EAAA7B,KAAKE,SAAS8C,IAAIhD,KAAKO,eAAiB,WAAG,IAAAsB,OAAA,EAAAA,EAAElB,YACtD,CAIQ,WAAAE,CAAYK,EAAgBC,GAClCnB,KAAKE,SAAS+C,IAAI/B,EAAQC,EAC5B,CAEQ,WAAAC,CAAYF,GAClB,OAAOlB,KAAKE,SAAS8C,IAAI9B,IAAW,CAAA,CACtC,CAGA,eAAAgC,GACE,MAAMC,EAASpC,KAAKC,MAAQ,IAC5B,IAAK,MAAOE,EAAQC,KAASnB,KAAKE,SAASkD,UACrCjC,EAAKE,SAA0B8B,EAAfhC,EAAKE,SACvBrB,KAAKE,SAASmD,OAAOnC,EAG3B,QC1JWoC,EAMX,WAAAvD,CAAYwD,EAAoBC,GAJxBxD,KAAAyD,YAA4B,GAC5BzD,KAAA0D,YAAmB,CAAA,EAIzB1D,KAAKuD,OAASA,EACdvD,KAAKwD,aAAeA,GAAgB,IAAI1D,EACxCE,KAAK2D,qBACP,CAEQ,mBAAAA,GACN,GAAsB,oBAAXC,OAAwB,OAGnCA,OAAOC,iBAAiB,QAAUC,IAChC9D,KAAK+D,aAAa,CAChBC,QAASF,EAAME,QACfC,SAAUH,EAAMG,SAChBC,OAAQJ,EAAMI,OACdC,MAAOL,EAAMK,MACb9E,MAAOyE,EAAMzE,UAKjBuE,OAAOC,iBAAiB,qBAAuBC,IAC7C,MAAMzE,EAAQyE,EAAMM,OACpB,IAAIJ,EAAU,8BACV1E,EAAQ,GAERD,aAAiBgF,OACnBL,EAAU3E,EAAM2E,QAChB1E,EAAQF,EAAiBC,IAEzB2E,EAD0B,iBAAV3E,EACNA,EAEAiF,KAAKC,UAAUlF,GAG3BW,KAAK+D,aAAa,CAChBC,UACA1E,QACAD,YAKJ,MAAMmF,EAAuBC,QAAQpF,MACrCoF,QAAQpF,MAAQ,IAAIqF,KAClB1E,KAAK2E,cAAc,CACjBC,UAAW7D,KAAKC,MAChBgD,QAASU,EAAK7E,KAAK,KACnBgF,SAAU,UACVC,MAAO,UAETN,EAAqBO,MAAMN,QAASC,IAItC,MAAMM,EAAsBP,QAAQQ,KACpCR,QAAQQ,KAAO,IAAIP,KACjB1E,KAAK2E,cAAc,CACjBC,UAAW7D,KAAKC,MAChBgD,QAASU,EAAK7E,KAAK,KACnBgF,SAAU,UACVC,MAAO,YAETE,EAAoBD,MAAMN,QAASC,GAEvC,CAEA,YAAAX,CAAamB,WAYX,GAAIlF,KAAKuD,OAAO4B,YAAclG,KAAKC,SAAWc,KAAKuD,OAAO4B,WACxD,MAAO,GAGT,MAAMC,EAAUvG,IAGVqC,EAASlB,KAAKwD,aAAa/C,UAAU,SAASyE,EAAUlB,SACxDqB,EAAerF,KAAKwD,aAAahC,kBAEjC8D,EAAyB,CAC7BC,GAAIH,EACJR,UAAW7D,KAAKC,MAChBgD,QAASkB,EAAUlB,QACnB1E,MAAO4F,EAAU5F,QAAU4F,EAAU7F,MAAQD,EAAiB8F,EAAU7F,YAASmB,GACjFgF,IAAKN,EAAUjB,UAAYL,OAAO6B,SAASC,KAC3CxB,OAAQgB,EAAUhB,OAClBC,MAAOe,EAAUf,MACjBF,SAAUiB,EAAUjB,SACpB0B,OAAQ3F,KAAKuD,OAAOoC,QAAU3F,KAAK0D,YAAY6B,GAC/CK,UAAW,GACXC,UAAWC,UAAUD,UACrBE,YAAa/F,KAAKuD,OAAOwC,YACzBC,QAAShG,KAAKuD,OAAOyC,QACrBC,KAAMf,EAAUe,KAChBC,MAAOhB,EAAUgB,MACjBzC,YAAa,IAAIzD,KAAKyD,aACtBqB,MAAOI,EAAUJ,OAAS,QAC1BrD,QAAS4D,EAAa5D,QACtBP,OAAQA,EACRP,aAAc0E,EAAa1E,cAK7B,OAD4C,QAAtBmB,KAAA9B,KAAKuD,QAAO4C,kBAAU,IAAArE,OAAA,EAAAA,EAAAsE,KAAAvE,EAAGyD,KAAeA,EAGvDF,EAFoB,EAG7B,CAEA,gBAAAiB,CAAiBhH,EAAciH,EAI3B,IACF,OAAOtG,KAAK+D,aAAa,CACvBC,QAAS3E,EAAM2E,QACf1E,MAAOF,EAAiBC,GACxBA,QACAyF,MAAOwB,EAAQxB,MACfmB,KAAMK,EAAQL,KACdC,MAAOI,EAAQJ,OAEnB,CAEA,cAAAK,CAAevC,EAAiBsC,EAI5B,IACF,OAAOtG,KAAK+D,aAAa,CACvBC,UACAc,MAAOwB,EAAQxB,OAAS,OACxBmB,KAAMK,EAAQL,KACdC,MAAOI,EAAQJ,OAEnB,CAEA,aAAAvB,CAAc6B,GACZxG,KAAKyD,YAAYgD,KAAKD,GAEtB,MAAME,EAAiB1G,KAAKuD,OAAOmD,gBAAkB,GACjD1G,KAAKyD,YAAY7D,OAAS8G,GAC5B1G,KAAKyD,YAAYkD,OAAO,EAAG3G,KAAKyD,YAAY7D,OAAS8G,EAEzD,CAEA,cAAAE,CAAeC,GACb7G,KAAK0D,YAAc,IAAK1D,KAAK0D,eAAgBmD,EAC/C,CAEA,OAAAC,CAAQC,GAER,CAEA,QAAAC,CAASC,GAET,CAEA,cAAAC,GACE,MAAO,IAAIlH,KAAKyD,YAClB,CAEA,gBAAA0D,GACEnH,KAAKyD,YAAc,EACrB,QCpLW2D,EAQX,WAAArH,CAAYwD,EAAoBC,GALxBxD,KAAAqH,OAAyB,GAM/BrH,KAAKuD,OAASA,EACdvD,KAAKwD,aAAeA,EACpBxD,KAAKsH,mBHyGP,IACE,GAAsB,oBAAX1D,QAA0BA,OAAO2D,eAG1C,OAFA3D,OAAO2D,eAAeC,QAAQ,OAAQ,QACtC5D,OAAO2D,eAAeE,WAAW,QAC1B7D,OAAO2D,cAElB,CAAE,MAAA1F,GAEF,CACA,OAAO,IACT,CGnHmB6F,GACf1H,KAAK4F,UAAY5F,KAAK2H,uBACtB3H,KAAKc,UAAYC,KAAKC,MAEtBhB,KAAK4H,sBACL5H,KAAK6H,eACP,CAEQ,oBAAAF,GACN,MAAMG,EAAa,kBAEnB,GAAI9H,KAAKsH,QAAS,CAChB,MAAMS,EAAa/H,KAAKsH,QAAQU,QAAQF,GACxC,GAAIC,EAAY,OAAOA,CACzB,CAEA,MAAME,EAAQpJ,IAKd,OAJImB,KAAKsH,SACPtH,KAAKsH,QAAQE,QAAQM,EAAYG,GAG5BA,CACT,CAEA,YAAAC,GACE,OAAOlI,KAAK4F,SACd,CAEQ,mBAAAgC,GACN,GAAsB,oBAAXhE,OAAwB,OA4BnC,IAAIuE,EAaAC,EAtCe,CAAC,QAAS,QAAS,SAAU,SAAU,QAAS,QACxDC,QAAQC,IACjBC,SAAS1E,iBAAiByE,EAAYxE,IACpC9D,KAAKwI,aAAaF,EAAWtI,KAAKyI,kBAAkB3E,KACnD,CAAE4E,SAAS,EAAMC,SAAS,MAI/B/E,OAAOC,iBAAiB,WAAY,KAClC7D,KAAKwI,aAAa,aAAc,CAC9BI,KAAM,WACNpD,IAAK5B,OAAO6B,SAASC,KACrBd,UAAW7D,KAAKC,UAKpBuH,SAAS1E,iBAAiB,mBAAoB,KAC5C7D,KAAKwI,aAAa,aAAc,CAC9BK,OAAQN,SAASM,OACjBjE,UAAW7D,KAAKC,UAMpB4C,OAAOC,iBAAiB,SAAU,KAChCiF,aAAaX,GACbA,EAAgBY,WAAW,KACzB/I,KAAKwI,aAAa,SAAU,CAC1BQ,EAAGpF,OAAOqF,QACVC,EAAGtF,OAAOuF,QACVvE,UAAW7D,KAAKC,SAEjB,MACF,CAAE2H,SAAS,IAId/E,OAAOC,iBAAiB,SAAU,KAChCiF,aAAaV,GACbA,EAAgBW,WAAW,KACzB/I,KAAKwI,aAAa,SAAU,CAC1BY,MAAOxF,OAAOyF,WACdC,OAAQ1F,OAAO2F,YACf3E,UAAW7D,KAAKC,SAEjB,MACF,CAAE2H,SAAS,IAGd/E,OAAOC,iBAAiB,eAAgB,KACtC7D,KAAKwI,aAAa,eAAgB,CAChC5D,UAAW7D,KAAKC,MAChBwI,SAAUzI,KAAKC,MAAQhB,KAAKc,YAE9Bd,KAAKyJ,SAET,CAEQ,iBAAAhB,CAAkB3E,SACxB,MAAM4F,EAAS5F,EAAM4F,OACrB,IAAKA,EAAQ,MAAO,CAAA,EAEpB,MAAMvI,EAA4B,CAChCyH,KAAM9E,EAAM8E,KACZhE,UAAW7D,KAAKC,MAChB0I,OAAQ,CACNC,QAASD,EAAOC,QAChBpE,GAAImE,EAAOnE,GACXqE,UAAWF,EAAOE,UAClBC,YAAa7J,KAAK8J,eAAeJ,GAAU,WAA+B,QAAlB7H,EAAA6H,EAAOG,mBAAW,IAAAhI,OAAA,EAAAA,EAAEkI,MAAM,EAAG,OAazF,GARmB,UAAfjG,EAAM8E,OAERzH,EAAK6I,YAAc,CACjBhB,EAFiBlF,EAEHmG,QACdf,EAHiBpF,EAGHoG,UAIC,UAAfpG,EAAM8E,MAAmC,WAAf9E,EAAM8E,KAAmB,CACrD,MAAMuB,EAAarG,EAAM4F,OACrBS,QAAmC3J,IAArB2J,EAAWC,QAC3BjJ,EAAKiJ,MAAQpK,KAAKqK,gBAAgBF,GAAc,WAAaA,EAAWC,MAE5E,CAEA,OAAOjJ,CACT,CAEQ,eAAAkJ,CAAgBC,aACtB,KAAwB,QAAnBzI,EAAA7B,KAAKuD,OAAOgH,eAAO,IAAA1I,OAAA,EAAAA,EAAE2I,YAAY,OAAO,EAK7C,GAHuB,CAAC,WAAY,QAAS,MAAO,sBAGjCC,SAASH,EAAQ1B,MAAO,OAAO,EAElD,MAAM8B,GAAmB,QAAZ5I,EAAAwI,EAAQI,YAAI,IAAA5I,OAAA,EAAAA,EAAE6I,gBAAiB,GACtCpF,GAAe,QAAVxD,EAAAuI,EAAQ/E,UAAE,IAAAxD,OAAA,EAAAA,EAAE4I,gBAAiB,GAExC,MAPuB,CAAC,WAAY,QAAS,QAAS,SAAU,OAAQ,OAOlDC,KAAKC,GACzBH,EAAKD,SAASI,IAActF,EAAGkF,SAASI,GAE5C,CAEQ,cAAAf,CAAeQ,WACrB,KAAuB,QAAlBzI,EAAA7B,KAAKuD,OAAOuH,cAAM,IAAAjJ,OAAA,EAAAA,EAAEkJ,aAAa,OAAO,EAG7C,GAAsB,QAAlBjJ,EAAA9B,KAAKuD,OAAOuH,cAAM,IAAAhJ,OAAA,EAAAA,EAAEkJ,aACtB,IACE,OAAOV,EAAQW,QAAQjL,KAAKuD,OAAOuH,OAAOE,aAC5C,CAAE,MAAAjJ,GACA,OAAO,CACT,CAGF,OAAO,CACT,CAEQ,aAAA8F,GACN,GAAsB,oBAAXjE,OAAwB,OAEnC,MAAMsH,EAAmB,KACvBlL,KAAKwI,aAAa,YAAa,CAC7BhD,IAAK5B,OAAO6B,SAASC,KACrByF,MAAO5C,SAAS4C,MAChBC,SAAU7C,SAAS6C,SACnBxG,UAAW7D,KAAKC,MAChBqK,SAAUC,YAAYtK,SAIE,aAAxBuH,SAASgD,WACXL,IAEAtH,OAAOC,iBAAiB,OAAQqH,EAEpC,CAEA,YAAA1C,CAAaI,EAAczH,eAEzB,GAAInB,KAAKuD,OAAOiI,mBAAqBvM,KAAKC,SAAWc,KAAKuD,OAAOiI,kBAC/D,OAIF,MAAMnG,EAAgC,QAAjBxD,EAAA7B,KAAKwD,oBAAY,IAAA3B,OAAA,EAAAA,EAAEL,kBAClCN,EAA0B,QAAjBY,EAAA9B,KAAKwD,oBAAY,IAAA1B,OAAA,EAAAA,EAAErB,UAAU,WAAWmI,GAEjD9E,EAAsB,CAC1B8B,UAAW5F,KAAK4F,UAChBhB,UAAW7D,KAAKC,MAChB4H,OACAzH,OACAM,QAAS4D,aAAY,EAAZA,EAAc5D,QACvBP,OAAQA,GAIJuK,GAA6C,QAA7BzJ,KAAAhC,KAAKuD,QAAOmI,yBAAiB,IAAA1J,OAAA,EAAAA,EAAAoE,KAAArE,EAAG+B,KAAUA,EAC3D2H,IAELzL,KAAKqH,OAAOZ,KAAKgF,GAGS,IAAtBzL,KAAKqH,OAAOzH,QACdI,KAAKyJ,QAET,CAEA,SAAAkC,GACE,MAAO,IAAI3L,KAAKqH,OAClB,CAEA,mBAAAuE,GACE,OAAO5L,KAAKqH,OAAOzH,MACrB,CAEA,WAAAiM,GACE7L,KAAKqH,OAAS,EAChB,CAEA,KAAAoC,GACE,MAAMpC,EAASrH,KAAK2L,YAEpB,OADA3L,KAAK6L,cACExE,CACT,CAEA,UAAAyE,GACE9L,KAAKwI,aAAa,cAAe,CAC/B5D,UAAW7D,KAAKC,MAChBwI,SAAUzI,KAAKC,MAAQhB,KAAKc,YAG1Bd,KAAKsH,SACPtH,KAAKsH,QAAQG,WAAW,kBAE5B,QCtPWsE,EAUX,WAAAhM,CAAYwD,EAAoBC,GARxBxD,KAAAqH,OAAyB,GAKzBrH,KAAAgM,iBAA2BjL,KAAKC,MAChChB,KAAAiM,sBAA+C,KAGrDjM,KAAKuD,OAASA,EACdvD,KAAKwD,aAAeA,GAAgB,IAAI1D,EACxCE,KAAKkM,cAAgBtI,OAAOuI,MAC5BnM,KAAKoM,gBAAkBC,eAAeC,UAAUC,KAChDvM,KAAKwM,gBAAkBH,eAAeC,UAAUG,KAEhDzM,KAAK0M,oBACL1M,KAAK2M,sBACP,CAEQ,iBAAAD,GACgB,oBAAX9I,SAEX5D,KAAK4M,iBACL5M,KAAK6M,eACP,CAEQ,oBAAAF,GACgB,oBAAX/I,SAGX5D,KAAKiM,sBAAwBa,YAAY,KAC3B/L,KAAKC,MACehB,KAAKgM,kBAGZ,KAAQhM,KAAKqH,OAAOzH,OAAS,GAIpDI,KAAKyJ,SAEN,KACL,CAEQ,cAAAsD,GACN/M,KAAKgM,iBAAmBjL,KAAKC,KAC/B,CAEQ,cAAA4L,GACNhJ,OAAOuI,MAAQa,SAAUtI,eACvB,MAAM5D,EAAYC,KAAKC,MACjBwE,EAAyB,iBAAZd,EAAK,GAAkBA,EAAK,GAAMA,EAAK,GAAec,IACnEyH,IAAiB,QAAPpL,EAAA6C,EAAK,UAAE,IAAA7C,OAAA,EAAAA,EAAEoL,SAAU,OAAOC,cAG1C,IAAKlN,KAAKmN,qBAAqB3H,GAC7B,aAAaxF,KAAKkM,cAAcnH,MAAMnB,OAAQc,GAIhD1E,KAAK+M,iBAGL,MAAM7L,EAASlB,KAAKwD,aAAa/C,UAAU,QAAQwM,KAAUzH,KAGvD4H,EAAepN,KAAKwD,aAAavB,qBAEjCL,EAAU,KADe,QAAPE,EAAA4C,EAAK,UAAE,IAAA5C,OAAA,EAAAA,EAAEF,UAAW,CAAA,KACHwL,GAGnCC,EAAyC,CAC7C3I,EAAK,GACL,IACKA,EAAK,GACR9C,QAASA,IAIb,IACI0L,EADAC,EAAc,GAGP,QAAPxL,EAAA2C,EAAK,UAAE,IAAA3C,OAAA,EAAAA,EAAEyL,QACXF,EAActN,KAAKyN,qBAAqB/I,EAAK,GAAG8I,MAChDD,EAAcvN,KAAK0N,kBAAkBhJ,EAAK,GAAG8I,OAG/C,IACE,MAAMG,QAAiB3N,KAAKkM,cAAcnH,MAAMnB,OAAQyJ,GAClDhM,EAAUN,KAAKC,MAErB,IAAI4M,EACAC,EAAe,EAEnB,GAAI7N,KAAK8N,0BAA0BtI,GAAM,CACvC,MAAMuI,EAAiBJ,EAASK,QAChC,IACEJ,QAAqB5N,KAAKiO,oBAAoBF,GAC9CF,EAAe7N,KAAKkO,sBAAsBN,EAC5C,CAAE,MAAA5L,GAEF,CACF,CAGA,MAAMmM,EAAgBnO,KAAKwD,aAAa7B,wBACtC3B,KAAKoO,uBAAuBT,EAAS/L,UAInCuM,EAAc1M,SAChBzB,KAAKwD,aAAatB,0BAA0BiM,EAAc1M,QAAS0M,EAAcjN,QAInFlB,KAAKwD,aAAavC,WAAWC,EAAQ,CACnCmN,WAAYV,EAASW,OACrBC,aAAclN,EAAUP,IAG1B,MAAMuE,EAAerF,KAAKwD,aAAahC,kBAmBvC,OAjBAxB,KAAKwO,oBAAoB,CACvBvB,SACAzH,MACA6I,WAAYV,EAASW,OACrBC,aAAclN,EAAUP,EACxByM,cACAM,eACAY,eAAgBzO,KAAK0O,eAAe9M,GACpC+M,gBAAiB3O,KAAKoO,uBAAuBT,EAAS/L,SACtD0L,cACAM,eACAhJ,UAAW9D,EACXW,QAAS4D,EAAa5D,QACtBP,OAAQA,EACRP,aAAc0E,EAAa1E,eAGtBgN,CACT,CAAE,MAAOtO,GACP,MAAMgC,EAAUN,KAAKC,MAGrBhB,KAAKwD,aAAavC,WAAWC,EAAQ,CACnCmN,WAAY,EACZE,aAAclN,EAAUP,EACxBzB,MAAOA,aAAiBgF,MAAQhF,EAAM2E,QAAiB3E,EAAPuP,KAGlD,MAAMvJ,EAAerF,KAAKwD,aAAahC,kBAiBvC,MAfAxB,KAAKwO,oBAAoB,CACvBvB,SACAzH,MACA6I,WAAY,EACZE,aAAclN,EAAUP,EACxByM,cACAM,aAAc,EACdY,eAAgBzO,KAAK0O,eAAe9M,GACpC0L,cACA1I,UAAW9D,EACXW,QAAS4D,EAAa5D,QACtBP,OAAQA,EACRP,aAAc0E,EAAa1E,eAGvBtB,CACR,EAEJ,CAEQ,YAAAwN,GACN,MAAMgC,EAAO7O,KAEbqM,eAAeC,UAAUC,KAAO,SAASU,EAAgBzH,KAAgBd,GACvE,MAAMoK,EAAgBD,EAAK1B,qBAAqB3H,GAahD,OAZCxF,KAAa+O,EAAY,CACxB9B,OAAQA,EAAOC,cACf1H,MACA1E,UAAWC,KAAKC,MAChB8N,iBAIEA,GACFD,EAAK9B,iBAGA8B,EAAKzC,gBAAgBhG,KAAKpG,KAAMiN,EAAQzH,KAASd,EAC1D,EAEA2H,eAAeC,UAAUG,KAAO,SAASe,GACvC,MAAMwB,EAAYhP,KAAa+O,EAC/B,OAAKC,GAAaA,EAASF,eAI3BE,EAAS1B,YAAcuB,EAAKpB,qBAAqBD,GACjDwB,EAASzB,YAAcsB,EAAKnB,kBAAkBF,GAE9CxN,KAAK6D,iBAAiB,UAAW,KAC/B,MAAMxC,EAAUN,KAAKC,MAErB,IAAI4M,EACJ,IAC4B,KAAtB5N,KAAKiP,cAA6C,SAAtBjP,KAAKiP,aACnCrB,EAAe5N,KAAKkP,aACW,SAAtBlP,KAAKiP,eACdrB,EAAe5N,KAAK2N,SAExB,CAAE,MAAA9L,GAEF,CAEAgN,EAAKL,oBAAoB,CACvBvB,OAAQ+B,EAAS/B,OACjBzH,IAAKwJ,EAASxJ,IACd6I,WAAYrO,KAAKsO,OACjBC,aAAclN,EAAU2N,EAASlO,UACjCyM,YAAayB,EAASzB,YACtBM,aAAcgB,EAAKX,sBAAsBN,GACzCN,YAAa0B,EAAS1B,YACtBM,aAAciB,EAAKf,0BAA0BkB,EAASxJ,KAAOoI,OAAepN,EAC5EoE,UAAWoK,EAASlO,cAIjB+N,EAAKrC,gBAAgBpG,KAAKpG,KAAMwN,IAjC9BqB,EAAKrC,gBAAgBpG,KAAKpG,KAAMwN,EAkC3C,CACF,CAEQ,oBAAAC,CAAqBD,GAC3B,GAAKA,EAAL,CAEA,GAAoB,iBAATA,EAAmB,OAAOA,EACrC,GAAIA,aAAgB2B,SAAU,CAC5B,MAAMC,EAAkC,CAAA,EAIxC,OAHA5B,EAAKnF,QAAQ,CAAC+B,EAAOiF,KACnBD,EAAWC,GAAOjF,aAAiBkF,KAAO,UAAUlF,EAAMM,QAAUN,IAE/DgF,CACT,CACA,GAAI5B,aAAgB+B,gBAClB,OAAOC,OAAOC,YAAYjC,GAG5B,IACE,OAAOlJ,KAAKoL,MAAMpL,KAAKC,UAAUiJ,GACnC,CAAE,MAAA3L,GACA,MAAO,kBACT,CAlB2B,CAmB7B,CAEQ,yBAAMoM,CAAoBN,GAChC,MAAMgC,EAAchC,EAAS/L,QAAQoB,IAAI,iBAAmB,GAE5D,OAAI2M,EAAYlF,SAAS,0BACVkD,EAASiC,OACbD,EAAYlF,SAAS,eACjBkD,EAASkC,OAGjB,eACT,CAEQ,cAAAnB,CAAe9M,GACrB,IAAKA,EAAS,MAAO,CAAA,EAErB,GAAIA,aAAmBkO,QAAS,CAC9B,MAAMC,EAAoC,CAAA,EAI1C,OAHAnO,EAAQyG,QAAQ,CAAC+B,EAAOiF,KACtBU,EAAUV,GAAOjF,IAEZ2F,CACT,CAEA,GAAInN,MAAMoN,QAAQpO,GAAU,CAC1B,MAAMmO,EAAoC,CAAA,EAI1C,OAHAnO,EAAQyG,QAAQ,EAAEgH,EAAKjF,MACrB2F,EAAUV,GAAOjF,IAEZ2F,CACT,CAEA,OAAOnO,CACT,CAEQ,sBAAAwM,CAAuBxM,GAC7B,MAAMmO,EAAoC,CAAA,EAI1C,OAHAnO,EAAQyG,QAAQ,CAAC+B,EAAOiF,KACtBU,EAAUV,GAAOjF,IAEZ2F,CACT,CAEQ,iBAAArC,CAAkBF,GACxB,IAAKA,EAAM,OAAO,EAElB,GAAoB,iBAATA,EAAmB,OAAOA,EAAK5N,OAC1C,GAAI4N,aAAgByC,YAAa,OAAOzC,EAAK0C,WAC7C,GAAI1C,aAAgB2C,KAAM,OAAO3C,EAAK4C,KAEtC,IACE,OAAO9L,KAAKC,UAAUiJ,GAAM5N,MAC9B,CAAE,MAAAiC,GACA,OAAO,CACT,CACF,CAEQ,qBAAAqM,CAAsBP,GAC5B,IAAKA,EAAU,OAAO,EAEtB,IACE,OAAOrJ,KAAKC,UAAUoJ,GAAU/N,MAClC,CAAE,MAAAiC,GACA,OAAO,CACT,CACF,CAEQ,yBAAAiM,CAA0BtI,GAOhC,MALwB,CACtB,UACA,aAGqBoF,KAAKyF,GAAWA,EAAQC,KAAK9K,GACtD,CAEQ,oBAAA2H,CAAqB3H,WAO3B,MACM+K,GADSvQ,KAAKuD,OAAOiN,QAAU,wBACL1R,QAAQ,MAAO,IACzC2R,EAAgBjL,EAAI1G,QAAQ,MAAO,IAGzC,GAAI2R,EAAcC,WAAWH,GAI3B,OAAO,EAIT,GAAI/K,EAAIiF,SAAS,mBAAqBjF,EAAIiF,SAAS,kBAIjD,OAAO,EAIT,GAAIjF,EAAIiF,SAAS,mBAIf,OAAO,EAIT,MAUMkG,EAVkB,CACtB,mBACA,gBACA,iBACA,kBACA,kBACA,aAIuC/F,KAAKyF,GAAWA,EAAQC,KAAK9K,IAChEoL,EAAoBH,EAAchG,SAAS8F,EAAiBzR,QAAQ,eAAgB,KAE1F,QAAI6R,IAAoBC,OAQpB5Q,KAAKuD,OAAOsN,cACG7Q,KAAKuD,OAAOsN,YAAYjG,KAAKyF,GAAWA,EAAQC,KAAK9K,UAUjD,QAAnB3D,EAAA7B,KAAKuD,OAAOgH,eAAO,IAAA1I,OAAA,EAAAA,EAAEiP,YACR9Q,KAAKuD,OAAOgH,QAAQuG,SAASlG,KAAKyF,GAC7BU,OAAOV,GACZC,KAAK9K,SAWC,QAAnB1D,EAAA9B,KAAKuD,OAAOgH,eAAO,IAAAzI,OAAA,EAAAA,EAAEkP,YACPhR,KAAKuD,OAAOgH,QAAQyG,UAAUpG,KAAKyF,GAC/BU,OAAOV,GACZC,KAAK9K,MAaxB,CAEQ,mBAAAgJ,CAAoBrN,GAgB1BnB,KAAKqH,OAAOZ,KAfgB,CAC1Bb,UAAW,GACXhB,UAAWzD,EAAKyD,UAChBqI,OAAQ9L,EAAK8L,OACbzH,IAAKrE,EAAKqE,IACV6I,WAAYlN,EAAKkN,WACjBE,aAAcpN,EAAKoN,aACnBhB,YAAapM,EAAKoM,YAClBM,aAAc1M,EAAK0M,aACnBY,eAAgBtN,EAAKsN,eACrBE,gBAAiBxN,EAAKwN,gBACtBrB,YAAanM,EAAKmM,YAClBM,aAAczM,EAAKyM,eAMK,IAAtB5N,KAAKqH,OAAOzH,OAKYmB,KAAKC,MAJ/BhB,KAAKyJ,OAaT,CAEA,SAAAkC,GACE,MAAO,IAAI3L,KAAKqH,OAClB,CAEA,WAAAwE,GACE7L,KAAKqH,OAAS,EAChB,CAEA,KAAAoC,GACE,MAAMpC,EAASrH,KAAK2L,YAEpB,OADA3L,KAAK6L,cACExE,CACT,CAEA,OAAA4J,GAEMjR,KAAKiM,wBACPiF,cAAclR,KAAKiM,uBACnBjM,KAAKiM,sBAAwB,MAI3BjM,KAAKkM,gBACPtI,OAAOuI,MAAQnM,KAAKkM,eAGtBG,eAAeC,UAAUC,KAAOvM,KAAKoM,gBACrCC,eAAeC,UAAUG,KAAOzM,KAAKwM,eACvC,QCzeW2E,EAAb,WAAApR,GACUC,KAAAoR,GAAyB,KACzBpR,KAAAqR,OAAS,eACTrR,KAAAsR,QAAU,EACVtR,KAAAuR,UAAY,QACZvR,KAAAwR,aAAe,IACfxR,KAAAyR,OAAS,MAkPnB,CAhPE,gBAAMC,GACJ,GAAsB,oBAAX9N,SAA2BA,OAAO+N,UAC3C,MAAUtN,MAAM,2BAGlB,OAAO,IAAIuN,QAAQ,CAACC,EAASC,KAC3B,MAAMC,EAAUJ,UAAUpF,KAAKvM,KAAKqR,OAAQrR,KAAKsR,SAEjDS,EAAQC,QAAU,KAChBF,EAAWzN,MAAM,8BAGnB0N,EAAQE,UAAY,KAClBjS,KAAKoR,GAAKW,EAAQG,OAClBL,KAGFE,EAAQI,gBAAmBrO,IACzB,MAAMsN,EAAMtN,EAAM4F,OAA4BwI,OAE9C,IAAKd,EAAGgB,iBAAiBC,SAASrS,KAAKuR,WAAY,CACjD,MAAMe,EAAclB,EAAGmB,kBAAkBvS,KAAKuR,UAAW,CAAEiB,QAAS,OACpEF,EAAYG,YAAY,YAAa,YAAa,CAAEC,QAAQ,IAC5DJ,EAAYG,YAAY,OAAQ,OAAQ,CAAEC,QAAQ,GACpD,IAGN,CAEA,WAAMC,CAAM/J,EAAuCzH,GAC5CnB,KAAKoR,UACFpR,KAAK0R,mBAGP1R,KAAK4S,sBAEX,MAAMC,QAAkB7S,KAAK8S,eACZ9S,KAAKwR,aAAlBqB,SACI7S,KAAK+S,kBAAkB,KAG/B,MAAMC,EAAoB,CACxBzN,GAAIvF,KAAKnB,aACT+J,OACAzH,WAAYnB,KAAKiT,SAAS9R,GAC1ByD,UAAW7D,KAAKC,MAChBkS,YAAY,GAGd,OAAO,IAAItB,QAAQ,CAACC,EAASC,KAC3B,IAAK9R,KAAKoR,GAER,YADAU,EAAWzN,MAAM,6BAInB,MAEM0N,EAFc/R,KAAKoR,GAAG+B,YAAY,CAACnT,KAAKuR,WAAY,aAC1Be,YAAYtS,KAAKuR,WACrB6B,IAAIJ,GAEhCjB,EAAQE,UAAY,IAAMJ,IAC1BE,EAAQC,QAAU,IAAMF,EAAWzN,MAAM,0BAE7C,CAEA,YAAMgP,GAKJ,OAJKrT,KAAKoR,UACFpR,KAAK0R,aAGN,IAAIE,QAAQ,CAACC,EAASC,KAC3B,IAAK9R,KAAKoR,GAER,YADAU,EAAWzN,MAAM,6BAInB,MAEM0N,EAFc/R,KAAKoR,GAAG+B,YAAY,CAACnT,KAAKuR,WAAY,YAC1Be,YAAYtS,KAAKuR,WACrB8B,SAE5BtB,EAAQE,UAAYjF,UAClB,MAAMsG,EAAQvB,EAAQG,OAChBA,EAAS,CACbqB,OAAQ,GACRC,cAAe,GACfC,cAAe,IAGjB,IAAK,MAAMT,KAAQM,EAAO,CACxB,MAAMI,QAAyB1T,KAAK2T,WAAWX,EAAK7R,MAEpD,OAAQ6R,EAAKpK,MACX,IAAK,QACHsJ,EAAOqB,OAAO9M,QAAS7D,MAAMoN,QAAQ0D,GAAoBA,EAAmB,CAACA,IAC7E,MACF,IAAK,UACHxB,EAAOsB,cAAc/M,QAAS7D,MAAMoN,QAAQ0D,GAAoBA,EAAmB,CAACA,IACpF,MACF,IAAK,UACHxB,EAAOuB,cAAchN,QAAS7D,MAAMoN,QAAQ0D,GAAoBA,EAAmB,CAACA,IAG1F,CAEA7B,EAAQK,IAGVH,EAAQC,QAAU,IAAMF,EAAWzN,MAAM,8BAE7C,CAEA,WAAMuP,GAKJ,OAJK5T,KAAKoR,UACFpR,KAAK0R,aAGN,IAAIE,QAAQ,CAACC,EAASC,KAC3B,IAAK9R,KAAKoR,GAER,YADAU,EAAWzN,MAAM,6BAInB,MAEM0N,EAFc/R,KAAKoR,GAAG+B,YAAY,CAACnT,KAAKuR,WAAY,aAC1Be,YAAYtS,KAAKuR,WACrBqC,QAE5B7B,EAAQE,UAAY,IAAMJ,IAC1BE,EAAQC,QAAU,IAAMF,EAAWzN,MAAM,6BAE7C,CAEA,kBAAMyO,GAKJ,OAJK9S,KAAKoR,UACFpR,KAAK0R,aAGN,IAAIE,QAAQ,CAACC,EAASC,KAC3B,IAAK9R,KAAKoR,GAER,YADAU,EAAWzN,MAAM,6BAInB,MAEM0N,EAFc/R,KAAKoR,GAAG+B,YAAY,CAACnT,KAAKuR,WAAY,YAC1Be,YAAYtS,KAAKuR,WACrBsC,QAE5B9B,EAAQE,UAAY,IAAMJ,EAAQE,EAAQG,QAC1CH,EAAQC,QAAU,IAAMF,EAAWzN,MAAM,8BAE7C,CAEQ,yBAAMuO,GACZ,IAAK5S,KAAKoR,GAAI,OAEd,MAAM0C,EAAa/S,KAAKC,MAAQhB,KAAKyR,OAErC,OAAO,IAAIG,QAASC,IAClB,IAAK7R,KAAKoR,GAER,YADAS,IAIF,MAEMkC,EAFc/T,KAAKoR,GAAG+B,YAAY,CAACnT,KAAKuR,WAAY,aAC1Be,YAAYtS,KAAKuR,WACvBwC,MAAM,aAC1BC,EAAQC,YAAYC,WAAWJ,GAC/B/B,EAAUgC,EAAMI,WAAWH,GAEjCjC,EAAQE,UAAanO,IACnB,MAAMsQ,EAAUtQ,EAAM4F,OAAsBwI,OACxCkC,GACFA,EAAO/Q,SACP+Q,EAAOC,YAEPxC,KAIJE,EAAQC,QAAU,IAAMH,KAE5B,CAEQ,uBAAMkB,CAAkBc,GAC9B,GAAK7T,KAAKoR,GAEV,OAAO,IAAIQ,QAASC,IAClB,IAAK7R,KAAKoR,GAER,YADAS,IAIF,MAGME,EAHc/R,KAAKoR,GAAG+B,YAAY,CAACnT,KAAKuR,WAAY,aAC1Be,YAAYtS,KAAKuR,WACvBwC,MAAM,aACVI,aAEtB,IAAIG,EAAe,EACnBvC,EAAQE,UAAanO,IACnB,MAAMsQ,EAAUtQ,EAAM4F,OAAsBwI,OACxCkC,GAAyBP,EAAfS,GACZF,EAAO/Q,SACPiR,IACAF,EAAOC,YAEPxC,KAIJE,EAAQC,QAAU,IAAMH,KAE5B,CAEQ,cAAMoB,CAAS9R,GACrB,IACE,MAAMyO,EAAOtL,KAAKC,UAAUpD,GAE5B,OAAOoT,KAAKC,SAASC,mBAAmB7E,IAC1C,CAAE,MAAOvQ,GAEP,OAAOiF,KAAKC,UAAUpD,EACxB,CACF,CAEQ,gBAAMwS,CAAWxS,GACvB,IAEE,MAAMuT,EAAUC,mBAAmBC,OAAOC,KAAK1T,KAC/C,OAAOmD,KAAKoL,MAAMgF,EACpB,CAAE,MAAOrV,GAEP,IACE,OAAOiF,KAAKoL,MAAMvO,EACpB,CAAE,MAAO2T,GACP,OAAO3T,CACT,CACF,CACF,CAEQ,UAAAtC,GACN,MAAO,QAAQkC,KAAKC,SAAS/B,KAAKC,SAASC,SAAS,IAAI4V,OAAO,EAAG,IACpE,ECtPF,MAAMC,EAIJ,WAAAjV,GAFQC,KAAA8H,WAAa,oBAGnB,MAAMmN,aNqHR,IACE,GAAsB,oBAAXrR,QAA0BA,OAAOqR,aAG1C,OAFArR,OAAOqR,aAAazN,QAAQ,OAAQ,QACpC5D,OAAOqR,aAAaxN,WAAW,QACxB7D,OAAOqR,YAElB,CAAE,MAAApT,GAEF,CACA,OAAO,IACT,CM/HyBqT,GACrB,IAAKD,EACH,MAAU5Q,MAAM,wBAElBrE,KAAKsH,QAAU2N,CACjB,CAEA,WAAMtC,CAAM/J,EAAuCzH,GACjD,IACE,MAAMgU,QAAiBnV,KAAKqT,SAE5B,OAAQzK,GACN,IAAK,QACHuM,EAAS5B,OAAO9M,QAAS7D,MAAMoN,QAAQ7O,GAAQA,EAAO,CAACA,IACvD,MACF,IAAK,UACHgU,EAAS3B,cAAc/M,QAAS7D,MAAMoN,QAAQ7O,GAAQA,EAAO,CAACA,IAC9D,MACF,IAAK,UACHgU,EAAS1B,cAAchN,QAAS7D,MAAMoN,QAAQ7O,GAAQA,EAAO,CAACA,IAIlEnB,KAAKsH,QAAQE,QAAQxH,KAAK8H,WAAYxD,KAAKC,UAAU4Q,GACvD,CAAE,MAAO9V,GAEP,MAAUgF,MAAM,uBAClB,CACF,CAEA,YAAMgP,GACJ,IACE,MAAM+B,EAAapV,KAAKsH,QAAQU,QAAQhI,KAAK8H,YAC7C,GAAIsN,EACF,OAAO9Q,KAAKoL,MAAM0F,EAEtB,CAAE,MAAO/V,GAET,CAEA,MAAO,CACLkU,OAAQ,GACRC,cAAe,GACfC,cAAe,GAEnB,CAEA,WAAMG,GACJ,IACE5T,KAAKsH,QAAQG,WAAWzH,KAAK8H,WAC/B,CAAE,MAAOzI,GAET,CACF,QAGWgW,EAAb,WAAAtV,GACUC,KAAAsH,QAAmC,KACnCtH,KAAAsV,eAAgB,CAwE1B,CAtEE,gBAAM5D,GACJ,IAAI1R,KAAKsV,cAAT,CAEA,IAEE,MAAM3D,EAAY,IAAIR,QAChBQ,EAAUD,aAChB1R,KAAKsH,QAAUqK,CAEjB,CAAE,MAAOtS,GAEP,IACEW,KAAKsH,QAAU,IAAI0N,CAErB,CAAE,MAAOO,GAEPvV,KAAKsH,QAAU,IAAIkO,CACrB,CACF,CAEAxV,KAAKsV,eAAgB,CAnBG,CAoB1B,CAEA,iBAAMG,CAAYlC,SACVvT,KAAK0V,oBACPnC,EAAO3T,OAAS,SACZI,KAAKsH,QAASqL,MAAM,QAASY,EAEvC,CAEA,wBAAMoC,CAAmBtO,SACjBrH,KAAK0V,oBACPrO,EAAOzH,OAAS,SACZI,KAAKsH,QAASqL,MAAM,UAAWtL,EAEzC,CAEA,wBAAMuO,CAAmBvO,SACjBrH,KAAK0V,oBACPrO,EAAOzH,OAAS,SACZI,KAAKsH,QAASqL,MAAM,UAAWtL,EAEzC,CAEA,gBAAMwO,GAEJ,aADM7V,KAAK0V,0BACE1V,KAAKsH,QAAS+L,QAC7B,CAEA,cAAMyC,SACE9V,KAAK0V,0BACL1V,KAAKsH,QAASsM,OACtB,CAEA,kBAAMd,GAEJ,SADM9S,KAAK0V,oBACP1V,KAAKsH,SAAW,iBAAkBtH,KAAKsH,SAAWtH,KAAKsH,QAAQwL,aACjE,aAAa9S,KAAKsH,QAAQwL,eACrB,CAEL,MAAM3R,QAAanB,KAAK6V,aACxB,OAAO1U,EAAKoS,OAAO3T,OAASuB,EAAKqS,cAAc5T,OAASuB,EAAKsS,cAAc7T,MAC7E,CACF,CAEQ,uBAAM8V,GACP1V,KAAKsV,qBACFtV,KAAK0R,YAEf,EAGF,MAAM8D,EACJ,WAAM7C,GAEN,CAEA,YAAMU,GACJ,MAAO,CACLE,OAAQ,GACRC,cAAe,GACfC,cAAe,GAEnB,CAEA,WAAMG,GAEN,QCnKWmC,EAKX,WAAAhW,GAJQC,KAAAgW,SAAgC,oBAAdlQ,WAA4BA,UAAUmQ,OACxDjW,KAAAkW,eAAyB,UACzBlW,KAAAmW,UAA8C,GAG9B,oBAAXvS,SAETA,OAAOC,iBAAiB,SAAU,KAChC7D,KAAKgW,UAAW,EAChBhW,KAAKoW,iBAAgB,KAGvBxS,OAAOC,iBAAiB,UAAW,KACjC7D,KAAKgW,UAAW,EAChBhW,KAAKoW,iBAAgB,KAIvBpW,KAAKqW,uBAET,CAEA,mBAAAC,GACE,MAAO,CACLC,OAAQvW,KAAKgW,SACbE,eAAgBlW,KAAKkW,eAEzB,CAEA,kBAAAM,CAAmBC,GAIjB,OAHAzW,KAAKmW,UAAU1P,KAAKgQ,GAGb,KACL,MAAM1C,EAAQ/T,KAAKmW,UAAUO,QAAQD,GACjC1C,GAAQ,GACV/T,KAAKmW,UAAUxP,OAAOoN,EAAO,GAGnC,CAEA,YAAA4C,GACE,IAAK3W,KAAKgW,SACR,OAAO,EAIT,OAAQhW,KAAKkW,gBACX,IAAK,UACH,OAAO,EACT,IAAK,KACH,OAAO,GACT,IAAK,KAIL,QACE,OAAO,GAHT,IAAK,KACH,OAAO,GAIb,CAEA,cAAAU,GACE,IAAK5W,KAAKgW,SACR,OAAO,EAIT,OAAQhW,KAAKkW,gBACX,IAAK,UACH,OAAO,IACT,IAAK,KACH,OAAO,KACT,IAAK,KAIL,QACE,OAAO,IAHT,IAAK,KACH,OAAO,IAIb,CAEA,WAAAW,CAAYC,GACV,QAAK9W,KAAKgW,UAKU,EACbc,CACT,CAEA,aAAAC,CAAcD,GAEZ,OAAO7X,KAAK+X,IAAI,IAAO/X,KAAKgY,IAAI,EAAGH,GAAU,KAC/C,CAEQ,oBAAAT,GACN,GAAI,eAAgBvQ,UAAW,CAC7B,MAAMoR,EAAcpR,UAAkBoR,WACtClX,KAAKkW,eAAiBgB,EAAWC,eAAiBD,EAAWtO,MAAQ,UAGrEsO,EAAWrT,iBAAiB,SAAU,KACpC7D,KAAKkW,eAAiBgB,EAAWC,eAAiBD,EAAWtO,MAAQ,WAEzE,CACF,CAEQ,eAAAwN,CAAgBG,GACtBvW,KAAKmW,UAAU9N,QAAQoO,IACrB,IACEA,EAASF,EACX,CAAE,MAAOlX,GAET,GAEJ,CAGA,sBAAM+X,CAAiB5R,GACrB,IAAKxF,KAAKgW,SACR,OAAO,EAGT,IACE,MAAMqB,EAAU7R,GAAO,8BAMvB,aALM2G,MAAMkL,EAAS,CACnBpK,OAAQ,OACRqK,KAAM,UACNC,MAAO,cAEF,CACT,CAAE,MAAOlY,GACP,OAAO,CACT,CACF,ECrIK2N,eAAewK,EAAarW,GAKjC,MAAO,CAAEA,KAJUmD,KAAKC,UAAUpD,GAIP+R,YAAY,EAyDzC,CA8BM,SAAUuE,EAAiDpQ,GAI/D,GAAsB,IAAlBA,EAAOzH,OAAc,MAAO,CAAEyH,SAAQqQ,iBAAkB,GAE5D,MAAMC,EAAerT,KAAKC,UAAU8C,GAAQzH,OAGtCgY,EAAiB,IAAIC,IAAI,CAC7B,YAAa,aAAc,YAAa,aAAc,OACtD,KAAM,WAAY,UAAW,SAAU,MAAO,gBAI1CC,EAAU,IAAI3X,IAEpB,IAAK,MAAM2D,KAASuD,EAAQ,CAC1B,MAAM0Q,EAAOvI,OAAOuI,KAAKjU,GAAOkU,OAAOnY,KAAK,KACvCiY,EAAQG,IAAIF,IACfD,EAAQ7U,IAAI8U,EAAM,IAEpBD,EAAQ9U,IAAI+U,GAAOtR,KAAK3C,EAC1B,CAGA,MAAMoP,EAAkB,GAExB,IAAK,MAAO6E,EAAMG,KAAkBJ,EAAS,CAC3C,GAA6B,IAAzBI,EAActY,OAAc,CAC9BsT,EAAWzM,KAAKyR,EAAc,IAC9B,QACF,CAGA,MAAMC,EAAoC,CAAA,EACpCC,EAAWL,EAAKxY,MAAM,KAE5B,IAAK,MAAM8P,KAAO+I,EAAU,CAE1B,GAAIR,EAAeK,IAAI5I,GACrB,SAGF,MAAMgJ,EAASH,EAAc1Y,IAAI8Y,GAAKA,EAAEjJ,IAClCkJ,EAAaF,EAAO,GAEtBA,EAAOG,MAAMC,GACfnU,KAAKC,UAAUkU,KAAOnU,KAAKC,UAAUgU,MAErCJ,EAAa9I,GAAOkJ,EAExB,CAGA,IAAK,MAAMzU,KAASoU,EAAe,CACjC,MAAMQ,EAAuB,IAAK5U,GAGlC,IAAK,MAAMuL,KAAOG,OAAOuI,KAAKI,GACvBP,EAAeK,IAAI5I,IACpB/K,KAAKC,UAAUT,EAAMuL,MAAU/K,KAAKC,UAAU4T,EAAa9I,YACtDqJ,EAAgBrJ,GAKvBG,OAAOuI,KAAKI,GAAcvY,OAAS,IACrC8Y,EAAgBC,EAAUR,GAG5BjF,EAAWzM,KAAKiS,EAClB,CACF,CAKA,MAAO,CAAErR,OAAQ6L,EAAYwE,iBAHNpT,KAAKC,UAAU2O,GAAYtT,OACR+X,EAG5C,CAGM,SAAUiB,EACdvR,EACAwR,EACAC,EAAwB,OAExB,GAAsB,IAAlBzR,EAAOzH,OAAc,MAAO,GAEhC,MAAMmZ,EAAiB,GACvB,IAAIC,EAAoB,GACpBC,EAAmB,EAEvB,IAAK,MAAMnV,KAASuD,EAAQ,CAC1B,MAAM6R,EAAY5U,KAAKC,UAAUT,GAAOlE,OAIfiZ,EAAvBG,EAAapZ,QACkBkZ,GAA/BG,EAAmBC,GAEfF,EAAapZ,OAAS,IACxBmZ,EAAQtS,KAAKuS,GACbA,EAAe,GACfC,EAAmB,GAIvBD,EAAavS,KAAK3C,GAClBmV,GAAoBC,CACtB,CAOA,OAJIF,EAAapZ,OAAS,GACxBmZ,EAAQtS,KAAKuS,GAGRD,CACT,OCtMaI,EAMX,WAAApZ,CAAYqZ,GAAmB,EAAOC,GAAsB,GALpDrZ,KAAAsZ,KAAwB,GACxBtZ,KAAAuZ,WAAqB,EACrBvZ,KAAAqZ,YAAsB,EACtBrZ,KAAAwZ,QAAkB,IAuKlBxZ,KAAAyZ,UAAmC,KAEnCzZ,KAAA0Z,cAAgB,KAClB1Z,KAAKyZ,WAAW3Q,aAAa9I,KAAKyZ,WAEtCzZ,KAAKyZ,UAAY1Q,WAAW,KAC1B/I,KAAK2Z,kBACJ,MA3KH3Z,KAAKuZ,UAAYH,EACjBpZ,KAAKqZ,WAAaA,EAEdrZ,KAAKuZ,WAEPvZ,KAAK4Z,IAAI,UAAW,oBAAqB,2BAA4B,CACnER,UACAC,aACAzU,UAAW7D,KAAKC,OAGtB,CAEA,GAAA4Y,CAAI/U,EAAqCgV,EAAmB7V,EAAiB7C,GAC3E,IAAKnB,KAAKuZ,UAAW,OAErB,MAAMO,EAAuB,CAC3BlV,UAAW7D,KAAKC,MAChB8D,MAAO,OACPD,WACAgV,YACA1Y,KAAM,CACJ6C,aACG7C,GAEL4Y,WAAY/Z,KAAKga,iBAGnBha,KAAKia,YAAYH,GACjB9Z,KAAKka,WAAWJ,EAClB,CAEA,QAAAK,CAAStV,EAAqCgV,EAAmBxa,EAAc8B,GAC7E,IAAKnB,KAAKuZ,UAAW,OAErB,MAAMO,EAAuB,CAC3BlV,UAAW7D,KAAKC,MAChB8D,MAAO,QACPD,WACAgV,YACA1Y,KAAM,CACJ9B,MAAOA,EAAM2E,QACb1E,MAAOD,EAAMC,SACV6B,GAEL4Y,WAAY1a,EAAMC,OAGpBU,KAAKia,YAAYH,GACjB9Z,KAAKka,WAAWJ,EAClB,CAEA,eAAAM,CAAgBP,EAAmBjU,EAAmByU,GACpDra,KAAK4Z,IAAI,UAAWC,EAAW,kBAAkBA,EAAa,CAC5DjU,YACAyU,UAAWra,KAAKsa,aAAaD,GAC7BE,eAAgB3U,GAEpB,CAEA,UAAA4U,CAAWX,EAAmBrU,EAAaiV,EAAc9M,EAAgBtO,GACvEW,KAAK4Z,IAAI,MAAOC,EAAW,eAAerU,EAAO,CAC/CA,MACAiV,QAASza,KAAKsa,aAAaG,GAC3B9M,SAAUA,EAAW3N,KAAKsa,aAAa3M,QAAYnN,EACnDnB,MAAOA,aAAK,EAALA,EAAO2E,QACd0W,YAAapW,KAAKC,UAAUkW,GAAW,CAAA,GAAI7a,QAE/C,CAEA,qBAAA+a,CAAsBd,EAAmBe,EAAaC,EAAYjV,GAChE5F,KAAK4Z,IAAI,OAAQC,EAAW,wBAAwBA,EAAa,CAC/De,OAAQ5a,KAAKsa,aAAaM,GAC1BC,MAAO7a,KAAKsa,aAAaO,GACzBjV,YACAkV,kBAAmBF,EACnBG,iBAAkBF,EAClBG,aAAcpY,MAAMoN,QAAQ4K,GAAUA,EAAOhb,YAASY,EACtDya,YAAarY,MAAMoN,QAAQ6K,GAASA,EAAMjb,YAASY,GAEvD,CAGA,qBAAA0a,CAAsB7T,EAAezB,EAAmB6U,aACtDza,KAAK4Z,IAAI,UAAW,uBAAwB,iCAAkC,CAC5EuB,YAAa9T,EAAOzH,OACpBgG,YACAwV,gBAAiB/T,EAAO7H,IAAI8Y,IAAC,CAC3BhQ,UAAWgQ,EAAE+C,YAAc/C,EAAE1P,KAC7B2R,gBAAiBjC,EAAEgD,aAAchD,EAAE1S,WACnC2V,eAAgBjD,EAAEgD,YAAchD,EAAE1S,WAAa,UAC/ChB,UAAW0T,EAAE1T,UACb4W,SAAUhM,OAAOuI,KAAKO,EAAEnX,MAAQ,CAAA,MAElCsZ,QAAS,CACPa,WAAYb,EAAQa,WACpBH,aAA2B,QAAdtZ,EAAA4Y,EAAQpT,cAAM,IAAAxF,OAAA,EAAAA,EAAEjC,SAAU,EACvC6b,0BAA2C,QAAnB1Z,EAAc,UAAd0Y,EAAQpT,cAAM,IAAAvF,OAAA,EAAAA,EAAG,UAAE,IAAAC,OAAA,EAAAA,EAAEuZ,cAGnD,CAEQ,WAAArB,CAAYH,GAClB9Z,KAAKsZ,KAAK7S,KAAKqT,GAGX9Z,KAAKsZ,KAAK1Z,OAASI,KAAKwZ,UAC1BxZ,KAAKsZ,KAAOtZ,KAAKsZ,KAAKvP,OAAO/J,KAAKwZ,UAIhCxZ,KAAKqZ,YAAgC,oBAAXzV,QAC5B5D,KAAK0Z,eAET,CAEQ,UAAAQ,CAAWJ,GAEC,IAAI/Y,KAAK+Y,EAAMlV,WAAW8W,aAe9C,CAEQ,YAAApB,CAAanZ,GACnB,IAAKA,EAAM,OAAOA,EAElB,IAEE,MAAMwa,EAASrX,KAAKoL,MAAMpL,KAAKC,UAAUpD,IAGzC,OAAIyB,MAAMoN,QAAQ2L,IAAWA,EAAO/b,OAAS,GACpC,CACLgc,EAAO,QACPhc,OAAQ+b,EAAO/b,OACfic,OAAQF,EAAO5R,MAAM,EAAG,GACxB+R,MAAOH,EAAO5R,OAAO,IAIlB4R,CACT,CAAE,MAAOrD,GACP,MAAO,CAAEyD,EAAQ,2BAA4BH,SAAcza,EAC7D,CACF,CAEQ,aAAA6Y,GACN,MAAM1a,EAAY+E,QAAQ/E,MAC1B,OAAOA,EAAQA,EAAMC,MAAM,MAAMwK,MAAM,EAAG,GAAGlK,KAAK,MAAQ,EAC5D,CAaA,cAAA8Z,GACE,GAAsB,oBAAX/V,OAEX,IACE,MAAMoY,EAAU,CACdpX,WAAW,IAAI7D,MAAO2a,cACtBpK,QAAS,QACT2K,aAAcjc,KAAKsZ,KAAK3Z,OAAOuc,GAAoB,YAAfA,EAAErX,UAAwBjF,OAC9Duc,aAAcnc,KAAKsZ,KAAK3Z,OAAOuc,GAAoB,QAAfA,EAAErX,UAAoBjF,OAC1Dwc,WAAYpc,KAAKsZ,KAAK3Z,OAAOuc,GAAiB,UAAZA,EAAEpX,OAAmBlF,OACvD0Z,KAAMtZ,KAAKsZ,MAGP+C,EAAU/X,KAAKC,UAAUyX,EAAS,KAAM,GACxCM,EAAW,IAAInM,KAAK,CAACkM,GAAU,CAAEzT,KAAM,qBAEvCpD,EAAM+W,IAAIC,gBAAgBF,GAC1BG,EAAOlU,SAASmU,cAAc,KACpCD,EAAK/W,KAAOF,EACZiX,EAAKE,SAAW,mBAAmB5b,KAAKC,aAQvC4C,OAAegZ,iBAAmB,KACjCH,EAAKI,QACLN,IAAIO,gBAAgBtX,IAGtB+W,IAAIO,gBAAgBtX,EAEtB,CAAE,MAAOnG,GAET,CACF,CAGA,OAAA0d,CAAQlY,EAAsCgV,GAC5C,IAAImD,EAAWhd,KAAKsZ,KAUpB,OARIzU,IACFmY,EAAWA,EAASrd,OAAOuc,GAAKA,EAAErX,WAAaA,IAG7CgV,IACFmD,EAAWA,EAASrd,OAAOuc,GAAKA,EAAErC,YAAcA,IAG3CmD,CACT,CAGA,UAAAC,GACE,MAAMC,EAAiBld,KAAKsZ,KAAK6D,OAAO,CAACC,EAAKxD,KAC5CwD,EAAIxD,EAAI/U,WAAauY,EAAIxD,EAAI/U,WAAa,GAAK,EACxCuY,GACN,CAAA,GAEGC,EAAkBrd,KAAKsZ,KAAK6D,OAAO,CAACC,EAAKxD,KAC7CwD,EAAIxD,EAAIC,YAAcuD,EAAIxD,EAAIC,YAAc,GAAK,EAC1CuD,GACN,CAAA,GAEH,MAAO,CACLE,UAAWtd,KAAKsZ,KAAK1Z,OACrB2d,WAAYL,EACZM,WAAYH,EACZ9J,OAAQvT,KAAKsZ,KAAK3Z,OAAOuc,GAAiB,UAAZA,EAAEpX,OAAmBlF,OACnD6d,UAAWzd,KAAKsZ,KAAK1Z,OAAS,EAAI,CAChC8d,MAAO,IAAI3c,KAAKf,KAAKsZ,KAAK,GAAG1U,WAAW8W,cACxCiC,IAAK,IAAI5c,KAAKf,KAAKsZ,KAAKtZ,KAAKsZ,KAAK1Z,OAAS,GAAGgF,WAAW8W,eACvD,KAER,CAGA,KAAA9H,GACE5T,KAAKsZ,KAAO,EAEd,CAGA,UAAAsE,CAAWxE,GACTpZ,KAAKuZ,UAAYH,CAEnB,EAIF,IAAIyE,EAAwC,cAE5BC,IAId,OAHKD,IACHA,EAAoB,IAAI1E,GAAY,GAAO,IAEtC0E,CACT,OCjSaE,EAkBX,WAAAhe,CAAYwD,GAdJvD,KAAAge,YAAcF,IACd9d,KAAAie,YAAqC,KACrCje,KAAAke,aAAc,EACdle,KAAAme,cAAgB,IAAIhe,IACpBH,KAAAoe,YAIJ,CACF7K,OAAQ,GACRC,cAAe,GACfC,cAAe,IAIfzT,KAAKuD,OAASA,EACdvD,KAAKqe,eAAiB,IAAIhJ,EAC1BrV,KAAKse,eAAiB,IAAIvI,EAE1B/V,KAAK0R,YACP,CAEQ,gBAAMA,GACZ,UACQ1R,KAAKqe,eAAe3M,mBACpB1R,KAAKue,uBACXve,KAAKwe,+BACLxe,KAAKye,2BACLze,KAAK0e,2BACP,CAAE,MAAOrf,GAET,CACF,CAEQ,0BAAMkf,GACZ,IACE,MAAMnJ,QAAmBpV,KAAKqe,eAAexI,aAC7C7V,KAAKoe,YAAchJ,CACrB,CAAE,MAAO/V,GAET,CACF,CAEQ,wBAAMsf,GACZ,UACQ3e,KAAKqe,eAAevI,WACtB9V,KAAKoe,YAAY7K,OAAO3T,OAAS,SAC7BI,KAAKqe,eAAe5I,YAAYzV,KAAKoe,YAAY7K,QAErDvT,KAAKoe,YAAY5K,cAAc5T,OAAS,SACpCI,KAAKqe,eAAe1I,mBAAmB3V,KAAKoe,YAAY5K,eAE5DxT,KAAKoe,YAAY3K,cAAc7T,OAAS,SACpCI,KAAKqe,eAAezI,mBAAmB5V,KAAKoe,YAAY3K,cAElE,CAAE,MAAOpU,GAET,CACF,CAEQ,4BAAAmf,GACN,MAAMI,EAAqB,KACrB5e,KAAKie,aACPnV,aAAa9I,KAAKie,aAGpB,MAAMY,EAAQ7e,KAAKse,eAAe1H,iBAC9BiI,EAAQ,IACV7e,KAAKie,YAAclV,WAAW,MACvB/I,KAAKke,aAAele,KAAK8e,gBAC5B9e,KAAK+e,aAAaC,QAAQ,KACxBJ,MAGFA,KAEDC,KAIPD,GACF,CAEQ,yBAAAF,GACN1e,KAAKse,eAAe9H,mBAAoBD,IAClCA,GAEEvW,KAAK8e,kBAAoB9e,KAAKke,aAEhCnV,WAAW,KACT/I,KAAK+e,cACJ,MAMX,CAEQ,wBAAAN,GACgB,oBAAX7a,QAEXA,OAAOC,iBAAiB,eAAgB,KAClC7D,KAAK8e,iBACP9e,KAAKif,kBAGX,CAEA,UAAAC,CAAW7f,GACTW,KAAKoe,YAAY7K,OAAO9M,KAAKpH,GAC7BW,KAAK2e,qBAAqBQ,MAAMC,MAGlC,CAEA,kBAAAC,CAAmBhY,GACjBrH,KAAKoe,YAAY5K,cAAc/M,QAAQY,GACvCrH,KAAK2e,qBAAqBQ,MAAMC,MAGlC,CAEA,kBAAAE,CAAmBjY,GACjBrH,KAAKoe,YAAY3K,cAAchN,QAAQY,GACvCrH,KAAK2e,qBAAqBQ,MAAMC,MAGlC,CAEQ,aAAAN,GACN,OAAO9e,KAAKoe,YAAY7K,OAAO3T,OAAS,GACjCI,KAAKoe,YAAY5K,cAAc5T,OAAS,GACxCI,KAAKoe,YAAY3K,cAAc7T,OAAS,CACjD,CAEQ,gBAAMmf,GACZ,GAAI/e,KAAKke,cAAgBle,KAAK8e,gBAAiB,OAE/C,MAAMvI,OAAEA,GAAWvW,KAAKse,eAAehI,sBACvC,IAAKC,EAEH,OAGFvW,KAAKke,aAAc,EACnB,MAAM1N,EAASxQ,KAAKuD,OAAOiN,QAAU,uBAC/B+O,EAAYvf,KAAKse,eAAe3H,eAEtC,IAEE,GAAI3W,KAAKoe,YAAY7K,OAAO3T,OAAS,EAAG,CACtC,MAAQyH,OAAQmY,GAAkB/H,EAAkBzX,KAAKoe,YAAY7K,QAC/DkM,EAAe7G,EAAqB4G,EAAeD,EAAW,OACpE,IAAK,MAAMG,KAASD,QACZzf,KAAK2f,sBAAsBnP,EAAQkP,GAE3C1f,KAAKoe,YAAY7K,OAAS,EAC5B,CAGA,GAAIvT,KAAKoe,YAAY5K,cAAc5T,OAAS,EAAG,CAC7C,MAAQyH,OAAQuY,GAAkBnI,EAAkBzX,KAAKoe,YAAY5K,eAC/DqM,EAAiBjH,EAAqBgH,EAAeL,EAAW,OACtE,IAAK,MAAMG,KAASG,QACZ7f,KAAK8f,6BAA6BtP,EAAQkP,GAElD1f,KAAKoe,YAAY5K,cAAgB,EACnC,CAGA,GAAIxT,KAAKoe,YAAY3K,cAAc7T,OAAS,EAAG,CAC7C,MAAQyH,OAAQuY,GAAkBnI,EAAkBzX,KAAKoe,YAAY3K,eAC/DsM,EAAiBnH,EAAqBgH,EAAeL,EAAW,OACtE,IAAK,MAAMG,KAASK,QACZ/f,KAAKggB,6BAA6BxP,EAAQkP,GAElD1f,KAAKoe,YAAY3K,cAAgB,EACnC,OAEMzT,KAAK2e,qBAGX3e,KAAKme,cAAcvK,OAErB,CAAE,MAAOvU,GAKT,SACEW,KAAKke,aAAc,CACrB,CACF,CAGQ,cAAAe,SACN,IAAKjf,KAAK8e,gBAAiB,OAE3B,MAAMtO,EAASxQ,KAAKuD,OAAOiN,QAAU,uBAGrC,GAAI1K,UAAUma,WAAY,CACxB,GAAIjgB,KAAKoe,YAAY7K,OAAO3T,OAAS,EAAG,CACtC,MAAM6a,EAAUnW,KAAKC,UAAU,CAAEgP,OAAQvT,KAAKoe,YAAY7K,SAC1DzN,UAAUma,WAAczP,EAAH,qBAA+BiK,EACtD,CAEA,GAAIza,KAAKoe,YAAY5K,cAAc5T,OAAS,EAAG,CAC7C,MAAM6a,EAAUnW,KAAKC,UAAU,CAC7B+W,WAA6C,QAAjCzZ,EAAA7B,KAAKoe,YAAY5K,cAAc,UAAE,IAAA3R,OAAA,EAAAA,EAAE+D,UAC/CyB,OAAQrH,KAAKoe,YAAY5K,cAAchU,IAAI8Y,IAAC,CAC1C+C,WAAY/C,EAAE1P,KACdzH,KAAMmX,EAAEnX,KACRyD,UAAW0T,EAAE1T,UACb0W,WAAYhD,EAAE1S,eAGlBE,UAAUma,WAAczP,EAAH,6BAAuCiK,EAC9D,CAEA,GAAIza,KAAKoe,YAAY3K,cAAc7T,OAAS,EAAG,CAC7C,MAAM6a,EAAUnW,KAAKC,UAAU,CAAE8C,OAAQrH,KAAKoe,YAAY3K,gBAC1D3N,UAAUma,WAAczP,EAAH,6BAAuCiK,EAC9D,CACF,CACF,CAEQ,kBAAMyF,CAAa1P,EAAgB+C,GACzC,MAAMkH,EAAU,CACdlH,OAAQA,EAAO/T,IAAIH,IAAK,CACtB2E,QAAS3E,EAAM2E,QACfmc,YAAa9gB,EAAMC,MACnBkG,IAAKnG,EAAMmG,IACX4a,WAAY/gB,EAAMwG,UAClByV,WAAYjc,EAAMuG,UAClBya,SAAU,CACR9a,GAAIlG,EAAMkG,GACVI,OAAQtG,EAAMsG,OACdI,YAAa1G,EAAM0G,YACnBC,QAAS3G,EAAM2G,QACfC,KAAM5G,EAAM4G,KACZC,MAAO7G,EAAM6G,MACbzC,YAAapE,EAAMoE,YACnBqB,MAAOzF,EAAMyF,MACbZ,OAAQ7E,EAAM6E,OACdC,MAAO9E,EAAM8E,MACbF,SAAU5E,EAAM4E,UAGlBqc,YAAajhB,EAAMkhB,WAAa,CAC9BC,aAAcnhB,EAAMkhB,WAAWC,aAC/BC,gBAAiBphB,EAAMkhB,WAAWE,gBAClCC,sBAAuBrhB,EAAMkhB,WAAWG,sBACxCC,QAASthB,EAAMkhB,WAAWI,QAC1BC,WAAYvhB,EAAMkhB,WAAWK,WAC7BC,YAAaxhB,EAAMkhB,WAAWM,YAC9BC,mBAAoBzhB,EAAMkhB,WAAWO,mBACrCC,kBAAmB1hB,EAAMkhB,WAAWQ,kBACpCC,YAAa3hB,EAAMkhB,WAAWS,YAC9BC,mBAAoB5hB,EAAMkhB,WAAWU,mBACrCC,cAAe7hB,EAAMkhB,WAAWW,cAChCC,SAAU9hB,EAAMkhB,WAAWY,SAC3BC,SAAU/hB,EAAMkhB,WAAWa,SAC3BC,SAAUhiB,EAAMkhB,WAAWc,SAC3BC,mBAAoBjiB,EAAMkhB,WAAWe,mBACrCC,kBAAmBliB,EAAMkhB,WAAWgB,kBACpCC,eAAgBniB,EAAMkhB,WAAWiB,eACjCC,sBAAuBpiB,EAAMkhB,WAAWkB,sBACxCC,wBAAyBriB,EAAMkhB,WAAWmB,8BACxClhB,OAIAW,KAAMwgB,EAAczO,WAAEA,SAAqBsE,EAAaiD,GAE1D7Y,EAAkC,CACtC,YAAa5B,KAAKuD,OAAOqe,QAGvB1O,GACFtR,EAAQ,gBAAkB,2BAC1BA,EAAQ,oBAAsB,OAC9BA,EAAQ,2BAA6B,oBAErCA,EAAQ,gBAAkB,mBAG5B,MAAM+L,QAAiBxB,MAASqE,EAAH,qBAA+B,CAC1DvD,OAAQ,OACRrL,UACA4L,KAAMmU,IAGR,IAAKhU,EAASkU,GACZ,MAAUxd,MAAM,kBAAkBsJ,EAASW,OAE/C,CAEQ,yBAAMwT,CAAoBtR,EAAgBnJ,SAChD,GAAsB,IAAlBA,EAAOzH,OAAc,OAEzBI,KAAKge,YAAYpE,IAAI,UAAW,8BAA+B,iCAAkC,CAC/FuB,YAAa9T,EAAOzH,OACpBwb,gBAAiB/T,EAAO7H,IAAI,CAAC8Y,EAAG5V,KAAC,CAC/BqR,MAAOrR,EACPkG,KAAM0P,EAAE1P,KACR2R,eAAgBjC,EAAE1S,UAClB2V,eAAgBjD,EAAE1S,WAAa,UAC/BhB,UAAW0T,EAAE1T,UACb4W,SAAUhM,OAAOuI,KAAKO,EAAEnX,MAAQ,CAAA,QAIpC,MAAMyE,EAAYyB,EAAO,GAAGzB,UAC5B5F,KAAKge,YAAYpE,IAAI,UAAW,wBAAyB,wCAAyC,CAChGhU,YACAmc,qBAAsBnc,EACtBoc,gBAAiBpc,EACjBqc,eAAgB5a,EAAO,GAAGuB,OAG5B,MAAM6R,EAAU,CACda,WAAY1V,EACZyB,OAAQA,EAAO7H,IAAIsE,IAAK,CACtBuX,WAAYvX,EAAM8E,KAClBzH,KAAM2C,EAAM3C,KACZyD,UAAWd,EAAMc,UACjB0W,WAAYxX,EAAM8B,cAItB5F,KAAKge,YAAY9C,sBAAsB7T,EAAQzB,EAAW6U,GAE1D,MAAQtZ,KAAMwgB,EAAczO,WAAEA,SAAqBsE,EAAaiD,GAEhEza,KAAKge,YAAYpE,IAAI,UAAW,sBAAuB,gCAAiC,CACtFjC,aAAcrT,KAAKC,UAAUkW,GAAS7a,OACtCsiB,eAAiBP,aAAkC1R,YAAe0R,EAA0CzR,WAAcyR,EAAqC/hB,OAC/JsT,aACAiP,iBAAkB1H,EAAQa,WAC1B8G,mBAAoB3H,EAAQpT,OAAOzH,OACnC6b,0BAAyC,QAAjB5Z,EAAA4Y,EAAQpT,OAAO,UAAE,IAAAxF,OAAA,EAAAA,EAAEyZ,cAG7C,MAAM1Z,EAAkC,CACtC,YAAa5B,KAAKuD,OAAOqe,QAGvB1O,GACFtR,EAAQ,gBAAkB,2BAC1BA,EAAQ,oBAAsB,OAC9BA,EAAQ,2BAA6B,oBAErCA,EAAQ,gBAAkB,mBAG5B5B,KAAKge,YAAYxD,WACf,wBACGhK,EAAH,6BACAiK,OACAja,OACAA,GAGF,MAAMmN,QAAiBxB,MAASqE,EAAH,6BAAuC,CAClEvD,OAAQ,OACRrL,UACA4L,KAAMmU,IAUR,GAPA3hB,KAAKge,YAAYpE,IAAI,UAAW,eAAgB,wBAAyB,CACvEtL,OAAQX,EAASW,OACjB+T,WAAY1U,EAAS0U,WACrBR,GAAIlU,EAASkU,GACbjgB,QAAS4N,OAAOC,YAAY9B,EAAS/L,QAAQwB,cAG1CuK,EAASkU,GAAI,CAChB,MAAMS,QAAkB3U,EAASkC,OAAOsP,MAAM,IAAM,iCAWpD,MAVAnf,KAAKge,YAAY7D,SAAS,UAAW,gBAAqB9V,MAAM,kBAAkBsJ,EAASW,QAAW,CACpGA,OAAQX,EAASW,OACjB+T,WAAY1U,EAAS0U,WACrBE,cAAeD,EACfE,eAAgB,CACdlH,WAAYb,EAAQa,WACpBH,YAAaV,EAAQpT,OAAOzH,OAC5B6iB,eAAgBhI,EAAQpT,OAAO,GAAKmI,OAAOuI,KAAK0C,EAAQpT,OAAO,IAAM,MAG/DhD,MAAM,kBAAkBsJ,EAASW,OAC7C,CAEAtO,KAAKge,YAAYpE,IAAI,UAAW,iBAAkB,uCAAwC,CACxF8I,eAAgBrb,EAAOzH,OACvBgG,UAAW6U,EAAQa,YAEvB,CAEQ,yBAAMqH,CAAoBnS,EAAgBnJ,GAChD,GAAsB,IAAlBA,EAAOzH,OAAc,OAEzBI,KAAKge,YAAYpE,IAAI,UAAW,8BAA+B,iCAAkC,CAC/FuB,YAAa9T,EAAOzH,OACpBwb,gBAAiB/T,EAAO7H,IAAI,CAAC8Y,EAAG5V,KAAC,CAC/BqR,MAAOrR,EACPuK,OAAQqL,EAAErL,OACVzH,IAAK8S,EAAE9S,IACP+U,eAAgBjC,EAAE1S,UAClB2V,eAAgBjD,EAAE1S,WAAa,UAC/ByI,WAAYiK,EAAEjK,WACdzJ,UAAW0T,EAAE1T,eAKjB,MAAMgB,EAAYyB,EAAO,GAAGzB,UAC5B5F,KAAKge,YAAYpE,IAAI,UAAW,wBAAyB,wCAAyC,CAChGhU,YACAmc,qBAAsBnc,EACtBoc,gBAAiBpc,EACjBgd,iBAAkBvb,EAAO,GAAG4F,SAG9B,MAAMwN,EAAU,CACda,WAAY1V,EACZyB,OAAQA,EAAO7H,IAAIsE,IAAK,CACtBmJ,OAAQnJ,EAAMmJ,OACdzH,IAAK1B,EAAM0B,IACXqd,YAAa/e,EAAMuK,WACnByU,cAAehf,EAAMyK,aACrB3J,UAAWd,EAAMc,UACjB0W,WAAYxX,EAAM8B,UAClBmd,aAAc,CACZnhB,QAASkC,EAAM2K,gBAAkB,CAAA,EACjCjB,KAAM1J,EAAMwJ,aAAe,KAC3B8C,KAAMtM,EAAMyJ,aAAe,GAE7ByV,cAAe,CACbphB,QAASkC,EAAM6K,iBAAmB,CAAA,EAClCnB,KAAM1J,EAAM8J,cAAgB,KAC5BwC,KAAMtM,EAAM+J,cAAgB,OAKlC7N,KAAKge,YAAYpE,IAAI,UAAW,wBAAyB,uCAAwC,CAC/FhU,UAAW6U,EAAQa,WACnBH,YAAaV,EAAQpT,OAAOzH,OAC5BqjB,iBAAkBxI,EAAQpT,OAAOmR,MAAMF,KAAOA,EAAEgD,YAChD4H,WAAYzI,EAAQpT,OAAO7H,IAAI8Y,GAAKA,EAAEgD,cAGxC,MAAQna,KAAMwgB,EAAczO,WAAEA,SAAqBsE,EAAaiD,GAEhEza,KAAKge,YAAYpE,IAAI,UAAW,sBAAuB,wCAAyC,CAC9FjC,aAAcrT,KAAKC,UAAUkW,GAAS7a,OACtCsiB,eAAiBP,aAAkC1R,YAAe0R,EAA0CzR,WAAcyR,EAAqC/hB,OAC/JsT,aACAiP,iBAAkB1H,EAAQa,WAC1B8G,mBAAoB3H,EAAQpT,OAAOzH,SAGrC,MAAMgC,EAAkC,CACtC,YAAa5B,KAAKuD,OAAOqe,QAGvB1O,GACFtR,EAAQ,gBAAkB,2BAC1BA,EAAQ,oBAAsB,OAC9BA,EAAQ,2BAA6B,oBAErCA,EAAQ,gBAAkB,mBAG5B5B,KAAKge,YAAYxD,WACf,wBACGhK,EAAH,6BACAiK,OACAja,OACAA,GAGF,MAAMmN,QAAiBxB,MAASqE,EAAH,6BAAuC,CAClEvD,OAAQ,OACRrL,UACA4L,KAAMmU,IAUR,GAPA3hB,KAAKge,YAAYpE,IAAI,UAAW,eAAgB,gCAAiC,CAC/EtL,OAAQX,EAASW,OACjB+T,WAAY1U,EAAS0U,WACrBR,GAAIlU,EAASkU,GACbjgB,QAAS4N,OAAOC,YAAY9B,EAAS/L,QAAQwB,cAG1CuK,EAASkU,GAAI,CAChB,MAAMS,QAAkB3U,EAASkC,OAAOsP,MAAM,IAAM,iCAWpD,MAVAnf,KAAKge,YAAY7D,SAAS,UAAW,gBAAqB9V,MAAM,0BAA0BsJ,EAASW,QAAW,CAC5GA,OAAQX,EAASW,OACjB+T,WAAY1U,EAAS0U,WACrBE,cAAeD,EACfE,eAAgB,CACdlH,WAAYb,EAAQa,WACpBH,YAAaV,EAAQpT,OAAOzH,OAC5B6iB,eAAgBhI,EAAQpT,OAAO,GAAKmI,OAAOuI,KAAK0C,EAAQpT,OAAO,IAAM,MAG/DhD,MAAM,0BAA0BsJ,EAASW,OACrD,CAEAtO,KAAKge,YAAYpE,IAAI,UAAW,iBAAkB,uCAAwC,CACxF8I,eAAgBrb,EAAOzH,OACvBgG,UAAW6U,EAAQa,YAEvB,CAEQ,2BAAMqE,CAAsBnP,EAAgB+C,GAElD,OAAOvT,KAAKmjB,iBADA,SACsB,IAAMnjB,KAAKkgB,aAAa1P,EAAQ+C,GACpE,CAEQ,kCAAMuM,CAA6BtP,EAAgBnJ,GAEzD,OAAOrH,KAAKmjB,iBADA,iBACsB,IAAMnjB,KAAK8hB,oBAAoBtR,EAAQnJ,GAC3E,CAEQ,kCAAM2Y,CAA6BxP,EAAgBnJ,GAEzD,OAAOrH,KAAKmjB,iBADA,iBACsB,IAAMnjB,KAAK2iB,oBAAoBnS,EAAQnJ,GAC3E,CAEQ,sBAAM8b,CAAoB9T,EAAawK,GAC7C,MAAMuJ,EAAiBpjB,KAAKme,cAAcnb,IAAIqM,IAAQ,EAEtD,IAAKrP,KAAKse,eAAezH,YAAYuM,GACnC,MAAU/e,MAAM,mCAAmCgL,GAGrD,IACE,MAAM6C,QAAe2H,IAErB,OADA7Z,KAAKme,cAAc9a,OAAOgM,GACnB6C,CACT,CAAE,MAAO7S,GAGP,GAFAW,KAAKme,cAAclb,IAAIoM,EAAK+T,EAAiB,GAEzCpjB,KAAKse,eAAezH,YAAYuM,EAAiB,GAAI,CACvD,MAAMvE,EAAQ7e,KAAKse,eAAevH,cAAcqM,EAAiB,GAIjE,aADM,IAAIxR,QAAQC,GAAW9I,WAAW8I,EAASgN,IAC1C7e,KAAKmjB,iBAAiB9T,EAAKwK,EACpC,CAEE,MAAMxa,CAEV,CACF,CAEA,gBAAMgkB,GACJrjB,KAAKoe,YAAc,CACjB7K,OAAQ,GACRC,cAAe,GACfC,cAAe,UAGXzT,KAAKqe,eAAevI,UAC5B,CAEA,OAAA7E,GACMjR,KAAKie,cACPnV,aAAa9I,KAAKie,aAClBje,KAAKie,YAAc,MAIjBje,KAAK8e,iBACP9e,KAAKif,gBAET,QCljBWqE,EAUX,WAAAvjB,CAAYwD,EAAoBggB,GAJxBvjB,KAAAwjB,cAAgC,GAChCxjB,KAAAyjB,YAAa,EAInBzjB,KAAKuD,OAASA,EACdvD,KAAKujB,kBAAoBA,EACzBvjB,KAAK0jB,kBAAoB1jB,KAAK2jB,4BAC9B3jB,KAAK4jB,iBAAmB7iB,KAAKC,MAC7BhB,KAAK6jB,qBAAuB9iB,KAAKC,MAEX,oBAAX4C,QACT5D,KAAK8jB,sBAET,CAKA,aAAAC,CAAcpe,GACZ3F,KAAK2F,OAASA,EACd3F,KAAKyjB,YAAa,EAGlBzjB,KAAKgkB,eAKP,CAKA,YAAAC,GACEjkB,KAAKyjB,YAAa,EAClBzjB,KAAKyJ,OACP,CAKA,SAAAya,CAAUve,GACR3F,KAAK2F,OAASA,CAChB,CAKQ,aAAAqe,GACN,IAAKhkB,KAAKyjB,WAAY,OAEtB,MAAM3f,EAAsB,CAC1BuX,WAAY,YACZ7V,IAAK5B,OAAO6B,SAASC,KACrB0F,SAAU7C,SAAS6C,eAAY5K,EAC/BoE,UAAW7D,KAAKC,MAChBqf,SAAU,CACRlV,MAAO5C,SAAS4C,MAChBgZ,SAAU,CACR/a,MAAOxF,OAAOyF,WACdC,OAAQ1F,OAAO2F,aAEjB6a,gBAAiB,CACfpb,EAAGpF,OAAOqF,QACVC,EAAGtF,OAAOuF,SAEZ2X,mBAAoB9gB,KAAK0jB,kBACzBtD,WAAYta,UAAUD,UACtBub,SAAUtb,UAAUsb,SACpBC,SAAUgD,KAAKC,iBAAiBC,kBAAkBC,SAClDC,gBAAiBzkB,KAAK0kB,sBAI1B1kB,KAAK2kB,gBAAgB7gB,EACvB,CAKQ,UAAA8gB,CAAWta,EAAsBxG,GACvC,IAAK9D,KAAKyjB,WAAY,OAEtB,MAAMoB,EAA6B,CACjCxJ,WAAY,QACZ7V,IAAK5B,OAAO6B,SAASC,KACrBd,UAAW7D,KAAKC,MAChBqf,SAAU,CACR/V,QAAS,CACPwa,IAAKxa,EAAQX,QAAQgB,cACrBpF,GAAI+E,EAAQ/E,GACZwf,MAAOza,EAAQV,UACfiG,KAAM7P,KAAKglB,eAAe1a,GAC1B2a,WAAYjlB,KAAKklB,sBAAsB5a,IAEzCN,YAAa,CACXhB,EAAGlF,EAAMmG,QACTf,EAAGpF,EAAMoG,QACTib,OAAQrhB,EAAMshB,MACdC,OAAQvhB,EAAMwhB,OAEhBnB,SAAU,CACR/a,MAAOxF,OAAOyF,WACdC,OAAQ1F,OAAO2F,aAEjB6a,gBAAiB,CACfpb,EAAGpF,OAAOqF,QACVC,EAAGtF,OAAOuF,WAKhBnJ,KAAK2kB,gBAAgBE,EACvB,CAKQ,eAAAU,CAAgBC,SACtB,IAAKxlB,KAAKyjB,WAAY,OAEtB,MAAMgC,EAAW,IAAItW,SAASqW,GACxBE,EAA8B,CAAA,EAEpCD,EAASpd,QAAQ,CAAC+B,EAAOiF,KAEvB,MAAMsW,EAAQH,EAAKI,cAAc,UAAUvW,OAC3CqW,EAAOrW,GAAO,CACZzG,MAAM+c,eAAAA,EAAO/c,OAAQ,UACrBid,YAAazb,EACb0b,aAA+B,iBAAV1b,EAAqBA,EAAMxK,OAAS,KAI7D,MAAMilB,EAA6B,CACjCxJ,WAAY,cACZ7V,IAAK5B,OAAO6B,SAASC,KACrBd,UAAW7D,KAAKC,MAChBqf,SAAU,CACRmF,KAAM,CACJjgB,GAAIigB,EAAKjgB,GACTwf,MAAOS,EAAK5b,UACZqD,OAAQuY,EAAKvY,OACb8Y,OAAQP,EAAKO,OACbC,YAAaP,EAASriB,UAAUxD,QAElC8lB,QAA2B,QAAnB7jB,EAAA7B,KAAKuD,OAAOgH,eAAO,IAAA1I,OAAA,EAAAA,EAAE2I,YAAa,CAAA,EAAKkb,IAInD1lB,KAAK2kB,gBAAgBE,EACvB,CAKA,YAAAoB,CAAazgB,EAAayH,EAAgBqB,EAAgB9E,EAAkB4G,GAC1E,IAAKpQ,KAAKyjB,WAAY,OAEtB,MAAMoB,EAA6B,CACjCxJ,WAAY,WACZ7V,IAAK5B,OAAO6B,SAASC,KACrBd,UAAW7D,KAAKC,MAChBklB,YAAa1c,EACb6W,SAAU,CACR8F,IAAK,CACH3gB,MACAyH,SACAqB,SACA9E,WACA4G,KAAMA,GAAQ,EACdgW,QAAS9X,GAAU,KAAgB,IAATA,GAE5B+X,aAAc,CACZlb,MAAO5C,SAAS4C,MAChBmb,aAAcvlB,KAAKC,MAAQhB,KAAK6jB,wBAKtC7jB,KAAK2kB,gBAAgBE,EACvB,CAKA,UAAA0B,CAAWlnB,EAAcmnB,SACvB,IAAKxmB,KAAKyjB,WAAY,OAEtB,MAAMoB,EAA6B,CACjCxJ,WAAY,QACZ7V,IAAK5B,OAAO6B,SAASC,KACrBd,UAAW7D,KAAKC,MAChBqf,SAAU,CACRhhB,MAAO,CACL2E,QAAS3E,EAAM2E,QACf0G,KAAMrL,EAAMqL,KACZpL,MAAkB,UAAXD,EAAMC,aAAK,IAAAuC,OAAA,EAAAA,EAAEtC,MAAM,MAAMwK,MAAM,EAAG,GAAGlK,KAAK,OAEnD4mB,aAAc,CACZH,aAAcvlB,KAAKC,MAAQhB,KAAK6jB,qBAChC6C,iBAAkB3lB,KAAKC,MAAQhB,KAAK4jB,iBACpC+C,kBAAmB3mB,KAAK4mB,yBAE1BC,eAAgBL,GAAW,CAAA,IAI/BxmB,KAAK2kB,gBAAgBE,EACvB,CAKQ,oBAAAf,GAEN,IAAIgD,EAAaljB,OAAO6B,SAASC,KAEjC,MAAMqhB,EAAmB,KACvB,GAAInjB,OAAO6B,SAASC,OAASohB,EAAY,CAEvC,MAAME,EAAYjmB,KAAKC,MAAQhB,KAAK6jB,qBACpC7jB,KAAKinB,2BAA2BD,GAGhCF,EAAaljB,OAAO6B,SAASC,KAC7B1F,KAAK6jB,qBAAuB9iB,KAAKC,MACjChB,KAAKgkB,eACP,GAIFpgB,OAAOC,iBAAiB,WAAYkjB,GAGpC,MAAMG,EAAoBC,QAAQC,UAC5BC,EAAuBF,QAAQG,aAErCH,QAAQC,UAAY,YAAY1iB,GAC9BwiB,EAAkBniB,MAAMoiB,QAASziB,GACjCqE,WAAWge,EAAkB,EAC/B,EAEAI,QAAQG,aAAe,YAAY5iB,GACjC2iB,EAAqBtiB,MAAMoiB,QAASziB,GACpCqE,WAAWge,EAAkB,EAC/B,EAGAxe,SAAS1E,iBAAiB,QAAUC,IAClC,MAAM4F,EAAS5F,EAAM4F,OACjBA,GAAU1J,KAAKunB,iBAAiB7d,IAClC1J,KAAK4kB,WAAWlb,EAAQ5F,IAEzB,CAAE4E,SAAS,EAAMC,SAAS,IAG7BJ,SAAS1E,iBAAiB,SAAWC,IACnC,MAAM0hB,EAAO1hB,EAAM4F,OACf8b,GAAyB,SAAjBA,EAAK7b,SACf3J,KAAKulB,gBAAgBC,IAEtB,CAAE9c,SAAS,EAAMC,SAAS,IAG7B/E,OAAOC,iBAAiB,eAAgB,KACtC,MAAMmjB,EAAYjmB,KAAKC,MAAQhB,KAAK6jB,qBACpC7jB,KAAKinB,2BAA2BD,GAChChnB,KAAKyJ,UAIPqD,YAAY,KACN9M,KAAKwjB,cAAc5jB,OAAS,GAC9BI,KAAKyJ,SAEN,IACL,CAKQ,yBAAAka,GACN,GAAsB,oBAAX/f,OAAwB,MAAO,SAE1C,MAAM4jB,EAAa,CACjB1hB,UAAUD,UACVC,UAAUsb,SACVqG,OAAOre,MAAQ,IAAMqe,OAAOne,OAC5Bme,OAAOC,WACPrD,KAAKC,iBAAiBC,kBAAkBC,SACxC1e,UAAUqb,SACVrb,UAAU6hB,mBACqB,IAAxB/jB,OAAOqR,kBACmB,IAA1BrR,OAAO2D,gBAIhB,IACE,MAAMqgB,EAASrf,SAASmU,cAAc,UAChCmL,EAAMD,EAAOE,WAAW,MAC1BD,IACFA,EAAIE,aAAe,MACnBF,EAAIG,KAAO,aACXH,EAAII,SAAS,qBAAsB,EAAG,GACtCT,EAAW/gB,KAAKmhB,EAAOM,aAE3B,CAAE,MAAO5P,GAET,CAGA,MAAM6P,EAAcX,EAAW3nB,KAAK,KAGpC,IAAIuoB,EAAO,EACX,IAAK,IAAI1lB,EAAI,EAAOylB,EAAYvoB,OAAhB8C,EAAwBA,IAEtC0lB,GAASA,GAAQ,GAAKA,EADTD,EAAYE,WAAW3lB,GAEpC0lB,GAAcA,EAGhB,OAAOnpB,KAAKqpB,IAAIF,GAAMjpB,SAAS,GACjC,CAKQ,eAAAwlB,CAAgB7gB,GACtB9D,KAAKwjB,cAAc/c,KAAK3C,GAGS,GAA7B9D,KAAKwjB,cAAc5jB,QACrBI,KAAKyJ,OAET,CAKQ,KAAAA,GACN,GAAkC,IAA9BzJ,KAAKwjB,cAAc5jB,OAAc,OAErC,MAAMyH,EAAS,IAAIrH,KAAKwjB,eACxBxjB,KAAKwjB,cAAgB,GAGrBxjB,KAAKuoB,kBAAkBlhB,GAAQ8X,MAAM9f,IAKnCW,KAAKwjB,cAAcgF,WAAWnhB,IAElC,CAKQ,uBAAMkhB,CAAkBlhB,GAC9B,MAAMmJ,EAASxQ,KAAKuD,OAAOiN,QAAU,uBAG/BiY,EAAWphB,EAAO7H,IAAIsE,GAC1BqI,MAASqE,EAAH,4BAAsC,CAC1CvD,OAAQ,OACRrL,QAAS,CACP,eAAgB,mBAChB,YAAa5B,KAAKuD,OAAOqe,QAE3BpU,KAAMlJ,KAAKC,UAAU,CACnBmkB,QAAS1oB,KAAK2F,OACd2V,WAAYtb,KAAKkI,kBACdpE,aAKH8N,QAAQ+W,WAAWF,EAC3B,CAKQ,gBAAAlB,CAAiBjd,GAEvB,MAAMwa,EAAMxa,EAAQX,QAAQgB,cAC5B,QAAI,CAAC,QAAS,YAAYF,SAASqa,KAE7B,CAAC,WAAY,UAAUra,SADbH,EAC4B1B,SAMpC0B,EAAQse,aAAa,mBAC/B,CAEQ,cAAA5D,CAAe1a,GAErB,OADaA,EAAQT,aAAeS,EAAQue,WAAa,IAC7CnpB,OAAOopB,UAAU,EAAG,IAClC,CAEQ,qBAAA5D,CAAsB5a,GAC5B,MAAMye,EAAgC,CAAA,EAUtC,MATsB,CAAC,OAAQ,MAAO,MAAO,QAAS,cAAe,QAEvD1gB,QAAQ2gB,IACpB,MAAM5e,EAAQE,EAAQ2e,aAAaD,GAC/B5e,IACF2e,EAAMC,GAAQ5e,KAIX2e,CACT,CAEQ,iBAAArE,GACN,GAAI,eAAgB5e,UAAW,CAC7B,MAAMoR,EAAcpR,UAAkBoR,WACtC,OAAOA,aAAU,EAAVA,EAAYC,iBAAiBD,eAAAA,EAAYtO,OAAQ,SAC1D,CACA,MAAO,SACT,CAEQ,qBAAAge,GACN,OAAO5mB,KAAKwjB,cAAc7jB,OAAOmE,GAC/B,CAAC,QAAS,eAAe2G,SAAS3G,EAAMuX,aACxCzb,MACJ,CAEQ,0BAAAqnB,CAA2Bzd,GACjC,GAAIxJ,KAAKwjB,cAAc5jB,OAAS,EAAG,CACjC,MAAMspB,EAAYlpB,KAAKwjB,cAAcxjB,KAAKwjB,cAAc5jB,OAAS,GACpC,cAAzBspB,EAAU7N,aACZ6N,EAAUhD,YAAc1c,EAE5B,CACF,CAEQ,YAAAtB,GAEN,OAAIlI,KAAKujB,kBACAvjB,KAAKujB,oBAIP,WAAaxiB,KAAKC,KAC3B,QCheWmoB,EAOX,WAAAppB,CAAYwD,GALJvD,KAAAopB,cAAgB,EAChBppB,KAAAqpB,aAAetoB,KAAKC,MACpBhB,KAAAspB,eAAiB,EACjBtpB,KAAAupB,kBAAoB,EAG1BvpB,KAAKuD,OAASA,EACdvD,KAAKwpB,4BACP,CAEQ,0BAAAA,GAEgB,oBAAX5lB,QAA0B,gBAAiBA,QACpDkJ,YAAY,KACV9M,KAAKypB,2BACJ,IAEP,CAEQ,uBAAAA,GACN,GAA2B,oBAAhBne,YAEX,IAEE,MAAMtK,EAAMsK,YAAYtK,MAElB0oB,EADUpe,YAAYqe,iBAAiB,YACbhqB,OAAOma,GACX,IAAzB9Y,EAAM8Y,EAAMhZ,WAIfd,KAAKupB,kBAAoBtqB,KAAK+X,IAAI0S,EAAgB9pB,OAAS,EAAG,EAChE,CAAE,MAAOP,GAEPW,KAAKupB,kBAAoB,EAC3B,CACF,CAEA,mBAAAK,CAAoBC,GAElB7pB,KAAKopB,cADU,CAAEU,KAAM,EAAGC,OAAQ,GAAKC,IAAK,GAAKC,KAAM,IAC3BJ,GAC5B7pB,KAAKqpB,aAAetoB,KAAKC,KAC3B,CAEA,uBAAAkpB,GACElqB,KAAKspB,eAAiBrqB,KAAK+X,IAAIhX,KAAKspB,eAAiB,GAAK,GAG1DvgB,WAAW,KACT/I,KAAKspB,eAAiBrqB,KAAKkrB,IAAInqB,KAAKspB,eAAiB,IAAM,IAC1D,IACL,CAEA,iBAAAc,WACE,MAAMC,EAAsD,QAArCvoB,EAAoB,QAApBD,EAAA7B,KAAKuD,OAAO+mB,gBAAQ,IAAAzoB,OAAA,EAAAA,EAAE0oB,uBAAe,IAAAzoB,EAAAA,EAAI,EAGhE,GAAI9B,KAAKspB,eAAiB,GACxB,OAAOrqB,KAAKC,SAAWmrB,EAIzB,MAAMG,EAAeH,GAAkB,EAA6B,GAAzBrqB,KAAKupB,mBAEhD,OAAOtqB,KAAKC,SAAWsrB,CACzB,CAEA,mBAAAC,aACE,MAAMJ,EAAyF,QAAxEtoB,EAAuC,QAAvCD,YAAA9B,KAAKuD,OAAO+mB,+BAAU9e,yBAAiB,IAAA1J,EAAAA,EAAI9B,KAAKuD,OAAOiI,yBAAiB,IAAAzJ,EAAAA,EAAI,EAO7F2oB,EAHezrB,KAAK+X,IAAIqT,EADa,GAArBrqB,KAAKopB,cACmC,IAG5B,EAA6B,GAAzBppB,KAAKupB,mBAE3C,OAAOtqB,KAAKC,SAAWwrB,CACzB,CAEA,uBAAAC,WACE,MAGMH,GAH4D,QAA3C1oB,EAAoB,QAApBD,EAAA7B,KAAKuD,OAAO+mB,gBAAQ,IAAAzoB,OAAA,EAAAA,EAAE+oB,6BAAqB,IAAA9oB,EAAAA,EAAI,KAG/B,EAA6B,GAAzB9B,KAAKupB,mBAEhD,OAAOtqB,KAAKC,SAAWsrB,CACzB,CAEA,mBAAAK,WACE,MAMML,GANwD,QAAvC1oB,EAAoB,QAApBD,EAAA7B,KAAKuD,OAAO+mB,gBAAQ,IAAAzoB,OAAA,EAAAA,EAAEipB,yBAAiB,IAAAhpB,EAAAA,EAAI,MAG5Cf,KAAKC,MAAQhB,KAAKqpB,cAAY,IACjB,EAAI,GAAM,IAEQ,EAA6B,GAAzBrpB,KAAKupB,mBAE9D,OAAOtqB,KAAKC,SAAWsrB,CACzB,CAEA,kBAAAO,WACE,MAAMV,EAAuD,QAAtCvoB,EAAoB,QAApBD,EAAA7B,KAAKuD,OAAO+mB,gBAAQ,IAAAzoB,OAAA,EAAAA,EAAEmpB,wBAAgB,IAAAlpB,EAAAA,EAAI,GAIjE,IAAI0oB,EAAevrB,KAAK+X,IAAIqT,EADa,GAAtBrqB,KAAKspB,eACiC,GAKzD,OAFAkB,GAA+B,EAA6B,GAAzBxqB,KAAKupB,kBAEjCtqB,KAAKC,SAAWsrB,CACzB,CAEA,oBAAAS,CAAqBC,GAGnB,OAAOjsB,KAAKkrB,IAAIlrB,KAAK0D,MAAMuoB,GAAY,EADU,GAAzBlrB,KAAKupB,oBACiC,EAChE,CAEA,sBAAA4B,CAAuBC,GAOrB,OAAOnsB,KAAK0D,MAAMyoB,GALO,EAA8B,EAAzBprB,KAAKupB,mBAGXtqB,KAAKkrB,IAAI,GAAK,EAA2B,GAAtBnqB,KAAKspB,gBAGlD,CAEA,iBAAA+B,CAAkB/iB,GAChB,OAAQA,GACN,IAAK,QACH,OAAQtI,KAAKoqB,oBACf,IAAK,UACH,OAAQpqB,KAAKyqB,sBACf,IAAK,cACH,OAAQzqB,KAAK2qB,0BACf,IAAK,UACH,OAAQ3qB,KAAK6qB,sBACf,IAAK,SACH,OAAQ7qB,KAAK+qB,qBACf,QACE,OAAO,EAEb,CAEA,oBAAAO,GACE,OAAOtrB,KAAKupB,iBACd,CAEA,gBAAAgC,GACE,OAAOvrB,KAAKopB,aACd,CAEA,iBAAAoC,GACE,OAAOxrB,KAAKspB,cACd,QC/JWmC,EAKX,WAAA1rB,CAAYwD,aAHJvD,KAAA0rB,UAAuB,CAAA,EACvB1rB,KAAA2rB,mBAAyC,GAG/C3rB,KAAKuD,OAASA,GAEa,QAAvB1B,EAAA7B,KAAKuD,OAAO+H,mBAAW,IAAAzJ,OAAA,EAAAA,EAAE+pB,mBAC3B5rB,KAAK6rB,kBAGoB,QAAvB/pB,EAAA9B,KAAKuD,OAAO+H,mBAAW,IAAAxJ,OAAA,EAAAA,EAAEgqB,wBAC3B9rB,KAAK+rB,uBAGoB,QAAvBhqB,EAAA/B,KAAKuD,OAAO+H,mBAAW,IAAAvJ,OAAA,EAAAA,EAAEiqB,0BAC3BhsB,KAAKisB,uBAET,CAEQ,cAAAJ,GACN,GAAsB,oBAAXjoB,QAA4B,wBAAyBA,OAAhE,CAGA,IACsB,IAAIsoB,oBAAqBC,IAC3C,MAAM/oB,EAAU+oB,EAAKC,aAErBpsB,KAAK0rB,UAAUW,IADGjpB,EAAQA,EAAQxD,OAAS,GACZkB,YAErBwrB,QAAQ,CAAEC,WAAY,CAAC,6BACrC,CAAE,MAAOjU,GAET,CAGA,IACsB,IAAI4T,oBAAqBC,IAC3BA,EAAKC,aACb/jB,QAASyR,IACf9Z,KAAK0rB,UAAUc,IAAM1S,EAAM2S,gBAAkB3S,EAAMhZ,cAG3CwrB,QAAQ,CAAEC,WAAY,CAAC,gBACrC,CAAE,MAAOjU,GAET,CAGA,IACE,IAAIoU,EAAW,EACK,IAAIR,oBAAqBC,IAC3BA,EAAKC,aACb/jB,QAASyR,IACVA,EAAM6S,iBACTD,GAAY5S,EAAM1P,MAClBpK,KAAK0rB,UAAUkB,IAAMF,OAIfJ,QAAQ,CAAEC,WAAY,CAAC,iBACrC,CAAE,MAAOjU,GAET,CAGA,IACsB,IAAI4T,oBAAqBC,IAC3BA,EAAKC,aACb/jB,QAASyR,IACI,2BAAfA,EAAMpP,OACR1K,KAAK0rB,UAAUmB,IAAM/S,EAAMhZ,eAIrBwrB,QAAQ,CAAEC,WAAY,CAAC,UACrC,CAAE,MAAOjU,GAET,CAGAtY,KAAK8sB,eA5DoE,CA6D3E,CAEQ,aAAAA,GACN,GAAsB,oBAAXlpB,QAA2BA,OAAO0H,YAE7C,IACE,MAAMyhB,EAAmBzhB,YAAYqe,iBAAiB,cAAc,GAChEoD,IACF/sB,KAAK0rB,UAAUsB,KAAOD,EAAiBE,cAAgBF,EAAiBG,aAE5E,CAAE,MAAO5U,GAET,CACF,CAEQ,mBAAAyT,GACN,GAAsB,oBAAXnoB,QAA2BA,OAAO0H,YAE7C,IAC2B,IAAI4gB,oBAAqBC,IAChCA,EAAKC,aACb/jB,QAASyR,IACf9Z,KAAK2rB,mBAAmBllB,KAAK,CAC3BiE,KAAMoP,EAAMpP,KACZyiB,UAAWrT,EAAMqT,UACjBrsB,UAAWgZ,EAAMhZ,UACjB0I,SAAUsQ,EAAMtQ,SAChB4jB,aAAetT,EAAcsT,aAC7BC,gBAAkBvT,EAAcuT,gBAChCC,gBAAkBxT,EAAcwT,sBAKrBhB,QAAQ,CAAEC,WAAY,CAAC,aAC1C,CAAE,MAAOjU,GAET,CACF,CAEQ,qBAAA2T,GACgB,oBAAXroB,QAA2BA,OAAO0H,aAE7C1H,OAAOC,iBAAiB,OAAQ,KAC9B,IACE,MAAMkpB,EAAmBzhB,YAAYqe,iBAAiB,cAAc,GAChEoD,GACF/sB,KAAK2rB,mBAAmBllB,KAAK,CAC3BiE,KAAM,aACNyiB,UAAW,aACXrsB,UAAWisB,EAAiBjsB,UAC5B0I,SAAUujB,EAAiBvjB,SAC3B+jB,yBAA0BR,EAAiBQ,yBAC3CC,2BAA4BT,EAAiBS,2BAC7CC,aAAcV,EAAiBU,aAC/BC,eAAgBX,EAAiBW,eACjCC,YAAaZ,EAAiBY,YAC9BC,eAAgBb,EAAiBa,gBAGvC,CAAE,MAAOtV,GAET,GAEJ,CAEA,YAAAuV,GACE,MAAO,IAAK7tB,KAAK0rB,UACnB,CAEA,qBAAAoC,GACE,MAAO,IAAI9tB,KAAK2rB,mBAClB,CAEA,uBAAAoC,GACE/tB,KAAK2rB,mBAAqB,EAC5B,CAGA,IAAAqC,CAAKtjB,GACH,GAAsB,oBAAX9G,QAA0BA,OAAO0H,aAAkD,mBAA5B1H,OAAO0H,YAAY0iB,KACnF,IACE1iB,YAAY0iB,KAAKtjB,EACnB,CAAE,MAAO4N,GAET,CAEJ,CAEA,OAAA2V,CAAQvjB,EAAcwjB,EAAoBC,GACxC,GAAsB,oBAAXvqB,SAA2BA,OAAO0H,cAAgB1H,OAAO0H,YAAY2iB,QAC9E,OAAO,KAGT,IACE3iB,YAAY2iB,QAAQvjB,EAAMwjB,EAAWC,GACrC,MAAMF,EAAU3iB,YAAY8iB,iBAAiB1jB,EAAM,WAAW,GAC9D,OAAOujB,EAAUA,EAAQzkB,SAAW,IACtC,CAAE,MAAO8O,GACP,OAAO,IACT,CACF,QCJW+V,EAkBX,WAAAtuB,CAAYuuB,GAhBJtuB,KAAAuuB,UAAY,IAAIC,QAChBxuB,KAAAyuB,QAAU,IAAItuB,IACdH,KAAA0uB,WAAa,EAGb1uB,KAAA2uB,aAAc,EAKd3uB,KAAA4uB,mBAA4B,GAI5B5uB,KAAA6uB,mBAAqB,IAAIL,QAI/BxuB,KAAK8uB,2BACL9uB,KAAK+uB,yBACP,CAKA,oBAAAC,GACoB1jB,YAAYtK,MAA9B,MAEMiuB,EAAgC,CACpCrqB,UAAW7D,KAAKC,MAChBwE,IAAK5B,OAAO6B,SAASC,KACrByF,MAAO5C,SAAS4C,MAChBgZ,SAAU,CACR/a,MAAOxF,OAAOyF,WACdC,OAAQ1F,OAAO2F,YACf2lB,iBAAkBtrB,OAAOsrB,iBACzBjmB,QAASrF,OAAOqF,QAChBE,QAASvF,OAAOuF,SAElBgmB,MAAO,GACPC,YAAa,GACbC,UAAW,GAEX/jB,YAAatL,KAAKsvB,4BAClBvpB,YAAa/F,KAAKuvB,0BAepB,OAXAN,EAASE,MAAQnvB,KAAKwvB,0BAA0BjnB,UAGhD0mB,EAASG,YAAcpvB,KAAKyvB,+BAG5BR,EAASI,UAAYrvB,KAAK0vB,6BAEVpkB,YAAYtK,MAGrBiuB,CACT,CAKA,sBAAAU,CAAuBC,GACjB5vB,KAAK2uB,cAET3uB,KAAK4vB,YAAcA,EACnB5vB,KAAK6vB,SAAW,IAAIC,iBAAiB9vB,KAAK+vB,wBAAwBC,KAAKhwB,OAEvEA,KAAK6vB,SAASvD,QAAQ/jB,SAAU,CAC9B0nB,WAAW,EACXhL,YAAY,EACZiL,eAAe,EACfC,SAAS,EACTC,mBAAmB,EACnBC,uBAAuB,EACvBC,qBAAiB9vB,IAIW,oBAAnB+vB,iBACTvwB,KAAKwwB,eAAiB,IAAID,eAAevwB,KAAKywB,oBAAoBT,KAAKhwB,OACvEA,KAAKwwB,eAAelE,QAAQ/jB,SAASmoB,kBAGvC1wB,KAAK2uB,aAAc,EACrB,CAKA,qBAAAgC,GACM3wB,KAAK6vB,WACP7vB,KAAK6vB,SAASe,aACd5wB,KAAK6vB,cAAWrvB,GAEdR,KAAKwwB,iBACPxwB,KAAKwwB,eAAeI,aACpB5wB,KAAKwwB,oBAAiBhwB,GAEpBR,KAAK6wB,qBACP7wB,KAAK6wB,oBAAoBD,aAE3B5wB,KAAK2uB,aAAc,EACnB3uB,KAAK4vB,iBAAcpvB,CACrB,CAKQ,yBAAAgvB,CAA0BsB,GAChC,MAAM3B,EAAkC,GAQxC,GALI2B,EAAIC,SACN5B,EAAM1oB,KAAKzG,KAAKgxB,iBAAiBF,EAAIC,UAInCD,EAAIJ,gBAAiB,CACvB,MAAMO,EAAajxB,KAAKkxB,sBAAsBJ,EAAIJ,iBAC9CO,GACF9B,EAAM1oB,KAAKwqB,EAEf,CAEA,OAAO9B,CACT,CAKQ,qBAAA+B,CAAsBC,GAC5B,GAAInxB,KAAKoxB,iBAAiBD,GACxB,OAAO,KAGT,MACMF,EAAqC,CACzC1rB,GAFavF,KAAKqxB,UAAUF,GAG5BvoB,KAAM5I,KAAKsxB,YAAYH,GACvBI,WAAYjmB,YAAYtK,OAG1B,OAAQmwB,EAAKK,UACX,KAAKC,KAAKC,aACR,MAAMpnB,EAAU6mB,EAChBF,EAAWtnB,QAAUW,EAAQX,QAAQgB,cACrCsmB,EAAWhM,WAAajlB,KAAK2xB,4BAA4BrnB,GAGzD2mB,EAAWW,eAAiB5xB,KAAK6xB,sBAAsBvnB,GACvD2mB,EAAWa,aAAe9xB,KAAK+xB,oBAAoBznB,GAGnD2mB,EAAWe,aAAe1nB,EAAQ2nB,wBAClChB,EAAWiB,WAAalyB,KAAKmyB,sBAAsB7nB,GAGnD2mB,EAAWmB,iBAAmBpyB,KAAKqyB,wBAAwB/nB,GAGvDtK,KAAKsyB,cAAchoB,KACrB2mB,EAAWsB,WAAavyB,KAAKwyB,kBAAkBloB,GAC/C2mB,EAAWwB,gBAAkBzyB,KAAK0yB,uBAAuBpoB,KAIvDA,EAAQqoB,YAAcroB,EAAQsoB,aAAetoB,EAAQuoB,aAAevoB,EAAQwoB,gBAC9E7B,EAAW8B,eAAiB,CAC1B/pB,EAAGsB,EAAQ0oB,WACX9pB,EAAGoB,EAAQ2oB,YAKfhC,EAAWiC,SAAWlzB,KAAKmzB,0BAA0B7oB,GACrD,MAEF,KAAKmnB,KAAK2B,UACR,MAAMC,EAAWlC,EACjBF,EAAWpnB,YAAc7J,KAAK8J,eAAeupB,GACzC,gBACAA,EAASxpB,aAAe,GAC5B,MAEF,KAAK4nB,KAAK6B,aAERrC,EAAWpnB,YADSsnB,EACiBtnB,aAAe,GACpD,MAEF,QACE,OAAO,KAGX,OAAOonB,CACT,CAKQ,qBAAAY,CAAsBvnB,GAE5B,GAAItK,KAAK6uB,mBAAmB5W,IAAI3N,GAC9B,OAAOtK,KAAK6uB,mBAAmB7rB,IAAIsH,GAGrC,MAAMipB,EAAgB3vB,OAAO4vB,iBAAiBlpB,GACxCmpB,EAAiC,CAAA,EA+CvC,MA5C2B,CAEzB,UAAW,WAAY,MAAO,QAAS,SAAU,OAAQ,QAAS,SAClE,SAAU,aAAc,eAAgB,gBAAiB,cACzD,UAAW,cAAe,gBAAiB,iBAAkB,eAC7D,SAAU,eAAgB,eAAgB,eAAgB,gBAC1D,aAAc,WAAY,aAAc,aAAc,UAGtD,OAAQ,iBAAkB,YAAa,kBAAmB,cAAe,aACzE,YAAa,cAAe,aAAc,QAG1C,OAAQ,gBAAiB,YAAa,eAAgB,aAGtD,OAAQ,cAAe,YAAa,cAAe,aAAc,cACjE,aAAc,kBAAmB,iBAAkB,iBAAkB,eACrE,QAAS,cAGT,aAAc,mBAAoB,mBAAoB,kBACtD,sBAAuB,oBAAqB,wBAG5C,UAAW,aAAc,YAAa,SAAU,kBAChD,aAAc,YAGd,aAAc,YAAa,cAG3B,SAAU,iBAAkB,cAAe,UAG1BprB,QAAQqrB,IACzB,MAAMtpB,EAAQmpB,EAAcI,iBAAiBD,GACzCtpB,GAAmB,YAAVA,GAAiC,YAAVA,IAClCqpB,EAAOC,GAAYtpB,KAKvBpK,KAAK6uB,mBAAmB5rB,IAAIqH,EAASmpB,GAC9BA,CACT,CAKQ,mBAAA1B,CAAoBznB,GAC1B,MAAMmpB,EAAiC,CAAA,EAEvC,GAAInpB,aAAmBspB,aAAetpB,EAAQupB,MAAMj0B,OAAS,EAC3D,IAAK,IAAI8C,EAAI,EAAO4H,EAAQupB,MAAMj0B,OAAlB8C,EAA0BA,IAAK,CAC7C,MAAMgxB,EAAWppB,EAAQupB,MAAM7gB,KAAKtQ,GAC9B0H,EAAQE,EAAQupB,MAAMF,iBAAiBD,GACvCI,EAAWxpB,EAAQupB,MAAME,oBAAoBL,GAEnDD,EAAOC,GAAYI,EAAW,GAAG1pB,MAAU0pB,IAAa1pB,CAC1D,CAGF,OAAOqpB,CACT,CAKQ,qBAAAtB,CAAsB7nB,GAC5B,MAAMipB,EAAgB3vB,OAAO4vB,iBAAiBlpB,GACxC0pB,EAAO1pB,EAAQ2nB,wBAErB,MAAO,CACLgC,QAASD,EAAK5qB,MAAQ,GAAK4qB,EAAK1qB,OAAS,GAAkC,WAA7BiqB,EAAcrB,WAC5DgC,QAASC,WAAWZ,EAAcW,SAClCE,QAASb,EAAca,QACvBC,OAAQC,SAASf,EAAcc,SAAW,EAE9C,CAKQ,uBAAAhC,CAAwB/nB,GAC9B,MAAMiqB,EAAoD,CACxDC,QAASjsB,SAASksB,gBAAkBnqB,EACpCoqB,QAASpqB,EAAQW,QAAQ,UACzB0pB,QAASrqB,EAAQW,QAAQ,WACzB2pB,SAAUtqB,aAAmBspB,aAActpB,EAAQse,aAAa,aAYlE,OARIte,aAAmBuqB,iBACA,aAAjBvqB,EAAQ1B,MAAwC,UAAjB0B,EAAQ1B,OACzC2rB,EAAMO,QAAUxqB,EAAQwqB,SAEjBxqB,aAAmByqB,oBAC5BR,EAAMS,UAAqC,IAA1B1qB,EAAQ2qB,eAGpBV,CACT,CAKQ,iBAAA/B,CAAkBloB,GACxB,OAAIA,aAAmBuqB,iBAEA,aAAjBvqB,EAAQ1B,MAAuB0B,EAAQse,aAAa,kBAC/C,WAEFte,EAAQF,MACNE,aAAmB4qB,qBAEnB5qB,aAAmByqB,kBADrBzqB,EAAQF,WACV,CAKT,CAKQ,sBAAAsoB,CAAuBpoB,GAC7B,GAAIA,aAAmByqB,mBAAqBzqB,EAAQ6qB,SAAU,CAC5D,MAAMH,EAAW,GACjB,IAAK,IAAItyB,EAAI,EAAO4H,EAAQhE,QAAQ1G,OAApB8C,EAA4BA,IACtC4H,EAAQhE,QAAQ5D,GAAGsyB,UACrBA,EAASvuB,KAAK6D,EAAQhE,QAAQ5D,GAAG0H,OAGrC,OAAO4qB,CACT,CAGF,CAKQ,4BAAAvF,GACN,MAAML,EAAoC,GAE1C,IAAK,IAAI1sB,EAAI,EAAGA,EAAI6F,SAAS6sB,YAAYx1B,OAAQ8C,IAC/C,IACE,MAAM2yB,EAAQ9sB,SAAS6sB,YAAY1yB,GAC7B4yB,EAAWt1B,KAAKu1B,kBAAkBF,GACpCC,GACFlG,EAAY3oB,KAAK6uB,EAErB,CAAE,MAAOj2B,GAGT,CAGF,OAAO+vB,CACT,CAKQ,iBAAAmG,CAAkBF,GACxB,IACE,MAAMG,EAA4B,GAElC,GAAIH,EAAMI,SACR,IAAK,IAAI/yB,EAAI,EAAO2yB,EAAMI,SAAS71B,OAAnB8C,EAA2BA,IAAK,CAC9C,MACMgzB,EAAY11B,KAAK21B,eADVN,EAAMI,SAAS/yB,IAExBgzB,GACFF,EAAM/uB,KAAKivB,EAEf,CAGF,MAAO,CACLhwB,KAAM2vB,EAAM3vB,WAAQlF,EACpBo1B,QAAS51B,KAAK61B,eAAeR,GAC7BT,SAAUS,EAAMT,SAChBkB,MAAOT,EAAMS,MAAMC,UACnB5qB,MAAOkqB,EAAMlqB,YAAS3K,EACtBoI,KAAMysB,EAAMzsB,KACZotB,OAAQ,SACRR,QACAplB,KAAMpQ,KAAKi2B,uBAAuBZ,GAEtC,CAAE,MAAOh2B,GAEP,OAAO,IACT,CACF,CAKQ,cAAAs2B,CAAeO,GACrB,MAAMR,EAA8B,CAClC9sB,KAAMstB,EAAKttB,KACXgtB,QAASM,EAAKN,SAWhB,OARIM,aAAgBC,cAClBT,EAAUU,aAAeF,EAAKE,aAC9BV,EAAUW,aAAer2B,KAAKs2B,oBAAoBJ,EAAKrC,OACvD6B,EAAUa,YAAcv2B,KAAKw2B,qBAAqBN,EAAKE,eAC9CF,aAAgBO,eACzBf,EAAUI,MAAQI,EAAKJ,MAAMC,WAGxBL,CACT,CAKQ,mBAAAY,CAAoBzC,GAC1B,MAAMwC,EAAiC,GAEvC,IAAK,IAAI3zB,EAAI,EAAOmxB,EAAMj0B,OAAV8C,EAAkBA,IAAK,CACrC,MAAMgxB,EAAWG,EAAM7gB,KAAKtQ,GACtB0H,EAAQypB,EAAMF,iBAAiBD,GAC/BI,EAAWD,EAAME,oBAAoBL,GAE3C2C,EAAa5vB,KAAK,CAChBitB,WACAtpB,QACA0pB,WACA4C,UAAwB,cAAb5C,GAEf,CAEA,OAAOuC,CACT,CAKQ,oBAAAG,CAAqBG,GAQ3B,OAAa,KANAA,EAASC,MAAM,sBAAwB,IAAIh3B,OAMI,KAL3C+2B,EAASC,MAAM,uBAAyB,IAAIh3B,QACzC+2B,EAASC,MAAM,gBAAkB,IAAIh3B,QAClC+2B,EAASC,MAAM,sBAAwB,IAAIh3B,SAChD+2B,EAASC,MAAM,qBAAuB,IAAIh3B,MAG9D,CAKQ,0BAAA8vB,GACN,MAAML,EAAgC,GAChCwH,EAAgB,IAAIhf,IAyB1B,OAtBAtP,SAASuuB,iBAAiB,OAAOzuB,QAAQ0uB,IAClCF,EAAc5e,IAAI8e,EAAIC,OACzBH,EAAczjB,IAAI2jB,EAAIC,KACtB3H,EAAU5oB,KAAKzG,KAAKi3B,oBAAoBF,OAQxC,gBAAiBnzB,QAAU0H,YAAYqe,kBACjBre,YAAYqe,iBAAiB,YAErCthB,QAAQyR,IACjB+c,EAAc5e,IAAI6B,EAAMpP,QAC3BmsB,EAAczjB,IAAI0G,EAAMpP,MACxB2kB,EAAU5oB,KAAKzG,KAAKk3B,mCAAmCpd,OAKtDuV,CACT,CAKQ,mBAAA4H,CAAoBF,GAC1B,MAAO,CACLvxB,IAAKuxB,EAAIC,IACTpuB,KAAM,QACNuuB,WAAY,CACV/tB,MAAO2tB,EAAIK,aACX9tB,OAAQytB,EAAIM,eAEdjnB,UAAM5P,EACN82B,QAASP,EAAIQ,UAAiC,IAArBR,EAAIK,aAEjC,CAKQ,kCAAAF,CAAmCpd,GASzC,MARmC,CACjCtU,IAAKsU,EAAMpP,KACX9B,KAAM5I,KAAKw3B,kBAAkB1d,EAAMpP,MACnC0F,KAAM0J,EAAMsT,aACZ/hB,SAAUyO,EAAM2d,YAAc3d,EAAMoT,aACpCwK,UAAkC,IAAvB5d,EAAMsT,cAAsBtT,EAAMwT,gBAAkB,EAInE,CAKQ,uBAAAyC,CAAwB4H,GAC9BA,EAAUtvB,QAAQuvB,UAChB,MAAMC,EAA4B,CAChCjzB,UAAW7D,KAAKC,MAChB4H,KAAMgvB,EAAShvB,KACfc,OAAQ1J,KAAKqxB,UAAUuG,EAASluB,QAChCouB,SAAUF,EAASE,eAAYt3B,EAC/Bu3B,cAAezsB,YAAYtK,OAI7B,OAAQ42B,EAAShvB,MACf,IAAK,YACCgvB,EAASI,WAAWp4B,OAAS,IAC/Bi4B,EAAOG,WAAap1B,MAAMC,KAAK+0B,EAASI,YACrCx4B,IAAI2xB,GAAQnxB,KAAKkxB,sBAAsBC,IACvCxxB,OAAQwxB,GAAkD,OAATA,IAElDyG,EAASK,aAAar4B,OAAS,IACjCi4B,EAAOI,aAAer1B,MAAMC,KAAK+0B,EAASK,cACvCz4B,IAAI2xB,GAAQnxB,KAAKqxB,UAAUF,IAC3BxxB,OAAO4F,QAAa/E,IAAP+E,IAElB,MAEF,IAAK,aACHsyB,EAAOK,cAAgBN,EAASM,oBAAiB13B,EAC7Co3B,EAASluB,kBAAkByuB,UAC7BN,EAAOO,eAAiBR,EAASluB,OAAOuf,aAAa2O,EAASM,qBAAmB13B,EAGlD,UAA3Bo3B,EAASM,cACXL,EAAOQ,aAAer4B,KAAKs4B,oBAAoBV,EAASE,SAAUD,EAAOO,gBACrC,UAA3BR,EAASM,gBAClBL,EAAOU,aAAev4B,KAAKw4B,oBAAoBZ,EAASluB,UAOhEmuB,EAAOY,aAAez4B,KAAK04B,oBAAoBd,GAE/B,QAAhB/1B,EAAA7B,KAAK4vB,mBAAW,IAAA/tB,GAAAA,EAAAuE,KAAApG,KAAG63B,IAEvB,CAIQ,wBAAA/I,GAC6B,oBAAxB5C,sBACTlsB,KAAK6wB,oBAAsB,IAAI3E,oBAAqBC,IAClCA,EAAKC,aACb/jB,QAAQyR,IACU,iBAApBA,EAAMqT,WACRntB,KAAK4uB,mBAAmBnoB,KAAKqT,OAKnC9Z,KAAK6wB,oBAAoBvE,QAAQ,CAC/BC,WAAY,CAAC,eAAgB,QAAS,aAG5C,CAEQ,uBAAAwC,GAEW,IAAIe,iBAAkB6H,IACrCA,EAAUtvB,QAAQuvB,IAChBA,EAASI,WAAW3vB,QAAQ8oB,IACtBA,aAAgBwH,iBAAgC,eAAbxH,EAAKyH,KAGjBC,uBAQxBvM,QAAQ/jB,SAASuwB,KAAM,CAAE7I,WAAW,GAC/C,CAEQ,yBAAAX,SACN,KAAM,gBAAiB1rB,QAAS,OAEhC,MAAMm1B,EAAaztB,YAAYqe,iBAAiB,cAAc,GACxDqP,EAAQ1tB,YAAYqe,iBAAiB,SAE3C,MAAO,CACLsP,kBAAkBF,eAAAA,EAAYxL,2BAA4B,EAC1D2L,cAAcH,eAAAA,EAAYtL,eAAgB,EAC1C0L,aAAcH,EAAM7b,OAAO,CAACC,EAAKtD,KAC/BsD,EAAItD,EAAMpP,MAAQoP,EAAMhZ,UACjBsc,GACN,CAAA,GACHgc,aAAc,IAAIp5B,KAAK4uB,oBACvByK,aAAwC,QAA3Bx3B,EAACyJ,YAAoBguB,cAAM,IAAAz3B,OAAA,EAAAA,EAAE03B,iBAAkB,EAEhE,CAEQ,sBAAAhK,GAON,MAAO,CACL1pB,UAAWC,UAAUD,UACrBub,SAAUtb,UAAUsb,SACpBC,SAAUgD,KAAKC,iBAAiBC,kBAAkBC,SAClDgV,YAAa51B,OAAO61B,WAAW,gCAAgCxuB,QAAU,OAAkB,QAC3FyuB,cAAe91B,OAAO61B,WAAW,oCAAoCxuB,QAEzE,CAIQ,gBAAAmmB,CAAiBuI,GAEvB,OAAO,CACT,CAEQ,WAAArI,CAAYH,GAClB,OAAQA,EAAKK,UACX,KAAKC,KAAKC,aAAc,MAAO,UAC/B,KAAKD,KAAK2B,UAAW,MAAO,OAC5B,KAAK3B,KAAK6B,aAAc,MAAO,UAC/B,KAAK7B,KAAKmI,cAAe,MAAO,WAChC,KAAKnI,KAAKoI,mBAAoB,MAAO,UACrC,QAAS,MAAO,UAEpB,CAEQ,SAAAxI,CAAUF,GAChB,IAAKnxB,KAAKuuB,UAAUtW,IAAIkZ,GAAO,CAC7B,MAAM5rB,EAAKvF,KAAK0uB,aAChB1uB,KAAKuuB,UAAUtrB,IAAIkuB,EAAM5rB,GACzBvF,KAAKyuB,QAAQxrB,IAAIsC,EAAI4rB,EACvB,CACA,OAAOnxB,KAAKuuB,UAAUvrB,IAAImuB,EAC5B,CAEQ,gBAAAH,CAAiBD,GACvB,MAAO,CACLxrB,GAAIvF,KAAKqxB,UAAUN,GACnBnoB,KAAM,UACNe,QAAS,UACTsb,WAAY,CACVva,KAAMqmB,EAAQrmB,KACdovB,SAAU/I,EAAQ+I,SAClBC,SAAUhJ,EAAQgJ,UAGxB,CAEQ,2BAAApI,CAA4BrnB,GAClC,MAAM2a,EAAqC,CAAA,EAE3C,IAAK,IAAIviB,EAAI,EAAO4H,EAAQ2a,WAAWrlB,OAAvB8C,EAA+BA,IAAK,CAClD,MAAMsmB,EAAO1e,EAAQ2a,WAAWviB,GAC1BgI,EAAOse,EAAKte,KAAKC,cAEnB3K,KAAKg6B,sBAAsBtvB,EAAMse,EAAK5e,SAKxC6a,EAAWva,GADT1K,KAAKi6B,oBAAoBvvB,EAAMJ,GACd,WAEA0e,EAAK5e,MAE5B,CAEA,OAAO6a,CACT,CAEQ,yBAAAkO,CAA0B7oB,GAChC,MAAM4oB,EAAqC,GAE3C,IAAK,IAAIxwB,EAAI,EAAO4H,EAAQ4vB,WAAWt6B,OAAvB8C,EAA+BA,IAAK,CAClD,MACMuuB,EAAajxB,KAAKkxB,sBADV5mB,EAAQ4vB,WAAWx3B,IAG7BuuB,GACFiC,EAASzsB,KAAKwqB,EAElB,CAEA,OAAOiC,CACT,CAEQ,cAAAppB,CAAeupB,WACrB,MAAM8G,EAAS9G,EAAS+G,cACxB,IAAKD,EAAQ,OAAO,EAEpB,MAAMxwB,EAAwB,QAAd9H,EAAAs4B,EAAOxwB,eAAO,IAAA9H,OAAA,EAAAA,EAAE8I,cAC1B/B,EAAwC,QAAjC9G,EAACq4B,EAA4BvxB,YAAI,IAAA9G,OAAA,EAAAA,EAAE6I,cAEhD,MAAoB,UAAZhB,GAAgC,aAATf,GACxBuxB,EAAOvR,aAAa,mBACmB,OAAvCuR,EAAOE,QAAQ,mBACxB,CAEQ,aAAA/H,CAAchoB,GACpB,MAAMX,EAAUW,EAAQX,QAAQgB,cAChC,MAAO,CAAC,QAAS,WAAY,UAAUF,SAASd,EAClD,CAEQ,qBAAAqwB,CAAsBtvB,EAAcN,GAE1C,OAAOM,EAAKgG,WAAW,OAAkB,UAAThG,GAAoBN,EAAMxK,OAAS,GACrE,CAEQ,mBAAAq6B,CAAoBvvB,EAAcJ,GACxC,MAAiB,UAATI,GAA2D,aAAtCJ,EAA6B1B,MACnD0B,EAAQse,aAAa,iBAC9B,CAEQ,mBAAA6H,CAAoBrtB,GAE1BA,EAAQiF,QAAQyR,UACd,MAAM+d,EAA4B,CAChCjzB,UAAW7D,KAAKC,MAChB4H,KAAM,aACNc,OAAQ1J,KAAKqxB,UAAUvX,EAAMpQ,QAC7BwuB,cAAe,SACfH,cAAezsB,YAAYtK,MAC3By3B,aAAc,CACZ6B,aAAcxgB,EAAMygB,YACpBC,aAAc,aAIF,QAAhB34B,EAAA7B,KAAK4vB,mBAAW,IAAA/tB,GAAAA,EAAAuE,KAAApG,KAAG63B,IAEvB,CAEQ,mBAAAS,CAAoBR,EAAyB2C,GACnD,MAAMC,EAAa5C,EAAWA,EAASv4B,MAAM,OAAOI,OAAOg7B,SAAW,GAChEC,EAAaH,EAAWA,EAASl7B,MAAM,OAAOI,OAAOg7B,SAAW,GAKtE,MAAO,CAAEE,MAHKD,EAAWj7B,OAAOitB,IAAQ8N,EAAWjwB,SAASmiB,IAG5CkO,QAFAJ,EAAW/6B,OAAOitB,IAAQgO,EAAWnwB,SAASmiB,IAGhE,CAEQ,mBAAA4L,CAAoBuC,GAG1B,MAAO,EACT,CAEQ,mBAAArC,CAAoBd,GAE1B,GAAIA,EAASluB,kBAAkByuB,QAAS,CACtC,MAAMnE,EAAO4D,EAASluB,OAAOuoB,wBAC7B,MAAO,CACLqI,aAActG,EACdwG,aAAcxG,EAAK5qB,MAAQ4qB,EAAK1qB,OAAS,IAAQ,QACpC0qB,EAAK5qB,MAAQ4qB,EAAK1qB,OAAS,IAAO,WAAa,QAEhE,CAEF,CAEQ,cAAAusB,CAAeR,GACrB,IACE,GAAIA,EAAMI,SACR,OAAO7yB,MAAMC,KAAKwyB,EAAMI,UAAUj2B,IAAI02B,GAAQA,EAAKN,SAAS/1B,KAAK,KAErE,CAAE,MAAOR,GAET,CACA,MAAO,EACT,CAEQ,sBAAA42B,CAAuBZ,GAC7B,OAAOr1B,KAAK61B,eAAeR,GAAOz1B,MACpC,CAEQ,iBAAA43B,CAAkBhyB,SAGxB,OAFsC,QAApB3D,EAAA2D,EAAIjG,MAAM,KAAKy7B,aAAK,IAAAn5B,OAAA,EAAAA,EAAE8I,eAGtC,IAAK,MACL,IAAK,OACL,IAAK,MACL,IAAK,MACL,IAAK,MACL,IAAK,OACH,MAAO,QACT,IAAK,OACL,IAAK,QACL,IAAK,MACL,IAAK,MACH,MAAO,OACT,IAAK,MACL,IAAK,OACL,IAAK,MACH,MAAO,QACT,IAAK,KACH,MAAO,SACT,IAAK,MACH,MAAO,aACT,QACE,MAAO,QAEb,QC9+BWswB,EAOX,WAAAl7B,CAAY6F,EAAmBrC,EAAyC,IANhEvD,KAAAk7B,gBAA4C,CAAA,EAC5Cl7B,KAAAoD,QAA6B,GAE7BpD,KAAAm7B,aAAc,EAIpBn7B,KAAK4F,UAAYA,EACjB5F,KAAKuD,OAAS,CACZ63B,WAAY,IACZC,mBAAmB,EACnBC,kBAAkB,EAClBC,eAAgB,EAChBC,gBAAiB,IACjBC,cAAe,MACZl4B,EAEP,CAEA,KAAAma,GACM1d,KAAKm7B,cAE4B,CAAC,MAAO,OAAQ,OAAQ,QAAS,QAAS,SAExE9yB,QAAQvD,IACb,GAAI9E,KAAKuD,OAAOk4B,cAAchxB,SAAS3F,GAAQ,OAE/C,MAAM42B,EAAiBj3B,QAAQK,GAC/B9E,KAAKk7B,gBAAgBp2B,GAAS42B,EAE7Bj3B,QAAgBK,GAAS,IAAIJ,KAE3Bg3B,EAAuB32B,MAAMN,QAASC,GAGvC1E,KAAK27B,YAAY72B,EAAmCJ,MAIxD1E,KAAKm7B,aAAc,EACrB,CAEA,IAAAS,GACO57B,KAAKm7B,cAGV3rB,OAAOpM,QAAQpD,KAAKk7B,iBAAiB7yB,QAAQ,EAAEvD,EAAOmI,MACnDxI,QAAgBK,GAASmI,IAG5BjN,KAAKk7B,gBAAkB,CAAA,EACvBl7B,KAAKm7B,aAAc,EACrB,CAEQ,WAAAQ,CAAY72B,EAAiCJ,WACnD,IACE,MAAMoV,EAAyB,CAC7BvU,GAAIvF,KAAKnB,aACT+F,UAAW7D,KAAKC,MAChB8D,QACAJ,KAAM1E,KAAK67B,cAAcn3B,IAI3B,IAAe,UAAVI,GAA+B,SAAVA,IAAqB9E,KAAKuD,OAAO83B,kBAAmB,CAC5E,MAAMh8B,EAAYgF,QACdhF,EAAMC,QACRwa,EAAMxa,MAAQU,KAAK87B,gBAAgBz8B,EAAMC,OAE7C,CAGA,GAAc,UAAVwF,GAAqBJ,EAAK,aAAcL,MAAO,CACjD,MAGM03B,IADwB,QAAXl6B,EAFL6C,EAAK,GAEMpF,aAAK,IAAAuC,OAAA,EAAAA,EAAEtC,MAAM,QAAS,IACjBy8B,KAAKv8B,GACjCA,EAAKgL,SAAS,SAAWhL,EAAKgL,SAAS,SAAWhL,EAAKgL,SAAS,UAGlE,GAAIsxB,EAAY,CACd,MAAMnF,EAAQmF,EAAWnF,MAAM,uBAC3BA,IACF9c,EAAMtU,IAAMoxB,EAAM,GAClB9c,EAAMmiB,WAAa3H,SAASsC,EAAM,IAClC9c,EAAMoiB,aAAe5H,SAASsC,EAAM,IAExC,CACF,CAEA52B,KAAKm8B,SAASriB,EAChB,CAAE,MAAOza,GAEkB,QAAzByC,EAAA9B,KAAKk7B,gBAAgBj2B,YAAI,IAAAnD,GAAAA,EAAEsE,KAAK3B,QAAS,yBAA0BpF,EACrE,CACF,CAEQ,aAAAw8B,CAAcn3B,GACpB,OAAOA,EAAKlF,IAAI48B,GAAOp8B,KAAKq8B,eAAeD,EAAK,GAClD,CAEQ,cAAAC,CAAejyB,EAAYkyB,GACjC,GAAIA,EAAQt8B,KAAKuD,OAAOg4B,eACtB,MAAO,oBAGT,GAAInxB,QACF,OAAOA,EAGT,GAAqB,iBAAVA,EACT,OAAOA,EAAMxK,OAASI,KAAKuD,OAAOi4B,gBAC9BpxB,EAAM0e,UAAU,EAAG9oB,KAAKuD,OAAOi4B,iBAAmB,MAClDpxB,EAGN,GAAqB,iBAAVA,GAAuC,kBAAVA,EACtC,OAAOA,EAGT,GAAqB,mBAAVA,EACT,MAAO,cAAcA,EAAMM,MAAQ,eAGrC,GAAIN,aAAiB/F,MACnB,MAAO,CACLqG,KAAMN,EAAMM,KACZ1G,QAASoG,EAAMpG,QACf1E,MAAOU,KAAKuD,OAAO83B,kBAAoBr7B,KAAK87B,gBAAgB1xB,EAAM9K,OAAS,SAAMkB,GAIrF,GAAI4J,aAAiBrJ,KACnB,MAAO,CACLw7B,EAAQ,OACRnyB,MAAOA,EAAMsR,eAIjB,GAAItR,aAAiB2G,OACnB,MAAO,CACLwrB,EAAQ,SACRnyB,MAAOA,MAIX,GAAIxH,MAAMoN,QAAQ5F,GAChB,OAAKpK,KAAKuD,OAAO+3B,iBAEVlxB,EAAML,MAAM,EAAG,KAAKvK,IAAIwT,GAAQhT,KAAKq8B,eAAerpB,EAAMspB,EAAQ,IAF/B,UAK5C,GAAqB,iBAAVlyB,EAAoB,CAC7B,IAAKpK,KAAKuD,OAAO+3B,iBAAkB,MAAO,WAE1C,IACE,MAAMrK,EAAkC,CAAA,EAClClZ,EAAOvI,OAAOuI,KAAK3N,GAAOL,MAAM,EAAG,IAEzC,IAAK,MAAMsF,KAAO0I,EAChB,IACEkZ,EAAW5hB,GAAOrP,KAAKq8B,eAAejyB,EAAMiF,GAAMitB,EAAQ,EAC5D,CAAE,MAAAz6B,GACAovB,EAAW5hB,GAAO,kBACpB,CAOF,OAJIG,OAAOuI,KAAK3N,GAAOxK,OAAS,KAC9BqxB,EAAW,OAAS,IAAIzhB,OAAOuI,KAAK3N,GAAOxK,OAAS,iBAG/CqxB,CACT,CAAE,MAAAnvB,GACA,MAAO,yBACT,CACF,CAEA,OAAcsI,EAAPwE,EACT,CAEQ,eAAAktB,CAAgBx8B,GACtB,OAAOA,EACJC,MAAM,MACNI,OAAOF,IACLA,EAAKgL,SAAS,yBACdhL,EAAKgL,SAAS,oBAEhBV,MAAM,EAAG,IACTlK,KAAK,KACV,CAEQ,QAAAs8B,CAASriB,GACf9Z,KAAKoD,QAAQqD,KAAKqT,GAGd9Z,KAAKoD,QAAQxD,OAASI,KAAKuD,OAAO63B,aACpCp7B,KAAKoD,QAAUpD,KAAKoD,QAAQ2G,MAAgC,IAAzB/J,KAAKuD,OAAO63B,YAEnD,CAEQ,UAAAv8B,GACN,MAAO,WAAWkC,KAAKC,SAAS/B,KAAKC,SAASC,SAAS,IAAI4V,OAAO,EAAG,IACvE,CAEA,UAAAqX,CAAWoQ,EAAwBC,GACjC,IAAIzf,EAAWhd,KAAKoD,QAUpB,OARIo5B,IACFxf,EAAWA,EAASrd,OAAOma,GAASA,EAAMlV,WAAa43B,IAGrDC,IACFzf,EAAWA,EAASrd,OAAOma,GAA4B2iB,GAAnB3iB,EAAMlV,YAGrC,IAAIoY,EACb,CAEA,iBAAA0f,CAAkB53B,GAChB,OAAO9E,KAAKoD,QAAQzD,OAAOma,GAASA,EAAMhV,QAAUA,EACtD,CAEA,KAAA8O,GACE5T,KAAKoD,QAAU,EACjB,CAGA,eAAAu5B,GACE,OAAO38B,KAAKoD,QAAQ5D,IAAIsa,IAAK,CAC3BlU,UAAW5F,KAAK4F,UAChBgD,KAAM,UACNzH,KAAM,CACJ2D,MAAOgV,EAAMhV,MACbJ,KAAMoV,EAAMpV,KACZpF,MAAOwa,EAAMxa,MACbkG,IAAKsU,EAAMtU,IACXy2B,WAAYniB,EAAMmiB,WAClBC,aAAcpiB,EAAMoiB,aACpBU,UAAW9iB,EAAMvU,GACjBs3B,YAAa/iB,EAAMtU,KAAO5B,OAAO6B,SAASC,KAC1CG,UAAWC,UAAUD,WAEvBjB,UAAWkV,EAAMlV,YAErB,CAGA,UAAAk4B,GAYE,MAAMC,EAAsC,CAAA,EAC5C,IAAIC,EAAUC,IACVC,GAAU,IAQd,OANAl9B,KAAKoD,QAAQiF,QAAQyR,IACnBijB,EAAYjjB,EAAMhV,QAAUi4B,EAAYjjB,EAAMhV,QAAU,GAAK,EAC7Dk4B,EAAU/9B,KAAK+X,IAAIgmB,EAASljB,EAAMlV,WAClCs4B,EAAUj+B,KAAKkrB,IAAI+S,EAASpjB,EAAMlV,aAG7B,CACLgB,UAAW5F,KAAK4F,UAChBrC,OAAQvD,KAAKuD,OACbH,QAAS,IAAIpD,KAAKoD,SAClB+5B,MAAO,CACLC,aAAcp9B,KAAKoD,QAAQxD,OAC3Bm9B,cACA3gB,WAAY2gB,EAAY19B,OAAS,EACjCg+B,aAAcN,EAAY93B,MAAQ,EAClCwY,UAAW,CACTC,MAAOsf,IAAYC,IAAW,EAAID,EAClCrf,IAAKuf,KAAY,IAAY,EAAIA,IAIzC,CAGA,gBAAAI,GASE,MAAO,CACLC,cALoBv9B,KAAKw9B,oBAMzBC,kBALwBz9B,KAAK09B,0BAM7BC,gBALsB39B,KAAK49B,0BAO/B,CAEQ,iBAAAJ,GACN,MAAMjqB,EAASvT,KAAKoD,QAAQzD,OAAOma,GAAyB,UAAhBA,EAAMhV,OAC5C+4B,EAA8C,CAAA,EA0BpD,OAxBAtqB,EAAOlL,QAAQhJ,IACb,IAAIgR,EAAU,gBAEd,GAAIhR,EAAMqF,KAAK9E,OAAS,EAAG,CACzB,MAAMk+B,EAAWz+B,EAAMqF,KAAK,GACJ,iBAAbo5B,EAETztB,EAAUytB,EACPh/B,QAAQ,OAAQ,KAChBA,QAAQ,kBAAmB,UAC3BA,QAAQ,kBAAmB,SAC3BA,QAAQ,qBAAsB,OAC9BgqB,UAAU,EAAG,KACa,iBAAbgV,GAAyBA,EAASpzB,OAClD2F,EAAU,GAAGytB,EAASpzB,SAASozB,EAAS95B,UAAU8kB,UAAU,EAAG,KAEnE,CAEK+U,EAASxtB,KACZwtB,EAASxtB,GAAW,IAEtBwtB,EAASxtB,GAAS5J,KAAKpH,KAGlBmQ,OAAOpM,QAAQy6B,GACnB7lB,KAAK,EAAC,CAAG+lB,IAAI,CAAGC,KAAOA,EAAEp+B,OAASm+B,EAAEn+B,QACpCmK,MAAM,EAAG,IACTvK,IAAI,EAAE6Q,EAAS4tB,MAAS,CACvB5tB,UACAwD,MAAOoqB,EAASr+B,OAChBq+B,SAAUA,EAASl0B,MAAM,EAAG,KAElC,CAEQ,uBAAA2zB,GACN,MAAMQ,EAAwF,GAGxFC,EAAgBn+B,KAAKoD,QAAQzD,OAAOma,GACxCA,EAAMlV,UAAY7D,KAAKC,MAAQ,KAG7Bm9B,EAAcv+B,OAAS,KACzBs+B,EAAOz3B,KAAK,CACVmC,KAAM,oBACNw1B,SAAU,SACVC,QAAYF,EAAcv+B,OAAjB,+DAKb,MAAM0+B,EAAsC,CAAA,EAmC5C,OAlCAt+B,KAAKoD,QACFzD,OAAOma,GAAyB,UAAhBA,EAAMhV,OACtBuD,QAAQyR,IACP,MAAMzK,EAAM/K,KAAKC,UAAUuV,EAAMpV,MACjC45B,EAAYjvB,IAAQivB,EAAYjvB,IAAQ,GAAK,IAGjDG,OAAOpM,QAAQk7B,GAAaj2B,QAAQ,EAAC,CAAGwL,MAClCA,EAAQ,IACVqqB,EAAOz3B,KAAK,CACVmC,KAAM,iBACNw1B,SAAUvqB,EAAQ,GAAK,OAAS,SAChCwqB,QAAS,uBAAuBxqB,cAMnB7T,KAAKoD,QAAQzD,OAAOma,GACrCA,EAAMpV,KAAKkG,KAAKwxB,GACC,iBAARA,GACC,OAARA,IACCx5B,MAAMoN,QAAQosB,KAIJx8B,OAA+B,GAAtBI,KAAKoD,QAAQxD,QACnCs+B,EAAOz3B,KAAK,CACVmC,KAAM,iBACNw1B,SAAU,MACVC,QAAS,gEAINH,CACT,CAEQ,uBAAAN,GACN,MAAMD,EAA4B,GAC5BR,EAAQn9B,KAAK88B,aAAaK,MA8BhC,OA5BIA,EAAM/gB,WAAa,GACrBuhB,EAAgBl3B,KACd,SAAS02B,EAAM/gB,+EAIf+gB,EAAME,aAAkC,EAAnBF,EAAM/gB,YAC7BuhB,EAAgBl3B,KACd,uFAIA02B,EAAMC,aAAe,KACvBO,EAAgBl3B,KACd,2EAIA02B,EAAMJ,YAAYwB,OAASpB,EAAMJ,YAAYwB,MAAQ,KACvDZ,EAAgBl3B,KACd,6DAI2B,IAA3Bk3B,EAAgB/9B,QAClB+9B,EAAgBl3B,KAAK,0CAGhBk3B,CACT,QCjbWa,EAMX,WAAAz+B,CAAY0+B,EAAwBl7B,EAAiC,IAF7DvD,KAAAmB,KAAsB,GAG5BnB,KAAKuD,OAAS,CACZm7B,OAAQ,GACRC,aAAc,IACdC,SAAU,CACR,GAAK,OACL,GAAK,OACL,GAAK,OACL,GAAK,SACL,EAAK,OAEPC,KAAM,GACNC,WAAY,EACZC,WAAY,MACTx7B,GAGLvD,KAAK4nB,OAASrf,SAASmU,cAAc,UACrC1c,KAAK4nB,OAAOiM,MAAMmL,SAAW,WAC7Bh/B,KAAK4nB,OAAOiM,MAAMoL,IAAM,IACxBj/B,KAAK4nB,OAAOiM,MAAMqL,KAAO,IACzBl/B,KAAK4nB,OAAOiM,MAAMsL,cAAgB,OAClCn/B,KAAK4nB,OAAOiM,MAAMQ,OAAS,OAE3BoK,EAAUW,YAAYp/B,KAAK4nB,QAE3B,MAAMC,EAAM7nB,KAAK4nB,OAAOE,WAAW,MACnC,IAAKD,EACH,MAAUxjB,MAAM,gCAElBrE,KAAK6nB,IAAMA,EAEX7nB,KAAKq/B,eACLz7B,OAAOC,iBAAiB,SAAU,IAAM7D,KAAKq/B,eAC/C,CAEQ,YAAAA,GACN,MAAMrL,EAAOh0B,KAAK4nB,OAAOwS,cAAenI,wBACxCjyB,KAAK4nB,OAAOxe,MAAQ4qB,EAAK5qB,MACzBpJ,KAAK4nB,OAAOte,OAAS0qB,EAAK1qB,OAC1BtJ,KAAK4nB,OAAOiM,MAAMzqB,MAAQ4qB,EAAK5qB,MAAQ,KACvCpJ,KAAK4nB,OAAOiM,MAAMvqB,OAAS0qB,EAAK1qB,OAAS,IAC3C,CAEA,YAAAg2B,CAAat2B,EAAWE,EAAWq2B,EAAmBj3B,GACpDtI,KAAKmB,KAAKsF,KAAK,CACbuC,IACAE,IACAq2B,YACAlkB,WAAY/S,EACZ1D,UAAW7D,KAAKC,QAIdhB,KAAKmB,KAAKvB,OAAS,MACrBI,KAAKmB,KAAOnB,KAAKmB,KAAK4I,OAAM,KAEhC,CAEA,kBAAAy1B,CAAmBn4B,GACjBrH,KAAKmB,KAAO,GAEZkG,EAAOgB,QAAQvE,oBACM,UAAfA,EAAM8E,OAA8B,QAAV/G,EAAAiC,EAAM3C,YAAI,IAAAU,OAAA,EAAAA,EAAEmH,KAAe,UAAVlF,EAAM3C,YAAI,IAAAW,OAAA,EAAAA,EAAEoH,GACzDlJ,KAAKs/B,aACHx7B,EAAM3C,KAAK6H,EACXlF,EAAM3C,KAAK+H,EACX,GACA,SAEsB,cAAfpF,EAAM8E,OAAkC,QAAV7G,EAAA+B,EAAM3C,YAAI,IAAAY,OAAA,EAAAA,EAAEiH,KAAe,UAAVlF,EAAM3C,YAAI,IAAAa,OAAA,EAAAA,EAAEkH,GACpElJ,KAAKs/B,aACHx7B,EAAM3C,KAAK6H,EACXlF,EAAM3C,KAAK+H,EACX,EACA,QAEsB,WAAfpF,EAAM8E,WAA6CpI,KAAd,QAAVi/B,EAAA37B,EAAM3C,YAAI,IAAAs+B,OAAA,EAAAA,EAAEx2B,eAAiDzI,KAAd,QAAVk/B,EAAA57B,EAAM3C,YAAI,IAAAu+B,OAAA,EAAAA,EAAEv2B,UAErFnJ,KAAKs/B,aACHx7B,EAAM3C,KAAK8H,SAAW,EACtBnF,EAAM3C,KAAKgI,SAAW,EACtB,EACA,WAIR,CAEA,MAAAw2B,CAAOhgC,GAGL,GAFAK,KAAK6nB,IAAI+X,UAAU,EAAG,EAAG5/B,KAAK4nB,OAAOxe,MAAOpJ,KAAK4nB,OAAOte,QAE/B,IAArBtJ,KAAKmB,KAAKvB,OAAc,OAE5B,MAAMigC,EAAelgC,EACjBK,KAAKmB,KAAKxB,OAAOmgC,GAAKngC,EAAO8K,SAASq1B,EAAEzkB,aACxCrb,KAAKmB,KAGH4+B,EAAgB//B,KAAKggC,mBAAmBH,GAGxCjB,EAAW5+B,KAAKigC,iBAGtBjgC,KAAKkgC,cAAcH,EAAenB,EACpC,CAEQ,kBAAAoB,CAAmB7+B,GACzB,MAAMg/B,EAAe53B,SAASmU,cAAc,UAC5CyjB,EAAa/2B,MAAQpJ,KAAK4nB,OAAOxe,MACjC+2B,EAAa72B,OAAStJ,KAAK4nB,OAAOte,OAClC,MAAM82B,EAAYD,EAAarY,WAAW,MA2B1C,OAxBA3mB,EAAKkH,QAAQg4B,IACX,MAAM3B,EAAS1+B,KAAKuD,OAAOm7B,OACrBE,EAAWwB,EAAUE,qBACzBD,EAAMr3B,EAAGq3B,EAAMn3B,EAAG,EAClBm3B,EAAMr3B,EAAGq3B,EAAMn3B,EAAGw1B,GAIpBE,EAAS2B,aAAa,EAAG,iBADXthC,KAAK+X,IAAIqpB,EAAMd,UAAYv/B,KAAKuD,OAAOo7B,aAAc,OAEnEC,EAAS2B,aAAa,EAAG,oBAEzBH,EAAUI,UAAY5B,EACtBwB,EAAUK,SACRJ,EAAMr3B,EAAI01B,EACV2B,EAAMn3B,EAAIw1B,EACD,EAATA,EACS,EAATA,KAKJ0B,EAAUzgC,OAAS,QAAQK,KAAKuD,OAAOs7B,UACvCuB,EAAUM,UAAUP,EAAc,EAAG,GAE9BC,EAAUO,aAAa,EAAG,EAAGR,EAAa/2B,MAAO+2B,EAAa72B,OACvE,CAEQ,cAAA22B,GACN,MAAMW,EAAiBr4B,SAASmU,cAAc,UAC9CkkB,EAAex3B,MAAQ,IACvBw3B,EAAet3B,OAAS,EACxB,MAAMu3B,EAAcD,EAAe9Y,WAAW,MAExC8W,EAAWiC,EAAYC,qBAAqB,EAAG,EAAG,IAAK,GAQ7D,OAPAtxB,OAAOpM,QAAQpD,KAAKuD,OAAOq7B,UAAUv2B,QAAQ,EAAEuzB,EAAMmF,MACnDnC,EAAS2B,aAAapM,WAAWyH,GAAOmF,KAG1CF,EAAYL,UAAY5B,EACxBiC,EAAYJ,SAAS,EAAG,EAAG,IAAK,GAEzBI,EAAYF,aAAa,EAAG,EAAG,IAAK,EAC7C,CAEQ,aAAAT,CAAcH,EAA0BiB,GAC9C,MAAMC,EAASjhC,KAAK6nB,IAAIqZ,gBAAgBnB,EAAc32B,MAAO22B,EAAcz2B,QAE3E,IAAK,IAAI5G,EAAI,EAAOq9B,EAAc5+B,KAAKvB,OAAvB8C,EAA+BA,GAAK,EAAG,CACrD,MAAMy+B,EAAQpB,EAAc5+B,KAAKuB,EAAI,GAErC,GAAIy+B,EAAQ,EAAG,CACb,MAAMC,EAAkD,EAAlCniC,KAAK0D,MAAOw+B,EAAQ,IAAO,KAEjDF,EAAO9/B,KAAKuB,GAAKs+B,EAAa7/B,KAAKigC,GACnCH,EAAO9/B,KAAKuB,EAAI,GAAKs+B,EAAa7/B,KAAKigC,EAAgB,GACvDH,EAAO9/B,KAAKuB,EAAI,GAAKs+B,EAAa7/B,KAAKigC,EAAgB,GACvDH,EAAO9/B,KAAKuB,EAAI,GAAKzD,KAAK0D,MAAMw+B,EAAQnhC,KAAKuD,OAAOw7B,WACtD,CACF,CAEA/+B,KAAK6nB,IAAIwZ,aAAaJ,EAAQ,EAAG,EACnC,CAEA,KAAArtB,GACE5T,KAAKmB,KAAO,GACZnB,KAAK6nB,IAAI+X,UAAU,EAAG,EAAG5/B,KAAK4nB,OAAOxe,MAAOpJ,KAAK4nB,OAAOte,OAC1D,CAEA,OAAA2H,GACEjR,KAAK4T,QACD5T,KAAK4nB,OAAOwS,eACdp6B,KAAK4nB,OAAOwS,cAAckH,YAAYthC,KAAK4nB,QAE7ChkB,OAAO29B,oBAAoB,SAAU,IAAMvhC,KAAKq/B,eAClD,CAGA,UAAAvC,GAUE,MAAM0E,EAAqC,CAAA,EAC3C,IAAIC,EAAOxE,IAAUyE,GAAO,IAAWC,EAAO1E,IAAU2E,GAAO,IAC3D5E,EAAUC,IAAUC,GAAU,IAclC,OAZAl9B,KAAKmB,KAAKkH,QAAQg4B,IAChBmB,EAAWnB,EAAMhlB,aAAemmB,EAAWnB,EAAMhlB,aAAe,GAAK,EAErEomB,EAAOxiC,KAAK+X,IAAIyqB,EAAMpB,EAAMr3B,GAC5B04B,EAAOziC,KAAKkrB,IAAIuX,EAAMrB,EAAMr3B,GAC5B24B,EAAO1iC,KAAK+X,IAAI2qB,EAAMtB,EAAMn3B,GAC5B04B,EAAO3iC,KAAKkrB,IAAIyX,EAAMvB,EAAMn3B,GAE5B8zB,EAAU/9B,KAAK+X,IAAIgmB,EAASqD,EAAMz7B,WAClCs4B,EAAUj+B,KAAKkrB,IAAI+S,EAASmD,EAAMz7B,aAG7B,CACLrB,OAAQvD,KAAKuD,OACbpC,KAAM,IAAInB,KAAKmB,MACfg8B,MAAO,CACL0E,YAAa7hC,KAAKmB,KAAKvB,OACvB4hC,aACA/jB,UAAW,CAAEC,MAAOsf,EAASrf,IAAKuf,GAClC4E,OAAQ,CAAEL,OAAMC,OAAMC,OAAMC,SAGlC,CAGA,gBAAAtE,GAmBE,MAAO,CACLyE,SATe/hC,KAAKgiC,eAUpBC,cAPoBjiC,KAAKkiC,uBAQzBC,aALmBniC,KAAKoiC,sBAO5B,CAEQ,YAAAJ,GACN,MAAMK,EAA8E,GAC9EC,EAAqC,EAArBtiC,KAAKuD,OAAOm7B,OA+BlC,OA7BA1+B,KAAKmB,KAAKkH,QAAQg4B,IAChB,IAAIkC,GAAe,EAEnB,IAAK,MAAMC,KAAWH,EAKpB,GAAgBC,GAJCrjC,KAAKwjC,KACpBxjC,KAAKgY,IAAIopB,EAAMr3B,EAAIw5B,EAAQx5B,EAAG,GAAK/J,KAAKgY,IAAIopB,EAAMn3B,EAAIs5B,EAAQt5B,EAAG,IAGpC,CAE7Bs5B,EAAQx5B,GAAKw5B,EAAQx5B,EAAIw5B,EAAQ3uB,MAAQwsB,EAAMr3B,IAAMw5B,EAAQ3uB,MAAQ,GACrE2uB,EAAQt5B,GAAKs5B,EAAQt5B,EAAIs5B,EAAQ3uB,MAAQwsB,EAAMn3B,IAAMs5B,EAAQ3uB,MAAQ,GACrE2uB,EAAQjD,WAAac,EAAMd,UAC3BiD,EAAQ3uB,QACR0uB,GAAe,EACf,KACF,CAGGA,GACHF,EAAS57B,KAAK,CACZuC,EAAGq3B,EAAMr3B,EACTE,EAAGm3B,EAAMn3B,EACTq2B,UAAWc,EAAMd,UACjB1rB,MAAO,MAKNwuB,EACJ1iC,OAAO6iC,GAAWA,EAAQ3uB,OAAS,GACnCmE,KAAK,CAAC+lB,EAAGC,IAAMA,EAAEuB,UAAYxB,EAAEwB,WAC/Bx1B,MAAM,EAAG,IACTvK,IAAIgjC,IAAO,CACVx5B,EAAG/J,KAAKyjC,MAAMF,EAAQx5B,GACtBE,EAAGjK,KAAKyjC,MAAMF,EAAQt5B,GACtBq2B,UAAWtgC,KAAKyjC,MAAMF,EAAQjD,WAC9Bb,OAAQz/B,KAAK+X,IAAIsrB,EAA+B,EAAhBE,EAAQ3uB,SAE9C,CAEQ,oBAAAquB,GACN,MAAMS,EAAS3iC,KAAKmB,KAAKxB,OAAOmgC,GAAsB,UAAjBA,EAAEzkB,YACjCwiB,EAAmC,CAAA,EAGzC,IAAK,IAAIn7B,EAAI,EAAOigC,EAAO/iC,OAAS,EAApB8C,EAAuBA,IAAK,CAC1C,MAAMkgC,EAAUD,EAAOjgC,GACjBmgC,EAAOF,EAAOjgC,EAAI,GAGxB,GAAe,IADEmgC,EAAKj+B,UAAYg+B,EAAQh+B,UACrB,CACnB,MAAMyL,EAAU,IAAIpR,KAAKyjC,MAAME,EAAQ55B,MAAM/J,KAAKyjC,MAAME,EAAQ15B,WAAWjK,KAAKyjC,MAAMG,EAAK75B,MAAM/J,KAAKyjC,MAAMG,EAAK35B,MACjH20B,EAASxtB,IAAYwtB,EAASxtB,IAAY,GAAK,CACjD,CACF,CAEA,OAAOb,OAAOpM,QAAQy6B,GACnB7lB,KAAK,EAAC,CAAG+lB,IAAI,CAAGC,KAAOA,EAAID,GAC3Bh0B,MAAM,EAAG,GACTvK,IAAI,EAAE6Q,EAASyyB,MAAU,CAAQzyB,UAASyyB,cAC/C,CAEQ,mBAAAV,GAMN,MAAMO,EAAS3iC,KAAKmB,KAAKxB,OAAOmgC,GAAsB,UAAjBA,EAAEzkB,YACjC0nB,EAAU/iC,KAAKmB,KAAKxB,OAAOmgC,GAAsB,WAAjBA,EAAEzkB,YAGlC2nB,EAAoB,IAAIhjC,KAAKmB,MAAM6W,KAAK,CAAC+lB,EAAGC,IAAMA,EAAEuB,UAAYxB,EAAEwB,WAClE0D,EAAUD,EAAkBj5B,MAAM,EAAG9K,KAAK0D,MAAiC,GAA3BqgC,EAAkBpjC,SAElE6hC,EAAOxiC,KAAK+X,OAAOisB,EAAQzjC,IAAIsgC,GAAKA,EAAE92B,IACtC04B,EAAOziC,KAAKkrB,OAAO8Y,EAAQzjC,IAAIsgC,GAAKA,EAAE92B,IACtC24B,EAAO1iC,KAAK+X,OAAOisB,EAAQzjC,IAAIsgC,GAAKA,EAAE52B,IACtC04B,EAAO3iC,KAAKkrB,OAAO8Y,EAAQzjC,IAAIsgC,GAAKA,EAAE52B,IAEtCg6B,EAAcH,EAAQnjC,OAAS,EACjCX,KAAKkrB,OAAO4Y,EAAQvjC,IAAI2jC,GAAKA,EAAEj6B,IAAMlJ,KAAK4nB,OAAOte,OACjD,EAEE85B,EAAkBnkC,KAAK+X,IAAI,IACd,EAAhB2rB,EAAO/iC,OACO,GAAdsjC,EACwD,GAAxDljC,KAAKmB,KAAKxB,OAAOmgC,GAAsB,SAAjBA,EAAEzkB,YAAuBzb,QAGlD,MAAO,CACLyjC,eAAgB,CACdr6B,EAAG/J,KAAKyjC,MAAMjB,GACdv4B,EAAGjK,KAAKyjC,MAAMf,GACdv4B,MAAOnK,KAAKyjC,MAAMhB,EAAOD,GACzBn4B,OAAQrK,KAAKyjC,MAAMd,EAAOD,IAE5B2B,wBAAyBrkC,KAAKyjC,MAAMC,EAAO/iC,QAC3CsjC,YAAajkC,KAAKyjC,MAAoB,IAAdQ,GAAqB,IAC7CE,gBAAiBnkC,KAAKyjC,MAAMU,GAEhC,QCjWWG,EAeX,WAAAxjC,CAAYwD,EAAoBqC,yCAc9B,GAzBM5F,KAAAwjC,iBAA4C,KAC5CxjC,KAAAqH,OAAwB,GACxBrH,KAAAyjC,YAA4B,GAC5BzjC,KAAA0jC,gBAA+C,IAAIvjC,IACnDH,KAAAm7B,aAAc,EAGdn7B,KAAA2jC,gBAAuB,CAAA,EAK7B3jC,KAAKuD,OAASA,EACdvD,KAAK4F,UAAYA,EACjB5F,KAAKc,UAAYC,KAAKC,MACtBhB,KAAK4jC,cAAgB,IAAIvV,EAAsB9qB,GAC/CvD,KAAK6jC,gBAAkB,IAAI5I,EAAgBr1B,EAAW,CACpDw1B,YAAyB,QAAbv5B,EAAA0B,EAAOuH,cAAM,IAAAjJ,OAAA,EAAAA,EAAEiiC,oBAAqB,IAChDzI,mBAAwD,KAAxB,QAAbv5B,EAAAyB,EAAOuH,cAAM,IAAAhJ,OAAA,EAAAA,EAAEu5B,mBAClCC,kBAAsD,KAAvB,QAAbv5B,EAAAwB,EAAOuH,cAAM,IAAA/I,OAAA,EAAAA,EAAEu5B,kBACjCC,gBAA6B,QAAbv5B,EAAAuB,EAAOuH,cAAM,IAAA9I,OAAA,EAAAA,EAAEu5B,iBAAkB,EACjDC,iBAA8B,QAAbiE,EAAAl8B,EAAOuH,cAAM,IAAA20B,OAAA,EAAAA,EAAEjE,kBAAmB,IACnDC,eAA4B,QAAbiE,EAAAn8B,EAAOuH,cAAM,IAAA40B,OAAA,EAAAA,EAAEqE,uBAAwB,MAGlC,QAAlBC,EAAAhkC,KAAKuD,OAAOuH,cAAM,IAAAk5B,OAAA,EAAAA,EAAE5qB,WACtBpZ,KAAKikC,eAG2B,QAA5BC,EAAkB,QAAlBC,EAAAnkC,KAAKuD,OAAOuH,cAAM,IAAAq5B,OAAA,EAAAA,EAAEC,gBAAQ,IAAAF,OAAA,EAAAA,EAAE9qB,UAA+B,oBAAb7Q,UAA0B,CAC5E,MAAMk2B,EAAYl2B,SAASiF,MAAQjF,SAASmoB,gBACxC+N,IACFz+B,KAAKwjC,iBAAmB,IAAIhF,EAAiBC,EAAW,CACtDC,QAA+B,QAAvB2F,EAAa,QAAbC,EAAA/gC,EAAOuH,cAAM,IAAAw5B,OAAA,EAAAA,EAAEF,gBAAQ,IAAAC,OAAA,EAAAA,EAAE3F,SAAU,GAC3CC,cAAqC,QAAvB4F,EAAa,QAAbC,EAAAjhC,EAAOuH,cAAM,IAAA05B,OAAA,EAAAA,EAAEJ,gBAAQ,IAAAG,OAAA,EAAAA,EAAE5F,eAAgB,IACvDE,MAA6B,QAAvB4F,EAAa,QAAbC,EAAAnhC,EAAOuH,cAAM,IAAA45B,OAAA,EAAAA,EAAEN,gBAAQ,IAAAK,OAAA,EAAAA,EAAE5F,OAAQ,GACvCE,YAAmC,QAAvB4F,EAAa,QAAbC,EAAArhC,EAAOuH,cAAM,IAAA85B,OAAA,EAAAA,EAAER,gBAAQ,IAAAO,OAAA,EAAAA,EAAE5F,aAAc,KAGzD,CAEJ,CAKA,cAAA8F,UACM7kC,KAAKm7B,cAAkC,QAAlBt5B,EAAA7B,KAAKuD,OAAOuH,cAAM,IAAAjJ,OAAA,EAAAA,EAAEuX,WAE7CpZ,KAAKm7B,aAAc,EAGnBn7B,KAAK8kC,mBAGL9kC,KAAK4jC,cAAcjU,uBAAuB3vB,KAAK+kC,gBAAgB/U,KAAKhwB,OAGpEA,KAAK6jC,gBAAgBnmB,QAGrB1d,KAAKglC,sBAGLhlC,KAAKilC,2BAGLn4B,YAAY,KACN9M,KAAKm7B,aACPn7B,KAAK8kC,oBAEN,KAKL,CAKA,aAAAI,GACOllC,KAAKm7B,cAEVn7B,KAAKm7B,aAAc,EACnBn7B,KAAK4jC,cAAcjT,wBACnB3wB,KAAK6jC,gBAAgBjI,OACrB57B,KAAKmlC,yBAEDnlC,KAAKwjC,mBACPxjC,KAAKwjC,iBAAiBvyB,UACtBjR,KAAKwjC,iBAAmB,MAM5B,CAKA,aAAA4B,GAgBE,MAAMC,EAAiBrlC,KAAK6jC,gBAAgBzX,aACtCkZ,EAAkBtlC,KAAK6jC,gBAAgBvG,mBAE7C,IAAIiI,EACAC,EAQJ,OANIxlC,KAAKwjC,mBAEP+B,EADsBvlC,KAAKwjC,iBAAiB1G,aAChB37B,KAC5BqkC,EAAkBxlC,KAAKwjC,iBAAiBlG,oBAGnC,CACLj2B,OAAQ,IAAIrH,KAAKqH,QACjBo+B,aAAcJ,EACdK,iBAAkB9iC,MAAMC,KAAK7C,KAAK0jC,gBAAgBrrB,UAClDstB,aAAcJ,EACdK,aAAc,CACZtqB,WAAYtb,KAAK4F,UACjBigC,WAAY7lC,KAAKc,UACjB0I,SAAUzI,KAAKC,MAAQhB,KAAKc,UAC5BglC,SAAUliC,OAAO6B,SAASC,MAE5BqgC,UAAW,CACTC,iBAAkBV,EAClBW,iBAAkBT,GAGxB,CAKA,eAAAU,GACElmC,KAAKqH,OAAS,GACdrH,KAAKyjC,YAAc,GACnBzjC,KAAK0jC,gBAAgB9vB,QACrB5T,KAAK6jC,gBAAgBjwB,QAEjB5T,KAAKwjC,kBACPxjC,KAAKwjC,iBAAiB5vB,OAE1B,CAKQ,WAAAqwB,GACN,GAAsB,oBAAXrgC,OAAwB,OA2BnC,IAAIuE,EAxBJI,SAAS1E,iBAAiB,mBAAoB,KAC5C7D,KAAKmmC,eAAe,oBAAqB,CACvCt9B,OAAQN,SAASM,WAKrBjF,OAAOC,iBAAiB,QAAS,KAC/B7D,KAAKmmC,eAAe,eAAgB,MAGtCviC,OAAOC,iBAAiB,OAAQ,KAC9B7D,KAAKmmC,eAAe,cAAe,MAIrCviC,OAAOC,iBAAiB,SAAU,KAChC7D,KAAKmmC,eAAe,kBAAmB,CACrC/8B,MAAOxF,OAAOyF,WACdC,OAAQ1F,OAAO2F,gBAMnB3F,OAAOC,iBAAiB,SAAU,KAChCiF,aAAaX,GACbA,EAAgBY,WAAW,KAErB/I,KAAKwjC,kBACPxjC,KAAKwjC,iBAAiBlE,aACpB17B,OAAOqF,SAAW,EAClBrF,OAAOuF,SAAW,EAClB,EACA,UAIJnJ,KAAKmmC,eAAe,SAAU,CAC5Bn9B,EAAGpF,OAAOqF,QACVC,EAAGtF,OAAOuF,WAEX,MACF,CAAER,SAAS,GAChB,CAKQ,gBAAAm8B,GACN,GAAK9kC,KAAKm7B,YAEV,IACE,MAAMlM,EAAWjvB,KAAK4jC,cAAc5U,uBAEpChvB,KAAKomC,SAAS,CACZx9B,KAAM,gBACNhE,UAAW7D,KAAKC,MAChBG,KAAM8tB,GAEV,CAAE,MAAO5vB,GAIT,CACF,CAKQ,eAAA0lC,CAAgBlN,GACjB73B,KAAKm7B,aAEVn7B,KAAKomC,SAAS,CACZx9B,KAAM,uBACNhE,UAAWizB,EAAOjzB,UAClBzD,KAAM,CACJklC,OAAQ,cACLxO,IAGT,CAKA,aAAAqI,CAAcvgC,GACRK,KAAKwjC,kBACPxjC,KAAKwjC,iBAAiB7D,OAAOhgC,EAEjC,CAEA,aAAA2mC,CAAcrS,GACRj0B,KAAKwjC,mBACHvP,EACFj0B,KAAKwjC,iBAAiB7D,SAEtB3/B,KAAKwjC,iBAAiB5vB,QAG5B,CAEA,kBAAA2yB,SACE,eAAO1kC,EAAA7B,KAAKwjC,uCAAkBlG,qBAAsB,IACtD,CAKQ,mBAAA0H,GA+DN,QA7D4B,IAAjBphC,OAAOuI,QAChBnM,KAAKkM,cAAgBtI,OAAOuI,MAE5BvI,OAAOuI,MAAQa,MAAO2Y,EAA0B6gB,KAC9C,MAAM1lC,EAAYC,KAAKC,MACjBylC,EAAYzmC,KAAK0mC,oBACjBlhC,EAAMmgB,aAAiBghB,QAAUhhB,EAAMngB,IAAMmgB,KAC7C1Y,GAASu5B,aAAI,EAAJA,EAAMv5B,UAAW0Y,aAAiBghB,QAAUhhB,EAAM1Y,OAAS,OAEtEjN,KAAKm7B,aACPn7B,KAAK0jC,gBAAgBzgC,IAAIwjC,EAAW,CAClC7hC,UAAW9D,EACXyE,GAAIkhC,EACJx5B,SACAzH,MACAiJ,eAAgBzO,KAAK4mC,kBAAkBJ,EAAM7gB,GAC7CrY,kBAAmBtN,KAAKyN,qBAAqB+4B,EAAM7gB,KAIvD,IACE,MAAMhY,QAAiB3N,KAAKkM,cAAcyZ,EAAO6gB,GAC3Ch9B,EAAWzI,KAAKC,MAAQF,EAE9B,GAAId,KAAKm7B,YAAa,CACpB,MAAM0L,EAAiB7mC,KAAK0jC,gBAAgB1gC,IAAIyjC,GAChD,GAAII,IACFA,EAAev4B,OAASX,EAASW,OACjCu4B,EAAer9B,SAAWA,EAC1Bq9B,EAAel4B,gBAAkB3O,KAAK8mC,mBAAmBn5B,GAGrD3N,KAAK8N,0BAA0BH,IACjC,IACE,MAAMI,EAAiBJ,EAASK,QAChC64B,EAAej5B,mBAAqBG,EAAe8B,MACrD,CAAE,MAAOyI,GAET,CAGN,CAEA,OAAO3K,CACT,CAAE,MAAOtO,GACP,MAAMmK,EAAWzI,KAAKC,MAAQF,EAE9B,GAAId,KAAKm7B,YAAa,CACpB,MAAM0L,EAAiB7mC,KAAK0jC,gBAAgB1gC,IAAIyjC,GAC5CI,IACFA,EAAer9B,SAAWA,EAC1Bq9B,EAAevP,QAAS,EAE5B,CAEA,MAAMj4B,CACR,IAK0B,oBAAnBgN,eAAgC,CACzCrM,KAAK+mC,uBAAyB16B,eAE9B,MAAMwC,EAAO7O,KAEb4D,OAAOyI,eAAiB,WACtB,MAAM26B,EAAM,IAAIn4B,EAAKk4B,uBACfN,EAAY53B,EAAK63B,oBACvB,IAAIz5B,EAAS,MACTzH,EAAM,GACN1E,EAAY,EAEhB,MAAMmmC,EAAeD,EAAIz6B,KACnB26B,EAAeF,EAAIv6B,KAyCzB,OAvCAu6B,EAAIz6B,KAAO,SAAS46B,EAAWC,KAAoB1iC,GAGjD,OAFAuI,EAASk6B,EACT3hC,EAAM4hC,KACCH,EAAa7gC,KAAKpG,KAAMmnC,EAAGC,KAAM1iC,EAC1C,EAEAsiC,EAAIv6B,KAAO,SAASe,GAalB,OAZA1M,EAAYC,KAAKC,MAEb6N,EAAKssB,aACPtsB,EAAK60B,gBAAgBzgC,IAAIwjC,EAAW,CAClC7hC,UAAW9D,EACXyE,GAAIkhC,EACJx5B,SACAzH,MACA8H,YAAaE,IAIV05B,EAAa9gC,KAAKpG,KAAMwN,EACjC,EAEAw5B,EAAInjC,iBAAiB,UAAW,KAC9B,MAAM2F,EAAWzI,KAAKC,MAAQF,EAE9B,GAAI+N,EAAKssB,YAAa,CACpB,MAAM0L,EAAiBh4B,EAAK60B,gBAAgB1gC,IAAIyjC,GAC5CI,IACFA,EAAev4B,OAAS04B,EAAI14B,OAC5Bu4B,EAAer9B,SAAWA,EAC1Bq9B,EAAevP,OAAwB,IAAf0P,EAAI14B,QAAgB04B,EAAI14B,QAAU,IAEtDO,EAAKw4B,yBAAyBL,KAChCH,EAAej5B,aAAeo5B,EAAI93B,cAGxC,IAGK83B,CACT,CACF,CACF,CAKQ,wBAAA/B,GAEc,CAAC,YAAa,UAAW,QAAS,WAAY,aAEtD58B,QAAQC,IAClBC,SAAS1E,iBAAiByE,EAAYxE,IACpC,GAAK9D,KAAKm7B,cAGQ,cAAd7yB,GAA6C,IAAhBrJ,KAAKC,UAAtC,CAGA,GAAIc,KAAKwjC,iBAAkB,CACzB,IAAIjE,EAAY,EACE,UAAdj3B,EAAuBi3B,EAAY,GAChB,cAAdj3B,EAA2Bi3B,EAAY,EACzB,cAAdj3B,IAA2Bi3B,EAAY,GAEhDv/B,KAAKwjC,iBAAiBlE,aACpBx7B,EAAMmG,QACNnG,EAAMoG,QACNq1B,EACc,UAAdj3B,EAAwB,QAAU,OAEtC,CAEAtI,KAAKomC,SAAS,CACZx9B,KAAM,uBACNhE,UAAW7D,KAAKC,MAChBG,KAAM,CACJklC,OAAQ,QACRz9B,KAAMN,EACNU,EAAGlF,EAAMmG,QACTf,EAAGpF,EAAMoG,QACT3E,GAAIvF,KAAKsnC,aAAaxjC,EAAM4F,UAzBsB,GA4BrD,CAAEhB,SAAS,EAAMC,SAAS,MAI/BJ,SAAS1E,iBAAiB,UAAYC,IAC/B9D,KAAKm7B,cAGNn7B,KAAKunC,sBAAsBzjC,IAE/B9D,KAAKomC,SAAS,CACZx9B,KAAM,uBACNhE,UAAW7D,KAAKC,MAChBG,KAAM,CACJklC,OAAQ,WACRz9B,KAAM,UACNyG,IAAKrP,KAAKwnC,YAAY1jC,EAAMuL,KAC5Bo4B,KAAM3jC,EAAM2jC,KACZliC,GAAIvF,KAAKsnC,aAAaxjC,EAAM4F,aAG/B,CAAEhB,SAAS,EAAMC,SAAS,GAC/B,CAKQ,QAAAy9B,CAAStiC,GACf9D,KAAKqH,OAAOZ,KAAK3C,GAGb9D,KAAKqH,OAAOzH,OAAS,MACvBI,KAAKqH,OAASrH,KAAKqH,OAAO0C,OAAM,KAEpC,CAEQ,cAAAo8B,CAAev9B,EAAczH,GACnCnB,KAAKomC,SAAS,CACZx9B,KAAM,SACNhE,UAAW7D,KAAKC,MAChBG,KAAM,CAAEyH,UAASzH,IAErB,CAEQ,oBAAAumC,CAAqBhjC,GAC3B,OAAOA,EAAKlF,IAAI48B,IACd,IACE,MAAmB,iBAARA,GAA4B,OAARA,EACtB93B,KAAKoL,MAAMpL,KAAKC,UAAU63B,IAE5BA,CACT,CAAE,MAAO9jB,GACP,MAAO,yBACT,GAEJ,CAEQ,iBAAAouB,GACN,OAAO3lC,KAAKC,MAAM7B,SAAS,IAAMF,KAAKC,SAASC,SAAS,IAAI4V,OAAO,EACrE,CAEQ,iBAAA6xB,CAAkBJ,EAAoB7gB,GAC5C,MAAM/jB,EAAkC,CAAA,EAsBxC,OApBI4kC,aAAI,EAAJA,EAAM5kC,WACJ4kC,EAAK5kC,mBAAmBkO,QAC1B02B,EAAK5kC,QAAQyG,QAAQ,CAAC+B,EAAOiF,KAC3BzN,EAAQyN,GAAOjF,IAERxH,MAAMoN,QAAQw2B,EAAK5kC,SAC5B4kC,EAAK5kC,QAAQyG,QAAQ,EAAEgH,EAAKjF,MAC1BxI,EAAQyN,GAAOjF,IAGjBoF,OAAOm4B,OAAO/lC,EAAS4kC,EAAK5kC,UAI5B+jB,aAAiBghB,SACnBhhB,EAAM/jB,QAAQyG,QAAQ,CAAC+B,EAAOiF,KAC5BzN,EAAQyN,GAAOjF,IAIZxI,CACT,CAEQ,kBAAAklC,CAAmBn5B,GACzB,MAAM/L,EAAkC,CAAA,EAIxC,OAHA+L,EAAS/L,QAAQyG,QAAQ,CAAC+B,EAAOiF,KAC/BzN,EAAQyN,GAAOjF,IAEVxI,CACT,CAEQ,0BAAM6L,CAAqB+4B,EAAoB7gB,GACrD,IAAInY,EAAOg5B,aAAI,EAAJA,EAAMh5B,KAEjB,GAAImY,aAAiBghB,UAAYn5B,EAC/B,IACEA,QAAamY,EAAM3X,QAAQ6B,MAC7B,CAAE,MAAOyI,GACP,OAAO,IACT,CAGF,IAAK9K,EAAM,OAAO,KAElB,GAAoB,iBAATA,EACT,OAAOA,EAAK5N,OAAS,IAAQ4N,EAAKsb,UAAU,EAAG,KAAS,iBAAmBtb,EAG7E,GAAIA,aAAgB2B,SAAU,CAC5B,MAAMsW,EAAgC,CAAA,EAItC,OAHAjY,EAAKnF,QAAQ,CAAC+B,EAAOiF,KACnBoW,EAASpW,GAAOjF,aAAiBkF,KAAO,UAAUlF,EAAMM,QAAUN,IAE7Dqb,CACT,CAEA,MAAO,eACT,CAEQ,yBAAA3X,CAA0BH,GAChC,MAAMgC,EAAchC,EAAS/L,QAAQoB,IAAI,iBAAmB,GACtD4kC,EAAgBtT,SAAS3mB,EAAS/L,QAAQoB,IAAI,mBAAqB,KAGzE,OAAO2M,EAAYlF,SAAS,qBACrBkF,EAAYlF,SAAS,UACpBm9B,EAAgB,GAAqB,IAAhBA,CAC/B,CAEQ,wBAAAP,CAAyBL,GAC/B,MAAMr3B,EAAcq3B,EAAIa,kBAAkB,iBAAmB,GAE7D,OAAOl4B,EAAYlF,SAAS,qBACrBkF,EAAYlF,SAAS,UACpBu8B,EAAI93B,cAA0C,IAA1B83B,EAAI93B,aAAatP,MAC/C,CAEQ,YAAA0nC,CAAah9B,GAEnB,OAAOA,EAAUrL,KAAKC,cAAWsB,CACnC,CAEQ,qBAAA+mC,CAAsBzjC,GAC5B,MAAM4F,EAAS5F,EAAM4F,OAErB,GAAIA,GAAUA,EAAOC,QAAS,CAK5B,GAAgB,UAJAD,EAAOC,QAAQgB,eAIK,aAHtBjB,EAA4Bd,KAGM,OAAO,EAGvD,GAAIc,EAAOkf,aAAa,oBAAqB,OAAO,CACtD,CAEA,OAAO,CACT,CAEQ,WAAA4e,CAAYn4B,GAElB,OAAmB,IAAfA,EAAIzP,QAAgB,cAAc0Q,KAAKjB,GAClC,IAEFA,CACT,CAGQ,sBAAA81B,GACFnlC,KAAKkM,gBACPtI,OAAOuI,MAAQnM,KAAKkM,eAGlBlM,KAAK+mC,yBACPnjC,OAAOyI,eAAiBrM,KAAK+mC,uBAEjC,QCtmBWe,EAIX,WAAA/nC,GACE,GAHMC,KAAA+nC,iBAAsC,KAGxCD,EAAkBE,SACpB,OAAOF,EAAkBE,SAE3BF,EAAkBE,SAAWhoC,IAC/B,CAKA,aAAAioC,GACE,GAAIjoC,KAAK+nC,iBACP,OAAO/nC,KAAK+nC,iBAGd,GAAsB,oBAAXnkC,OACT,OAAO5D,KAAKkoC,0BAGd,MAAMriC,EAAYC,UAAUD,UACtBsiC,EAAcnoC,KAAKooC,aAAaviC,GAChCwiC,EAASroC,KAAKsoC,qBAAqBziC,GACnC0iC,EAAavoC,KAAKwoC,iBAAiB3iC,GAwCzC,OAtCA7F,KAAK+nC,iBAAmB,CAEtBvnB,aAAc2nB,EAAYz9B,KAC1B+V,gBAAiB0nB,EAAY72B,QAC7BoP,sBAAuBynB,EAAYM,aAGnC9nB,QAAS0nB,EAAO39B,KAChBkW,WAAYynB,EAAO/2B,QAGnBuP,YAAa0nB,EACbznB,mBAAoB9gB,KAAK2jB,4BAGzB5C,kBAAmB,GAAG0G,OAAOre,SAASqe,OAAOne,SAC7C0X,YAAayG,OAAOC,WACpBzG,mBAAoBrd,OAAOsrB,kBAAoB,EAC/ChO,cAAe,GAAGtd,OAAOyF,cAAczF,OAAO2F,cAG9C4X,SAAUrb,UAAUqb,SACpBC,SAAUtb,UAAUsb,SACpBC,SAAUgD,KAAKC,iBAAiBC,kBAAkBC,SAGlDlD,mBAAoBthB,KAAK0oC,4BACzBnnB,kBAAmBvhB,KAAK2oC,2BAGxBnnB,eAAgB1b,UAAU6hB,cAC1BlG,sBAAuBzhB,KAAK4oC,wBAAwB,gBACpDlnB,wBAAyB1hB,KAAK4oC,wBAAwB,kBAGtDxoB,WAAYva,GAGP7F,KAAK+nC,gBACd,CAKQ,YAAAK,CAAaviC,GACnB,MAAMgjC,EAAW,CACf,CAAEn+B,KAAM,SAAUo+B,MAAO,qBACzB,CAAEp+B,KAAM,UAAWo+B,MAAO,sBAC1B,CAAEp+B,KAAM,SAAUo+B,MAAO,sCACzB,CAAEp+B,KAAM,OAAQo+B,MAAO,kBACvB,CAAEp+B,KAAM,QAASo+B,MAAO,oBACxB,CAAEp+B,KAAM,oBAAqBo+B,MAAO,kBACpC,CAAEp+B,KAAM,oBAAqBo+B,MAAO,4BAGtC,IAAK,MAAMC,KAAWF,EAAU,CAC9B,MAAMjS,EAAQ/wB,EAAU+wB,MAAMmS,EAAQD,OACtC,GAAIlS,EAAO,CACT,MAAMtlB,EAAUslB,EAAM,GAChB6R,EAAenU,SAAShjB,EAAQ/R,MAAM,KAAK,GAAI,IACrD,MAAO,CACLmL,KAAMq+B,EAAQr+B,KACd4G,UACAm3B,aAAcO,MAAMP,GAAgB,EAAIA,EAE5C,CACF,CAEA,MAAO,CAAE/9B,KAAM,UAAW4G,QAAS,GAAIm3B,aAAc,EACvD,CAKQ,oBAAAH,CAAqBziC,GAQ3B,GAAyB,oBAAdC,WAA6BA,UAAUqb,SAAU,CAC1D,MAAMA,EAAWrb,UAAUqb,SAC3B,GAAIA,EAAS1W,SAAS,QAAuB,aAAb0W,EAAyB,CAEvD,MAAM8nB,EAAkBpjC,EAAU+wB,MAAM,uBAKxC,MAAO,CAAElsB,KAAM,QAAS4G,QAJR23B,EAAkBA,EAAgB,GAAGnqC,QAAQ,KAAM,KAAO,GAK5E,CAEA,GAAIqiB,EAAS1W,SAAS,QAAU0W,EAASzQ,WAAW,OAAQ,CAE1D,MAAMw4B,EAAkBrjC,EAAU+wB,MAAM,wBAExC,MAAO,CAAElsB,KAAM,UAAW4G,QADV43B,EAAkBA,EAAgB,GAAK,GAEzD,CAEA,GAAI/nB,EAAS1W,SAAS,WAAa5E,EAAU4E,SAAS,WAEpD,MAAO,CAAEC,KAAM,QAAS4G,QAAS,GAErC,CAGA,MAAM63B,EAAU,CAEd,CAAEz+B,KAAM,aAAco+B,MAAO,gCAC7B,CAAEp+B,KAAM,aAAco+B,MAAO,oBAC7B,CAAEp+B,KAAM,cAAeo+B,MAAO,mBAC9B,CAAEp+B,KAAM,YAAao+B,MAAO,mBAC5B,CAAEp+B,KAAM,YAAao+B,MAAO,mBAC5B,CAAEp+B,KAAM,gBAAiBo+B,MAAO,mBAChC,CAAEp+B,KAAM,aAAco+B,MAAO,mBAC7B,CAAEp+B,KAAM,UAAWo+B,MAAO,wBAG1B,CAAEp+B,KAAM,QAASo+B,MAAO,uBACxB,CAAEp+B,KAAM,QAASo+B,MAAO,uBAGxB,CAAEp+B,KAAM,MAAOo+B,MAAO,wBACtB,CAAEp+B,KAAM,MAAOo+B,MAAO,sBACtB,CAAEp+B,KAAM,MAAOo+B,MAAO,sBAGtB,CAAEp+B,KAAM,WAAYo+B,MAAO,QAG3B,CAAEp+B,KAAM,UAAWo+B,MAAO,8BAG1B,CAAEp+B,KAAM,SAAUo+B,MAAO,UACzB,CAAEp+B,KAAM,QAASo+B,MAAO,uBAG1B,IAAK,MAAMM,KAAUD,EAAS,CAC5B,MAAMvS,EAAQ/wB,EAAU+wB,MAAMwS,EAAON,OACrC,GAAIlS,EAAO,CACT,IAAItlB,EAAU,GAOd,OANIslB,EAAM,KACRtlB,EAAUslB,EAAM,GAAG93B,QAAQ,KAAM,MAK5B,CAAE4L,KAAM0+B,EAAO1+B,KAAM4G,UAC9B,CACF,CAKA,MAAO,CAAE5G,KAAM,UAAW4G,QAAS,GACrC,CAKQ,gBAAAk3B,CAAiB3iC,GAWvB,GAT0B,CACxB,cACA,YACA,YACA,cACA,SAIoB+E,KAAKyF,GAAWA,EAAQC,KAAKzK,MAE1B,CACrB,iBACA,mBACA,UACA,QACA,kBAGkB+E,KAAKyF,GAAWA,EAAQC,KAAKzK,IAC/C,MAAO,UAKX,MAAMwjC,EAAiB,CACrB,UACA,QACA,mBACA,cACA,iBACA,cACA,mBAIIC,EAAiB,CACrB,QACA,uBACA,UACA,UACA,QACA,aAIF,GAAsB,oBAAX7hB,OAAwB,CACjC,MAAM8hB,EAActqC,KAAKkrB,IAAI1C,OAAOre,MAAOqe,OAAOne,QAIlD,GAAmB,KAAfigC,EACF,MAAO,SAIT,GAAIA,GAAe,KACjB,MAAO,UAIT,GAAmB,MAAfA,EAAqB,CACvB,GAAID,EAAe1+B,KAAKyF,GAAWA,EAAQC,KAAKzK,IAC9C,MAAO,SAET,GAAIwjC,EAAez+B,KAAKyF,GAAWA,EAAQC,KAAKzK,IAC9C,MAAO,QAEX,CACF,CAGA,OAAIwjC,EAAez+B,KAAKyF,GAAWA,EAAQC,KAAKzK,IACvC,SAGLyjC,EAAe1+B,KAAKyF,GAAWA,EAAQC,KAAKzK,IACvC,SAIF,SACT,CAKQ,yBAAA8d,GACN,GAAsB,oBAAX/f,OACT,MAAO,UAAY/E,IAGrB,MAAM2oB,EAAa,CACjB1hB,UAAUD,UACVC,UAAUsb,SACVqG,OAAOre,MAAQ,IAAMqe,OAAOne,OAC5Bme,OAAOC,WACP5hB,UAAUqb,SACVrb,aAAU6hB,mBACqB,IAAxB/jB,OAAOqR,kBACmB,IAA1BrR,OAAO2D,eACd8c,KAAKC,iBAAiBC,kBAAkBC,SACxC1e,UAAU0jC,qBAAuB,UACjC5lC,OAAOsrB,kBAAoB,GAIvBua,EAAoBzpC,KAAK0oC,4BAC3Be,GACFjiB,EAAW/gB,KAAKgjC,GAIlB,MAAMC,EAAmB1pC,KAAK2oC,2BAC1Be,GACFliB,EAAW/gB,KAAKijC,GAIlB,MAAMC,EAAMniB,EAAW3nB,KAAK,KAC5B,IAAIuoB,EAAO,EACX,IAAK,IAAI1lB,EAAI,EAAOinC,EAAI/pC,OAAR8C,EAAgBA,IAE9B0lB,GAASA,GAAQ,GAAKA,EADTuhB,EAAIthB,WAAW3lB,GAE5B0lB,GAAcA,EAGhB,MAAO,MAAQnpB,KAAKqpB,IAAIF,GAAMjpB,SAAS,GACzC,CAKQ,yBAAAupC,GACN,IACE,MAAM9gB,EAASrf,SAASmU,cAAc,UAChCmL,EAAMD,EAAOE,WAAW,MAE9B,IAAKD,EAAK,OAcV,OAZAD,EAAOxe,MAAQ,IACfwe,EAAOte,OAAS,GAEhBue,EAAIE,aAAe,MACnBF,EAAIG,KAAO,aACXH,EAAI2Y,UAAY,OAChB3Y,EAAI4Y,SAAS,IAAK,EAAG,GAAI,IACzB5Y,EAAI2Y,UAAY,OAChB3Y,EAAII,SAAS,wBAAyB,EAAG,IACzCJ,EAAI2Y,UAAY,yBAChB3Y,EAAII,SAAS,wBAAyB,EAAG,IAElCL,EAAOM,WAChB,CAAE,MAAArmB,GACA,MACF,CACF,CAKQ,wBAAA8mC,SACN,IACE,MAAM/gB,EAASrf,SAASmU,cAAc,UAChCktB,EAAKhiB,EAAOE,WAAW,UAAYF,EAAOE,WAAW,sBAE3D,IAAK8hB,EAAI,OAET,MAAMC,EAAWD,EAAGE,aAAaF,EAAGG,UAC9BC,EAASJ,EAAGE,aAAaF,EAAGK,QAIlC,MAAO,GAAGD,KAAUH,KAHJD,EAAGE,aAAaF,EAAGM,aACW,QAA3BroC,EAAA+nC,EAAGO,gCAAwB,IAAAtoC,OAAA,EAAAA,EAAEhC,KAAK,OAAQ,IAG/D,CAAE,MAAAiC,GACA,MACF,CACF,CAKQ,uBAAA8mC,CAAwBhgC,GAC9B,IACE,MAAMtB,EAAU1D,OAAOgF,GACjBwhC,EAAU,gBAGhB,OAFA9iC,EAAQE,QAAQ4iC,EAAS,QACzB9iC,EAAQG,WAAW2iC,IACZ,CACT,CAAE,MAAAvoC,GACA,OAAO,CACT,CACF,CAKQ,uBAAAqmC,GACN,MAAO,CACL1nB,aAAc,UACdC,gBAAiB,GACjBC,sBAAuB,EACvBC,QAAS,UACTC,WAAY,GACZC,YAAa,UACbC,mBAAoB,UAAYjiB,IAChCkiB,kBAAmB,UACnBC,YAAa,EACbC,mBAAoB,EACpBC,cAAe,UACfC,SAAU,SACVC,SAAU,UACVC,SAAU,UACVG,gBAAgB,EAChBC,uBAAuB,EACvBC,yBAAyB,EACzBtB,WAAY,SAEhB,CAKA,UAAAiqB,GACErqC,KAAK+nC,iBAAmB,IAC1B,CAKA,gBAAAuC,GACE,MAAMC,EAAOvqC,KAAKioC,gBAClB,MAAO,GAAGsC,EAAK/pB,gBAAgB+pB,EAAK9pB,sBAAsB8pB,EAAK5pB,YAAY4pB,EAAK1pB,cAClF,EAIK,MAAM2pB,EAAoB,IAAI1C,QC5cxB2C,EAeX,WAAA1qC,CAAYwD,GAgCV,GApCMvD,KAAAge,YAAcF,IAEd9d,KAAAsV,eAAgB,EAGtBtV,KAAKuD,OAAS,CACZiN,OAAQk6B,QAAQC,IAAIC,cAAgB,uBACpC7kC,YAAa,aACbw4B,OAAO,EACPp5B,WAAY,EACZqG,kBAAmB,EACnB9E,eAAgB,GAChB6D,QAAS,CACPC,YAAY,EACZqgC,eAAe,EACfC,iBAAiB,GAEnBx/B,YAAa,CACXsgB,kBAAkB,EAClBE,uBAAuB,EACvBE,yBAAyB,GAE3BlhB,OAAQ,CACNsO,SAAS,EACT2xB,eAAe,EACfhgC,aAAa,MAEZxH,GAILvD,KAAKge,qBViPuB5E,EAAkBC,GAAsB,GAStE,OARAwE,EAAoB,IAAI1E,EAAYC,EAASC,GAGvB,oBAAXzV,SACRA,OAAeonC,gBAAkBntB,GAI7BA,CACT,CU3PuBotB,CACjBjrC,KAAKuD,OAAOg7B,QAAS,EACpBv+B,KAAKuD,OAAe2nC,gBAAiB,IAGnClrC,KAAKuD,OAAOqe,OACf,MAAUvd,MAAM,6BAIlBrE,KAAKugB,WAAaiqB,EAAkBvC,gBnBuCb,oBAAdniC,WAES,CAClB,OACA,UACA,SACA,YACA,WACA,aAGiB8E,KAAKyF,GAAWA,EAAQC,KAAKxK,UAAUD,amBrCxD7F,KAAKwmC,MACP,CAEQ,IAAAA,SACN,IAAIxmC,KAAKsV,cAET,IAEEtV,KAAKwD,aAAe,IAAI1D,EAGxBE,KAAKmrC,aAAe,IAAI7nC,EAAatD,KAAKuD,OAAQvD,KAAKwD,cACvDxD,KAAKorC,eAAiB,IAAIhkC,EAAepH,KAAKuD,OAAQvD,KAAKwD,cAC3DxD,KAAKqrC,eAAiB,IAAIt/B,EAAe/L,KAAKuD,OAAQvD,KAAKwD,cAC3DxD,KAAKsrC,mBAAqB,IAAI7f,EAAmBzrB,KAAKuD,QACtDvD,KAAKurC,YAAc,IAAIxtB,EAAY/d,KAAKuD,QACxCvD,KAAKwrC,mBAAqB,IAAIloB,EAAmBtjB,KAAKuD,OAAQ,IAAMvD,KAAKorC,eAAeljC,gBACxFlI,KAAKyrC,qBAAuB,IAAIlI,EAAqBvjC,KAAKuD,OAAQvD,KAAKorC,eAAeljC,gBACtFlI,KAAK0rC,gBAAkB,IAAIviB,EAAgBnpB,KAAKuD,QAEhDvD,KAAK2rC,sBAGiB,QAAlB9pC,EAAA7B,KAAKuD,OAAOuH,cAAM,IAAAjJ,OAAA,EAAAA,EAAEuX,UACtBpZ,KAAKyrC,qBAAqB5G,iBAG5B7kC,KAAKsV,eAAgB,EAGrBtV,KAAK4rC,iBAAiBzsB,MAAM9f,MAS9B,CAAE,MAAOA,GAIT,CACF,CAEQ,kBAAAssC,GACN,IAAIvvB,EAAa,EACbyvB,EAAgB9qC,KAAKC,MAEzB,MAAM8qC,EAAgB,eACpB,MAAM9qC,EAAMD,KAAKC,MACX+qC,EAAqB/qC,EAAM6qC,EAG3BG,GAAuC,QAAnBnqC,EAAA7B,KAAKqrC,sBAAc,IAAAxpC,OAAA,EAAAA,EAAE8J,YAAY/L,SAAU,EAC/DqsC,GAA4D,QAAxClqC,EAAmB,QAAnBD,EAAA9B,KAAKorC,sBAAc,IAAAtpC,OAAA,EAAAA,EAAE8J,2BAAmB,IAAA7J,OAAA,EAAAA,EAAAqE,KAAAtE,KAAQ,EACpEoqC,EAAqB9vB,EAAa4vB,EAAoBC,EAG5D,IAAIE,EAAgB,IAGhBD,EAAqB,IAEG,GAAtBA,EAE6B,GAAtBA,EAEsB,EAAtBA,IACTC,EAAgB,KAFhBA,EAAgB,IAFhBA,EAAgB,KASO,IAAvBD,GAA4BH,EAAqB,OACnDI,EAAgBltC,KAAK+X,IAAI,IAAOm1B,EAAgB,MAIzB,IAArBH,IACFG,EAAgBltC,KAAK+X,IAAIm1B,EAAe,MAGhBA,EAAtBJ,IACF/rC,KAAKyJ,QACLoiC,EAAgB7qC,EAChBob,EAAa,GAIfrT,WAAW+iC,EAAe,MAI5BA,IAGA,MAAMM,EAA2BpsC,KAAKqG,iBAAiB2pB,KAAKhwB,MAC5DA,KAAKqG,iBAAmB,CAAChH,EAAciH,EAAU,CAAA,KAC/C8V,IACOgwB,EAAyB/sC,EAAOiH,GAE3C,CAGA,gBAAAD,CAAiBhH,EAAciH,EAI3B,IACF,IAAKtG,KAAKsV,cAAe,MAAO,GAIhC,GAD0C,UAAlBhP,EAAQxB,OAAsBwB,EAAQxB,OACtC9E,KAAK0rC,gBAAgBrgB,kBAAkB,SAC7D,MAAO,GAITrrB,KAAK0rC,gBAAgBxhB,0BACrBlqB,KAAK0rC,gBAAgB9hB,oBAAoB,QAEzC,MAAMxkB,EAAUpF,KAAKmrC,aAAa9kC,iBAAiBhH,EAAOiH,GAC1D,GAAIlB,EAAS,CAEX,MAAME,EAAyB,CAC7BC,GAAIH,EACJR,UAAW7D,KAAKC,MAChBgD,QAAS3E,EAAM2E,QACf1E,MAAOD,EAAMC,MACbkG,IAAK5B,OAAO6B,SAASC,KACrBC,OAAQ3F,KAAKuD,OAAOoC,OACpBC,UAAW5F,KAAKorC,eAAeljC,eAC/BrC,UAAWC,UAAUD,UACrBE,YAAa/F,KAAKuD,OAAOwC,YACzBC,QAAShG,KAAKuD,OAAOyC,QACrBC,KAAMK,EAAQL,KACdC,MAAOI,EAAQJ,MACfzC,YAAazD,KAAKmrC,aAAajkC,iBAC/BpC,MAAOwB,EAAQxB,OAAS,QACxByb,WAAYvgB,KAAKugB,YAGnBvgB,KAAKurC,YAAYrsB,WAAW5Z,GAGxBtF,KAAKwrC,oBACPxrC,KAAKwrC,mBAAmBjlB,WAAWlnB,EAAO,CACxCyF,MAAOwB,EAAQxB,MACfmB,KAAMK,EAAQL,KACdC,MAAOI,EAAQJ,OAGrB,CAEA,OAAOd,CACT,CAEA,cAAAmB,CAAevC,EAAiBsC,EAI5B,IACF,IAAKtG,KAAKsV,cAAe,MAAO,GAEhC,MAAMlQ,EAAUpF,KAAKmrC,aAAa5kC,eAAevC,EAASsC,GAC1D,GAAIlB,EAAS,CACX,MAAME,EAAyB,CAC7BC,GAAIH,EACJR,UAAW7D,KAAKC,MAChBgD,UACAwB,IAAK5B,OAAO6B,SAASC,KACrBC,OAAQ3F,KAAKuD,OAAOoC,OACpBC,UAAW5F,KAAKorC,eAAeljC,eAC/BrC,UAAWC,UAAUD,UACrBE,YAAa/F,KAAKuD,OAAOwC,YACzBC,QAAShG,KAAKuD,OAAOyC,QACrBC,KAAMK,EAAQL,KACdC,MAAOI,EAAQJ,MACfzC,YAAazD,KAAKmrC,aAAajkC,iBAC/BpC,MAAOwB,EAAQxB,OAAS,OACxByb,WAAYvgB,KAAKugB,YAGnBvgB,KAAKurC,YAAYrsB,WAAW5Z,EAC9B,CAEA,OAAOF,CACT,CAEA,aAAAT,CAAc6B,GAMPxG,KAAKsV,eAEVtV,KAAKmrC,aAAaxmC,cAAc,CAC9BC,UAAW7D,KAAKC,MAChBgD,QAASwC,EAAWxC,QACpBa,SAAU2B,EAAW3B,UAAY,SACjCC,MAAO0B,EAAW1B,OAAS,OAC3B3D,KAAMqF,EAAWrF,MAErB,CAEA,cAAAyF,CAAeC,GACR7G,KAAKsV,gBAEVtV,KAAKuD,OAAOoC,OAASkB,EAAKtB,GAC1BvF,KAAKmrC,aAAavkC,eAAeC,GACjC7G,KAAKwrC,mBAAmBtnB,UAAUrd,EAAKtB,IAAM,IAC7CvF,KAAKwrC,mBAAmBznB,cAAcld,EAAKtB,IAC7C,CAEA,OAAAuB,CAAQb,GACDjG,KAAKsV,eACVtV,KAAKmrC,aAAarkC,QAAQb,EAC5B,CAEA,QAAAe,CAASd,GACFlG,KAAKsV,eACVtV,KAAKmrC,aAAankC,SAASd,EAC7B,CAGA,YAAAgC,GACE,OAAKlI,KAAKsV,cACHtV,KAAKorC,eAAeljC,eADK,EAElC,CAEA,UAAA4D,GACO9L,KAAKsV,gBAEVtV,KAAKyJ,QACLzJ,KAAKorC,eAAet/B,aACtB,CAGA,IAAAkiB,CAAKtjB,GACE1K,KAAKsV,eACVtV,KAAKsrC,mBAAmBtd,KAAKtjB,EAC/B,CAEA,OAAAujB,CAAQvjB,EAAcwjB,EAAoBC,GACxC,OAAKnuB,KAAKsV,cACHtV,KAAKsrC,mBAAmBrd,QAAQvjB,EAAMwjB,EAAWC,GADxB,IAElC,CAEA,YAAAN,GACE,OAAK7tB,KAAKsV,cACHtV,KAAKsrC,mBAAmBzd,eADC,CAAA,CAElC,CAGA,aAAAoa,GACE,OAAOjoC,KAAKugB,UACd,CAEQ,oBAAMqrB,GACZ,GAAsB,oBAAXhoC,OAAwB,OAGnC,MACMkE,EAAa,0BADD9H,KAAKorC,eAAeljC,eAGtC,IACE,GAA8B,oBAAnBX,gBACiBA,eAAeS,QAAQF,GAK/C,MAGN,CAAE,MAAOwQ,GAET,CAEA,IACE,MAAM+zB,EAAgB,CACpB/rB,YAAa,CACXE,aAAcxgB,KAAKugB,WAAWC,aAC9BC,gBAAiBzgB,KAAKugB,WAAWE,gBACjCC,sBAAuB1gB,KAAKugB,WAAWG,sBACvCC,QAAS3gB,KAAKugB,WAAWI,QACzBC,WAAY5gB,KAAKugB,WAAWK,WAC5BC,YAAa7gB,KAAKugB,WAAWM,YAC7BC,mBAAoB9gB,KAAKugB,WAAWO,mBACpCC,kBAAmB/gB,KAAKugB,WAAWQ,kBACnCC,YAAahhB,KAAKugB,WAAWS,YAC7BC,mBAAoBjhB,KAAKugB,WAAWU,mBACpCC,cAAelhB,KAAKugB,WAAWW,cAC/BC,SAAUnhB,KAAKugB,WAAWY,SAC1BC,SAAUphB,KAAKugB,WAAWa,SAC1BC,SAAUrhB,KAAKugB,WAAWc,SAC1BC,mBAAoBthB,KAAKugB,WAAWe,mBACpCC,kBAAmBvhB,KAAKugB,WAAWgB,kBACnCC,eAAgBxhB,KAAKugB,WAAWiB,eAChCC,sBAAuBzhB,KAAKugB,WAAWkB,sBACvCC,wBAAyB1hB,KAAKugB,WAAWmB,yBAE3CpG,WAAYtb,KAAKorC,eAAeljC,eAChCwgB,QAAS1oB,KAAKuD,OAAOoC,QAGjBgI,QAAiBxB,MAASnM,KAAKuD,OAAOiN,OAAf,sBAA4C,CACvEvD,OAAQ,OACRrL,QAAS,CACP,eAAgB,mBAChB,YAAa5B,KAAKuD,OAAOqe,QAE3BpU,KAAMlJ,KAAKC,UAAU8nC,KAGvB,IAAK1+B,EAASkU,GACZ,MAAUxd,MAAM,+BAA+BsJ,EAASW,QAI1D,IACgC,oBAAnB/G,gBACTA,eAAeC,QAAQM,EAAY,OAEvC,CAAE,MAAOwQ,GAET,CAKF,CAAE,MAAOjZ,GAKT,CACF,CAGA,kBAAAitC,GACOtsC,KAAKsV,eAAkBtV,KAAKyrC,sBACjCzrC,KAAKyrC,qBAAqB5G,gBAC5B,CAEA,iBAAA0H,GACOvsC,KAAKsV,eAAkBtV,KAAKyrC,sBACjCzrC,KAAKyrC,qBAAqBvG,eAC5B,CAEA,oBAAAsH,GACE,OAAKxsC,KAAKsV,eAAkBtV,KAAKyrC,qBAC1BzrC,KAAKyrC,qBAAqBrG,gBAD6B,IAEhE,CAGA,KAAA37B,GACE,IAAKzJ,KAAKsV,cAER,YADAtV,KAAKge,YAAYpE,IAAI,UAAW,gBAAiB,4CAInD5Z,KAAKge,YAAYpE,IAAI,UAAW,cAAe,4BAG/C,MAAMpG,EAAgBxT,KAAKorC,eAAe3hC,QACpCgK,EAAgBzT,KAAKqrC,eAAe5hC,QAE1CzJ,KAAKge,YAAYrD,sBACf,mBACA,CAAE8xB,mBAAoBj5B,EAAc5T,OAAQ8sC,mBAAoBj5B,EAAc7T,QAC9E,CAAE4T,gBAAeC,iBACjBzT,KAAKorC,eAAeljC,gBAItBlI,KAAKge,YAAYpE,IAAI,UAAW,kCAAmC,yCAA0C,CAC3G/F,MAAOL,EAAc5T,OACrByH,OAAQmM,EAAchU,IAAI,CAACsE,EAAOiQ,KAAK,CACrCA,QACAnL,KAAM9E,EAAM8E,KACZ2R,eAAiBzW,EAAe,UAChCyX,eAAgBzX,EAAM8B,WAAa,UACnC4V,SAAUhM,OAAOuI,KAAKjU,EAAM3C,MAAQ,CAAA,GACpCyD,UAAWd,EAAMc,eAIrB,MAAM+nC,EAAmB3sC,KAAKorC,eAAeljC,eAC7ClI,KAAKge,YAAYpE,IAAI,UAAW,qBAAsB,yCAA0C,CAC9FhU,UAAW+mC,EACX5qB,qBAAsB4qB,EACtBC,gBAAiBD,EAAmBA,EAAiB/sC,OAAS,IAIhE4T,EAAcnL,QAAQ,CAACvE,EAAOiQ,KAC5B,MAAM84B,EAAkB/oC,EAAM8B,UAC9B9B,EAAM8B,UAAY+mC,EAElB3sC,KAAKge,YAAYpE,IAAI,UAAW,uBAAwB,gCAAgC7F,EAAS,CAC/F+4B,WAAY/4B,EACZzL,UAAWxE,EAAM8E,KACjBikC,gBAAiBA,GAAmB,UACpCE,eAAgBjpC,EAAM8B,UACtBonC,iBAAkBlpC,EAAM8B,YAAc+mC,MAK1C3sC,KAAKge,YAAYpE,IAAI,UAAW,iCAAkC,wCAAyC,CACzG/F,MAAOL,EAAc5T,OACrByH,OAAQmM,EAAchU,IAAI,CAACsE,EAAOiQ,KAAK,CACrCA,QACAnL,KAAM9E,EAAM8E,KACZ2R,eAAiBzW,EAAe,UAChCyX,eAAgBzX,EAAM8B,UACtBqnC,iBAAkBnpC,EAAM8B,YAAc+mC,EACtCnxB,SAAUhM,OAAOuI,KAAKjU,EAAM3C,MAAQ,CAAA,GACpCyD,UAAWd,EAAMc,eAKrB6O,EAAcpL,QAAQ,CAACvE,EAAOiQ,KAC5B,MAAM84B,EAAkB/oC,EAAM8B,UAC9B9B,EAAM8B,UAAY+mC,EAElB3sC,KAAKge,YAAYpE,IAAI,UAAW,+BAAgC,wCAAwC7F,EAAS,CAC/G+4B,WAAY/4B,EACZ84B,gBAAiBA,GAAmB,UACpCE,eAAgBjpC,EAAM8B,cAKtB4N,EAAc5T,OAAS,GACzBI,KAAKge,YAAYpE,IAAI,UAAW,uBAAwB,qCAAsC,CAC5F/F,MAAOL,EAAc5T,OACrBqjB,iBAAkBzP,EAAcgF,MAAMF,KAAOA,EAAE1S,WAC/Csd,WAAY1P,EAAchU,IAAI8Y,GAAKA,EAAE1S,aAGvC5F,KAAKurC,YAAYlsB,mBAAmB7L,IAEpCxT,KAAKge,YAAYpE,IAAI,UAAW,oBAAqB,8BAGnDnG,EAAc7T,OAAS,GACzBI,KAAKge,YAAYpE,IAAI,UAAW,uBAAwB,qCAAsC,CAC5F/F,MAAOJ,EAAc7T,SAGvBI,KAAKurC,YAAYjsB,mBAAmB7L,IAEpCzT,KAAKge,YAAYpE,IAAI,UAAW,oBAAqB,8BAGvD5Z,KAAKge,YAAYpE,IAAI,UAAW,iBAAkB,4BAA6B,CAC7EszB,oBAAqB15B,EAAc5T,OACnCutC,oBAAqB15B,EAAc7T,QAEvC,CAIA,iBAAA0B,SACE,OAAwB,UAAjBtB,KAAKwD,oBAAY,IAAA3B,OAAA,EAAAA,EAAEP,mBAC5B,CAEA,gBAAAC,SACE,OAAwB,UAAjBvB,KAAKwD,oBAAY,IAAA3B,OAAA,EAAAA,EAAEN,kBAC5B,CAEA,eAAAC,SACE,eAAOK,EAAA7B,KAAKwD,mCAAchC,oBAAqB,CAAA,CACjD,CAEA,SAAAf,CAAUC,SACR,eAAOmB,EAAA7B,KAAKwD,mCAAc/C,UAAUC,EACtC,CAEA,UAAAO,CAAWC,EAAiBC,SACT,QAAjBU,EAAA7B,KAAKwD,oBAAY,IAAA3B,GAAAA,EAAEZ,WAAWC,EAAQC,EACxC,CAEA,OAAA8P,GACOjR,KAAKsV,gBAEVtV,KAAKyJ,QAEDzJ,KAAKqrC,gBACPrrC,KAAKqrC,eAAep6B,UAGlBjR,KAAKurC,aACPvrC,KAAKurC,YAAYt6B,UAGfjR,KAAKyrC,sBACPzrC,KAAKyrC,qBAAqBvG,gBAGxBllC,KAAKwrC,oBACPxrC,KAAKwrC,mBAAmBvnB,eAItBjkB,KAAKwD,cACPxD,KAAKwD,aAAaN,kBAGpBlD,KAAKsV,eAAgB,EACvB,QC1iBW83B,EASX,WAAArtC,CAAYwD,EAA+B,IAPnCvD,KAAAqtC,WAAsC,IAAIltC,IAC1CH,KAAAstC,gBAAkB,EAClBttC,KAAAutC,gBAAkBxsC,KAAKC,MACvBhB,KAAAwtC,oBAAsB,IACtBxtC,KAAAytC,qBAAuB,IAAIttC,IAC3BH,KAAA0tC,iBAAmB,EAGzB1tC,KAAKuD,OAAS,CACZoqC,YAAa,EACbviB,UAAW,IACXwiB,SAAU,IACVC,YAAa,GACbC,kBAAmB,IACnBC,YAAa,IACbC,cAAc,KACXzqC,EAEP,CAKA,sBAAM4f,CACJ9T,EACAwK,EACAvT,EAKI,CAAA,GAEJ,MAAMwtB,SAAEA,EAAW,SAAQma,QAAEA,EAAOvzB,YAAEA,EAAWwzB,iBAAEA,GAAqB5nC,EAGxE,GAAI4nC,GAAoBluC,KAAKytC,qBAAqBx1B,IAAIi2B,GACpD,OAAOluC,KAAKytC,qBAAqBzqC,IAAIkrC,GAKvC,GADAluC,KAAKmuC,uBACAnuC,KAAKouC,mBAAmBta,GAC3B,MAAUzvB,MAAM,kDAGlB,MAAM84B,EAAQn9B,KAAKquC,iBAAiBh/B,GAK9Bi/B,EAAiBtuC,KAAKuuC,iBAAiBl/B,EAAKwK,EAAWia,EAAUma,EAASvzB,EAJ/C,GAIsEyiB,GAWvG,OATI+Q,IACFluC,KAAKytC,qBAAqBxqC,IAAIirC,EAAkBI,GAGhDA,EAAetvB,QAAQ,KACrBhf,KAAKytC,qBAAqBpqC,OAAO6qC,MAI9BI,CACT,CAEQ,sBAAMC,CACZl/B,EACAwK,EACAia,EACAma,EACAvzB,EACA8zB,EACArR,GAEA,IAAK,IAAIrmB,EAAU,EAAa9W,KAAKuD,OAAOoqC,YAAtB72B,EAAmCA,IAAW,CAClE,MAAM23B,EAAe1tC,KAAKC,MAE1B,IAEE,GAAID,KAAKC,MAAQhB,KAAK0tC,iBACpB,MAAM1tC,KAAK0uC,qBAAqB,IAAK,eAAgB,UAAU,EAAO5a,GAIxE,MAAM5hB,EAAS+7B,QACLjuC,KAAK2uC,mBAAmB90B,EAAWo0B,EAAUhvC,KAAKgY,IAAIjX,KAAKuD,OAAOuqC,kBAAmBh3B,UACrF+C,IAGVsjB,EAAMyR,gBACNzR,EAAM0R,kBAAoB/3B,EAAU,EAAIqmB,EAAM0R,kBAAoB,EAAI1R,EAAM0R,kBAC5E1R,EAAM2R,YAAc/tC,KAAKC,MAEzB,MAAM+tC,EAA8B,CAClCj4B,QAASA,EAAU,EACnB+H,MAAO,EACPja,UAAW6pC,EACXjlC,SAAUzI,KAAKC,MAAQytC,GAIzB,OAFAD,EAAS/nC,KAAKsoC,GAEP78B,CAET,CAAE,MAAO7S,GACP,MAAM2vC,EAAiBhvC,KAAKivC,cAAc5vC,EAAOy0B,GAC3Cib,EAA8B,CAClCj4B,QAASA,EAAU,EACnB+H,MAAO,EACPja,UAAW6pC,EACXpvC,MAAO2vC,EACPxlC,SAAUzI,KAAKC,MAAQytC,GAazB,GAXAD,EAAS/nC,KAAKsoC,GAEd5R,EAAMyR,gBACNzR,EAAM+R,YAAcnuC,KAAKC,MAGS,MAA9BguC,EAAe3gC,YACjBrO,KAAKmvC,gBAAgB9vC,IAIlBW,KAAK6W,YAAYm4B,EAAgBl4B,EAASgd,EAAUpZ,GAEvD,MADAyiB,EAAMiS,gBACA/vC,EAIR,MAAMwf,EAAQ7e,KAAKqvC,eAAev4B,EAASgd,EAAUpZ,GACrDq0B,EAAclwB,MAAQA,EAGtB,MAAMywB,EAAad,EAASrxB,OAAO,CAACoyB,EAAKC,IAAQD,EAAMC,EAAI3wB,MAAO,GAClEse,EAAMsS,aAAeH,EAAad,EAAS5uC,OAGvCif,EAAQ,SACJ7e,KAAK0vC,MAAM7wB,GAInB7e,KAAK2vC,mBAAmB7b,EAC1B,CACF,CAIA,MADAqJ,EAAMiS,gBACI/qC,MAAM,uBAAuBrE,KAAKuD,OAAOoqC,6BAA6Bt+B,IAClF,CAEQ,kBAAAs/B,CAAsB90B,EAA6Bo0B,GACzD,OAAOr8B,QAAQg+B,KAAK,CAClB/1B,IACA,IAAIjI,QAAe,CAACi+B,EAAG/9B,IACrB/I,WAAW,IAAM+I,EAAWzN,MAAM,6BAA6B4pC,QAAeA,KAGpF,CAEQ,aAAAgB,CAAc5vC,EAAYy0B,SAEhC,GAAmB,cAAfz0B,EAAMqL,MAAwBrL,EAAM2E,QAAQyG,SAAS,SACvD,OAAOzK,KAAK0uC,qBAAqB,EAAGrvC,EAAM2E,QAAS,WAAW,EAAM8vB,GAItE,YAAIjyB,EAAAxC,EAAM2E,8BAASyG,SAAS,aAA6B,iBAAfpL,EAAMqL,KAC9C,OAAO1K,KAAK0uC,qBAAqB,EAAGrvC,EAAM2E,QAAS,WAAW,EAAM8vB,GAItE,GAAIz0B,EAAMiP,QAAUjP,EAAMgP,WAAY,CACpC,MAAMC,EAASjP,EAAMiP,QAAUjP,EAAMgP,WAErC,GAAIC,GAAU,IAEZ,OAAOtO,KAAK0uC,qBAAqBpgC,EAAQjP,EAAM2E,QAAS,UAAU,EAAM8vB,GACnE,GAAe,MAAXxlB,EAET,OAAOtO,KAAK0uC,qBAAqBpgC,EAAQjP,EAAM2E,QAAS,UAAU,EAAM8vB,GACnE,GAAIxlB,GAAU,IAGnB,OAAOtO,KAAK0uC,qBAAqBpgC,EAAQjP,EAAM2E,QAAS,SAD3B,MAAXsK,GAA6B,MAAXA,GAA6B,MAAXA,GAA6B,MAAXA,EACKwlB,EAEjF,CAGA,OAAO9zB,KAAK0uC,qBAAqB,EAAGrvC,EAAM2E,SAAW,gBAAiB,WAAW,EAAO8vB,EAC1F,CAEQ,oBAAA4a,CACNrgC,EACArK,EACA4E,EACAknC,EACAhc,GAEA,MAAO,CACLzlB,aACArK,UACA4E,OACAknC,YACAhc,WAEJ,CAEQ,WAAAjd,CACNxX,EACAyX,EACAgd,EACApZ,GAGA,QAAKrb,EAAMywC,YAKI9vC,KAAKuD,OAAOoqC,YAAc,EAArC72B,MAKa,aAAbgd,IAA4B9zB,KAAKouC,mBAAmBta,OAKpDpZ,GAA6B,KAAdA,GACkBzb,KAAKkrB,IAAI,EAAGnqB,KAAKuD,OAAOoqC,YAAc,GACrE72B,IAMR,CAEQ,cAAAu4B,CACNv4B,EACAgd,EACApZ,GAGA,IAAImE,EAAQ5f,KAAK+X,IACfhX,KAAKuD,OAAO6nB,UAAYnsB,KAAKgY,IAAI,EAAGH,GACpC9W,KAAKuD,OAAOqqC,UAwBd,OAdA/uB,GAN4B,CAC1BkxB,SAAU,GACVjmB,KAAM,GACNC,OAAQ,EACRC,IAAK,KAEsB8J,GAGzBpZ,GAAeA,EAAc,MAE/BmE,GADuB5f,KAAK+X,IAAI,EAAK0D,EAAc,IAAS,IAK1D1a,KAAKuD,OAAOyqC,eAEdnvB,GADeA,EAAQ7e,KAAKuD,OAAOsqC,aAAe5uC,KAAKC,SAAW,KAI7DD,KAAKkrB,IAAI,EAAGlrB,KAAK0D,MAAMkc,GAChC,CAEQ,eAAAswB,CAAgB9vC,SAEtB,MAAM2wC,GAA0B,QAAbnuC,EAAAxC,EAAMuC,eAAO,IAAAC,OAAA,EAAAA,EAAG,iBAAkBxC,EAAM2wC,WAE3D,GAAIA,EAAY,CACd,MAAMC,EAAsC,IAAvB3b,SAAS0b,GAC9BhwC,KAAK0tC,iBAAmB3sC,KAAKC,MAAQivC,CACvC,MAEEjwC,KAAK0tC,iBAAmB3sC,KAAKC,MAAQ,GAEzC,CAEQ,mBAAAmtC,GACN,MAAMntC,EAAMD,KAAKC,MACbA,EAAMhB,KAAKutC,gBAAkBvtC,KAAKwtC,sBACpCxtC,KAAKstC,gBAAkB,EACvBttC,KAAKutC,gBAAkBvsC,EAE3B,CAEQ,kBAAAotC,CAAmBta,GAEzB,MAAiB,aAAbA,GAO2B9zB,KAAKuD,OAAOwqC,aAFP,SAAbja,EAAgD,GAA1B9zB,KAAKuD,OAAOwqC,YAA8C,GAA1B/tC,KAAKuD,OAAOwqC,aAElF/tC,KAAKstC,eACd,CAEQ,kBAAAqC,CAAmB7b,GAEzB,GAAiB,aAAbA,EAAyB,CAC3B9zB,KAAKstC,kBAGL,IAAK,MAAMnQ,KAASn9B,KAAKqtC,WAAWh1B,SAClC8kB,EAAM+S,WAAalwC,KAAKstC,gBAAkBttC,KAAKuD,OAAOwqC,WAE1D,CACF,CAEQ,gBAAAM,CAAiBh/B,GAUvB,OATKrP,KAAKqtC,WAAWp1B,IAAI5I,IACvBrP,KAAKqtC,WAAWpqC,IAAIoM,EAAK,CACvBu/B,cAAe,EACfC,kBAAmB,EACnBO,cAAe,EACfK,aAAc,EACdS,WAAY,IAGTlwC,KAAKqtC,WAAWrqC,IAAIqM,EAC7B,CAEQ,KAAAqgC,CAAMS,GACZ,OAAO,IAAIv+B,QAAQC,GAAW9I,WAAW8I,EAASs+B,GACpD,CAKA,QAAAC,CAAS/gC,GACP,OAAIA,EACKrP,KAAKqtC,WAAWrqC,IAAIqM,IAAQrP,KAAKquC,iBAAiBh/B,GAEpD,IAAIlP,IAAIH,KAAKqtC,WACtB,CAKA,UAAAgD,CAAWhhC,GACLA,EACFrP,KAAKqtC,WAAWhqC,OAAOgM,IAEvBrP,KAAKqtC,WAAWz5B,QAChB5T,KAAKstC,gBAAkB,EACvBttC,KAAKutC,gBAAkBxsC,KAAKC,MAC5BhB,KAAKytC,qBAAqB75B,QAE9B,CAKA,aAAA08B,GACE,OAAOvvC,KAAKC,MAAQhB,KAAK0tC,gBAC3B,CAKA,kBAAA6C,GAEE,OADAvwC,KAAKmuC,sBACElvC,KAAKkrB,IAAI,EAAGnqB,KAAKuD,OAAOwqC,YAAc/tC,KAAKstC,gBACpD,CAKA,YAAAkD,CAAaC,GACXzwC,KAAKuD,OAAS,IAAKvD,KAAKuD,UAAWktC,EACrC,QChYWC,EAOX,WAAA3wC,CACU2K,EACRnH,EAAwC,IADhCvD,KAAA0K,KAAAA,EANF1K,KAAAu0B,MAAsB,SAEtBv0B,KAAA2wC,cAAkF,GAClF3wC,KAAAmW,UAA2E,GAMjFnW,KAAKuD,OAAS,CACZqtC,iBAAkB,EAClBC,aAAc,IACdC,iBAAkB,EAClB7C,QAAS,IACT8C,eAAgB,GAChBC,WAAY,IACZC,YAAa,KACV1tC,GAGLvD,KAAKkxC,QAAU,CACbC,SAAU,EACVC,SAAU,EACVC,UAAW,EACXC,YAAa,EACbC,oBAAqB,EACrBhd,MAAOv0B,KAAKu0B,MAEhB,CAKA,aAAMid,CAAW33B,EAA6B43B,GAE5C,GAAmB,SAAfzxC,KAAKu0B,MAAkB,CACzB,GAAIxzB,KAAKC,OAAShB,KAAKkxC,QAAQQ,eAAiB,GAAI,CAClD,GAAID,EACF,aAAaA,IAEf,MAAUptC,MAAM,mBAAmBrE,KAAK0K,6BAA6B,IAAI3J,KAAKf,KAAKkxC,QAAQQ,iBAC7F,CAGA1xC,KAAK2xC,sBACP,CAGA,MAAM7wC,EAAYC,KAAKC,MAEvB,IACE,MAAMkR,QAAeN,QAAQg+B,KAAK,CAChC/1B,IACA,IAAIjI,QAAe,CAACi+B,EAAG/9B,IACrB/I,WAAW,IAAM+I,EAAWzN,MAAM,4BAA4BrE,KAAKuD,OAAO0qC,cAAejuC,KAAKuD,OAAO0qC,YAKnGzkC,EAAWzI,KAAKC,MAAQF,EAE9B,OADAd,KAAK4xC,cAAcpoC,GACZ0I,CAET,CAAE,MAAO7S,GAEP,MAAMmK,EAAWzI,KAAKC,MAAQF,EAI9B,GAHAd,KAAK6xC,cAAcroC,GAGfioC,EACF,IACE,aAAaA,GACf,CAAE,MAAOK,GAEP,MAAMzyC,CACR,CAGF,MAAMA,CACR,CACF,CAEQ,aAAAuyC,CAAcpoC,GACpB,MAAMxI,EAAMD,KAAKC,MAEjBhB,KAAK2wC,cAAclqC,KAAK,CACtB7B,UAAW5D,EACXolB,SAAS,EACT5c,aAGFxJ,KAAK+xC,qBACL/xC,KAAKgyC,gBAELhyC,KAAKkxC,QAAQe,gBAAkBjxC,EAGZ,cAAfhB,KAAKu0B,QACuBv0B,KAAKuD,OAAOutC,iBAAtC9wC,KAAKkxC,QAAQG,WACfrxC,KAAKkyC,sBAITlyC,KAAKoW,iBACP,CAEQ,aAAAy7B,CAAcroC,GACpB,MAAMxI,EAAMD,KAAKC,MAEjBhB,KAAK2wC,cAAclqC,KAAK,CACtB7B,UAAW5D,EACXolB,SAAS,EACT5c,aAGFxJ,KAAK+xC,qBACL/xC,KAAKgyC,gBAELhyC,KAAKkxC,QAAQiB,gBAAkBnxC,EAGZ,WAAfhB,KAAKu0B,OAAqC,cAAfv0B,KAAKu0B,OAC9Bv0B,KAAKoyC,cACPpyC,KAAKqyC,mBAITryC,KAAKoW,iBACP,CAEQ,UAAAg8B,GAEN,QAA4BpyC,KAAKuD,OAAO0tC,YAApCjxC,KAAKkxC,QAAQC,UAKYnxC,KAAKuD,OAAOqtC,iBAArC5wC,KAAKkxC,QAAQE,UAKepxC,KAAKuD,OAAOwtC,eAAxC/wC,KAAKkxC,QAAQI,aAKE,cAAftxC,KAAKu0B,MAKX,CAEQ,kBAAA2d,GACNlyC,KAAKu0B,MAAQ,SACbv0B,KAAKkxC,QAAQ3c,MAAQ,SACrBv0B,KAAKkxC,QAAQoB,cAAW9xC,EACxBR,KAAKkxC,QAAQQ,mBAAgBlxC,EAG7BR,KAAKkxC,QAAQE,SAAW,EACxBpxC,KAAKkxC,QAAQG,UAAY,CAC3B,CAEQ,gBAAAgB,GACNryC,KAAKu0B,MAAQ,OACbv0B,KAAKkxC,QAAQ3c,MAAQ,OACrBv0B,KAAKkxC,QAAQoB,SAAWvxC,KAAKC,MAC7BhB,KAAKkxC,QAAQQ,cAAgB3wC,KAAKC,MAAQhB,KAAKuD,OAAOstC,YACxD,CAEQ,oBAAAc,GACN3xC,KAAKu0B,MAAQ,YACbv0B,KAAKkxC,QAAQ3c,MAAQ,YACrBv0B,KAAKkxC,QAAQG,UAAY,CAC3B,CAEQ,kBAAAU,GACN,MAAM5uC,EAASpC,KAAKC,MAAQhB,KAAKuD,OAAOytC,WACxChxC,KAAK2wC,cAAgB3wC,KAAK2wC,cAAchxC,OAAO4yC,GAAOA,EAAI3tC,UAAYzB,EACxE,CAEQ,aAAA6uC,GACN,MAAMQ,EAAgBxyC,KAAK2wC,cAAc/wC,OACnC6yC,EAAqBzyC,KAAK2wC,cAAchxC,OAAO4yC,GAAOA,EAAInsB,SAASxmB,OACnE8yC,EAAiBF,EAAgBC,EAQvC,GANAzyC,KAAKkxC,QAAQC,SAAWqB,EACxBxyC,KAAKkxC,QAAQG,UAAYoB,EACzBzyC,KAAKkxC,QAAQE,SAAWsB,EACxB1yC,KAAKkxC,QAAQI,YAAckB,EAAgB,EAAIE,EAAiBF,EAAgB,EAG5ExyC,KAAK2wC,cAAc/wC,OAAS,EAAG,CACjC,MAAM+yC,EAAgB3yC,KAAK2wC,cAAcxzB,OAAO,CAACoyB,EAAKgD,IAAQhD,EAAMgD,EAAI/oC,SAAU,GAClFxJ,KAAKkxC,QAAQK,oBAAsBoB,EAAgB3yC,KAAK2wC,cAAc/wC,MACxE,CACF,CAKA,UAAAgzC,GAGE,OAFA5yC,KAAK+xC,qBACL/xC,KAAKgyC,gBACE,IAAKhyC,KAAKkxC,QACnB,CAKA,QAAA2B,GACE,OAAO7yC,KAAKu0B,KACd,CAKA,UAAAue,CAAWve,GACTv0B,KAAKu0B,MAAQA,EACbv0B,KAAKkxC,QAAQ3c,MAAQA,EAEP,SAAVA,IACFv0B,KAAKkxC,QAAQoB,SAAWvxC,KAAKC,MAC7BhB,KAAKkxC,QAAQQ,cAAgB3wC,KAAKC,MAAQhB,KAAKuD,OAAOstC,cAGxD7wC,KAAKoW,iBACP,CAKA,KAAA28B,GACE/yC,KAAKu0B,MAAQ,SACbv0B,KAAK2wC,cAAgB,GACrB3wC,KAAKkxC,QAAU,CACbC,SAAU,EACVC,SAAU,EACVC,UAAW,EACXC,YAAa,EACbC,oBAAqB,EACrBhd,MAAO,UAETv0B,KAAKoW,iBACP,CAKA,aAAA48B,CAAcv8B,GAEZ,OADAzW,KAAKmW,UAAU1P,KAAKgQ,GACb,KACL,MAAM1C,EAAQ/T,KAAKmW,UAAUO,QAAQD,GACjC1C,GAAQ,GACV/T,KAAKmW,UAAUxP,OAAOoN,EAAO,GAGnC,CAEQ,eAAAqC,GACNpW,KAAKmW,UAAU9N,QAAQoO,IACrB,IACEA,EAASzW,KAAKu0B,MAAO,IAAKv0B,KAAKkxC,SACjC,CAAE,MAAO7xC,GAET,GAEJ,CAKA,YAAAmxC,CAAaC,GACXzwC,KAAKuD,OAAS,IAAKvD,KAAKuD,UAAWktC,EACrC,QAMWwC,EAOX,WAAAlzC,GANQC,KAAAkzC,gBAAkB,IAAI/yC,IAEtBH,KAAAmzC,eAAiB,IAAIhzC,IACrBH,KAAAozC,iBAAmB,IAAIv7B,IACvB7X,KAAAmW,UAAuD,GAI7DnW,KAAKqzC,qBAAuB,IAAI3C,EAAe,SAAU,CACvDE,iBAAkB,GAClBG,eAAgB,GAChBF,aAAc,IACdI,YAAa,KAGfjxC,KAAKqzC,qBAAqBL,cAAc,CAACze,EAAO2c,KAC9ClxC,KAAKoW,gBAAgB,sBAAuB,CAAEme,QAAO2c,YAEvC,SAAV3c,EACFv0B,KAAKszC,sBACc,WAAV/e,GACTv0B,KAAKuzC,wBAGX,CAKA,eAAAC,CACE9oC,EACA+oC,EACAlwC,GAEAvD,KAAKmzC,eAAelwC,IAAIyH,EAAM+oC,GAE9B,MAAMC,EAAiB,IAAIhD,EAAehmC,EAAM,CAE9CkmC,iBAAuC,aAArB6C,EAAQ3f,SAA0B,GAA0B,SAArB2f,EAAQ3f,SAAsB,EAAI,EAC3Fid,eAAqC,aAArB0C,EAAQ3f,SAA0B,GAAM,GACxD+c,aAAmC,aAArB4C,EAAQ3f,SAA0B,IAAQ,OACrDvwB,IAQL,OALAmwC,EAAeV,cAAc,CAACze,EAAO2c,KACnClxC,KAAK2zC,yBAAyBjpC,EAAM+oC,EAASlf,EAAO2c,KAGtDlxC,KAAKkzC,gBAAgBjwC,IAAIyH,EAAMgpC,GACxBA,CACT,CAKA,sBAAME,CACJC,EACAh6B,EACA43B,GAGA,IAAKzxC,KAAKkzC,gBAAgBj7B,IAAI47B,GAC5B,MAAUxvC,MAAM,WAAWwvC,yCAG7B,MAAMC,EAAiB9zC,KAAKkzC,gBAAgBlwC,IAAI6wC,GAC1CE,EAAgB/zC,KAAKmzC,eAAenwC,IAAI6wC,GAG9C,GAA6C,SAAzC7zC,KAAKqzC,qBAAqBR,YACG,aAA3BkB,EAAcjgB,SAAyB,CACzC,GAAI2d,EACF,aAAaA,IAEf,MAAUptC,MAAM,kEAClB,CAIF,OAAIrE,KAAKozC,iBAAiBn7B,IAAI47B,IACxBE,EAAcC,qBAAuBvC,QAC1BA,UAKJzxC,KAAKqzC,qBAAqB7B,QACrC,IAAMsC,EAAetC,QAAQ33B,EAAW43B,GACxCA,EAEJ,CAEQ,wBAAAkC,CACNE,EACAJ,EACAlf,EACA2c,GAEAlxC,KAAKoW,gBAAgB,uBAAwB,CAAEy9B,cAAaJ,UAASlf,QAAO2c,YAE9D,SAAV3c,GAEEkf,EAAQO,sBACVh0C,KAAKozC,iBAAiBhgC,IAAIygC,GAC1B7zC,KAAKoW,gBAAgB,mBAAoB,CAAEy9B,cAAaJ,aAIjC,aAArBA,EAAQ3f,UACV9zB,KAAKi0C,wBAGY,WAAV1f,GAELv0B,KAAKozC,iBAAiBn7B,IAAI47B,KAC5B7zC,KAAKozC,iBAAiB/vC,OAAOwwC,GAC7B7zC,KAAKoW,gBAAgB,oBAAqB,CAAEy9B,cAAaJ,YAG/D,CAEQ,oBAAAQ,GACN,MAAMC,EAAgBl0C,KAAKkzC,gBAAgB9iC,KAIrCkhC,EAHiB1uC,MAAMC,KAAK7C,KAAKkzC,gBAAgB76B,UACpD1Y,OAAOw0C,GAAwB,SAAlBA,EAAGtB,YAAuBjzC,OAELs0C,EAGjC5C,EAAc,GAChBtxC,KAAKo0C,+BACkB,GAAd9C,GACTtxC,KAAKq0C,+BAET,CAEQ,mBAAAf,GACNtzC,KAAKoW,gBAAgB,yBAA0B,CAAExR,UAAW7D,KAAKC,QAGjEhB,KAAKmzC,eAAe9qC,QAAQ,CAAC9E,EAAQmH,KACX,aAApBnH,EAAOuwB,UACT9zB,KAAKozC,iBAAiBhgC,IAAI1I,IAGhC,CAEQ,oBAAA6oC,GACNvzC,KAAKoW,gBAAgB,0BAA2B,CAAExR,UAAW7D,KAAKC,QAGlEhB,KAAKozC,iBAAiB/qC,QAAQwrC,IAC5B,MAAMS,EAAUt0C,KAAKkzC,gBAAgBlwC,IAAI6wC,GACrCS,GAAkC,SAAvBA,EAAQzB,YACrB7yC,KAAKozC,iBAAiB/vC,OAAOwwC,IAGnC,CAEQ,4BAAAO,GACNp0C,KAAKoW,gBAAgB,kCAAmC,CAAExR,UAAW7D,KAAKC,QAG1EhB,KAAKmzC,eAAe9qC,QAAQ,CAAC9E,EAAQmH,KACX,QAApBnH,EAAOuwB,UAAsBvwB,EAAOywC,qBACtCh0C,KAAKozC,iBAAiBhgC,IAAI1I,IAGhC,CAEQ,6BAAA2pC,GACNr0C,KAAKoW,gBAAgB,mCAAoC,CAAExR,UAAW7D,KAAKC,QAG3EhB,KAAKmzC,eAAe9qC,QAAQ,CAAC9E,EAAQmH,KACnC,GAAwB,QAApBnH,EAAOuwB,SAAoB,CAC7B,MAAMwgB,EAAUt0C,KAAKkzC,gBAAgBlwC,IAAI0H,GACrC4pC,GAAkC,SAAvBA,EAAQzB,YACrB7yC,KAAKozC,iBAAiB/vC,OAAOqH,EAEjC,GAEJ,CAKA,eAAA6pC,GASE,MAAMC,EAAgBx0C,KAAKkzC,gBAAgB9iC,KACrCqkC,EAAiB7xC,MAAMC,KAAK7C,KAAKkzC,gBAAgB76B,UACpD1Y,OAAOw0C,GAAwB,SAAlBA,EAAGtB,YAAuBjzC,OACpC80C,EAAkBF,EAAgBC,EAClCE,EAAmB30C,KAAKozC,iBAAiBhjC,KAE/C,MAAO,CACLwkC,YAAa50C,KAAKqzC,qBAAqBR,WACvC2B,gBACAE,kBACAD,iBACAE,mBACAE,cAAwD,SAAzC70C,KAAKqzC,qBAAqBR,WACzCiC,uBAAwBH,EAAmB,EAE/C,CAKA,aAAAI,GACE,MAAM7D,EAAU,IAAI/wC,IAQpB,OANA+wC,EAAQjuC,IAAI,SAAUjD,KAAKqzC,qBAAqBT,cAEhD5yC,KAAKkzC,gBAAgB7qC,QAAQ,CAACisC,EAAS5pC,KACrCwmC,EAAQjuC,IAAIyH,EAAM4pC,EAAQ1B,gBAGrB1B,CACT,CAKA,iBAAA8D,CAAkBnB,GAChB,OAAO7zC,KAAKkzC,gBAAgBlwC,IAAI6wC,EAClC,CAKA,iBAAAoB,CAAkBpB,GAChB,OAAO7zC,KAAKozC,iBAAiBn7B,IAAI47B,EACnC,CAKA,QAAAqB,GACEl1C,KAAKqzC,qBAAqBN,QAC1B/yC,KAAKkzC,gBAAgB7qC,QAAQisC,GAAWA,EAAQvB,SAChD/yC,KAAKozC,iBAAiBx/B,OACxB,CAKA,OAAAuhC,CAAQ1+B,GAEN,OADAzW,KAAKmW,UAAU1P,KAAKgQ,GACb,KACL,MAAM1C,EAAQ/T,KAAKmW,UAAUO,QAAQD,GACjC1C,GAAQ,GACV/T,KAAKmW,UAAUxP,OAAOoN,EAAO,GAGnC,CAEQ,eAAAqC,CAAgBtS,EAAe3C,GACrCnB,KAAKmW,UAAU9N,QAAQoO,IACrB,IACEA,EAAS3S,EAAO3C,EAClB,CAAE,MAAO9B,GAET,GAEJ,CAKA,kBAAA+1C,CACEvB,EACAh6B,EACAvT,EAKI,CAAA,GAEJ,MAAMwtB,SAAEA,EAAW,SAAQuhB,kBAAEA,GAAoB,EAAKC,iBAAEA,GAAqBhvC,EASvEmrC,EAAW4D,EAAoB,IAAMzjC,QAAQC,QAAQyjC,QAAoB90C,EAE/ER,KAAKwzC,gBAAgBK,EATgB,CACnCnpC,KAAMmpC,EACN/f,WACAyhB,gBAAiBF,EACjBrB,oBAAqBqB,IAMvB,MAAM3B,EAAiB1zC,KAAKkzC,gBAAgBlwC,IAAI6wC,GAEhD,IAAKH,EACH,MAAUrvC,MAAM,gCAAgCwvC,gBAGlD,OAAOH,EAAelC,QAAQ33B,EAAW43B,EAC3C,CAKA,kBAAA+D,CAAmBjyC,GACjBvD,KAAKqzC,qBAAqB7C,aAAajtC,EACzC,CAKA,cAAAkyC,GACE,MAAO,CACLC,OAAQ11C,KAAKqzC,qBAAqBT,aAClC+C,SAAUnmC,OAAOC,YAAYzP,KAAK+0C,iBAClCa,aAAc51C,KAAKu0C,kBACnBnB,iBAAkBxwC,MAAMC,KAAK7C,KAAKozC,kBAEtC,CAKA,UAAA/C,GACErwC,KAAKk1C,UACP,QC7lBWW,EASX,WAAA91C,GARQC,KAAA81C,MAA+C,IAAI31C,IACnDH,KAAA2R,UAAgC,KAChC3R,KAAAiV,aAA+B,KAC/BjV,KAAA+1C,YAAuC,IAAI51C,IAE3CH,KAAAg2C,aAAc,EACdh2C,KAAAi2C,kBAAmC,KAGzCj2C,KAAKk2C,kBACLl2C,KAAKm2C,aAAe,IAAIC,EACxBp2C,KAAKq2C,6BACP,CAEQ,eAAAH,GAENl2C,KAAK81C,MAAM7yC,IAAI,MAAO,CACpByH,KAAM,MACN4rC,QAAS,QACTC,oBAAoB,EACpBC,mBAAmB,EACnBC,cAAe,IACf3iB,SAAU,IAIZ9zB,KAAK81C,MAAM7yC,IAAI,OAAQ,CACrByH,KAAM,OACN4rC,QAAS,SACTC,oBAAoB,EACpBC,mBAAmB,EACnBC,cAAe,MACf3iB,SAAU,IAIZ9zB,KAAK81C,MAAM7yC,IAAI,OAAQ,CACrByH,KAAM,OACN4rC,QAAS,SACTC,oBAAoB,EACpBC,mBAAmB,EACnBC,cAAe,OACf3iB,SAAU,GAEd,CAEQ,iCAAMuiB,GACZ,GAAsB,oBAAXK,OACT,IAEE,MAmBMC,EAAO,IAAIxmC,KAAK,CAnBH,6rBAmBiB,CAAEvH,KAAM,2BAC5C5I,KAAKi2C,kBAAoB,IAAIS,OAAOn6B,IAAIC,gBAAgBm6B,GAC1D,CAAE,MAAOt3C,GAET,CAEJ,CAEA,gBAAMqS,GACA1R,KAAKg2C,oBAEHpkC,QAAQglC,IAAI,CAChB52C,KAAK62C,sBACL72C,KAAK82C,yBACL92C,KAAKm2C,aAAazkC,eAIpB1R,KAAK+2C,yBAEL/2C,KAAKg2C,aAAc,EACrB,CAEQ,yBAAMa,GACZ,GAAsB,oBAAXjzC,QAA2BA,OAAO+N,UAE7C,OAAO,IAAIC,QAAQ,CAACC,EAASC,KAC3B,MAAMC,EAAUJ,UAAUpF,KAAK,uBAAwB,GAEvDwF,EAAQC,QAAU,IAAMF,EAAOC,EAAQ1S,OACvC0S,EAAQE,UAAY,KAClBjS,KAAK2R,UAAYI,EAAQG,OACzBL,KAGFE,EAAQI,gBAAkB,KACxB,MAAMf,EAAKW,EAAQG,OAGdd,EAAGgB,iBAAiBC,SAAS,WAChCjB,EAAGmB,kBAAkB,SAAU,CAAEC,QAAS,OAEvCpB,EAAGgB,iBAAiBC,SAAS,aAChCjB,EAAGmB,kBAAkB,WAAY,CAAEC,QAAS,OAEzCpB,EAAGgB,iBAAiBC,SAAS,YAChCjB,EAAGmB,kBAAkB,UAAW,CAAEC,QAAS,OAExCpB,EAAGgB,iBAAiBC,SAAS,aAChCjB,EAAGmB,kBAAkB,WAAY,CAAEC,QAAS,UAIpD,CAEQ,sBAAAskC,GACgB,oBAAXlzC,QAA0BA,OAAOqR,eAC1CjV,KAAKiV,aAAerR,OAAOqR,aAE/B,CAKA,WAAMtC,CACJ/J,EACAzH,EACAmF,EAII,CAAA,GAECtG,KAAKg2C,mBACFh2C,KAAK0R,aAGb,MAAMoiB,SAAEA,EAAW,SAAQkjB,IAAEA,EAAGC,UAAEA,GAAY,GAAU3wC,EAGlDf,EAAKvF,KAAKnB,WAAW+J,GAGrBsuC,EAAWl3C,KAAKm3C,cAAch2C,GAG9Bi2C,EAAOp3C,KAAKq3C,kBAAkBvjB,EAAUojB,EAAUD,GAGlDjkC,EAAsB,CAC1BzN,KACApE,OACA2yB,WACAlvB,UAAW7D,KAAKC,MAChBoP,KAAM8mC,EACNhkC,YAAY,EACZokC,WAAW,EACXC,WAAY,EACZH,KAAMA,EAAK1sC,KACX8sC,UAAWR,EAAMj2C,KAAKC,MAAQg2C,OAAMx2C,EACpCi3C,SAAUz3C,KAAK03C,kBAAkBv2C,IAMnC,aAFMnB,KAAK23C,YAAY3kC,EAAMokC,GAEtB7xC,CACT,CAEQ,iBAAA8xC,CACNvjB,EACAojB,EACAD,GAGA,OACSj3C,KAAK81C,MAAM9yC,IADH,aAAb8wB,GAA2BmjB,EACP,MAIP,SAAbnjB,GAAkC,MAAXojB,EACH,OAIF,OACxB,CAEQ,iBAAMS,CAAe3kC,EAAqBokC,GAMhD,aAJWp3C,KAAK43C,oBAAoBR,EAAMpkC,EAAK5C,aACvCpQ,KAAK63C,UAAUT,EAAMpkC,EAAK5C,MAG1BgnC,EAAK1sC,MACX,IAAK,YACG1K,KAAK83C,cAAc9kC,GACzB,MACF,IAAK,aACGhT,KAAK+3C,iBAAiB/kC,EAAMokC,GAClC,MACF,IAAK,aACGp3C,KAAKg4C,oBAAoBhlC,EAAMokC,GAG3C,CAEQ,mBAAMU,CAAiB9kC,GAC7BhT,KAAK+1C,YAAY9yC,IAAI+P,EAAKzN,GAAIyN,EAChC,CAEQ,sBAAM+kC,CAAoB/kC,EAAqBokC,GACrD,IAAKp3C,KAAK2R,UAAW,MAAUtN,MAAM,2BAGrC,GAAI+yC,EAAKb,mBAAoB,CAC3B,MAAMrjC,QAAmBlT,KAAKwX,aAAaxE,EAAK7R,MAC5C+R,EAAWA,aACbF,EAAK7R,KAAO+R,EAAW/R,KACvB6R,EAAKE,YAAa,EAClBF,EAAK5C,KAAOpQ,KAAKm3C,cAAcnkC,EAAK7R,MAExC,CAEA,OAAO,IAAIyQ,QAAQ,CAACC,EAASC,KAC3B,MAGMC,EAHc/R,KAAK2R,UAAWwB,YAAY,CAAC,SAAU,WAAY,WAAY,aACzDb,YAAYtS,KAAKi4C,mBAAmBjlC,EAAKzN,KAE7C2yC,IAAIllC,GAC1BjB,EAAQE,UAAY,IAAMJ,IAC1BE,EAAQC,QAAU,IAAMF,EAAOC,EAAQ1S,QAE3C,CAEQ,yBAAM24C,CAAuBhlC,EAAqBokC,GACxD,IAAKp3C,KAAKiV,aAAc,MAAU5Q,MAAM,8BAGxC,IAAI8zC,EAAgBnlC,EAAK7R,KAEzB,GAAIi2C,EAAKb,mBAAoB,CAC3B,MAAMrjC,QAAmBlT,KAAKwX,aAAa2gC,GACvCjlC,EAAWA,aACbilC,EAAgBjlC,EAAW/R,KAC3B6R,EAAKE,YAAa,EAEtB,CAEIkkC,EAAKZ,oBACP2B,QAAsBn4C,KAAKo4C,YAAYD,GACvCnlC,EAAKskC,WAAY,GAGnBtkC,EAAK7R,KAAOg3C,EACZnlC,EAAK5C,KAAOpQ,KAAKm3C,cAAcnkC,EAAK7R,MAEpC,IACEnB,KAAKiV,aAAazN,QAAQ,QAAQwL,EAAKzN,GAAMjB,KAAKC,UAAUyO,GAC9D,CAAE,MAAO3T,GACP,KAAIA,aAAiBgF,OAAwB,uBAAfhF,EAAMqL,MAIlC,MAAMrL,QAHAW,KAAK63C,UAAUT,EAAMpkC,EAAK5C,MAChCpQ,KAAKiV,aAAazN,QAAQ,QAAQwL,EAAKzN,GAAMjB,KAAKC,UAAUyO,GAIhE,CACF,CAKA,cAAMqlC,CAAY9yC,GACXvF,KAAKg2C,mBACFh2C,KAAK0R,aAIb,MAAMokC,EAA+B,CAAC,MAAO,OAAQ,QAErD,IAAK,MAAMwC,KAAYxC,EAAO,CAC5B,MAAM9iC,QAAahT,KAAKu4C,iBAAoBhzC,EAAI+yC,GAChD,GAAItlC,EAAM,CAER,IAAKhT,KAAKw4C,sBAAsBxlC,GAE9B,SAQF,MAJiB,QAAbslC,GAAsBt4C,KAAKy4C,cAAczlC,UACrChT,KAAK04C,YAAY1lC,GAGlBA,CACT,CACF,CAEA,OAAO,IACT,CAEQ,sBAAMulC,CAAoBhzC,EAAY+yC,GAC5C,OAAQA,GACN,IAAK,MACH,OAAOt4C,KAAK+1C,YAAY/yC,IAAIuC,IAAwB,KACtD,IAAK,OACH,OAAOvF,KAAK24C,sBAAyBpzC,GACvC,IAAK,OACH,OAAOvF,KAAK44C,yBAA4BrzC,GAE9C,CAEQ,2BAAMozC,CAAyBpzC,GACrC,OAAKvF,KAAK2R,UAEH,IAAIC,QAAQ,CAACC,EAASC,KAC3B,MAGMC,EAHc/R,KAAK2R,UAAWwB,YAAY,CAAC,SAAU,WAAY,WAAY,YACzDb,YAAYtS,KAAKi4C,mBAAmB1yC,IAExCvC,IAAIuC,GAC1BwM,EAAQE,UAAYjF,UAClB,MAAMgG,EAAOjB,EAAQG,OACrB,GAAIc,GAAQA,EAAKE,WAAY,CAC3B,MAAM2lC,QAAqB74C,KAAK84C,eAAe9lC,EAAK7R,MACpD6R,EAAK7R,KAAO03C,EACZ7lC,EAAKE,YAAa,CACpB,CACArB,EAAQmB,GAAQ,OAElBjB,EAAQC,QAAU,IAAMF,EAAOC,EAAQ1S,SAhBb,IAkB9B,CAEQ,8BAAMu5C,CAA4BrzC,GACxC,IAAKvF,KAAKiV,aAAc,OAAO,KAE/B,IACE,MAAM8jC,EAAW/4C,KAAKiV,aAAajN,QAAQ,QAAQzC,GACnD,IAAKwzC,EAAU,OAAO,KAEtB,MAAM/lC,EAAO1O,KAAKoL,MAAMqpC,GASxB,GANI/lC,EAAKskC,YACPtkC,EAAK7R,WAAanB,KAAKg5C,YAAYhmC,EAAK7R,MACxC6R,EAAKskC,WAAY,GAIftkC,EAAKE,WAAY,CACnB,MAAM2lC,QAAqB74C,KAAK84C,eAAe9lC,EAAK7R,MACpD6R,EAAK7R,KAAO03C,EACZ7lC,EAAKE,YAAa,CACpB,CAEA,OAAOF,CACT,CAAE,MAAO3T,GAEP,OAAO,IACT,CACF,CAKA,kBAAM45C,CAAgBrwC,GACf5I,KAAKg2C,mBACFh2C,KAAK0R,aAGb,MAAM4B,EAAyB,GAG/B,IAAK,MAAMglC,IAAY,CAAC,MAAO,OAAQ,QAAkB,CACvD,MAAMY,QAAkBl5C,KAAKm5C,eAAkBvwC,EAAM0vC,GACrDhlC,EAAM7M,QAAQyyC,EAChB,CAGA,OAAO5lC,EAAM0E,KAAK,CAAC+lB,EAAGC,KACpB,MAAMob,EAAgB,CAAErJ,SAAU,EAAGjmB,KAAM,EAAGC,OAAQ,EAAGC,IAAK,GACxDqvB,EAAeD,EAAcrb,EAAEjK,UAAYslB,EAAcpb,EAAElK,UAEjE,OAAqB,IAAjBulB,EAA2BA,EACxBtb,EAAEn5B,UAAYo5B,EAAEp5B,WAE3B,CAEQ,oBAAMu0C,CAAkBvwC,EAAc0vC,GAC5C,OAAQA,GACN,IAAK,MACH,OAAO11C,MAAMC,KAAK7C,KAAK+1C,YAAY19B,UAChC1Y,OAAOqT,GAAQA,EAAKzN,GAAGmL,WAAW9H,IACvC,IAAK,OACH,OAAO5I,KAAKs5C,oBAAuB1wC,GACrC,IAAK,OACH,OAAO5I,KAAKu5C,uBAA0B3wC,GAE5C,CAEQ,yBAAM0wC,CAAuB1wC,GACnC,OAAK5I,KAAK2R,UAEH,IAAIC,QAAQ,CAACC,EAASC,KAC3B,MAGMC,EAHc/R,KAAK2R,UAAWwB,YAAY,CAACnT,KAAKw5C,aAAa5wC,IAAQ,YACjD0J,YAAYtS,KAAKw5C,aAAa5wC,IAElCyK,SACtBtB,EAAQE,UAAYjF,UAClB,MAAMsG,EAAQvB,EAAQG,OAGtB,IAAK,MAAMc,KAAQM,EACjB,GAAIN,EAAKE,WAAY,CACnB,MAAM2lC,QAAqB74C,KAAK84C,eAAe9lC,EAAK7R,MACpD6R,EAAK7R,KAAO03C,EACZ7lC,EAAKE,YAAa,CACpB,CAGFrB,EAAQyB,IAEVvB,EAAQC,QAAU,IAAMF,EAAOC,EAAQ1S,SArBb,EAuB9B,CAEQ,4BAAMk6C,CAA0B3wC,GACtC,IAAK5I,KAAKiV,aAAc,MAAO,GAE/B,MAAM3B,EAAyB,GAE/B,IAAK,IAAI5Q,EAAI,EAAO1C,KAAKiV,aAAarV,OAAtB8C,EAA8BA,IAAK,CACjD,MAAM2M,EAAMrP,KAAKiV,aAAa5F,IAAI3M,GAClC,GAAI2M,GAAOA,EAAIqB,WAAW,QAAQ9H,GAChC,IACE,MAAMmwC,EAAW/4C,KAAKiV,aAAajN,QAAQqH,GAC3C,GAAI0pC,EAAU,CACZ,MAAM/lC,EAAO1O,KAAKoL,MAAMqpC,GAOxB,GAJI/lC,EAAKskC,YACPtkC,EAAK7R,WAAanB,KAAKg5C,YAAYhmC,EAAK7R,MACxC6R,EAAKskC,WAAY,GAEftkC,EAAKE,WAAY,CACnB,MAAM2lC,QAAqB74C,KAAK84C,eAAe9lC,EAAK7R,MACpD6R,EAAK7R,KAAO03C,EACZ7lC,EAAKE,YAAa,CACpB,CAEAI,EAAM7M,KAAKuM,EACb,CACF,CAAE,MAAO3T,GAET,CAEJ,CAEA,OAAOiU,CACT,CAKA,YAAMmmC,CAAOl0C,GAEXvF,KAAK+1C,YAAY1yC,OAAOkC,GAEpBvF,KAAK2R,WACa3R,KAAK2R,UAAUwB,YAAY,CAAC,SAAU,WAAY,WAAY,aACxDb,YAAYtS,KAAKi4C,mBAAmB1yC,IACxDlC,OAAOkC,GAGXvF,KAAKiV,cACPjV,KAAKiV,aAAaxN,WAAW,QAAQlC,EAEzC,CAKA,WAAMqO,GAGJ,GAFA5T,KAAK+1C,YAAYniC,QAEb5T,KAAK2R,UAAW,CAClB,MAAMwB,EAAcnT,KAAK2R,UAAUwB,YAAY,CAAC,SAAU,WAAY,WAAY,aAClFA,EAAYb,YAAY,UAAUsB,QAClCT,EAAYb,YAAY,YAAYsB,QACpCT,EAAYb,YAAY,WAAWsB,OACrC,CAEA,GAAI5T,KAAKiV,aAAc,CACrB,MAAMykC,EAAyB,GAC/B,IAAK,IAAIh3C,EAAI,EAAO1C,KAAKiV,aAAarV,OAAtB8C,EAA8BA,IAAK,CACjD,MAAM2M,EAAMrP,KAAKiV,aAAa5F,IAAI3M,GAC9B2M,GAAOA,EAAIqB,WAAW,UACxBgpC,EAAajzC,KAAK4I,EAEtB,CACAqqC,EAAarxC,QAAQgH,GAAOrP,KAAKiV,aAAcxN,WAAW4H,GAC5D,CACF,CAEQ,yBAAMuoC,CAAoBR,EAAmBuC,GAEnD,aADoB35C,KAAKm2C,aAAayD,SAASxC,EAAK1sC,OACtCmvC,WAAaF,CAC7B,CAEQ,eAAM9B,CAAUT,EAAmBuC,SAEnC35C,KAAK4S,oBAAoBwkC,SAGrBp3C,KAAK43C,oBAAoBR,EAAMuC,UAKnC35C,KAAK85C,sBAAsB1C,EAAMuC,EACzC,CAEQ,yBAAM/mC,CAAoBwkC,GAChC,MAAMp2C,EAAMD,KAAKC,MAEjB,OAAQo2C,EAAK1sC,MACX,IAAK,MACH,IAAK,MAAOnF,EAAIyN,KAAShT,KAAK+1C,aACvB/iC,EAAKwkC,WAAax2C,EAAMgS,EAAKwkC,WAC7Bx2C,EAAMgS,EAAKpO,UAAYwyC,EAAKX,gBAC/Bz2C,KAAK+1C,YAAY1yC,OAAOkC,GAG5B,MAEF,IAAK,OACH,GAAIvF,KAAK2R,UAAW,CAElB,MAAMooC,EAAS,CAAC,SAAU,WAAY,WACtC,IAAK,MAAMxoC,KAAawoC,QAChB/5C,KAAKg6C,sBAAsBzoC,EAAW6lC,EAAKX,cAErD,CACA,MAEF,IAAK,OACCz2C,KAAKiV,oBACDjV,KAAKi6C,oBAAoB7C,EAAKX,eAI5C,CAEQ,2BAAMqD,CAAsB1C,EAAmBuC,GAErD,MAAMP,EAAgB,CAAEpvB,IAAK,EAAGD,OAAQ,EAAGD,KAAM,EAAGimB,SAAU,GAC9D,IAAImK,EAAc,EAIlB,GAAkB,QAAd9C,EAAK1sC,KAAgB,CACvB,MAAMyvC,EAAcv3C,MAAMC,KAAK7C,KAAK+1C,YAAY19B,UAAUL,KAAK,CAAC+lB,EAAGC,KACjE,MAAMqb,EAAeD,EAAcrb,EAAEjK,UAAYslB,EAAcpb,EAAElK,UACjE,OAAqB,IAAjBulB,EAA2BA,EACxBtb,EAAEn5B,UAAYo5B,EAAEp5B,YAGzB,IAAK,MAAMoO,KAAQmnC,EAAa,CAC9B,GAAID,GAAeP,EAAc,MACjC35C,KAAK+1C,YAAY1yC,OAAO2P,EAAKzN,IAC7B20C,GAAelnC,EAAK5C,IACtB,CACF,CACF,CAGQ,UAAAvR,CAAW+J,GACjB,MAAO,GAAGA,KAAQ7H,KAAKC,SAAS/B,KAAKC,SAASC,SAAS,IAAI4V,OAAO,EAAG,IACvE,CAEQ,aAAAoiC,CAAch2C,GACpB,OAAqC,EAA9BmD,KAAKC,UAAUpD,GAAMvB,MAC9B,CAEQ,iBAAA83C,CAAkBv2C,GAExB,MAAMwoC,EAAMrlC,KAAKC,UAAUpD,GAC3B,IAAIinB,EAAO,EACX,IAAK,IAAI1lB,EAAI,EAAOinC,EAAI/pC,OAAR8C,EAAgBA,IAE9B0lB,GAASA,GAAQ,GAAKA,EADTuhB,EAAIthB,WAAW3lB,GAE5B0lB,GAAcA,EAEhB,MAAOA,IACT,CAEQ,qBAAAowB,CAAsBxlC,GAC5B,OAAKA,EAAKykC,UAEcz3C,KAAK03C,kBAAkB1kC,EAAK7R,QACzB6R,EAAKykC,QAClC,CAEQ,aAAAgB,CAAczlC,GAEpB,MAAyB,aAAlBA,EAAK8gB,UACc,SAAlB9gB,EAAK8gB,UAAqD,IAA9B/yB,KAAKC,MAAQgS,EAAKpO,SACxD,CAEQ,iBAAM8zC,CAAe1lC,GAE3B,MAAMonC,EAAUp6C,KAAK81C,MAAM9yC,IAAI,aACzBhD,KAAK23C,YAAY3kC,EAAMonC,SAGvBp6C,KAAKy5C,OAAOzmC,EAAKzN,GACzB,CAEQ,kBAAMiS,CAAarW,GACzB,GAAInB,KAAKi2C,kBAEP,OAAO,IAAIrkC,QAASC,IAClB,MAAMtM,EAAKtG,QAAKC,SAEVm7C,EAAiB/hC,IACjBA,EAAEnX,KAAKoE,KAAOA,IAChBvF,KAAKi2C,kBAAmB1U,oBAAoB,UAAW8Y,GACvDxoC,EAAQ,CAAE1Q,KAAMmX,EAAEnX,KAAK+Q,OAAQgB,WAAYoF,EAAEnX,KAAK+R,eAItDlT,KAAKi2C,kBAAkBpyC,iBAAiB,UAAWw2C,GACnDr6C,KAAKi2C,kBAAkBqE,YAAY,CAAEv0B,OAAQ,WAAY5kB,OAAMoE,SAKnE,IACE,MAAM2M,QAAesF,EAAarW,GAClC,MAAO,CAAEA,KAAM+Q,EAAO/Q,KAAM+R,WAAYhB,EAAOgB,WACjD,CAAE,MAAO7T,GACP,MAAO,CAAE8B,OAAM+R,YAAY,EAC7B,CACF,CAEQ,oBAAM4lC,CAAe33C,GAC3B,OAAInB,KAAKi2C,kBACA,IAAIrkC,QAAQ,CAACC,EAASC,KAC3B,MAAMvM,EAAKtG,QAAKC,SAEVm7C,EAAiB/hC,IACjBA,EAAEnX,KAAKoE,KAAOA,IAChBvF,KAAKi2C,kBAAmB1U,oBAAoB,UAAW8Y,GACnD/hC,EAAEnX,KAAK9B,MACTyS,EAAWzN,MAAMiU,EAAEnX,KAAK9B,QAExBwS,EAAQyG,EAAEnX,KAAK+Q,UAKrBlS,KAAKi2C,kBAAkBpyC,iBAAiB,UAAWw2C,GACnDr6C,KAAKi2C,kBAAkBqE,YAAY,CAAEv0B,OAAQ,aAAc5kB,OAAMoE,SAK9C,iBAATpE,EAAoBmD,KAAKoL,MAAMvO,GAAQA,CACvD,CAEQ,iBAAMi3C,CAAYj3C,GAExB,MAAMwoC,EAAMrlC,KAAKC,UAAUpD,GAC3B,OAAOoT,KAAKo1B,EACd,CAEQ,iBAAMqP,CAAYuB,GAExB,IACE,MAAM5Q,EAAM90B,KAAK0lC,GACjB,OAAOj2C,KAAKoL,MAAMi6B,EACpB,CAAE,MAAOtqC,GACP,MAAUgF,MAAM,yBAClB,CACF,CAEQ,YAAAm1C,CAAa5wC,GACnB,OAAQA,GACN,IAAK,QAGL,QAAS,MAAO,SAFhB,IAAK,UAAW,MAAO,WACvB,IAAK,UAAW,MAAO,UAG3B,CAEQ,kBAAAqvC,CAAmB1yC,GACzB,OAAIA,EAAGmL,WAAW,UAAkB,SAChCnL,EAAGmL,WAAW,YAAoB,WAClCnL,EAAGmL,WAAW,YAAoB,UAC/B,QACT,CAEQ,2BAAMspC,CAAsBzoC,EAAmBklC,GAGvD,CAEQ,yBAAMwD,CAAoBxD,GAChC,IAAKz2C,KAAKiV,aAAc,OAExB,MAAMjU,EAAMD,KAAKC,MACX04C,EAAyB,GAE/B,IAAK,IAAIh3C,EAAI,EAAO1C,KAAKiV,aAAarV,OAAtB8C,EAA8BA,IAAK,CACjD,MAAM2M,EAAMrP,KAAKiV,aAAa5F,IAAI3M,GAClC,GAAI2M,GAAOA,EAAIqB,WAAW,SACxB,IACE,MAAMqoC,EAAW/4C,KAAKiV,aAAajN,QAAQqH,GACvC0pC,GAEE/3C,EADSsD,KAAKoL,MAAMqpC,GACTn0C,UAAY6xC,GACzBiD,EAAajzC,KAAK4I,EAGxB,CAAE,MAAOhQ,GAEPq6C,EAAajzC,KAAK4I,EACpB,CAEJ,CAEAqqC,EAAarxC,QAAQgH,GAAOrP,KAAKiV,aAAcxN,WAAW4H,GAC5D,CAEQ,sBAAA0nC,GAENjqC,YAAY,KACV9M,KAAK81C,MAAMztC,QAAQ2E,MAAOoqC,UAClBp3C,KAAK4S,oBAAoBwkC,MAEhC,IACL,CAKA,eAAMoD,CAAUnrC,EAAalO,EAAWmF,GAMtC,MAAM8wC,EAAOp3C,KAAKq3C,kBAAkB/wC,EAAQwtB,SAAUxvB,KAAKC,UAAUpD,GAAMvB,QACrE0H,EAAUtH,KAAKy6C,iBAAiBz3C,IAAIo0C,GAC1C,IAAK9vC,EACH,MAAUjD,MAAM,gBAAgB+yC,mBAGlC,IAAIe,EAAgBh3C,EAChBmF,EAAQ2M,WACVklC,EAAgBn4C,KAAKwX,aAAarW,UAG9BmG,EAAQE,QAAQ6H,EAAK/K,KAAKC,UAAU,CACxCpD,KAAMg3C,EACN93B,SAAU,CACRyT,SAAUxtB,EAAQwtB,SAClBsjB,OACAlkC,WAAY5M,EAAQ2M,WAAY,EAChCrO,UAAW7D,KAAKC,SAGtB,CAKA,aAAM05C,CAAQrrC,SACZ,IAAK,MAAOipC,EAAUhxC,KAAYtH,KAAKy6C,iBACrC,IACE,MAAMznC,QAAa1L,EAAQU,QAAQqH,GACnC,GAAI2D,EAAM,CACR,MAAM2nC,EAASr2C,KAAKoL,MAAMsD,GAC1B,eAAOnR,EAAA84C,EAAOt6B,+BAAUnN,YAAalT,KAAK84C,eAAe6B,EAAOx5C,MAAQw5C,EAAOx5C,IACjF,CACF,CAAE,MAAO9B,GAET,CAEF,OAAO,IACT,CAKA,gBAAMu7C,CAAWvrC,SACTuC,QAAQglC,IACZh0C,MAAMC,KAAK7C,KAAKy6C,iBAAiBpiC,UAAU7Y,IAAI8H,GAC7CA,EAAQG,WAAW4H,GAAK8P,MAAM,SAGpC,CAKA,yBAAM07B,CAAoBxqC,SACxB,MAAMyqC,EAA2D,GAC3DhS,EAAY/3B,OAAOV,EAAQvR,QAAQ,IAAK,OAE9C,IAAK,MAAOw5C,EAAUhxC,KAAYtH,KAAKy6C,iBACrC,IACE,IAAK,IAAI/3C,EAAI,EAAO4E,EAAQ1H,OAAZ8C,EAAoBA,IAAK,CACvC,MAAM2M,EAAM/H,EAAQ+H,IAAI3M,GACxB,GAAI2M,GAAOy5B,EAAMx4B,KAAKjB,GAAM,CAC1B,MAAM2D,QAAa1L,EAAQU,QAAQqH,GACnC,GAAI2D,EAAM,CACR,MAAM2nC,EAASr2C,KAAKoL,MAAMsD,GAC1B8nC,EAAQr0C,KAAK,CACX4I,MACAlO,MAAqB,QAAfU,EAAA84C,EAAOt6B,gBAAQ,IAAAxe,OAAA,EAAAA,EAAEqR,YAAalT,KAAK84C,eAAe6B,EAAOx5C,MAAQw5C,EAAOx5C,KAC9Ekf,SAAUs6B,EAAOt6B,UAErB,CACF,CACF,CACF,CAAE,MAAOhhB,GAET,CAGF,OAAOy7C,CACT,CAEQ,iBAAAzD,CAAkBvjB,EAAkBojB,GAC1C,MAAiB,aAAbpjB,GACa,SAAbA,GAAkC,IAAXojB,EADS,MAEnB,QAAbpjB,GAAsBojB,EAAW,IAAe,OAC7C,MACT,CAEQ,YAAA1/B,CAAarW,GAEnB,OAAOA,CACT,CAEQ,cAAA23C,CAAe33C,GAErB,OAAOA,CACT,CAKA,cAAMivC,GAgBJ,MAd4B,CAC1B2K,WAAY,EACZC,UAAW,EACXC,gBAAiB,CAAElL,SAAU,EAAGjmB,KAAM,EAAGC,OAAQ,EAAGC,IAAK,GACzDkxB,YAAa,CAAEC,IAAK,EAAGC,KAAM,EAAGC,KAAM,GACtC3jC,iBAAkB,GAClB4jC,iBAAkBt7C,KAAKm2C,aAAaoF,gBACpCC,UAAW,CACTL,IAAK,CAAEM,UAAW,EAAGC,UAAW,EAAGC,UAAW,GAC9CP,KAAM,CAAEK,UAAW,EAAGC,UAAW,EAAGC,UAAW,GAC/CN,KAAM,CAAEI,UAAW,EAAGC,UAAW,EAAGC,UAAW,IAKrD,CAKA,YAAAnL,CAAajtC,GACXvD,KAAKuD,OAAS,IAAKvD,KAAKuD,UAAWA,EACrC,CAKA,UAAA8sC,GAEA,EAMF,MAAM+F,EAAN,WAAAr2C,GACUC,KAAA47C,OAAoC,IAAIz7C,GAmClD,CAjCE,gBAAMuR,GACJ,GAAI,YAAa5L,WAAa,aAAcA,UAAUwB,QAAS,CAC7D,MAAMu0C,QAAiB/1C,UAAUwB,QAAQu0C,WACnCC,EAAQD,EAASE,OAAS,EAC1BC,EAAOH,EAASI,OAAS,EAE/Bj8C,KAAK47C,OAAO34C,IAAI,SAAU,CACxB64C,QACAE,OACAnC,UAAWiC,EAAQE,EACnBE,WAAYJ,EAAQ,EAAKE,EAAOF,EAAS,IAAM,GAEnD,CACF,CAEA,cAAMlC,CAAStB,GAEb,OAAOt4C,KAAK47C,OAAO54C,IAAI,WAAa,CAClC84C,MAAO,EACPE,KAAM,EACNnC,UAAW,EACXqC,WAAY,EAEhB,CAEA,mBAAMX,GACJ,OAAOv7C,KAAK47C,OAAO54C,IAAI,WAAa,CAClC84C,MAAO,EACPE,KAAM,EACNnC,UAAW,EACXqC,WAAY,EAEhB,QCn6BWC,EASX,WAAAp8C,CACU2K,EACRnH,GADQvD,KAAA0K,KAAAA,EAPF1K,KAAAo8C,cAAuC,KACvCp8C,KAAAmW,UAAmD,GACnDnW,KAAAq8C,eAAuF,GACvFr8C,KAAAgxC,WAAa,IACbhxC,KAAAs8C,WAAY,EAMlBt8C,KAAKuD,OAAS,CACZg5C,SAAU,IACVtO,QAAS,IACTuO,SAAU,GACVvvC,OAAQ,OACRwvC,eAAgB,CAAC,IAAK,KACtBlF,WAAY,EACZ3G,iBAAkB,EAClB8L,kBAAmB,EACnBC,qBAAsB,GACtB5M,UAAU,KACPxsC,GAGLvD,KAAKkxC,QAAUlxC,KAAK48C,mBACtB,CAEQ,iBAAAA,GACN,MAAO,CACLruC,aAAc,GACdsuC,YAAa,EACbC,UAAW,EACXC,aAAc,EACdC,UAAW,EACXC,oBAAqB,EACrBC,qBAAsB,EACtB3L,oBAAqB,EACrB4L,gBAAiB,EACjBC,gBAAiB,EACjB5K,cAAe,EACf6K,YAAa,EACbC,OAAQ,EACRC,SAAU,EAEd,CAKA,KAAA7/B,GACM1d,KAAKs8C,YAETt8C,KAAKs8C,WAAY,EACjBt8C,KAAKw9C,gBACP,CAKA,IAAA5hB,GACE57B,KAAKs8C,WAAY,EACbt8C,KAAKo8C,gBACPtzC,aAAa9I,KAAKo8C,eAClBp8C,KAAKo8C,cAAgB,KAEzB,CAEQ,aAAAoB,GACDx9C,KAAKs8C,YAEVt8C,KAAKo8C,cAAgBrzC,WAAWiE,gBACxBhN,KAAKy9C,qBACXz9C,KAAKw9C,iBACJx9C,KAAKuD,OAAOg5C,UACjB,CAEQ,wBAAMkB,GACZ,MAAM38C,EAAYC,KAAKC,MACvB,IAEI3B,EAFA+mB,GAAU,EACV7X,EAAe,EAGnB,IACE,IAAK,IAAIuI,EAAU,EAAc9W,KAAKuD,OAAOg0C,YAAvBzgC,EAAmCA,IACvD,IACE,MAAM4mC,EAAiB38C,KAAKC,MACtB2M,QAAiB3N,KAAK29C,qBAG5B,GAFApvC,EAAexN,KAAKC,MAAQ08C,EAExB19C,KAAKuD,OAAOk5C,eAAehyC,SAASkD,EAASW,QAAS,CACxD8X,GAAU,EACV,KACF,CACE,MAAU/hB,MAAM,2BAA2BsJ,EAASW,OAExD,CAAE,MAAOsvC,GACP,GAAI9mC,IAAY9W,KAAKuD,OAAOg0C,WAC1B,MAAMqG,QAGF59C,KAAK0vC,MAAM,IAAOzwC,KAAKgY,IAAI,EAAGH,GACtC,CAEJ,CAAE,MAAO+mC,GACPx+C,EAAQw+C,EAAW75C,QACnBuK,EAAexN,KAAKC,MAAQF,CAC9B,CAEAd,KAAK89C,kBAAkB13B,EAAS7X,EAAclP,EAChD,CAEQ,wBAAMs+C,GACZ,MAAMI,EAAa,IAAIC,gBACjBC,EAAYl1C,WAAW,IAAMg1C,EAAWG,QAASl+C,KAAKuD,OAAO0qC,SAEnE,IAUE,aATuB9hC,MAAMnM,KAAKuD,OAAOi5C,SAAU,CACjDvvC,OAAQjN,KAAKuD,OAAO0J,OACpBkxC,OAAQJ,EAAWI,OACnB5mC,MAAO,WACP3V,QAAS,CACP,aAAc,2BAKpB,SACEkH,aAAam1C,EACf,CACF,CAEQ,iBAAAH,CAAkB13B,EAAkB7X,EAAsBlP,GAChE,MAAMuF,EAAY7D,KAAKC,MAGvBhB,KAAKq8C,eAAe51C,KAAK,CAAE7B,YAAWwhB,UAAS7X,iBAC/CvO,KAAKo+C,oBAGLp+C,KAAKgyC,cAAc5rB,EAAS7X,GAGxB6X,GACFpmB,KAAKkxC,QAAQ+L,oBAAsB,EACnCj9C,KAAKkxC,QAAQgM,yBAEbl9C,KAAKkxC,QAAQgM,qBAAuB,EACpCl9C,KAAKkxC,QAAQ+L,uBAGfj9C,KAAKkxC,QAAQ8L,UAAYp4C,EAGzB,MAAM0J,EAAStO,KAAKq+C,sBAAsBh/C,GAC1CW,KAAKoW,gBAAgB9H,EACvB,CAEQ,iBAAA8vC,GACN,MAAMj7C,EAASpC,KAAKC,MAAQhB,KAAKgxC,WACjChxC,KAAKq8C,eAAiBr8C,KAAKq8C,eAAe18C,OAAO4yC,GAAOA,EAAI3tC,UAAYzB,EAC1E,CAEQ,aAAA6uC,CAAc5rB,EAAkB7X,GACtCvO,KAAKkxC,QAAQsB,gBAERpsB,GACHpmB,KAAKkxC,QAAQmM,cAIfr9C,KAAKkxC,QAAQ3iC,aAAa9H,KAAK8H,GAC3BvO,KAAKkxC,QAAQ3iC,aAAa3O,OAAS,KACrCI,KAAKkxC,QAAQ3iC,aAAa+vC,QAI5B,MAAMC,EAAiBv+C,KAAKq8C,eAAez8C,OACrC4+C,EAAkBx+C,KAAKq8C,eAAe18C,OAAOX,GAAKA,EAAEonB,SAASxmB,OAC7D6+C,EAAeF,EAAiBC,EAEtCx+C,KAAKkxC,QAAQ2L,YAAc0B,EAAiB,EAAIC,EAAkBD,EAAiB,EACnFv+C,KAAKkxC,QAAQ4L,UAAYyB,EAAiB,EAAIE,EAAeF,EAAiB,EAG9E,MAAMG,EAAY1+C,KAAKkxC,QAAQsB,cAAgBxyC,KAAKuD,OAAOg5C,SAK3D,GAHAv8C,KAAKkxC,QAAQ6L,aAAe2B,EAAY,EAAI,EADlB1+C,KAAKkxC,QAAQmM,YAAcr9C,KAAKuD,OAAOg5C,SACImC,EAAa,EAG9E1+C,KAAKkxC,QAAQ3iC,aAAa3O,OAAS,EAAG,CACxC,MAAM++C,EAAS,IAAI3+C,KAAKkxC,QAAQ3iC,cAAcyJ,KAAK,CAAC+lB,EAAGC,IAAMD,EAAIC,GACjEh+B,KAAKkxC,QAAQK,oBAAsBoN,EAAOxhC,OAAO,CAAC4gB,EAAGC,IAAMD,EAAIC,GAAK2gB,EAAO/+C,OAC3EI,KAAKkxC,QAAQiM,gBAAkBwB,EAAO1/C,KAAK0D,MAAsB,IAAhBg8C,EAAO/+C,SACxDI,KAAKkxC,QAAQkM,gBAAkBuB,EAAO1/C,KAAK0D,MAAsB,IAAhBg8C,EAAO/+C,QAC1D,CACF,CAEQ,qBAAAy+C,CAAsBh/C,GAC5B,IAAIiP,EAAiC,UACjCswC,EAA+B,SAC/BC,EAAa,GAejB,GAZwC7+C,KAAKuD,OAAOqtC,iBAAhD5wC,KAAKkxC,QAAQ+L,oBAGNj9C,KAAKkxC,QAAQ4L,UAAY98C,KAAKuD,OAAOo5C,sBAC9CruC,EAAS,WACTuwC,EAAa5/C,KAAK+X,IAAI,GAA8B,EAAzBhX,KAAKkxC,QAAQ4L,YACM98C,KAAKuD,OAAOm5C,kBAAjD18C,KAAKkxC,QAAQgM,uBACtB5uC,EAAS,UACTuwC,EAAa5/C,KAAK+X,IAAI,IAAMhX,KAAKkxC,QAAQgM,sBAAwD,EAAhCl9C,KAAKuD,OAAOm5C,sBAP7EpuC,EAAS,YACTuwC,EAAa5/C,KAAK+X,IAAI,GAAKhX,KAAKkxC,QAAQ+L,qBAAsD,EAA/Bj9C,KAAKuD,OAAOqtC,oBAUzE5wC,KAAKq8C,eAAez8C,QAAU,GAAI,CACpC,MAAMk/C,EAAa9+C,KAAKq8C,eAAetyC,OAAM,GACvCg1C,EAAc/+C,KAAKq8C,eAAetyC,OAAM,IAAK,GAE7Ci1C,EAAoBF,EAAWn/C,OAAOX,GAAKA,EAAEonB,SAASxmB,OAASk/C,EAAWl/C,OAC1Eq/C,EAAqBF,EAAYp/C,OAAOX,GAAKA,EAAEonB,SAASxmB,OAASm/C,EAAYn/C,OAE/Eo/C,EAAoBC,EAAqB,GAC3CL,EAAQ,YACqBK,EAAqB,GAAzCD,IACTJ,EAAQ,YAEZ,CAEA,MAAO,CACLtwC,SACA4wC,YAAal/C,KAAKkxC,QAAQ8L,UAC1BzuC,aAAcvO,KAAKkxC,QAAQK,oBAC3BlyC,QACA6xC,QAAS,IAAKlxC,KAAKkxC,SACnB0N,QACAC,aAEJ,CAEQ,KAAAnP,CAAMS,GACZ,OAAO,IAAIv+B,QAAQC,GAAW9I,WAAW8I,EAASs+B,GACpD,CAKA,eAAAgP,GACE,OAAOn/C,KAAKq+C,uBACd,CAKA,UAAAzL,GACE,MAAO,IAAK5yC,KAAKkxC,QACnB,CAKA,gBAAMkO,GAEJ,aADMp/C,KAAKy9C,qBACJz9C,KAAKm/C,iBACd,CAKA,cAAAE,CAAe5oC,GAEb,OADAzW,KAAKmW,UAAU1P,KAAKgQ,GACb,KACL,MAAM1C,EAAQ/T,KAAKmW,UAAUO,QAAQD,GACjC1C,GAAQ,GACV/T,KAAKmW,UAAUxP,OAAOoN,EAAO,GAGnC,CAEQ,eAAAqC,CAAgB9H,GACtBtO,KAAKmW,UAAU9N,QAAQoO,IACrB,IACEA,EAASnI,EACX,CAAE,MAAOjP,GAET,GAEJ,CAKA,YAAAmxC,CAAaC,GACX,MAAM6O,EAAct/C,KAAKuD,OAAOg5C,SAChCv8C,KAAKuD,OAAS,IAAKvD,KAAKuD,UAAWktC,GAG/BzwC,KAAKs8C,WAAagD,IAAgBt/C,KAAKuD,OAAOg5C,WAChDv8C,KAAK47B,OACL57B,KAAK0d,QAET,CAKA,KAAAq1B,GACE/yC,KAAKkxC,QAAUlxC,KAAK48C,oBACpB58C,KAAKq8C,eAAiB,EACxB,QAMWkD,EAOX,WAAAx/C,GANQC,KAAAw/C,iBAAmB,IAAIr/C,IACvBH,KAAAy/C,cAA+B,KAC/Bz/C,KAAA0/C,gBAA0F,GAC1F1/C,KAAAmW,UAAuD,GAI7DnW,KAAK2/C,iBAAmB,IAAIC,CAC9B,CAKA,cAAAC,CACEC,EACAtD,EACA1oB,EACAvwB,GAEA,MAAMw8C,EAAU,IAAI5D,EAAsB,UAAU2D,EAAU,CAC5DtD,WACAzM,SAAuB,IAAbjc,KACPvwB,IAaL,OATKvD,KAAKy/C,eAA8B,IAAb3rB,IACzB9zB,KAAKy/C,cAAgBK,GAGvBC,EAAQV,eAAgB/wC,IACtBtO,KAAKggD,2BAA2BF,EAAQxxC,KAG1CtO,KAAKw/C,iBAAiBv8C,IAAI68C,EAAQC,GAC3BA,CACT,CAKA,QAAAE,GACEjgD,KAAKw/C,iBAAiBn3C,QAAQ03C,GAAWA,EAAQriC,QACnD,CAKA,OAAAwiC,GACElgD,KAAKw/C,iBAAiBn3C,QAAQ03C,GAAWA,EAAQnkB,OACnD,CAEQ,0BAAAokB,CAA2BF,EAAgBxxC,GACjDtO,KAAKoW,gBAAgB,yBAA0B,CAAE0pC,SAAQxxC,WAGrDwxC,IAAW9/C,KAAKy/C,eAAmC,cAAlBnxC,EAAOA,QAC1CtO,KAAKmgD,gBAAgBL,EAAQ,qBAI/B9/C,KAAK2/C,iBAAiBS,qBAAqBN,EAAQxxC,EACrD,CAEQ,eAAA6xC,CAAgBE,EAAoBj8C,GAE1C,MAAMk8C,EAAmB19C,MAAMC,KAAK7C,KAAKw/C,iBAAiBp8C,WACvDzD,OAAO,EAAEmgD,EAAQC,KAChBD,IAAWO,GAC0B,cAArCN,EAAQZ,kBAAkB7wC,QAE3B0J,KAAK,EAAC,CAAG+lB,IAAI,CAAGC,MACf,MAAMuiB,EAAUxiB,EAAEohB,kBACZqB,EAAUxiB,EAAEmhB,kBAGlB,MAAuB,YAAnBoB,EAAQjyC,QAA2C,YAAnBkyC,EAAQlyC,QAA6B,EAClD,YAAnBkyC,EAAQlyC,QAA2C,YAAnBiyC,EAAQjyC,OAA6B,GAGjEiyC,EAAQhyC,cAAgB0uB,MAAaujB,EAAQjyC,cAAgB0uB,OAGzE,GAAIqjB,EAAiB1gD,OAAS,EAAG,CAC/B,MAAO6gD,GAAoBH,EAAiB,GAG5CtgD,KAAKy/C,cAAgBgB,EAErBzgD,KAAK0/C,gBAAgBj5C,KAAK,CACxB5D,KAAMw9C,EACNK,GAAID,EACJ77C,UAAW7D,KAAKC,MAChBoD,WAGFpE,KAAKoW,gBAAgB,WAAY,CAC/BvT,KAAMw9C,EACNK,GAAID,EACJr8C,SACAQ,UAAW7D,KAAKC,QAIlBhB,KAAK2/C,iBAAiBgB,eAAeN,EAAYI,EAAkBr8C,EACrE,CACF,CAKA,gBAAAw8C,GACE,OAAO5gD,KAAKy/C,aACd,CAKA,oBAAAoB,GACE,OAAOj+C,MAAMC,KAAK7C,KAAKw/C,iBAAiBp8C,WAAW5D,IAAI,EAAEsgD,EAAQC,YAAa,MAAA,CAC5ED,SACAtD,SAAUuD,EAAgB,OAAEvD,SAC5BluC,OAAQyxC,EAAQZ,kBAChBrrB,SAAUgsB,IAAW9/C,KAAKy/C,cAAgB,EAAI,EAC9CqB,qBAAcj/C,EAAA7B,KAAK0/C,gBAChB//C,OAAOohD,GAAKA,EAAEL,KAAOZ,GACrB9nC,KAAK,CAAC+lB,EAAGC,IAAMA,EAAEp5B,UAAYm5B,EAAEn5B,WAAW,yBAAIA,YAErD,CAKA,kBAAAo8C,GACE,MAAO,IAAIhhD,KAAK0/C,gBAClB,CAKA,kCAAAuB,GACE,OAAOjhD,KAAK2/C,iBAAiBuB,oBAC/B,CAKA,aAAAC,CAAcC,EAAkBh9C,EAAiB,UAC3CpE,KAAKw/C,iBAAiBvnC,IAAImpC,IAC5BphD,KAAKmgD,gBAAgBngD,KAAKy/C,eAAiB,UAAWr7C,EAE1D,CAKA,OAAA+wC,CAAQ1+B,GAEN,OADAzW,KAAKmW,UAAU1P,KAAKgQ,GACb,KACL,MAAM1C,EAAQ/T,KAAKmW,UAAUO,QAAQD,GACjC1C,GAAQ,GACV/T,KAAKmW,UAAUxP,OAAOoN,EAAO,GAGnC,CAEQ,eAAAqC,CAAgBtS,EAAe3C,GACrCnB,KAAKmW,UAAU9N,QAAQoO,IACrB,IACEA,EAAS3S,EAAO3C,EAClB,CAAE,MAAO9B,GAET,GAEJ,CAKA,cAAAo2C,GACE,MAAM4L,EAAWz+C,MAAMC,KAAK7C,KAAKw/C,iBAAiBnnC,UAAU7Y,IAAIugD,GAAWA,EAAQ3P,YAC7EkR,EAAaD,EAASlkC,OAAO,CAACoyB,EAAKpS,IAAUoS,EAAMpS,EAAMokB,eAAgB,GAAKF,EAASzhD,OACvF4hD,EAAeH,EAASlkC,OAAO,CAACoyB,EAAKpS,IAAUoS,EAAMpS,EAAM2f,UAAW,GAAKuE,EAASzhD,OAE1F,MAAO,CACL6hD,QAASzhD,KAAKuD,OAAOk+C,QAAQ7hD,OAC7B8hD,UAAWlyC,OAAOuI,KAAK/X,KAAKuD,OAAOm+C,WAAW9hD,OAC9C6/C,cAAez/C,KAAKy/C,cACpBkC,YAAaN,EAASlkC,OAAO,CAACoyB,EAAKpS,IAAUoS,EAAMpS,EAAMwkB,YAAa,GACtEJ,eAAgBD,GAAc,EAC9BM,iBAAkBJ,GAAgB,EAClCK,UAAW7hD,KAAK0/C,gBAAgB9/C,OAChC+/C,iBAAkB3/C,KAAK2/C,iBAAiBuB,qBAE5C,CAKA,UAAA7Q,GACErwC,KAAKw/C,iBAAiBn3C,QAAQ03C,GAAWA,EAAQ1P,cACjDrwC,KAAK0/C,gBAAkB,GACvB1/C,KAAK2/C,iBAAiB5M,OACxB,CAKA,YAAAvC,CAAajtC,GACXvD,KAAKuD,OAAS,IAAKvD,KAAKuD,UAAWA,EACrC,CAKA,OAAA0N,GACEjR,KAAKw/C,iBAAiBn3C,QAAQ03C,GAAWA,EAAQ9uC,WACjDjR,KAAKw/C,iBAAiB5rC,QACtB5T,KAAKmW,UAAY,EACnB,EAMF,MAAMypC,EAAN,WAAA7/C,GACUC,KAAA8hD,sBAAwB,IAAI3hD,IAC5BH,KAAA+hD,iBAA2F,GAC3F/hD,KAAAgiD,iBAAmB,CACzBC,gBAAiB,IACjB1iC,UAAW,GACXpB,cAAe,EACf2vB,kBAAmB,EA+FvB,CA5FE,oBAAAsS,CAAqBN,EAAgBxxC,GAC9BtO,KAAK8hD,sBAAsB7pC,IAAI6nC,IAClC9/C,KAAK8hD,sBAAsB7+C,IAAI68C,EAAQ,IAGzC,MAAM34B,EAAUnnB,KAAK8hD,sBAAsB9+C,IAAI88C,GAC/C34B,EAAQ1gB,KAAK6H,GAGT6Y,EAAQvnB,OAAS,KACnBunB,EAAQm3B,QAIVt+C,KAAKkiD,uBAAuBpC,EAAQxxC,EACtC,CAEA,cAAAqyC,CAAe99C,EAAc69C,EAAYt8C,GACvCpE,KAAK+hD,iBAAiBt7C,KAAK,CAAE5D,OAAM69C,KAAI97C,UAAW7D,KAAKC,MAAOoD,WAG1DpE,KAAK+hD,iBAAiBniD,OAAS,IACjCI,KAAK+hD,iBAAiBzD,OAE1B,CAEQ,sBAAA4D,CAAuBpC,EAAgBxxC,GAEvB,cAAlBA,EAAOA,OACTtO,KAAKgiD,iBAAiBC,gBAAkBhjD,KAAK+X,IAA4C,EAAxChX,KAAKgiD,iBAAiBC,gBAAqB,KACjE,YAAlB3zC,EAAOA,SAChBtO,KAAKgiD,iBAAiBC,gBAAkBhjD,KAAKkrB,IAA4C,GAAxCnqB,KAAKgiD,iBAAiBC,gBAAuB,MAI5F3zC,EAAOC,cAAgBD,EAAOC,aAAe,IAC/CvO,KAAKgiD,iBAAiBziC,UAAYtgB,KAAKkrB,IAAInqB,KAAKgiD,iBAAiBziC,UAAY,EAAG,GACvEjR,EAAOC,cAAsC,IAAtBD,EAAOC,eACvCvO,KAAKgiD,iBAAiBziC,UAAYtgB,KAAK+X,IAAIhX,KAAKgiD,iBAAiBziC,UAAY,EAAG,MAI9EjR,EAAO4iC,QAAQ4L,UAAY,GAC7B98C,KAAKgiD,iBAAiB7jC,cAAgBlf,KAAK+X,IAAIhX,KAAKgiD,iBAAiB7jC,cAAgB,EAAG,IACpD,IAA3B7P,EAAO4iC,QAAQ4L,YACxB98C,KAAKgiD,iBAAiB7jC,cAAgBlf,KAAKkrB,IAAInqB,KAAKgiD,iBAAiB7jC,cAAgB,EAAG,GAE5F,CAEA,kBAAA+iC,GAIE,MAAMiB,EAAsB,GAC5B,IAAItD,EAAa,GAqBjB,OAlBI7+C,KAAKgiD,iBAAiBC,gBAAkB,KAC1CE,EAAU17C,KAAK,mDAEqB,GAAlCzG,KAAKgiD,iBAAiBziC,WACxB4iC,EAAU17C,KAAK,iDAEbzG,KAAKgiD,iBAAiB7jC,cAAgB,GACxCgkC,EAAU17C,KAAK,oDAIU7D,MAAMC,KAAK7C,KAAK8hD,sBAAsBzpC,UAC9D8E,OAAO,CAACoyB,EAAKpoB,IAAYooB,EAAMpoB,EAAQvnB,OAAQ,GAEzB,KACvBi/C,EAAa5/C,KAAK+X,IAAI,IAAM6nC,EAAa,KAGpC,IACF7+C,KAAKgiD,iBACRnD,aACAsD,YAEJ,CAEA,KAAApP,GACE/yC,KAAK8hD,sBAAsBluC,QAC3B5T,KAAK+hD,iBAAmB,GACxB/hD,KAAKgiD,iBAAmB,CACtBC,gBAAiB,IACjB1iC,UAAW,GACXpB,cAAe,EACf2vB,kBAAmB,EAEvB,QCroBWsU,EAWX,WAAAriD,CACEuH,EACA/D,EAA8B,IAVxBvD,KAAAqiD,cAA8C,KAC9CriD,KAAAsiD,YAA4C,KAC5CtiD,KAAAuiD,YAAkC,KAElCviD,KAAAmW,UAAqD,GACrDnW,KAAAwiD,gBAA0C,KAC1CxiD,KAAAyiD,YAAqG,GAM3GziD,KAAKsH,QAAUA,EACftH,KAAK0iD,aAAe,IAAItV,EAAa,CACnCO,YAAa,EACbviB,UAAW,IACXwiB,SAAU,IACVI,cAAc,IAGhBhuC,KAAKuD,OAAS,CACZgc,UAAW,GACXojC,qBAAsB,EACtBC,gBAAiB,CACf7S,SAAU,EACVjmB,KAAM,GACNC,OAAQ,GACRC,IAAK,IAEP64B,qBAAqB,EACrBC,iBAAiB,EACjBC,mBAAoB,iBACpBC,YAAa,IACbC,kBAAkB,KACf1/C,EAEP,CAKA,UAAAmO,CAAWwxC,EAAqBb,GAC1BA,EACFriD,KAAKqiD,cAAgBA,GAErBriD,KAAKqiD,cAAgB,IAAIlG,EAAsB,cAAe,CAC5DK,SAAa0G,EAAH,UACV3G,SAAU,IACVtO,QAAS,MAEXjuC,KAAKqiD,cAAc3kC,SAIrB1d,KAAKmjD,uBACP,CAEQ,qBAAAA,GACgB,oBAAXv/C,SAEXA,OAAOC,iBAAiB,SAAU,KAChC7D,KAAKojD,8BAIP76C,SAAS1E,iBAAiB,mBAAoB,MACvC0E,SAASM,QAAU/C,UAAUmQ,QAChCjW,KAAKojD,8BAGX,CAEQ,+BAAMA,SAENpjD,KAAK0vC,MAAM,KAGb1vC,KAAKqiD,eAEe,qBADDriD,KAAKqiD,cAAcjD,cAC7B9wC,QAORtO,KAAKsiD,aACRtiD,KAAKqjD,sBAET,CAKA,0BAAMA,CAAqB78B,GAEzB,GAAIxmB,KAAKsiD,YACP,OAAOtiD,KAAKsiD,YAIdtiD,KAAKuiD,YAAc,CACjB38C,UAAW5F,KAAKsjD,oBAChBC,SAAUvjD,KAAKwjD,cACfC,kBAAmBzjD,KAAK0jD,uBACxBC,gBAAiB5iD,KAAKC,MAAQhB,KAAK0jD,uBACnCE,qBAAsB5jD,KAAK6jD,uBAC3BC,aAAc9jD,KAAK+jD,kBACnBC,aAAcz7C,SAASM,UACpB2d,GAILxmB,KAAKwiD,gBAAkB,IAAIxE,gBAG3Bh+C,KAAKsiD,YAActiD,KAAKikD,uBAAuBjkD,KAAKuiD,aAEpD,IACE,MAAMrwC,QAAelS,KAAKsiD,YAE1B,OADAtiD,KAAKkkD,kBAAkBhyC,GAChBA,CACT,SACElS,KAAKsiD,YAAc,KACnBtiD,KAAKuiD,YAAc,KACnBviD,KAAKwiD,gBAAkB,IACzB,CACF,CAEQ,4BAAMyB,CAAuBz9B,GACnC,MAAM29B,EAAyB,CAC7BC,MAAO,YACPrJ,WAAY,EACZsJ,YAAa,EACbC,YAAa,EACbtrC,aAAc,EACdurC,aAAc,EACdC,uBAAwB,EACxBC,iBAAkB,EAClBC,WAAY,EACZnxC,OAAQ,IAGVvT,KAAK2kD,eAAeR,GAEpB,IAEE,MAAMS,QAAiB5kD,KAAK6kD,gBAAgBr+B,GAwB5C,OAvBA29B,EAASpJ,WAAa6J,EAAS7J,WAC/BoJ,EAASI,aAAeK,EAAS7rC,QAAQnZ,OACzCukD,EAASO,WAAaE,EAASF,WAG/BP,EAASC,MAAQ,UACjBpkD,KAAK2kD,eAAeR,GAEFpjD,KAAKC,YACjBhB,KAAK8kD,mBAAmBF,EAAUT,GAGpCS,EAASG,UAAUnlD,OAAS,SACxBI,KAAKglD,iBAAiBJ,EAASG,WAGvCZ,EAASC,MAAQ,YACjBD,EAASK,uBAAyB,EAClCxkD,KAAK2kD,eAAeR,GAGpBnkD,KAAKilD,0BAEEd,CAET,CAAE,MAAO9kD,GAIP,MAHA8kD,EAASC,MAAQ,SACjBD,EAAS5wC,OAAO9M,KAAKpH,EAAM2E,SAC3BhE,KAAK2kD,eAAeR,GACd9kD,CACR,CACF,CAEQ,qBAAMwlD,CAAgBr+B,GAO5B,MAAOjT,EAAQ2xC,EAAUzxC,SAAuB7B,QAAQglC,IAAI,CAC1D52C,KAAKsH,QAAQ2xC,aAAyB,SACtCj5C,KAAKsH,QAAQ2xC,aAA2B,WACxCj5C,KAAKsH,QAAQ2xC,aAA2B,aAMpCkM,EAHW,IAAI5xC,KAAW2xC,KAAazxC,GAGhB9T,OAAOqT,GAClCA,EAAKpO,UAAY4hB,EAAQi9B,mBAI3B0B,EAAYntC,KAAK,CAAC+lB,EAAGC,KACnB,MAAMonB,EAAiBplD,KAAKuD,OAAOq/C,gBAAgB7kB,EAAEjK,UAAY9zB,KAAKuD,OAAOq/C,gBAAgB5kB,EAAElK,UAC/F,OAAuB,IAAnBsxB,GAA8BA,EAC3BrnB,EAAEn5B,UAAYo5B,EAAEp5B,YAIzB,MAAMygD,EAAmBrlD,KAAKslD,2BAA2B9+B,GAGnDzN,EAAU/Y,KAAKulD,yBAAyBJ,EAAaE,GAGrDN,QAAkB/kD,KAAKwlD,gBAAgBL,GAEvCT,EAAaS,EAAYhoC,OAAO,CAACoyB,EAAKv8B,IAASu8B,EAAMv8B,EAAK5C,KAAM,GAEtE,MAAO,CACL2I,UACAgiC,WAAYoK,EAAYvlD,OACxB8kD,aACAK,YAEJ,CAEQ,0BAAAO,CAA2B9+B,GACjC,IAAIi/B,EAAczlD,KAAKuD,OAAOgc,UAG9B,OAAQiH,EAAQo9B,gBACd,IAAK,OACH6B,EAAcxmD,KAAKkrB,IAAI,EAAiB,GAAds7B,GAC1B,MACF,IAAK,OACHA,EAAcxmD,KAAK0D,MAAoB,GAAd8iD,GACzB,MACF,IAAK,YACHA,EAAcxmD,KAAK0D,MAAoB,IAAd8iD,GAmB7B,OAdIj/B,EAAQs9B,cAAuC,GAAvBt9B,EAAQs9B,eAClC2B,EAAcxmD,KAAKkrB,IAAI,EAAiB,GAAds7B,IAIxBj/B,EAAQw9B,eACVyB,EAAcxmD,KAAKkrB,IAAI,EAAiB,GAAds7B,IAIxBj/B,EAAQm9B,gBAAkB,OAC5B8B,EAAcxmD,KAAKkrB,IAAI,GAAkB,GAAds7B,IAGtBxmD,KAAK0D,MAAM8iD,EACpB,CAEQ,wBAAAF,CACNjyC,EACAiM,GAEA,MAAMxG,EAAoF,GAGpF2sC,EAAiB,IAAIvlD,IAyB3B,OAxBAmT,EAAMjL,QAAQ2K,IACP0yC,EAAeztC,IAAIjF,EAAK8gB,WAC3B4xB,EAAeziD,IAAI+P,EAAK8gB,SAAU,IAEpC4xB,EAAe1iD,IAAIgQ,EAAK8gB,UAAWrtB,KAAKuM,KAIvB,CAAC,WAAY,OAAQ,SAAU,OACvC3K,QAAQyrB,IACjB,MAAM6xB,EAAaD,EAAe1iD,IAAI8wB,IAAa,GAEnD,IAAK,IAAIpxB,EAAI,EAAOijD,EAAW/lD,OAAf8C,EAAuBA,GAAK6c,EAAW,CACrD,MAAMqmC,EAAaD,EAAW57C,MAAMrH,EAAGA,EAAI6c,GACrCsmC,EAAiBD,EAAWzoC,OAAO,CAACoyB,EAAKv8B,IAASu8B,EAAMv8B,EAAK5C,KAAM,GAEzE2I,EAAQtS,KAAK,CACX6M,MAAOsyC,EACP9xB,SAAU9zB,KAAKuD,OAAOq/C,gBAAgB9uB,GACtC+xB,kBAEJ,IAGK9sC,CACT,CAEQ,wBAAM+rC,CACZF,EACAT,WAEA,MAAM2B,EAAqC,GAC3C,IAAIC,EAAgB,EAEpB,IAAK,IAAIrjD,EAAI,EAAOkiD,EAAS7rC,QAAQnZ,OAArB8C,EAA6BA,IAAK,CAChD,MAAMgd,EAAQklC,EAAS7rC,QAAQrW,GAG/B,KAAOqjD,GAAiB/lD,KAAKuD,OAAOo/C,4BAC5B/wC,QAAQg+B,KAAKkW,GACnBC,EAAgBD,EAAkBnmD,OAAOqmD,GAAKhmD,KAAKimD,iBAAiBD,IAAIpmD,OAI1E,WAAIiC,EAAA7B,KAAKwiD,sCAAiBrE,OAAO+H,QAC/B,MAAU7hD,MAAM,gBAIlB,MAAM8hD,EAAenmD,KAAKomD,UAAU1mC,EAAOhd,EAAI,EAAGyhD,GAClD2B,EAAkBr/C,KAAK0/C,GACvBJ,IAGA5B,EAASnrC,aAAetW,EAAI,EAC5B1C,KAAKqmD,oBAAoBlC,EAAUS,GACnC5kD,KAAK2kD,eAAeR,GAGhBnkD,KAAKuD,OAAOs/C,qBAA4D,UAArB,QAAhB/gD,EAAA9B,KAAKuiD,mBAAW,IAAAzgD,OAAA,EAAAA,EAAE8hD,uBACjD5jD,KAAK0vC,MAAchtC,EAAI,EAAZ,IAErB,OAGMkP,QAAQ+W,WAAWm9B,EAC3B,CAEQ,eAAMM,CACZ1mC,EACA4mC,EACAnC,GAEA,IAEE,MAAMoC,EAAa7mC,EAAMpM,MAAM3T,OAAOqT,GAAQA,EAAKzN,GAAGmL,WAAW,WAC3D81C,EAAe9mC,EAAMpM,MAAM3T,OAAOqT,GAAQA,EAAKzN,GAAGmL,WAAW,aAC7D+1C,EAAe/mC,EAAMpM,MAAM3T,OAAOqT,GAAQA,EAAKzN,GAAGmL,WAAW,mBAG7DkB,QAAQglC,IAAI,CAChB2P,EAAW3mD,OAAS,EAAII,KAAK0mD,eAAeH,GAAc30C,QAAQC,UAClE20C,EAAa5mD,OAAS,EAAII,KAAK2mD,iBAAiBH,GAAgB50C,QAAQC,UACxE40C,EAAa7mD,OAAS,EAAII,KAAK4mD,iBAAiBH,GAAgB70C,QAAQC,YAI1EsyC,EAASE,aAAe3kC,EAAMpM,MAAM1T,OACpCukD,EAASM,kBAAoB/kC,EAAMmmC,qBAG7Bj0C,QAAQglC,IACZl3B,EAAMpM,MAAM9T,IAAIwT,GAAQhT,KAAKsH,QAAQmyC,OAAOzmC,EAAKzN,KAGrD,CAAE,MAAOlG,GACP8kD,EAASG,aAAe5kC,EAAMpM,MAAM1T,OACpCukD,EAAS5wC,OAAO9M,KAAK,SAAS6/C,aAAuBjnD,EAAM2E,UAI7D,CACF,CAEQ,oBAAM0iD,CAAepzC,GAC3B,MAAMmH,EAAU,CACdlH,OAAQD,EAAM9T,IAAIwT,UAAQ,MAAA,IACrBA,EAAK7R,KACR0lD,iBAAkB7zC,EAAKpO,UACvBkiD,YAAa9zC,EAAKukC,WAClBwP,kBAAkC,QAAhBllD,EAAA7B,KAAKuiD,mBAAW,IAAA1gD,OAAA,EAAAA,EAAE8hD,kBAAmB,MAI3D,OAAO3jD,KAAK0iD,aAAav/B,iBACvB,cACAnW,kBACE,MAAMW,QAAiBxB,MAAM,qBAAsB,CACjDc,OAAQ,OACRrL,QAAS,CACP,eAAgB,mBAChB,kBAAkC,QAAhBC,EAAA7B,KAAKuiD,mBAAW,IAAA1gD,OAAA,EAAAA,EAAE+D,YAAa,IAEnD4H,KAAMlJ,KAAKC,UAAUkW,GACrB0jC,eAAQr8C,EAAA9B,KAAKwiD,sCAAiBrE,SAGhC,IAAKxwC,EAASkU,GACZ,MAAUxd,MAAM,sBAAsBsJ,EAASW,QAGjD,OAAOX,EAASiC,QAElB,CACEkkB,SAAU,OACVpZ,YAAapW,KAAKC,UAAUkW,GAAS7a,OACrCsuC,iBAAkB,UAAU56B,EAAM9T,IAAIkD,GAAKA,EAAE6C,IAAI1F,KAAK,MAG5D,CAEQ,sBAAM8mD,CAAiBrzC,GAE7B,MAAM0zC,EAAgB,IAAI7mD,IAC1BmT,EAAMjL,QAAQ2K,IACZ,MAAMpN,EAAYoN,EAAK7R,KAAKyE,UACvBohD,EAAc/uC,IAAIrS,IACrBohD,EAAc/jD,IAAI2C,EAAW,IAE/BohD,EAAchkD,IAAI4C,GAAYa,KAAKuM,KAIrC,IAAK,MAAOpN,EAAW4gD,KAAiBQ,EAAe,CACrD,MAAMvsC,EAAU,CACda,WAAY1V,EACZyB,OAAQm/C,EAAahnD,IAAIwT,IAAI,IACxBA,EAAK7R,KACR0lD,iBAAkB7zC,EAAKpO,UACvBkiD,YAAa9zC,EAAKukC,qBAIhBv3C,KAAK0iD,aAAav/B,iBACtB,gBAAgBvd,EAChBoH,kBACE,MAAMW,QAAiBxB,MAAM,6BAA8B,CACzDc,OAAQ,OACRrL,QAAS,CACP,eAAgB,mBAChB,kBAAkC,QAAhBC,EAAA7B,KAAKuiD,mBAAW,IAAA1gD,OAAA,EAAAA,EAAE+D,YAAa,IAEnD4H,KAAMlJ,KAAKC,UAAUkW,GACrB0jC,eAAQr8C,EAAA9B,KAAKwiD,sCAAiBrE,SAGhC,IAAKxwC,EAASkU,GACZ,MAAUxd,MAAM,wBAAwBsJ,EAASW,QAGnD,OAAOX,EAASiC,QAElB,CACEkkB,SAAU,SACVpZ,YAAapW,KAAKC,UAAUkW,GAAS7a,OACrCsuC,iBAAkB,WAAWtoC,GAGnC,CACF,CAEQ,sBAAMghD,CAAiBtzC,GAC7B,MAAMmH,EAAU,CACdpT,OAAQiM,EAAM9T,IAAIwT,IAAI,IACjBA,EAAK7R,KACR0lD,iBAAkB7zC,EAAKpO,UACvBkiD,YAAa9zC,EAAKukC,eAItB,OAAOv3C,KAAK0iD,aAAav/B,iBACvB,eACAnW,kBACE,MAAMW,QAAiBxB,MAAM,6BAA8B,CACzDc,OAAQ,OACRrL,QAAS,CACP,eAAgB,mBAChB,kBAAkC,QAAhBC,EAAA7B,KAAKuiD,mBAAW,IAAA1gD,OAAA,EAAAA,EAAE+D,YAAa,IAEnD4H,KAAMlJ,KAAKC,UAAUkW,GACrB0jC,eAAQr8C,EAAA9B,KAAKwiD,sCAAiBrE,SAGhC,IAAKxwC,EAASkU,GACZ,MAAUxd,MAAM,wBAAwBsJ,EAASW,QAGnD,OAAOX,EAASiC,QAElB,CACEkkB,SAAU,MACVpZ,YAAapW,KAAKC,UAAUkW,GAAS7a,OACrCsuC,iBAAkB,WAAW56B,EAAM1T,QAGzC,CAEQ,qBAAM4lD,CAAgBlyC,GAE5B,MAAMyxC,EAA4B,GAclC,OAXAzxC,EAAMjL,QAAQ2K,IACRA,EAAKukC,WAAa,GACpBwN,EAAUt+C,KAAK,CACbwgD,UAAWj0C,EACXk0C,aAAc,YACdC,WAAY,UACZC,aAAc,YAKbrC,CACT,CAEQ,sBAAMC,CAAiBD,GAC7B,IAAK,MAAMsC,KAAYtC,EAAW,CAChC,OAAQ/kD,KAAKuD,OAAOw/C,oBAClB,IAAK,cAML,IAAK,iBAEHsE,EAASD,aAAe,QACxB,MANF,IAAK,cACHC,EAASD,aAAe,SAO5BC,EAASF,WAAa,UACxB,CACF,CAEQ,mBAAAd,CAAoBlC,EAAwBS,SAClD,GAAIT,EAASE,YAAc,EAAG,CAC5B,MAAMiD,EAAcvmD,KAAKC,gBAASa,EAAA7B,KAAKuiD,kCAAakB,oBAAqB1iD,KAAKC,OAG9EmjD,EAASK,uBAAyBvlD,KAAK0D,MAFnB2kD,EAAcnD,EAASE,aACpBF,EAASpJ,WAAaoJ,EAASE,aAExD,CACF,CAKA,UAAAkD,GACMvnD,KAAKwiD,iBACPxiD,KAAKwiD,gBAAgBtE,OAEzB,CAKA,kBAAAsJ,GACE,OAA0B,IAC5B,CAKA,aAAAC,GACE,OAA4B,OAArBznD,KAAKsiD,WACd,CAKA,UAAAoF,CAAWjxC,GAET,OADAzW,KAAKmW,UAAU1P,KAAKgQ,GACb,KACL,MAAM1C,EAAQ/T,KAAKmW,UAAUO,QAAQD,GACjC1C,GAAQ,GACV/T,KAAKmW,UAAUxP,OAAOoN,EAAO,GAGnC,CAEQ,cAAA4wC,CAAeR,GACrBnkD,KAAKmW,UAAU9N,QAAQoO,IACrB,IACEA,EAAS,IAAK0tC,GAChB,CAAE,MAAO9kD,GAET,GAEJ,CAGQ,iBAAAikD,GACN,MAAO,QAAQviD,KAAKC,SAAS/B,KAAKC,SAASC,SAAS,IAAI4V,OAAO,EAAG,IACpE,CAEQ,WAAAyuC,GAEN,IAAID,EAAWtuC,aAAajN,QAAQ,kBAKpC,OAJKu7C,IACHA,EAAW,UAAUxiD,KAAKC,SAAS/B,KAAKC,SAASC,SAAS,IAAI4V,OAAO,EAAG,KACxEE,aAAazN,QAAQ,iBAAkB+7C,IAElCA,CACT,CAEQ,oBAAAG,GACN,MAAMiE,EAAS1yC,aAAajN,QAAQ,kBACpC,OAAO2/C,EAASrzB,SAASqzB,GAAU,CACrC,CAEQ,uBAAA1C,GACNhwC,aAAazN,QAAQ,iBAAkBzG,QAAKC,MAC9C,CAEQ,0BAAM6iD,GACZ,IAAK7jD,KAAKqiD,cAAe,MAAO,UAEhC,MAAMuF,EAAS5nD,KAAKqiD,cAAclD,kBAElC,OAAIyI,EAAOr5C,cAAsC,IAAtBq5C,EAAOr5C,cAAuBq5C,EAAO1W,QAAQ2L,YAAc,IAC7E,YACE+K,EAAOr5C,cAAsC,IAAtBq5C,EAAOr5C,cAAuBq5C,EAAO1W,QAAQ2L,YAAc,GACpF,OAC+B,GAA7B+K,EAAO1W,QAAQ2L,YACjB,OAGF,SACT,CAEQ,eAAAkH,GACcj+C,SAKtB,CAEQ,iBAAAo+C,CAAkBC,SACxBnkD,KAAKyiD,YAAYh8C,KAAK,CACpB7B,UAAW7D,KAAKC,MAChBwI,SAAUzI,KAAKC,gBAASa,EAAA7B,KAAKuiD,kCAAakB,oBAAqB1iD,KAAKC,OACpE6mD,YAAa1D,EAASE,YACtBj+B,QAA4B,cAAnB+9B,EAASC,QAIhBpkD,KAAKyiD,YAAY7iD,OAAS,IAC5BI,KAAKyiD,YAAYnE,OAErB,CAEQ,gBAAA2H,CAAiB6B,GAEvB,OAAO,CACT,CAEQ,KAAApY,CAAMS,GACZ,OAAO,IAAIv+B,QAAQC,GAAW9I,WAAW8I,EAASs+B,GACpD,CAKA,cAAA4X,GACE,MAAO,IAAI/nD,KAAKyiD,YAClB,CAKA,YAAAjS,CAAaC,GACXzwC,KAAKuD,OAAS,IAAKvD,KAAKuD,UAAWktC,EACrC,CAKA,SAAAuX,GACE,MAAO,IAAKhoD,KAAKuD,OACnB,CAKA,QAAA6sC,GACE,MAAO,CACL6X,YAAajoD,KAAKioD,YAAY73C,KAC9BqyC,YAAaziD,KAAKyiD,YAAY7iD,OAC9BsoD,SAAUloD,KAAKyiD,YAAY7iD,OAAS,EAAII,KAAKyiD,YAAYziD,KAAKyiD,YAAY7iD,OAAS,GAAK,KACxFuoD,WAAYnoD,KAAKyiD,YAAY7iD,OAC7BwoD,gBAAiBpoD,KAAKyiD,YAAY9iD,OAAOwjC,GAAKA,EAAE/c,SAASxmB,OAE7D,CAKA,UAAAywC,GACErwC,KAAKyiD,YAAc,GACnBziD,KAAKioD,YAAYr0C,OACnB,CAKA,OAAA3C,GACEjR,KAAKioD,YAAYr0C,QACjB5T,KAAKyiD,YAAc,EACrB,QCltBW4F,EAeX,WAAAtoD,CAAYwD,EAAqC,IAbzCvD,KAAAsoD,WAAa,IAAInoD,IACjBH,KAAAuoD,cAAgB,IAAIpoD,IACpBH,KAAAwoD,gBAAkB,IAAIroD,IACtBH,KAAAyoD,mBAA4C,KAC5CzoD,KAAAm9B,MAA4B,CAClCqV,cAAe,EACfkW,qBAAsB,EACtBC,UAAW,EACXC,sBAAuB,EACvBvvB,YAAa,EACbwvB,YAAa,GAIb7oD,KAAKuD,OAAS,CACZulD,OAAQ,IACRC,sBAAuB,GACvBC,uBAAuB,EACvBC,iBAAkB,IAClBC,6BAA6B,EAC7BC,cAAe,OACZ5lD,GAGLvD,KAAKopD,iBACP,CAKA,uBAAMC,CACJh6C,EACAwK,EACAvT,EAOI,CAAA,GAEJtG,KAAKm9B,MAAMqV,gBAGX,MAAMrqB,EAAcnoB,KAAKuD,OAAO2lD,kCACtBlpD,KAAKspD,2BAA2BhjD,GACtC,KAGJ,IAAKA,EAAQijD,aAAevpD,KAAKuD,OAAOylD,sBAAuB,CAC7D,MAAMQ,EAAiBxpD,KAAKypD,kBAAkBp6C,GAC9C,GAAIm6C,EAEF,OADAxpD,KAAKm9B,MAAMwrB,YACJa,CAEX,CAGA,MAAME,EAAkB1pD,KAAKsoD,WAAWtlD,IAAIqM,GAC5C,GAAIq6C,GAA8C,YAA3BA,EAAgBp7C,SACrCtO,KAAKm9B,MAAMurB,uBAGPgB,EAAgB5B,SAClB,IACE,aAAa4B,EAAgB5B,OAC/B,CAAE,MAAOzoD,GAEwB,EAA3BqqD,EAAgBlb,UAElBkb,EAAgBlb,WAChBkb,EAAgBC,cAAgB5oD,KAAKC,OAGrChB,KAAKsoD,WAAWjlD,OAAOgM,EAE3B,CAKJ,MAAMu6C,EAAuC,CAC3Cv6C,MACA8Y,YAAaA,GAAe,CAC1Blb,OAAQ3G,EAAQ2G,QAAU,UAC1BzH,IAAKc,EAAQd,KAAO,UACpB5D,QAAS0E,EAAQ1E,SAAW,CAAA,EAC5BgD,UAAW7D,KAAKC,OAElBsN,OAAQ,UACRkgC,SAAU,EACVqb,UAAW9oD,KAAKC,MAChB2oD,cAAe5oD,KAAKC,OAIhB8oD,EAAelnD,MAAMC,KAAK7C,KAAKsoD,WAAWjwC,UAC7C1Y,OAAO4yC,GAAsB,YAAfA,EAAIjkC,QAAsB1O,OAE3C,GAAIkqD,GAAgB9pD,KAAKuD,OAAOwlD,sBAC9B,MAAU1kD,MAAM,4CAA4CylD,KAAgB9pD,KAAKuD,OAAOwlD,0BAI1F,MAAMza,EAAiBtuC,KAAK+pD,2BAA2B16C,EAAKwK,EAAW+vC,GACvEA,EAAkB9B,QAAUxZ,EAE5BtuC,KAAKsoD,WAAWrlD,IAAIoM,EAAKu6C,GACzB5pD,KAAKwoD,gBAAgBvlD,IAAIoM,EAAKi/B,GAC9BtuC,KAAKgqD,cAEL,IAEE,aADqB1b,CAEvB,SACEtuC,KAAKwoD,gBAAgBnlD,OAAOgM,GAC5BrP,KAAKgqD,aACP,CACF,CAEQ,gCAAMD,CACZ16C,EACAwK,EACA9H,GAEA,IACE,MAAMG,QAAe2H,IAYrB,OATA9H,EAAQzD,OAAS,YACjByD,EAAQpE,SAAWuE,EACnBH,EAAQk4C,YAAclpD,KAAKC,MAGvBhB,KAAKuD,OAAOylD,uBACdhpD,KAAKkqD,cAAc76C,EAAK6C,GAGnBA,CAET,CAAE,MAAO7S,GAOP,MALA0S,EAAQzD,OAAS,SACjByD,EAAQ1S,MAAQA,EAChB0S,EAAQk4C,YAAclpD,KAAKC,MAGrB3B,CACR,CACF,CAKQ,gCAAMiqD,CAA2BhjD,GAMvC,MAAM6hB,EAAkC,CACtClb,OAAQ3G,EAAQ2G,QAAU,MAC1BzH,IAAKc,EAAQd,KAAO,GACpB5D,QAAS5B,KAAKmqD,iBAAiB7jD,EAAQ1E,SAAW,CAAA,GAClDgD,UAAW7D,KAAKC,OAQlB,OAJIsF,EAAQkH,MAA4B,SAAnBlH,EAAQ2G,QAAwC,QAAnB3G,EAAQ2G,SACxDkb,EAAYiiC,eAAiBpqD,KAAKqqD,gBAAgB/jD,EAAQkH,OAGrD2a,CACT,CAEQ,gBAAAgiC,CAAiBvoD,GACvB,MAAM0oD,EAAqC,CAAA,EAGrCC,EAAmB,CAAC,eAAgB,SAAU,iBAEpD,IAAK,MAAOl7C,EAAKjF,KAAUoF,OAAOpM,QAAQxB,GAAU,CAClD,MAAM4oD,EAAgBn7C,EAAI1E,cACtB4/C,EAAiB9/C,SAAS+/C,KAC5BF,EAAWE,GAAiBpgD,EAEhC,CAEA,OAAOkgD,CACT,CAEQ,qBAAMD,CAAgB78C,GAC5B,IACE,MAAMi9C,EAA6B,iBAATj9C,EAAoBA,EAAOlJ,KAAKC,UAAUiJ,GAGpE,IAAI4a,EAAO,EACX,IAAK,IAAI1lB,EAAI,EAAO+nD,EAAW7qD,OAAf8C,EAAuBA,IAErC0lB,GAASA,GAAQ,GAAKA,EADTqiC,EAAWpiC,WAAW3lB,GAEnC0lB,GAAcA,EAGhB,OAAOnpB,KAAKqpB,IAAIF,GAAMjpB,SAAS,GACjC,CAAE,MAAOE,GACP,MAAO,YACT,CACF,CAKQ,iBAAAoqD,CAAqBp6C,GAC3B,IAAKrP,KAAKuD,OAAOylD,sBACf,OAAO,KAGT,MAAM0B,EAAS1qD,KAAKuoD,cAAcvlD,IAAIqM,GACtC,OAAKq7C,EAIO3pD,KAAKC,MAAQ0pD,EAAOC,SACtB3qD,KAAKuD,OAAO0lD,kBACpBjpD,KAAKuoD,cAAcllD,OAAOgM,GACnB,MAGFq7C,EAAO/8C,SATL,IAUX,CAKQ,aAAAu8C,CAAc76C,EAAa1B,GACjC,GAAK3N,KAAKuD,OAAOylD,wBAIjBhpD,KAAKuoD,cAActlD,IAAIoM,EAAK,CAC1B1B,WACAg9C,SAAU5pD,KAAKC,QAIbhB,KAAKuoD,cAAcn4C,KAAOpQ,KAAKuD,OAAO4lD,eAAe,CACvD,MAAMyB,EAAY5qD,KAAKuoD,cAAcxwC,OAAO8qB,OAAOz4B,MAC/CwgD,GACF5qD,KAAKuoD,cAAcllD,OAAOunD,EAE9B,CACF,CAKA,sBAAAC,CACE59C,EACAzH,EACAgI,EACA9J,GAEA,MAAM8jB,EAAa,CACjBva,EAAOC,cACP1H,EACA9B,GAAe,aAGjB,GAAI8J,EACF,IACE,MAAMi9C,EAA6B,iBAATj9C,EAAoBA,EAAOlJ,KAAKC,UAAUiJ,GACpEga,EAAW/gB,KAAKgkD,EAClB,CAAE,MAAOprD,GACPmoB,EAAW/gB,KAAK,uBAClB,CAGF,OAAO+gB,EAAW3nB,KAAK,IACzB,CAKA,SAAAirD,CAAUz7C,GACR,MAAM0C,EAAU/R,KAAKsoD,WAAWtlD,IAAIqM,GACpC,MAA2B,aAApB0C,aAAO,EAAPA,EAASzD,UAAwB,CAC1C,CAKA,cAAAy8C,CAAe17C,GACb,OAAOrP,KAAKsoD,WAAWtlD,IAAIqM,IAAQ,IACrC,CAKA,aAAA27C,CAAc37C,GACZ,MAAM0C,EAAU/R,KAAKsoD,WAAWtlD,IAAIqM,GACpC,SAAI0C,GAA8B,YAAnBA,EAAQzD,SACrByD,EAAQzD,OAAS,SACjByD,EAAQ1S,MAAYgF,MAAM,qBAC1B0N,EAAQk4C,YAAclpD,KAAKC,MAE3BhB,KAAKwoD,gBAAgBnlD,OAAOgM,GAC5BrP,KAAKgqD,cACE,GAGX,CAKQ,eAAAZ,GACNppD,KAAKyoD,mBAAqB37C,YAAY,KACpC9M,KAAKirD,yBACJ,IACL,CAEQ,qBAAAA,GACN,MAAMjqD,EAAMD,KAAKC,MACjB,IAAIkqD,EAAe,EAGnB,IAAK,MAAO77C,EAAK0C,KAAY/R,KAAKsoD,WAAWllD,WAC/BpC,EAAM+Q,EAAQ83C,UAChB7pD,KAAKuD,OAAOulD,QAA6B,YAAnB/2C,EAAQzD,UACtCtO,KAAKsoD,WAAWjlD,OAAOgM,GACvB67C,KAKJ,IAAK,MAAO77C,EAAKq7C,KAAW1qD,KAAKuoD,cAAcnlD,UACjCpC,EAAM0pD,EAAOC,SACf3qD,KAAKuD,OAAO0lD,mBACpBjpD,KAAKuoD,cAAcllD,OAAOgM,GAC1B67C,KAKJ,GAAIlrD,KAAKsoD,WAAWl4C,KAAOpQ,KAAKuD,OAAO4lD,cAAe,CACpD,MAAMgC,EAASnrD,KAAKsoD,WAAWl4C,KAAOpQ,KAAKuD,OAAO4lD,cAC5CiC,EAAaxoD,MAAMC,KAAK7C,KAAKsoD,WAAWllD,WAC3C4U,KAAK,CAAC+lB,EAAGC,IAAMD,EAAE,GAAG8rB,UAAY7rB,EAAE,GAAG6rB,WACrC9/C,MAAM,EAAGohD,GACT3rD,IAAI,EAAE6P,KAASA,GAElB,IAAK,MAAMA,KAAO+7C,EAChBprD,KAAKsoD,WAAWjlD,OAAOgM,GACvB67C,GAEJ,CAEAlrD,KAAKm9B,MAAM0rB,aAAeqC,EAC1BlrD,KAAKgqD,aACP,CAEQ,WAAAA,GACNhqD,KAAKm9B,MAAMyrB,sBAAwB5oD,KAAKwoD,gBAAgBp4C,KACxDpQ,KAAKm9B,MAAM9D,YAAcr5B,KAAKsoD,WAAWl4C,KAAOpQ,KAAKuoD,cAAcn4C,IACrE,CAKA,QAAAggC,GAEE,OADApwC,KAAKgqD,cACE,IAAKhqD,KAAKm9B,MACnB,CAKA,UAAAkT,GACErwC,KAAKm9B,MAAQ,CACXqV,cAAe,EACfkW,qBAAsB,EACtBC,UAAW,EACXC,sBAAuB,EACvBvvB,YAAa,EACbwvB,YAAa,EAEjB,CAKA,KAAAj1C,GACE5T,KAAKsoD,WAAW10C,QAChB5T,KAAKuoD,cAAc30C,QACnB5T,KAAKwoD,gBAAgB50C,QACrB5T,KAAKqwC,YACP,CAKA,YAAAG,CAAaC,GACXzwC,KAAKuD,OAAS,IAAKvD,KAAKuD,UAAWktC,EACrC,CAKA,OAAAx/B,GACMjR,KAAKyoD,qBACPv3C,cAAclR,KAAKyoD,oBACnBzoD,KAAKyoD,mBAAqB,MAE5BzoD,KAAK4T,OACP,6RCnYA,WAAA7T,CAAYwD,EAAoC,IAbxCvD,KAAA2/C,iBAAmB,CACzB0L,YAAa,SACbC,gBAAiB,EACjBC,eAAgB,GAGVvrD,KAAAwrD,mBAKH,GAGHxrD,KAAKuD,OAAS,CACZkoD,MAAO,CAAA,EACP/X,eAAgB,CAAA,EAChBpsC,QAAS,CAAA,EACT+6C,cAAe,CAAA,EACfqJ,KAAM,CAAA,EACNC,YAAa,CAAA,EACbC,wBAAwB,EACxBC,sBAAuB,CACrBC,cAAe,IACfC,kBAAmB,IACnBC,cAAe,GACfC,kBAAmB,QAElB1oD,GAILvD,KAAK0iD,aAAe,IAAItV,EAAaptC,KAAKuD,OAAOkoD,OACjDzrD,KAAKksD,sBAAwB,IAAIjZ,EAAsBjzC,KAAKuD,OAAOmwC,gBACnE1zC,KAAKsH,QAAU,IAAIuuC,EAAiB71C,KAAKuD,OAAO+D,SAChDtH,KAAKqiD,cAAgB,IAAI9C,EAA2Bv/C,KAAKuD,OAAO8+C,eAChEriD,KAAKmsD,YAAc,IAAI/J,EAAuBpiD,KAAKuD,OAAOmoD,MAC1D1rD,KAAKosD,mBAAqB,IAAI/D,EAAmBroD,KAAKuD,OAAOooD,aAGzD3rD,KAAKuD,OAAOqoD,wBACd5rD,KAAKqsD,iCAET,CAKA,6BAAMC,CACJzyC,EACAvT,GAEA,MAAMxF,EAAYC,KAAKC,OACjByyC,QAAEA,EAAO3f,SAAEA,EAAQy4B,eAAEA,EAAczM,OAAEA,GAAWx5C,EAEtD,IA2BE,aAzBMtG,KAAKksD,sBAAsB9W,mBAC/B3B,EACAzmC,SAEMu/C,QACWvsD,KAAKosD,mBAAmB/C,kBACnCkD,EACA,IAAMvsD,KAAKwsD,0BAA0B3yC,EAAWvT,GAChD,CACE2G,OAAQ,OACRzH,IAAKiuC,EACL3f,WACAy1B,YAAajjD,EAAQijD,oBAIZvpD,KAAKwsD,0BAA0B3yC,EAAWvT,GAG3D,CAAEwtB,WAAUgsB,WAId9/C,KAAKysD,kBAAkB3rD,GAAW,EAAM2yC,SAE3B55B,GAEf,CAAE,MAAOxa,GASP,MAPAW,KAAKysD,kBAAkB3rD,GAAW,EAAO2yC,GAGrCzzC,KAAK0sD,wBAAwBrtD,EAAOy0B,UAChC9zB,KAAK2sD,kBAAkB9yC,EAAWvT,EAASjH,GAG7CA,CACR,CACF,CAEQ,+BAAMmtD,CACZ3yC,EACAvT,GAEA,MAAMmtC,QAAEA,EAAO3f,SAAEA,EAAQpZ,YAAWA,EAAWolC,OAAEA,GAAWx5C,EAGtDsmD,EAAuB5sD,KAAKqiD,cAAcwK,0BAC9CpZ,EACAqM,GAIIgN,EAAiB9sD,KAAK+sD,qBAAqBzmD,EAASsmD,GAG1D,aAAa5sD,KAAK0iD,aAAav/B,iBAC7B,GAAGswB,KAAWqM,GAAU,YACxBjmC,EACA,CACEia,WACAma,QAAS6e,EAAe7e,QACxBvzB,cACAwzB,iBAAkB4e,EAAe5e,kBAGvC,CAEQ,oBAAA6e,CACNzmD,EACAsmD,GAEA,MAAMI,EAAU,IAAK1mD,GAcrB,OAZIsmD,IAEEA,EAAqBK,kBACvBD,EAAQ/e,QAAU2e,EAAqBK,iBAIrCL,EAAqBM,mBAAqBF,EAAQT,iBACpDS,EAAQT,eAAiB,cAAcjmD,EAAQmtC,WAAW1yC,KAAKC,UAI5DgsD,CACT,CAEQ,uBAAAN,CAAwBrtD,EAAYy0B,SAE1C,QAAiB,aAAbA,IAKe,cAAfz0B,EAAMqL,OAAwBrL,EAAM2E,QAAQyG,SAAS,aAKxC,QAAb5I,EAAAxC,EAAM2E,eAAO,IAAAnC,OAAA,EAAAA,EAAE4I,SAAS,aAKR,IAAhBpL,EAAMiP,OAKZ,CAEQ,uBAAMq+C,CACZ9yC,EACAvT,EACAjH,GAEA,MAAM8tD,EAAc,CAClBtzC,UAAWA,KACXvT,UACAjH,MAAO,CACL2E,QAAS3E,EAAM2E,QACf0G,KAAMrL,EAAMqL,KACZpL,MAAOD,EAAMC,OAEfsF,UAAW7D,KAAKC,aAGZhB,KAAKsH,QAAQkzC,UACjB,kBAAkBl0C,EAAQmtC,WAAW1yC,KAAKC,QAC1CmsD,EACA,CACEr5B,SAAUxtB,EAAQwtB,SAClB7gB,UAAU,EACVm6C,SAAS,EACThW,KAA2B,SAArB9wC,EAAQwtB,SAAsB,MAAQ,QAGlD,CAKA,wBAAMu5B,GAEJ,MAAM3a,QAAuB1yC,KAAKsH,QAAQuzC,oBAAoB,oBAE9D,GAA8B,IAA1BnI,EAAe9yC,OAAnB,OAKMI,KAAKmsD,YAAYlI,uBACrB,kBACAvR,EAAelzC,IAAI+yC,YAAO,MAAA,CACxBhtC,GAAIgtC,EAAIljC,IACRlO,KAAMoxC,EAAIpxC,KACV2yB,UAAsB,QAAZjyB,EAAA0wC,EAAIlyB,gBAAQ,IAAAxe,OAAA,EAAAA,EAAEiyB,WAAY,SACpC1jB,KAAM9L,KAAKC,UAAUguC,EAAIpxC,MAAMvB,OAC/BgF,WAAuB,QAAZ9C,EAAAywC,EAAIlyB,gBAAQ,IAAAve,OAAA,EAAAA,EAAE8C,YAAa7D,KAAKC,MAC3CssD,aAAc,MAEhB,CACEz0C,aAAc,GACd00C,UAAW,IACXz5B,SAAU,SAKd,IAAK,MAAM/hB,KAAW2gC,QACd1yC,KAAKsH,QAAQszC,WAAW7oC,EAAQ1C,IAtBxC,CAwBF,CAKQ,+BAAAg9C,GACNv/C,YAAY,KACV9M,KAAKwtD,4BACJ,IACL,CAEQ,wBAAAA,GACN,IAAKxtD,KAAKuD,OAAOqoD,uBACf,OAGF,MAAM6B,EAAoBztD,KAAK0tD,qBAAqB,KACpD,GAAiC,IAA7BD,EAAkB7tD,OACpB,OAGF,MAAMk9C,EAAY2Q,EAAkB9tD,OAAOqmD,IAAMA,EAAE5/B,SAASxmB,OAAS6tD,EAAkB7tD,OACjF+tD,EAAkBF,EAAkBtwC,OAAO,CAACoyB,EAAKyW,IAAMzW,EAAMyW,EAAEx8C,SAAU,GAAKikD,EAAkB7tD,OAGtG,IAAIguD,EAA+C,SAGlC5tD,KAAKuD,OAAOsoD,sBAAsBI,kBAA/CnP,EAGW98C,KAAKuD,OAAOsoD,sBAAsBG,cAA/ClP,GACmB98C,KAAKuD,OAAOsoD,sBAAsBE,kBAArD4B,GAG4B3tD,KAAKuD,OAAOsoD,sBAAsBC,cAArD6B,IADTC,EAAU,YALVA,EAAU,YAWRA,IAhBgB5tD,KAAK2/C,iBAAiB0L,cAiBxCrrD,KAAK6tD,0BAA0BD,GAC/B5tD,KAAK2/C,iBAAiB0L,YAAcuC,EACpC5tD,KAAK2/C,iBAAiB2L,kBACtBtrD,KAAK2/C,iBAAiB4L,eAAiBxqD,KAAKC,MAEhD,CAEQ,yBAAA6sD,CAA0Bv2C,GAChC,OAAQA,GACN,IAAK,YAEHtX,KAAK0iD,aAAalS,aAAa,CAC7B7C,YAAa,EACbviB,UAAW,IACX2iB,YAAa,KAEf/tC,KAAKksD,sBAAsB1W,mBAAmB,CAC5C5E,iBAAkB,EAClBkd,gBAAiB,IACjBjZ,eAAe,IAEjB,MAEF,IAAK,WAEH70C,KAAK0iD,aAAalS,aAAa,CAC7B7C,YAAa,EACbviB,UAAW,IACX2iB,YAAa,KAEf/tC,KAAKksD,sBAAsB1W,mBAAmB,CAC5C5E,iBAAkB,EAClBkd,gBAAiB,KACjBjZ,eAAe,IAEjB,MAEF,IAAK,SAEH70C,KAAK0iD,aAAalS,aAAa,CAC7B7C,YAAa,EACbviB,UAAW,IACX2iB,YAAa,MAEf/tC,KAAKksD,sBAAsB1W,mBAAmB,CAC5C5E,iBAAkB,GAClBkd,gBAAiB,IACjBjZ,eAAe,IAIvB,CAEQ,iBAAA4X,CAAkB3rD,EAAmBslB,EAAkBqtB,GAC7D,MAAMjqC,EAAWzI,KAAKC,MAAQF,EAE9Bd,KAAKwrD,mBAAmB/kD,KAAK,CAC3B7B,UAAW7D,KAAKC,MAChBwI,WACA4c,UACAqtB,YAIF,MAAMsa,EAAahtD,KAAKC,MAAQ,KAChChB,KAAKwrD,mBAAqBxrD,KAAKwrD,mBAAmB7rD,OAChDqmD,GAAKA,EAAEphD,UAAYmpD,EAEvB,CAEQ,oBAAAL,CAAqBM,GAC3B,MAAM7qD,EAASpC,KAAKC,MAAQgtD,EAC5B,OAAOhuD,KAAKwrD,mBAAmB7rD,OAAOqmD,GAAKA,EAAEphD,UAAYzB,EAC3D,CAKA,QAAAitC,GACE,MAAO,CACLqb,MAAOzrD,KAAK0iD,aAAatS,WACzBsD,eAAgB1zC,KAAKksD,sBAAsBzW,iBAC3CnuC,QAAStH,KAAKsH,QAAQ8oC,WACtBiS,cAAeriD,KAAKqiD,cAAc5M,iBAClCiW,KAAM1rD,KAAKmsD,YAAY/b,WACvBub,YAAa3rD,KAAKosD,mBAAmBhc,WACrCuP,iBAAkB,IAAK3/C,KAAK2/C,kBAEhC,CAKA,aAAAsO,GACEjuD,KAAK0iD,aAAarS,aAClBrwC,KAAKksD,sBAAsB7b,aAC3BrwC,KAAKsH,QAAQ+oC,aACbrwC,KAAKqiD,cAAchS,aACnBrwC,KAAKmsD,YAAY9b,aACjBrwC,KAAKosD,mBAAmB/b,aACxBrwC,KAAKwrD,mBAAqB,GAC1BxrD,KAAK2/C,iBAAmB,CACtB0L,YAAa,SACbC,gBAAiB,EACjBC,eAAgB,EAEpB,CAKA,YAAA/a,CAAaC,GACXzwC,KAAKuD,OAAS,IAAKvD,KAAKuD,UAAWktC,GAE/BA,EAAUgb,OACZzrD,KAAK0iD,aAAalS,aAAaC,EAAUgb,OAEvChb,EAAUiD,gBACZ1zC,KAAKksD,sBAAsB1W,mBAAmB/E,EAAUiD,gBAEtDjD,EAAUnpC,SACZtH,KAAKsH,QAAQkpC,aAAaC,EAAUnpC,SAElCmpC,EAAU4R,eACZriD,KAAKqiD,cAAc7R,aAAaC,EAAU4R,eAExC5R,EAAUib,MACZ1rD,KAAKmsD,YAAY3b,aAAaC,EAAUib,MAEtCjb,EAAUkb,aACZ3rD,KAAKosD,mBAAmB5b,aAAaC,EAAUkb,YAEnD,CAKA,OAAA16C,GACEjR,KAAKosD,mBAAmBn7C,UACxBjR,KAAKqiD,cAAcpxC,UACnBjR,KAAKmsD,YAAYl7C,SAEnB"}